require=(function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c="function"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error("Cannot find module '"+i+"'");throw a.code="MODULE_NOT_FOUND",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u="function"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()({1:[function(require,module,exports){
"use strict";

// bundle.js

// Expose bitcoinjs-lib as a global variable
window.bitcoin = require('bitcoinjs-lib');

// Expose bip39 as a global variable
window.bip39 = require('bip39');
window.bip32 = require('bip32');
window.ecpair = require('ecpair');

//window.ecc = require('tiny-secp256k1');
//window.ecc = require('@noble/secp256k1');
window.ecc = require('@bitcoinerlab/secp256k1');
window.Buffer = require('buffer').Buffer;

},{"@bitcoinerlab/secp256k1":2,"bip32":50,"bip39":54,"bitcoinjs-lib":73,"buffer":"buffer","ecpair":102}],2:[function(require,module,exports){
(function (Buffer){(function (){
'use strict';

function _slicedToArray(r, e) { return _arrayWithHoles(r) || _iterableToArrayLimit(r, e) || _unsupportedIterableToArray(r, e) || _nonIterableRest(); }
function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _unsupportedIterableToArray(r, a) { if (r) { if ("string" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }
function _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }
function _iterableToArrayLimit(r, l) { var t = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (null != t) { var e, n, i, u, a = [], f = !0, o = !1; try { if (i = (t = t.call(r)).next, 0 === l) { if (Object(t) !== t) return; f = !1; } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0); } catch (r) { o = !0, n = r; } finally { try { if (!f && null != t["return"] && (u = t["return"](), Object(u) !== u)) return; } finally { if (o) throw n; } } return a; } }
function _arrayWithHoles(r) { if (Array.isArray(r)) return r; }
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
var necc = require('@noble/secp256k1');
var hmac = require('@noble/hashes/hmac');
var sha256 = require('@noble/hashes/sha256');
function _interopNamespaceDefault(e) {
  var n = Object.create(null);
  if (e) {
    Object.keys(e).forEach(function (k) {
      if (k !== 'default') {
        var d = Object.getOwnPropertyDescriptor(e, k);
        Object.defineProperty(n, k, d.get ? d : {
          enumerable: true,
          get: function get() {
            return e[k];
          }
        });
      }
    });
  }
  n["default"] = e;
  return Object.freeze(n);
}
var necc__namespace = /*#__PURE__*/_interopNamespaceDefault(necc);

/*
 * Copyright (c) 2023 Jose-Luis Landabaso
 * Distributed under the MIT software license.
 *
 * This file includes code from the following sources:
 *  * Paul Miller's @noble/secp256k1 (specifically, the privateAdd,
 *    privateNegate, pointAddScalar, and pointMultiply functions).
 *  * Some pieces from tiny-secp256k1
 *    (https://github.com/bitcoinjs/tiny-secp256k1)
 *  * It also uses code from BitGo's BitGoJS library
 *    (https://github.com/BitGo/BitGoJS)
 *
 * This package's tests are based on modified versions of tests from
 * tiny-secp256k1 (https://github.com/bitcoinjs/tiny-secp256k1/tests).
 */

var THROW_BAD_PRIVATE = 'Expected Private';
var THROW_BAD_POINT = 'Expected Point';
var THROW_BAD_TWEAK = 'Expected Tweak';
var THROW_BAD_HASH = 'Expected Hash';
var THROW_BAD_SIGNATURE = 'Expected Signature';
var THROW_BAD_EXTRA_DATA = 'Expected Extra Data (32 bytes)';
var THROW_BAD_SCALAR = 'Expected Scalar';
var THROW_BAD_RECOVERY_ID = 'Bad Recovery Id';
necc__namespace.utils.hmacSha256Sync = function (key) {
  var _necc__namespace$util;
  for (var _len = arguments.length, msgs = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    msgs[_key - 1] = arguments[_key];
  }
  return hmac.hmac(sha256.sha256, key, (_necc__namespace$util = necc__namespace.utils).concatBytes.apply(_necc__namespace$util, msgs));
};
necc__namespace.utils.sha256Sync = function () {
  var _necc__namespace$util2;
  return sha256.sha256((_necc__namespace$util2 = necc__namespace.utils).concatBytes.apply(_necc__namespace$util2, arguments));
};
var normalizePrivateKey = necc__namespace.utils._normalizePrivateKey;
var HASH_SIZE = 32;
var TWEAK_SIZE = 32;
var BN32_N = new Uint8Array([255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 254, 186, 174, 220, 230, 175, 72, 160, 59, 191, 210, 94, 140, 208, 54, 65, 65]);
var EXTRA_DATA_SIZE = 32;
var BN32_ZERO = new Uint8Array(32);
var BN32_P_MINUS_N = new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 69, 81, 35, 25, 80, 183, 95, 196, 64, 45, 161, 114, 47, 201, 186, 238]);
function isUint8Array(value) {
  return value instanceof Uint8Array;
}
function cmpBN32(data1, data2) {
  for (var i = 0; i < 32; ++i) {
    if (data1[i] !== data2[i]) {
      return data1[i] < data2[i] ? -1 : 1;
    }
  }
  return 0;
}
function isZero(x) {
  return cmpBN32(x, BN32_ZERO) === 0;
}
function isTweak(tweak) {
  // Check that the tweak is a Uint8Array of the correct length
  if (!(tweak instanceof Uint8Array) || tweak.length !== TWEAK_SIZE || cmpBN32(tweak, BN32_N) >= 0) {
    return false;
  }
  return true;
}
function isSignature(signature) {
  return signature instanceof Uint8Array && signature.length === 64 && cmpBN32(signature.subarray(0, 32), BN32_N) < 0 && cmpBN32(signature.subarray(32, 64), BN32_N) < 0;
}
function isSigrLessThanPMinusN(signature) {
  return isUint8Array(signature) && signature.length === 64 && cmpBN32(signature.subarray(0, 32), BN32_P_MINUS_N) < 0;
}
function isSignatureNonzeroRS(signature) {
  return !(isZero(signature.subarray(0, 32)) || isZero(signature.subarray(32, 64)));
}
function isHash(h) {
  return h instanceof Uint8Array && h.length === HASH_SIZE;
}
function isExtraData(e) {
  return e === undefined || e instanceof Uint8Array && e.length === EXTRA_DATA_SIZE;
}
function hexToNumber(hex) {
  if (typeof hex !== 'string') {
    throw new TypeError('hexToNumber: expected string, got ' + _typeof(hex));
  }
  return BigInt("0x".concat(hex));
}
function bytesToNumber(bytes) {
  return hexToNumber(necc__namespace.utils.bytesToHex(bytes));
}
function normalizeScalar(scalar) {
  var num;
  if (typeof scalar === 'bigint') {
    num = scalar;
  } else if (typeof scalar === 'number' && Number.isSafeInteger(scalar) && scalar >= 0) {
    num = BigInt(scalar);
  } else if (typeof scalar === 'string') {
    if (scalar.length !== 64) throw new Error('Expected 32 bytes of private scalar');
    num = hexToNumber(scalar);
  } else if (scalar instanceof Uint8Array) {
    if (scalar.length !== 32) throw new Error('Expected 32 bytes of private scalar');
    num = bytesToNumber(scalar);
  } else {
    throw new TypeError('Expected valid private scalar');
  }
  if (num < 0) throw new Error('Expected private scalar >= 0');
  return num;
}
var _privateAdd = function _privateAdd(privateKey, tweak) {
  var p = normalizePrivateKey(privateKey);
  var t = normalizeScalar(tweak);
  var add = necc__namespace.utils._bigintTo32Bytes(necc__namespace.utils.mod(p + t, necc__namespace.CURVE.n));
  if (necc__namespace.utils.isValidPrivateKey(add)) return add;else return null;
};
var _privateSub = function _privateSub(privateKey, tweak) {
  var p = normalizePrivateKey(privateKey);
  var t = normalizeScalar(tweak);
  var sub = necc__namespace.utils._bigintTo32Bytes(necc__namespace.utils.mod(p - t, necc__namespace.CURVE.n));
  if (necc__namespace.utils.isValidPrivateKey(sub)) return sub;else return null;
};
var _privateNegate = function _privateNegate(privateKey) {
  var p = normalizePrivateKey(privateKey);
  var not = necc__namespace.utils._bigintTo32Bytes(necc__namespace.CURVE.n - p);
  if (necc__namespace.utils.isValidPrivateKey(not)) return not;else return null;
};
var _pointAddScalar = function _pointAddScalar(p, tweak, isCompressed) {
  var P = necc__namespace.Point.fromHex(p);
  var t = normalizeScalar(tweak);
  var Q = necc__namespace.Point.BASE.multiplyAndAddUnsafe(P, t, BigInt(1));
  if (!Q) throw new Error('Tweaked point at infinity');
  return Q.toRawBytes(isCompressed);
};
var _pointMultiply = function _pointMultiply(p, tweak, isCompressed) {
  var P = necc__namespace.Point.fromHex(p);
  var h = typeof tweak === 'string' ? tweak : necc__namespace.utils.bytesToHex(tweak);
  var t = BigInt("0x".concat(h));
  return P.multiply(t).toRawBytes(isCompressed);
};
function assumeCompression(compressed, p) {
  if (compressed === undefined) {
    return p !== undefined ? isPointCompressed(p) : true;
  }
  return compressed ? true : false;
}
function throwToNull(fn) {
  try {
    return fn();
  } catch (e) {
    return null;
  }
}
function _isPoint(p, xOnly) {
  if (p.length === 32 !== xOnly) return false;
  try {
    return !!necc__namespace.Point.fromHex(p);
  } catch (e) {
    return false;
  }
}
function isPoint(p) {
  return _isPoint(p, false);
}
function isPointCompressed(p) {
  var PUBLIC_KEY_COMPRESSED_SIZE = 33;
  return _isPoint(p, false) && p.length === PUBLIC_KEY_COMPRESSED_SIZE;
}
function isPrivate(d) {
  return necc__namespace.utils.isValidPrivateKey(d);
}
function isXOnlyPoint(p) {
  return _isPoint(p, true);
}
function xOnlyPointAddTweak(p, tweak) {
  if (!isXOnlyPoint(p)) {
    throw new Error(THROW_BAD_POINT);
  }
  if (!isTweak(tweak)) {
    throw new Error(THROW_BAD_TWEAK);
  }
  return throwToNull(function () {
    var P = _pointAddScalar(p, tweak, true);
    var parity = P[0] % 2 === 1 ? 1 : 0;
    return {
      parity: parity,
      xOnlyPubkey: P.slice(1)
    };
  });
}
function xOnlyPointFromPoint(p) {
  if (!isPoint(p)) {
    throw new Error(THROW_BAD_POINT);
  }
  return p.slice(1, 33);
}
function pointFromScalar(sk, compressed) {
  if (!isPrivate(sk)) {
    throw new Error(THROW_BAD_PRIVATE);
  }
  return throwToNull(function () {
    return necc__namespace.getPublicKey(sk, assumeCompression(compressed));
  });
}
function xOnlyPointFromScalar(d) {
  if (!isPrivate(d)) {
    throw new Error(THROW_BAD_PRIVATE);
  }
  return xOnlyPointFromPoint(pointFromScalar(d));
}
function pointCompress(p, compressed) {
  if (!isPoint(p)) {
    throw new Error(THROW_BAD_POINT);
  }
  return necc__namespace.Point.fromHex(p).toRawBytes(assumeCompression(compressed, p));
}
function pointMultiply(a, tweak, compressed) {
  if (!isPoint(a)) {
    throw new Error(THROW_BAD_POINT);
  }
  if (!isTweak(tweak)) {
    throw new Error(THROW_BAD_TWEAK);
  }
  return throwToNull(function () {
    return _pointMultiply(a, tweak, assumeCompression(compressed, a));
  });
}
function pointAdd(a, b, compressed) {
  if (!isPoint(a) || !isPoint(b)) {
    throw new Error(THROW_BAD_POINT);
  }
  return throwToNull(function () {
    var A = necc__namespace.Point.fromHex(a);
    var B = necc__namespace.Point.fromHex(b);
    if (A.equals(B.negate())) {
      //https://github.com/paulmillr/noble-secp256k1/issues/91
      return null;
    } else {
      return A.add(B).toRawBytes(assumeCompression(compressed, a));
    }
  });
}
function pointAddScalar(p, tweak, compressed) {
  if (!isPoint(p)) {
    throw new Error(THROW_BAD_POINT);
  }
  if (!isTweak(tweak)) {
    throw new Error(THROW_BAD_TWEAK);
  }
  return throwToNull(function () {
    return _pointAddScalar(p, tweak, assumeCompression(compressed, p));
  });
}
function privateAdd(d, tweak) {
  if (isPrivate(d) === false) {
    throw new Error(THROW_BAD_PRIVATE);
  }
  if (isTweak(tweak) === false) {
    throw new Error(THROW_BAD_TWEAK);
  }
  return throwToNull(function () {
    return _privateAdd(d, tweak);
  });
}
function privateSub(d, tweak) {
  if (isPrivate(d) === false) {
    throw new Error(THROW_BAD_PRIVATE);
  }
  if (isTweak(tweak) === false) {
    throw new Error(THROW_BAD_TWEAK);
  }
  return throwToNull(function () {
    return _privateSub(d, tweak);
  });
}
function privateNegate(d) {
  if (isPrivate(d) === false) {
    throw new Error(THROW_BAD_PRIVATE);
  }
  return _privateNegate(d);
}
function sign(h, d, e) {
  if (!isPrivate(d)) {
    throw new Error(THROW_BAD_PRIVATE);
  }
  if (!isHash(h)) {
    throw new Error(THROW_BAD_SCALAR);
  }
  if (!isExtraData(e)) {
    throw new Error(THROW_BAD_EXTRA_DATA);
  }
  return necc__namespace.signSync(h, d, {
    der: false,
    extraEntropy: e
  });
}
function signRecoverable(h, d, e) {
  if (!isPrivate(d)) {
    throw new Error(THROW_BAD_PRIVATE);
  }
  if (!isHash(h)) {
    throw new Error(THROW_BAD_SCALAR);
  }
  if (!isExtraData(e)) {
    throw new Error(THROW_BAD_EXTRA_DATA);
  }
  var _necc__namespace$sign = necc__namespace.signSync(h, d, {
      der: false,
      extraEntropy: e,
      recovered: true
    }),
    _necc__namespace$sign2 = _slicedToArray(_necc__namespace$sign, 2),
    signature = _necc__namespace$sign2[0],
    recoveryId = _necc__namespace$sign2[1];
  return {
    signature: signature,
    recoveryId: recoveryId
  };
}
function signSchnorr(h, d) {
  var e = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : Buffer.alloc(32, 0x00);
  if (!isPrivate(d)) {
    throw new Error(THROW_BAD_PRIVATE);
  }
  if (!isHash(h)) {
    throw new Error(THROW_BAD_SCALAR);
  }
  if (!isExtraData(e)) {
    throw new Error(THROW_BAD_EXTRA_DATA);
  }
  return necc__namespace.schnorr.signSync(h, d, e);
}
function recover(h, signature, recoveryId, compressed) {
  if (!isHash(h)) {
    throw new Error(THROW_BAD_HASH);
  }
  if (!isSignature(signature) || !isSignatureNonzeroRS(signature)) {
    throw new Error(THROW_BAD_SIGNATURE);
  }
  if (recoveryId & 2) {
    if (!isSigrLessThanPMinusN(signature)) throw new Error(THROW_BAD_RECOVERY_ID);
  }
  if (!isXOnlyPoint(signature.subarray(0, 32))) {
    throw new Error(THROW_BAD_SIGNATURE);
  }
  return necc__namespace.recoverPublicKey(h, signature, recoveryId, assumeCompression(compressed));
}
function verify(h, Q, signature, strict) {
  if (!isPoint(Q)) {
    throw new Error(THROW_BAD_POINT);
  }
  if (!isSignature(signature)) {
    throw new Error(THROW_BAD_SIGNATURE);
  }
  if (!isHash(h)) {
    throw new Error(THROW_BAD_SCALAR);
  }
  return necc__namespace.verify(signature, h, Q, {
    strict: strict
  });
}
function verifySchnorr(h, Q, signature) {
  if (!isXOnlyPoint(Q)) {
    throw new Error(THROW_BAD_POINT);
  }
  if (!isSignature(signature)) {
    throw new Error(THROW_BAD_SIGNATURE);
  }
  if (!isHash(h)) {
    throw new Error(THROW_BAD_SCALAR);
  }
  return necc__namespace.schnorr.verifySync(signature, h, Q);
}
exports.isPoint = isPoint;
exports.isPointCompressed = isPointCompressed;
exports.isPrivate = isPrivate;
exports.isXOnlyPoint = isXOnlyPoint;
exports.pointAdd = pointAdd;
exports.pointAddScalar = pointAddScalar;
exports.pointCompress = pointCompress;
exports.pointFromScalar = pointFromScalar;
exports.pointMultiply = pointMultiply;
exports.privateAdd = privateAdd;
exports.privateNegate = privateNegate;
exports.privateSub = privateSub;
exports.recover = recover;
exports.sign = sign;
exports.signRecoverable = signRecoverable;
exports.signSchnorr = signSchnorr;
exports.verify = verify;
exports.verifySchnorr = verifySchnorr;
exports.xOnlyPointAddTweak = xOnlyPointAddTweak;
exports.xOnlyPointFromPoint = xOnlyPointFromPoint;
exports.xOnlyPointFromScalar = xOnlyPointFromScalar;

}).call(this)}).call(this,require("buffer").Buffer)
},{"@noble/hashes/hmac":8,"@noble/hashes/sha256":11,"@noble/secp256k1":3,"buffer":"buffer"}],3:[function(require,module,exports){
"use strict";

/*! noble-secp256k1 - MIT License (c) 2019 Paul Miller (paulmillr.com) */
function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
function _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }
function _regeneratorRuntime() { "use strict"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return e; }; var t, e = {}, r = Object.prototype, n = r.hasOwnProperty, o = Object.defineProperty || function (t, e, r) { t[e] = r.value; }, i = "function" == typeof Symbol ? Symbol : {}, a = i.iterator || "@@iterator", c = i.asyncIterator || "@@asyncIterator", u = i.toStringTag || "@@toStringTag"; function define(t, e, r) { return Object.defineProperty(t, e, { value: r, enumerable: !0, configurable: !0, writable: !0 }), t[e]; } try { define({}, ""); } catch (t) { define = function define(t, e, r) { return t[e] = r; }; } function wrap(t, e, r, n) { var i = e && e.prototype instanceof Generator ? e : Generator, a = Object.create(i.prototype), c = new Context(n || []); return o(a, "_invoke", { value: makeInvokeMethod(t, r, c) }), a; } function tryCatch(t, e, r) { try { return { type: "normal", arg: t.call(e, r) }; } catch (t) { return { type: "throw", arg: t }; } } e.wrap = wrap; var h = "suspendedStart", l = "suspendedYield", f = "executing", s = "completed", y = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var p = {}; define(p, a, function () { return this; }); var d = Object.getPrototypeOf, v = d && d(d(values([]))); v && v !== r && n.call(v, a) && (p = v); var g = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(p); function defineIteratorMethods(t) { ["next", "throw", "return"].forEach(function (e) { define(t, e, function (t) { return this._invoke(e, t); }); }); } function AsyncIterator(t, e) { function invoke(r, o, i, a) { var c = tryCatch(t[r], t, o); if ("throw" !== c.type) { var u = c.arg, h = u.value; return h && "object" == _typeof(h) && n.call(h, "__await") ? e.resolve(h.__await).then(function (t) { invoke("next", t, i, a); }, function (t) { invoke("throw", t, i, a); }) : e.resolve(h).then(function (t) { u.value = t, i(u); }, function (t) { return invoke("throw", t, i, a); }); } a(c.arg); } var r; o(this, "_invoke", { value: function value(t, n) { function callInvokeWithMethodAndArg() { return new e(function (e, r) { invoke(t, n, e, r); }); } return r = r ? r.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); } }); } function makeInvokeMethod(e, r, n) { var o = h; return function (i, a) { if (o === f) throw Error("Generator is already running"); if (o === s) { if ("throw" === i) throw a; return { value: t, done: !0 }; } for (n.method = i, n.arg = a;;) { var c = n.delegate; if (c) { var u = maybeInvokeDelegate(c, n); if (u) { if (u === y) continue; return u; } } if ("next" === n.method) n.sent = n._sent = n.arg;else if ("throw" === n.method) { if (o === h) throw o = s, n.arg; n.dispatchException(n.arg); } else "return" === n.method && n.abrupt("return", n.arg); o = f; var p = tryCatch(e, r, n); if ("normal" === p.type) { if (o = n.done ? s : l, p.arg === y) continue; return { value: p.arg, done: n.done }; } "throw" === p.type && (o = s, n.method = "throw", n.arg = p.arg); } }; } function maybeInvokeDelegate(e, r) { var n = r.method, o = e.iterator[n]; if (o === t) return r.delegate = null, "throw" === n && e.iterator["return"] && (r.method = "return", r.arg = t, maybeInvokeDelegate(e, r), "throw" === r.method) || "return" !== n && (r.method = "throw", r.arg = new TypeError("The iterator does not provide a '" + n + "' method")), y; var i = tryCatch(o, e.iterator, r.arg); if ("throw" === i.type) return r.method = "throw", r.arg = i.arg, r.delegate = null, y; var a = i.arg; return a ? a.done ? (r[e.resultName] = a.value, r.next = e.nextLoc, "return" !== r.method && (r.method = "next", r.arg = t), r.delegate = null, y) : a : (r.method = "throw", r.arg = new TypeError("iterator result is not an object"), r.delegate = null, y); } function pushTryEntry(t) { var e = { tryLoc: t[0] }; 1 in t && (e.catchLoc = t[1]), 2 in t && (e.finallyLoc = t[2], e.afterLoc = t[3]), this.tryEntries.push(e); } function resetTryEntry(t) { var e = t.completion || {}; e.type = "normal", delete e.arg, t.completion = e; } function Context(t) { this.tryEntries = [{ tryLoc: "root" }], t.forEach(pushTryEntry, this), this.reset(!0); } function values(e) { if (e || "" === e) { var r = e[a]; if (r) return r.call(e); if ("function" == typeof e.next) return e; if (!isNaN(e.length)) { var o = -1, i = function next() { for (; ++o < e.length;) if (n.call(e, o)) return next.value = e[o], next.done = !1, next; return next.value = t, next.done = !0, next; }; return i.next = i; } } throw new TypeError(_typeof(e) + " is not iterable"); } return GeneratorFunction.prototype = GeneratorFunctionPrototype, o(g, "constructor", { value: GeneratorFunctionPrototype, configurable: !0 }), o(GeneratorFunctionPrototype, "constructor", { value: GeneratorFunction, configurable: !0 }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, u, "GeneratorFunction"), e.isGeneratorFunction = function (t) { var e = "function" == typeof t && t.constructor; return !!e && (e === GeneratorFunction || "GeneratorFunction" === (e.displayName || e.name)); }, e.mark = function (t) { return Object.setPrototypeOf ? Object.setPrototypeOf(t, GeneratorFunctionPrototype) : (t.__proto__ = GeneratorFunctionPrototype, define(t, u, "GeneratorFunction")), t.prototype = Object.create(g), t; }, e.awrap = function (t) { return { __await: t }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, c, function () { return this; }), e.AsyncIterator = AsyncIterator, e.async = function (t, r, n, o, i) { void 0 === i && (i = Promise); var a = new AsyncIterator(wrap(t, r, n, o), i); return e.isGeneratorFunction(r) ? a : a.next().then(function (t) { return t.done ? t.value : a.next(); }); }, defineIteratorMethods(g), define(g, u, "Generator"), define(g, a, function () { return this; }), define(g, "toString", function () { return "[object Generator]"; }), e.keys = function (t) { var e = Object(t), r = []; for (var n in e) r.push(n); return r.reverse(), function next() { for (; r.length;) { var t = r.pop(); if (t in e) return next.value = t, next.done = !1, next; } return next.done = !0, next; }; }, e.values = values, Context.prototype = { constructor: Context, reset: function reset(e) { if (this.prev = 0, this.next = 0, this.sent = this._sent = t, this.done = !1, this.delegate = null, this.method = "next", this.arg = t, this.tryEntries.forEach(resetTryEntry), !e) for (var r in this) "t" === r.charAt(0) && n.call(this, r) && !isNaN(+r.slice(1)) && (this[r] = t); }, stop: function stop() { this.done = !0; var t = this.tryEntries[0].completion; if ("throw" === t.type) throw t.arg; return this.rval; }, dispatchException: function dispatchException(e) { if (this.done) throw e; var r = this; function handle(n, o) { return a.type = "throw", a.arg = e, r.next = n, o && (r.method = "next", r.arg = t), !!o; } for (var o = this.tryEntries.length - 1; o >= 0; --o) { var i = this.tryEntries[o], a = i.completion; if ("root" === i.tryLoc) return handle("end"); if (i.tryLoc <= this.prev) { var c = n.call(i, "catchLoc"), u = n.call(i, "finallyLoc"); if (c && u) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } else if (c) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); } else { if (!u) throw Error("try statement without catch or finally"); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } } } }, abrupt: function abrupt(t, e) { for (var r = this.tryEntries.length - 1; r >= 0; --r) { var o = this.tryEntries[r]; if (o.tryLoc <= this.prev && n.call(o, "finallyLoc") && this.prev < o.finallyLoc) { var i = o; break; } } i && ("break" === t || "continue" === t) && i.tryLoc <= e && e <= i.finallyLoc && (i = null); var a = i ? i.completion : {}; return a.type = t, a.arg = e, i ? (this.method = "next", this.next = i.finallyLoc, y) : this.complete(a); }, complete: function complete(t, e) { if ("throw" === t.type) throw t.arg; return "break" === t.type || "continue" === t.type ? this.next = t.arg : "return" === t.type ? (this.rval = this.arg = t.arg, this.method = "return", this.next = "end") : "normal" === t.type && e && (this.next = e), y; }, finish: function finish(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.finallyLoc === t) return this.complete(r.completion, r.afterLoc), resetTryEntry(r), y; } }, "catch": function _catch(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.tryLoc === t) { var n = r.completion; if ("throw" === n.type) { var o = n.arg; resetTryEntry(r); } return o; } } throw Error("illegal catch attempt"); }, delegateYield: function delegateYield(e, r, n) { return this.delegate = { iterator: values(e), resultName: r, nextLoc: n }, "next" === this.method && (this.arg = t), y; } }, e; }
function asyncGeneratorStep(n, t, e, r, o, a, c) { try { var i = n[a](c), u = i.value; } catch (n) { return void e(n); } i.done ? t(u) : Promise.resolve(u).then(r, o); }
function _asyncToGenerator(n) { return function () { var t = this, e = arguments; return new Promise(function (r, o) { var a = n.apply(t, e); function _next(n) { asyncGeneratorStep(a, r, o, _next, _throw, "next", n); } function _throw(n) { asyncGeneratorStep(a, r, o, _next, _throw, "throw", n); } _next(void 0); }); }; }
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }
function _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: !1 }), e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
function _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function"); }
function _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }
function _possibleConstructorReturn(t, e) { if (e && ("object" == _typeof(e) || "function" == typeof e)) return e; if (void 0 !== e) throw new TypeError("Derived constructors may only return object or undefined"); return _assertThisInitialized(t); }
function _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); return e; }
function _inherits(t, e) { if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, "prototype", { writable: !1 }), e && _setPrototypeOf(t, e); }
function _wrapNativeSuper(t) { var r = "function" == typeof Map ? new Map() : void 0; return _wrapNativeSuper = function _wrapNativeSuper(t) { if (null === t || !_isNativeFunction(t)) return t; if ("function" != typeof t) throw new TypeError("Super expression must either be null or a function"); if (void 0 !== r) { if (r.has(t)) return r.get(t); r.set(t, Wrapper); } function Wrapper() { return _construct(t, arguments, _getPrototypeOf(this).constructor); } return Wrapper.prototype = Object.create(t.prototype, { constructor: { value: Wrapper, enumerable: !1, writable: !0, configurable: !0 } }), _setPrototypeOf(Wrapper, t); }, _wrapNativeSuper(t); }
function _construct(t, e, r) { if (_isNativeReflectConstruct()) return Reflect.construct.apply(null, arguments); var o = [null]; o.push.apply(o, e); var p = new (t.bind.apply(t, o))(); return r && _setPrototypeOf(p, r.prototype), p; }
function _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }
function _isNativeFunction(t) { try { return -1 !== Function.toString.call(t).indexOf("[native code]"); } catch (n) { return "function" == typeof t; } }
function _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }
function _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.utils = exports.schnorr = exports.verify = exports.signSync = exports.sign = exports.getSharedSecret = exports.recoverPublicKey = exports.getPublicKey = exports.Signature = exports.Point = exports.CURVE = void 0;
var nodeCrypto = require("crypto");
var _0n = BigInt(0);
var _1n = BigInt(1);
var _2n = BigInt(2);
var _3n = BigInt(3);
var _8n = BigInt(8);
var CURVE = Object.freeze({
  a: _0n,
  b: BigInt(7),
  P: BigInt('0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f'),
  n: BigInt('0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141'),
  h: _1n,
  Gx: BigInt('55066263022277343669578718895168534326250603453777594175500187360389116729240'),
  Gy: BigInt('32670510020758816978083085130507043184471273380659243275938904335757337482424'),
  beta: BigInt('0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee')
});
exports.CURVE = CURVE;
var divNearest = function divNearest(a, b) {
  return (a + b / _2n) / b;
};
var endo = {
  beta: BigInt('0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee'),
  splitScalar: function splitScalar(k) {
    var n = CURVE.n;
    var a1 = BigInt('0x3086d221a7d46bcde86c90e49284eb15');
    var b1 = -_1n * BigInt('0xe4437ed6010e88286f547fa90abfe4c3');
    var a2 = BigInt('0x114ca50f7a8e2f3f657c1108d9d44cfd8');
    var b2 = a1;
    var POW_2_128 = BigInt('0x100000000000000000000000000000000');
    var c1 = divNearest(b2 * k, n);
    var c2 = divNearest(-b1 * k, n);
    var k1 = mod(k - c1 * a1 - c2 * a2, n);
    var k2 = mod(-c1 * b1 - c2 * b2, n);
    var k1neg = k1 > POW_2_128;
    var k2neg = k2 > POW_2_128;
    if (k1neg) k1 = n - k1;
    if (k2neg) k2 = n - k2;
    if (k1 > POW_2_128 || k2 > POW_2_128) {
      throw new Error('splitScalarEndo: Endomorphism failed, k=' + k);
    }
    return {
      k1neg: k1neg,
      k1: k1,
      k2neg: k2neg,
      k2: k2
    };
  }
};
var fieldLen = 32;
var groupLen = 32;
var hashLen = 32;
var compressedLen = fieldLen + 1;
var uncompressedLen = 2 * fieldLen + 1;
function weierstrass(x) {
  var a = CURVE.a,
    b = CURVE.b;
  var x2 = mod(x * x);
  var x3 = mod(x2 * x);
  return mod(x3 + a * x + b);
}
var USE_ENDOMORPHISM = CURVE.a === _0n;
var ShaError = /*#__PURE__*/function (_Error) {
  function ShaError(message) {
    _classCallCheck(this, ShaError);
    return _callSuper(this, ShaError, [message]);
  }
  _inherits(ShaError, _Error);
  return _createClass(ShaError);
}(/*#__PURE__*/_wrapNativeSuper(Error));
function assertJacPoint(other) {
  if (!(other instanceof JacobianPoint)) throw new TypeError('JacobianPoint expected');
}
var JacobianPoint = /*#__PURE__*/function () {
  function JacobianPoint(x, y, z) {
    _classCallCheck(this, JacobianPoint);
    this.x = x;
    this.y = y;
    this.z = z;
  }
  return _createClass(JacobianPoint, [{
    key: "equals",
    value: function equals(other) {
      assertJacPoint(other);
      var X1 = this.x,
        Y1 = this.y,
        Z1 = this.z;
      var X2 = other.x,
        Y2 = other.y,
        Z2 = other.z;
      var Z1Z1 = mod(Z1 * Z1);
      var Z2Z2 = mod(Z2 * Z2);
      var U1 = mod(X1 * Z2Z2);
      var U2 = mod(X2 * Z1Z1);
      var S1 = mod(mod(Y1 * Z2) * Z2Z2);
      var S2 = mod(mod(Y2 * Z1) * Z1Z1);
      return U1 === U2 && S1 === S2;
    }
  }, {
    key: "negate",
    value: function negate() {
      return new JacobianPoint(this.x, mod(-this.y), this.z);
    }
  }, {
    key: "double",
    value: function _double() {
      var X1 = this.x,
        Y1 = this.y,
        Z1 = this.z;
      var A = mod(X1 * X1);
      var B = mod(Y1 * Y1);
      var C = mod(B * B);
      var x1b = X1 + B;
      var D = mod(_2n * (mod(x1b * x1b) - A - C));
      var E = mod(_3n * A);
      var F = mod(E * E);
      var X3 = mod(F - _2n * D);
      var Y3 = mod(E * (D - X3) - _8n * C);
      var Z3 = mod(_2n * Y1 * Z1);
      return new JacobianPoint(X3, Y3, Z3);
    }
  }, {
    key: "add",
    value: function add(other) {
      assertJacPoint(other);
      var X1 = this.x,
        Y1 = this.y,
        Z1 = this.z;
      var X2 = other.x,
        Y2 = other.y,
        Z2 = other.z;
      if (X2 === _0n || Y2 === _0n) return this;
      if (X1 === _0n || Y1 === _0n) return other;
      var Z1Z1 = mod(Z1 * Z1);
      var Z2Z2 = mod(Z2 * Z2);
      var U1 = mod(X1 * Z2Z2);
      var U2 = mod(X2 * Z1Z1);
      var S1 = mod(mod(Y1 * Z2) * Z2Z2);
      var S2 = mod(mod(Y2 * Z1) * Z1Z1);
      var H = mod(U2 - U1);
      var r = mod(S2 - S1);
      if (H === _0n) {
        if (r === _0n) {
          return this["double"]();
        } else {
          return JacobianPoint.ZERO;
        }
      }
      var HH = mod(H * H);
      var HHH = mod(H * HH);
      var V = mod(U1 * HH);
      var X3 = mod(r * r - HHH - _2n * V);
      var Y3 = mod(r * (V - X3) - S1 * HHH);
      var Z3 = mod(Z1 * Z2 * H);
      return new JacobianPoint(X3, Y3, Z3);
    }
  }, {
    key: "subtract",
    value: function subtract(other) {
      return this.add(other.negate());
    }
  }, {
    key: "multiplyUnsafe",
    value: function multiplyUnsafe(scalar) {
      var P0 = JacobianPoint.ZERO;
      if (typeof scalar === 'bigint' && scalar === _0n) return P0;
      var n = normalizeScalar(scalar);
      if (n === _1n) return this;
      if (!USE_ENDOMORPHISM) {
        var p = P0;
        var _d = this;
        while (n > _0n) {
          if (n & _1n) p = p.add(_d);
          _d = _d["double"]();
          n >>= _1n;
        }
        return p;
      }
      var _endo$splitScalar = endo.splitScalar(n),
        k1neg = _endo$splitScalar.k1neg,
        k1 = _endo$splitScalar.k1,
        k2neg = _endo$splitScalar.k2neg,
        k2 = _endo$splitScalar.k2;
      var k1p = P0;
      var k2p = P0;
      var d = this;
      while (k1 > _0n || k2 > _0n) {
        if (k1 & _1n) k1p = k1p.add(d);
        if (k2 & _1n) k2p = k2p.add(d);
        d = d["double"]();
        k1 >>= _1n;
        k2 >>= _1n;
      }
      if (k1neg) k1p = k1p.negate();
      if (k2neg) k2p = k2p.negate();
      k2p = new JacobianPoint(mod(k2p.x * endo.beta), k2p.y, k2p.z);
      return k1p.add(k2p);
    }
  }, {
    key: "precomputeWindow",
    value: function precomputeWindow(W) {
      var windows = USE_ENDOMORPHISM ? 128 / W + 1 : 256 / W + 1;
      var points = [];
      var p = this;
      var base = p;
      for (var window = 0; window < windows; window++) {
        base = p;
        points.push(base);
        for (var i = 1; i < Math.pow(2, W - 1); i++) {
          base = base.add(p);
          points.push(base);
        }
        p = base["double"]();
      }
      return points;
    }
  }, {
    key: "wNAF",
    value: function wNAF(n, affinePoint) {
      if (!affinePoint && this.equals(JacobianPoint.BASE)) affinePoint = Point.BASE;
      var W = affinePoint && affinePoint._WINDOW_SIZE || 1;
      if (256 % W) {
        throw new Error('Point#wNAF: Invalid precomputation window, must be power of 2');
      }
      var precomputes = affinePoint && pointPrecomputes.get(affinePoint);
      if (!precomputes) {
        precomputes = this.precomputeWindow(W);
        if (affinePoint && W !== 1) {
          precomputes = JacobianPoint.normalizeZ(precomputes);
          pointPrecomputes.set(affinePoint, precomputes);
        }
      }
      var p = JacobianPoint.ZERO;
      var f = JacobianPoint.BASE;
      var windows = 1 + (USE_ENDOMORPHISM ? 128 / W : 256 / W);
      var windowSize = Math.pow(2, W - 1);
      var mask = BigInt(Math.pow(2, W) - 1);
      var maxNumber = Math.pow(2, W);
      var shiftBy = BigInt(W);
      for (var window = 0; window < windows; window++) {
        var offset = window * windowSize;
        var wbits = Number(n & mask);
        n >>= shiftBy;
        if (wbits > windowSize) {
          wbits -= maxNumber;
          n += _1n;
        }
        var offset1 = offset;
        var offset2 = offset + Math.abs(wbits) - 1;
        var cond1 = window % 2 !== 0;
        var cond2 = wbits < 0;
        if (wbits === 0) {
          f = f.add(constTimeNegate(cond1, precomputes[offset1]));
        } else {
          p = p.add(constTimeNegate(cond2, precomputes[offset2]));
        }
      }
      return {
        p: p,
        f: f
      };
    }
  }, {
    key: "multiply",
    value: function multiply(scalar, affinePoint) {
      var n = normalizeScalar(scalar);
      var point;
      var fake;
      if (USE_ENDOMORPHISM) {
        var _endo$splitScalar2 = endo.splitScalar(n),
          k1neg = _endo$splitScalar2.k1neg,
          k1 = _endo$splitScalar2.k1,
          k2neg = _endo$splitScalar2.k2neg,
          k2 = _endo$splitScalar2.k2;
        var _this$wNAF = this.wNAF(k1, affinePoint),
          k1p = _this$wNAF.p,
          f1p = _this$wNAF.f;
        var _this$wNAF2 = this.wNAF(k2, affinePoint),
          k2p = _this$wNAF2.p,
          f2p = _this$wNAF2.f;
        k1p = constTimeNegate(k1neg, k1p);
        k2p = constTimeNegate(k2neg, k2p);
        k2p = new JacobianPoint(mod(k2p.x * endo.beta), k2p.y, k2p.z);
        point = k1p.add(k2p);
        fake = f1p.add(f2p);
      } else {
        var _this$wNAF3 = this.wNAF(n, affinePoint),
          p = _this$wNAF3.p,
          f = _this$wNAF3.f;
        point = p;
        fake = f;
      }
      return JacobianPoint.normalizeZ([point, fake])[0];
    }
  }, {
    key: "toAffine",
    value: function toAffine(invZ) {
      var x = this.x,
        y = this.y,
        z = this.z;
      var is0 = this.equals(JacobianPoint.ZERO);
      if (invZ == null) invZ = is0 ? _8n : invert(z);
      var iz1 = invZ;
      var iz2 = mod(iz1 * iz1);
      var iz3 = mod(iz2 * iz1);
      var ax = mod(x * iz2);
      var ay = mod(y * iz3);
      var zz = mod(z * iz1);
      if (is0) return Point.ZERO;
      if (zz !== _1n) throw new Error('invZ was invalid');
      return new Point(ax, ay);
    }
  }], [{
    key: "fromAffine",
    value: function fromAffine(p) {
      if (!(p instanceof Point)) {
        throw new TypeError('JacobianPoint#fromAffine: expected Point');
      }
      if (p.equals(Point.ZERO)) return JacobianPoint.ZERO;
      return new JacobianPoint(p.x, p.y, _1n);
    }
  }, {
    key: "toAffineBatch",
    value: function toAffineBatch(points) {
      var toInv = invertBatch(points.map(function (p) {
        return p.z;
      }));
      return points.map(function (p, i) {
        return p.toAffine(toInv[i]);
      });
    }
  }, {
    key: "normalizeZ",
    value: function normalizeZ(points) {
      return JacobianPoint.toAffineBatch(points).map(JacobianPoint.fromAffine);
    }
  }]);
}();
JacobianPoint.BASE = new JacobianPoint(CURVE.Gx, CURVE.Gy, _1n);
JacobianPoint.ZERO = new JacobianPoint(_0n, _1n, _0n);
function constTimeNegate(condition, item) {
  var neg = item.negate();
  return condition ? neg : item;
}
var pointPrecomputes = new WeakMap();
var Point = /*#__PURE__*/function () {
  function Point(x, y) {
    _classCallCheck(this, Point);
    this.x = x;
    this.y = y;
  }
  return _createClass(Point, [{
    key: "_setWindowSize",
    value: function _setWindowSize(windowSize) {
      this._WINDOW_SIZE = windowSize;
      pointPrecomputes["delete"](this);
    }
  }, {
    key: "hasEvenY",
    value: function hasEvenY() {
      return this.y % _2n === _0n;
    }
  }, {
    key: "toRawBytes",
    value: function toRawBytes() {
      var isCompressed = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
      return hexToBytes(this.toHex(isCompressed));
    }
  }, {
    key: "toHex",
    value: function toHex() {
      var isCompressed = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
      var x = numTo32bStr(this.x);
      if (isCompressed) {
        var prefix = this.hasEvenY() ? '02' : '03';
        return "".concat(prefix).concat(x);
      } else {
        return "04".concat(x).concat(numTo32bStr(this.y));
      }
    }
  }, {
    key: "toHexX",
    value: function toHexX() {
      return this.toHex(true).slice(2);
    }
  }, {
    key: "toRawX",
    value: function toRawX() {
      return this.toRawBytes(true).slice(1);
    }
  }, {
    key: "assertValidity",
    value: function assertValidity() {
      var msg = 'Point is not on elliptic curve';
      var x = this.x,
        y = this.y;
      if (!isValidFieldElement(x) || !isValidFieldElement(y)) throw new Error(msg);
      var left = mod(y * y);
      var right = weierstrass(x);
      if (mod(left - right) !== _0n) throw new Error(msg);
    }
  }, {
    key: "equals",
    value: function equals(other) {
      return this.x === other.x && this.y === other.y;
    }
  }, {
    key: "negate",
    value: function negate() {
      return new Point(this.x, mod(-this.y));
    }
  }, {
    key: "double",
    value: function _double2() {
      return JacobianPoint.fromAffine(this)["double"]().toAffine();
    }
  }, {
    key: "add",
    value: function add(other) {
      return JacobianPoint.fromAffine(this).add(JacobianPoint.fromAffine(other)).toAffine();
    }
  }, {
    key: "subtract",
    value: function subtract(other) {
      return this.add(other.negate());
    }
  }, {
    key: "multiply",
    value: function multiply(scalar) {
      return JacobianPoint.fromAffine(this).multiply(scalar, this).toAffine();
    }
  }, {
    key: "multiplyAndAddUnsafe",
    value: function multiplyAndAddUnsafe(Q, a, b) {
      var P = JacobianPoint.fromAffine(this);
      var aP = a === _0n || a === _1n || this !== Point.BASE ? P.multiplyUnsafe(a) : P.multiply(a);
      var bQ = JacobianPoint.fromAffine(Q).multiplyUnsafe(b);
      var sum = aP.add(bQ);
      return sum.equals(JacobianPoint.ZERO) ? undefined : sum.toAffine();
    }
  }], [{
    key: "fromCompressedHex",
    value: function fromCompressedHex(bytes) {
      var isShort = bytes.length === 32;
      var x = bytesToNumber(isShort ? bytes : bytes.subarray(1));
      if (!isValidFieldElement(x)) throw new Error('Point is not on curve');
      var y2 = weierstrass(x);
      var y = sqrtMod(y2);
      var isYOdd = (y & _1n) === _1n;
      if (isShort) {
        if (isYOdd) y = mod(-y);
      } else {
        var isFirstByteOdd = (bytes[0] & 1) === 1;
        if (isFirstByteOdd !== isYOdd) y = mod(-y);
      }
      var point = new Point(x, y);
      point.assertValidity();
      return point;
    }
  }, {
    key: "fromUncompressedHex",
    value: function fromUncompressedHex(bytes) {
      var x = bytesToNumber(bytes.subarray(1, fieldLen + 1));
      var y = bytesToNumber(bytes.subarray(fieldLen + 1, fieldLen * 2 + 1));
      var point = new Point(x, y);
      point.assertValidity();
      return point;
    }
  }, {
    key: "fromHex",
    value: function fromHex(hex) {
      var bytes = ensureBytes(hex);
      var len = bytes.length;
      var header = bytes[0];
      if (len === fieldLen) return this.fromCompressedHex(bytes);
      if (len === compressedLen && (header === 0x02 || header === 0x03)) {
        return this.fromCompressedHex(bytes);
      }
      if (len === uncompressedLen && header === 0x04) return this.fromUncompressedHex(bytes);
      throw new Error("Point.fromHex: received invalid point. Expected 32-".concat(compressedLen, " compressed bytes or ").concat(uncompressedLen, " uncompressed bytes, not ").concat(len));
    }
  }, {
    key: "fromPrivateKey",
    value: function fromPrivateKey(privateKey) {
      return Point.BASE.multiply(normalizePrivateKey(privateKey));
    }
  }, {
    key: "fromSignature",
    value: function fromSignature(msgHash, signature, recovery) {
      var _normalizeSignature = normalizeSignature(signature),
        r = _normalizeSignature.r,
        s = _normalizeSignature.s;
      if (![0, 1, 2, 3].includes(recovery)) throw new Error('Cannot recover: invalid recovery bit');
      var h = truncateHash(ensureBytes(msgHash));
      var n = CURVE.n;
      var radj = recovery === 2 || recovery === 3 ? r + n : r;
      var rinv = invert(radj, n);
      var u1 = mod(-h * rinv, n);
      var u2 = mod(s * rinv, n);
      var prefix = recovery & 1 ? '03' : '02';
      var R = Point.fromHex(prefix + numTo32bStr(radj));
      var Q = Point.BASE.multiplyAndAddUnsafe(R, u1, u2);
      if (!Q) throw new Error('Cannot recover signature: point at infinify');
      Q.assertValidity();
      return Q;
    }
  }]);
}();
exports.Point = Point;
Point.BASE = new Point(CURVE.Gx, CURVE.Gy);
Point.ZERO = new Point(_0n, _0n);
function sliceDER(s) {
  return Number.parseInt(s[0], 16) >= 8 ? '00' + s : s;
}
function parseDERInt(data) {
  if (data.length < 2 || data[0] !== 0x02) {
    throw new Error("Invalid signature integer tag: ".concat(bytesToHex(data)));
  }
  var len = data[1];
  var res = data.subarray(2, len + 2);
  if (!len || res.length !== len) {
    throw new Error("Invalid signature integer: wrong length");
  }
  if (res[0] === 0x00 && res[1] <= 0x7f) {
    throw new Error('Invalid signature integer: trailing length');
  }
  return {
    data: bytesToNumber(res),
    left: data.subarray(len + 2)
  };
}
function parseDERSignature(data) {
  if (data.length < 2 || data[0] != 0x30) {
    throw new Error("Invalid signature tag: ".concat(bytesToHex(data)));
  }
  if (data[1] !== data.length - 2) {
    throw new Error('Invalid signature: incorrect length');
  }
  var _parseDERInt = parseDERInt(data.subarray(2)),
    r = _parseDERInt.data,
    sBytes = _parseDERInt.left;
  var _parseDERInt2 = parseDERInt(sBytes),
    s = _parseDERInt2.data,
    rBytesLeft = _parseDERInt2.left;
  if (rBytesLeft.length) {
    throw new Error("Invalid signature: left bytes after parsing: ".concat(bytesToHex(rBytesLeft)));
  }
  return {
    r: r,
    s: s
  };
}
var Signature = /*#__PURE__*/function () {
  function Signature(r, s) {
    _classCallCheck(this, Signature);
    this.r = r;
    this.s = s;
    this.assertValidity();
  }
  return _createClass(Signature, [{
    key: "assertValidity",
    value: function assertValidity() {
      var r = this.r,
        s = this.s;
      if (!isWithinCurveOrder(r)) throw new Error('Invalid Signature: r must be 0 < r < n');
      if (!isWithinCurveOrder(s)) throw new Error('Invalid Signature: s must be 0 < s < n');
    }
  }, {
    key: "hasHighS",
    value: function hasHighS() {
      var HALF = CURVE.n >> _1n;
      return this.s > HALF;
    }
  }, {
    key: "normalizeS",
    value: function normalizeS() {
      return this.hasHighS() ? new Signature(this.r, mod(-this.s, CURVE.n)) : this;
    }
  }, {
    key: "toDERRawBytes",
    value: function toDERRawBytes() {
      return hexToBytes(this.toDERHex());
    }
  }, {
    key: "toDERHex",
    value: function toDERHex() {
      var sHex = sliceDER(numberToHexUnpadded(this.s));
      var rHex = sliceDER(numberToHexUnpadded(this.r));
      var sHexL = sHex.length / 2;
      var rHexL = rHex.length / 2;
      var sLen = numberToHexUnpadded(sHexL);
      var rLen = numberToHexUnpadded(rHexL);
      var length = numberToHexUnpadded(rHexL + sHexL + 4);
      return "30".concat(length, "02").concat(rLen).concat(rHex, "02").concat(sLen).concat(sHex);
    }
  }, {
    key: "toRawBytes",
    value: function toRawBytes() {
      return this.toDERRawBytes();
    }
  }, {
    key: "toHex",
    value: function toHex() {
      return this.toDERHex();
    }
  }, {
    key: "toCompactRawBytes",
    value: function toCompactRawBytes() {
      return hexToBytes(this.toCompactHex());
    }
  }, {
    key: "toCompactHex",
    value: function toCompactHex() {
      return numTo32bStr(this.r) + numTo32bStr(this.s);
    }
  }], [{
    key: "fromCompact",
    value: function fromCompact(hex) {
      var arr = hex instanceof Uint8Array;
      var name = 'Signature.fromCompact';
      if (typeof hex !== 'string' && !arr) throw new TypeError("".concat(name, ": Expected string or Uint8Array"));
      var str = arr ? bytesToHex(hex) : hex;
      if (str.length !== 128) throw new Error("".concat(name, ": Expected 64-byte hex"));
      return new Signature(hexToNumber(str.slice(0, 64)), hexToNumber(str.slice(64, 128)));
    }
  }, {
    key: "fromDER",
    value: function fromDER(hex) {
      var arr = hex instanceof Uint8Array;
      if (typeof hex !== 'string' && !arr) throw new TypeError("Signature.fromDER: Expected string or Uint8Array");
      var _parseDERSignature = parseDERSignature(arr ? hex : hexToBytes(hex)),
        r = _parseDERSignature.r,
        s = _parseDERSignature.s;
      return new Signature(r, s);
    }
  }, {
    key: "fromHex",
    value: function fromHex(hex) {
      return this.fromDER(hex);
    }
  }]);
}();
exports.Signature = Signature;
function concatBytes() {
  for (var _len = arguments.length, arrays = new Array(_len), _key = 0; _key < _len; _key++) {
    arrays[_key] = arguments[_key];
  }
  if (!arrays.every(function (b) {
    return b instanceof Uint8Array;
  })) throw new Error('Uint8Array list expected');
  if (arrays.length === 1) return arrays[0];
  var length = arrays.reduce(function (a, arr) {
    return a + arr.length;
  }, 0);
  var result = new Uint8Array(length);
  for (var i = 0, pad = 0; i < arrays.length; i++) {
    var arr = arrays[i];
    result.set(arr, pad);
    pad += arr.length;
  }
  return result;
}
var hexes = Array.from({
  length: 256
}, function (v, i) {
  return i.toString(16).padStart(2, '0');
});
function bytesToHex(uint8a) {
  if (!(uint8a instanceof Uint8Array)) throw new Error('Expected Uint8Array');
  var hex = '';
  for (var i = 0; i < uint8a.length; i++) {
    hex += hexes[uint8a[i]];
  }
  return hex;
}
var POW_2_256 = BigInt('0x10000000000000000000000000000000000000000000000000000000000000000');
function numTo32bStr(num) {
  if (typeof num !== 'bigint') throw new Error('Expected bigint');
  if (!(_0n <= num && num < POW_2_256)) throw new Error('Expected number 0 <= n < 2^256');
  return num.toString(16).padStart(64, '0');
}
function numTo32b(num) {
  var b = hexToBytes(numTo32bStr(num));
  if (b.length !== 32) throw new Error('Error: expected 32 bytes');
  return b;
}
function numberToHexUnpadded(num) {
  var hex = num.toString(16);
  return hex.length & 1 ? "0".concat(hex) : hex;
}
function hexToNumber(hex) {
  if (typeof hex !== 'string') {
    throw new TypeError('hexToNumber: expected string, got ' + _typeof(hex));
  }
  return BigInt("0x".concat(hex));
}
function hexToBytes(hex) {
  if (typeof hex !== 'string') {
    throw new TypeError('hexToBytes: expected string, got ' + _typeof(hex));
  }
  if (hex.length % 2) throw new Error('hexToBytes: received invalid unpadded hex' + hex.length);
  var array = new Uint8Array(hex.length / 2);
  for (var i = 0; i < array.length; i++) {
    var j = i * 2;
    var hexByte = hex.slice(j, j + 2);
    var _byte = Number.parseInt(hexByte, 16);
    if (Number.isNaN(_byte) || _byte < 0) throw new Error('Invalid byte sequence');
    array[i] = _byte;
  }
  return array;
}
function bytesToNumber(bytes) {
  return hexToNumber(bytesToHex(bytes));
}
function ensureBytes(hex) {
  return hex instanceof Uint8Array ? Uint8Array.from(hex) : hexToBytes(hex);
}
function normalizeScalar(num) {
  if (typeof num === 'number' && Number.isSafeInteger(num) && num > 0) return BigInt(num);
  if (typeof num === 'bigint' && isWithinCurveOrder(num)) return num;
  throw new TypeError('Expected valid private scalar: 0 < scalar < curve.n');
}
function mod(a) {
  var b = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : CURVE.P;
  var result = a % b;
  return result >= _0n ? result : b + result;
}
function pow2(x, power) {
  var P = CURVE.P;
  var res = x;
  while (power-- > _0n) {
    res *= res;
    res %= P;
  }
  return res;
}
function sqrtMod(x) {
  var P = CURVE.P;
  var _6n = BigInt(6);
  var _11n = BigInt(11);
  var _22n = BigInt(22);
  var _23n = BigInt(23);
  var _44n = BigInt(44);
  var _88n = BigInt(88);
  var b2 = x * x * x % P;
  var b3 = b2 * b2 * x % P;
  var b6 = pow2(b3, _3n) * b3 % P;
  var b9 = pow2(b6, _3n) * b3 % P;
  var b11 = pow2(b9, _2n) * b2 % P;
  var b22 = pow2(b11, _11n) * b11 % P;
  var b44 = pow2(b22, _22n) * b22 % P;
  var b88 = pow2(b44, _44n) * b44 % P;
  var b176 = pow2(b88, _88n) * b88 % P;
  var b220 = pow2(b176, _44n) * b44 % P;
  var b223 = pow2(b220, _3n) * b3 % P;
  var t1 = pow2(b223, _23n) * b22 % P;
  var t2 = pow2(t1, _6n) * b2 % P;
  var rt = pow2(t2, _2n);
  var xc = rt * rt % P;
  if (xc !== x) throw new Error('Cannot find square root');
  return rt;
}
function invert(number) {
  var modulo = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : CURVE.P;
  if (number === _0n || modulo <= _0n) {
    throw new Error("invert: expected positive integers, got n=".concat(number, " mod=").concat(modulo));
  }
  var a = mod(number, modulo);
  var b = modulo;
  var x = _0n,
    y = _1n,
    u = _1n,
    v = _0n;
  while (a !== _0n) {
    var q = b / a;
    var r = b % a;
    var m = x - u * q;
    var n = y - v * q;
    b = a, a = r, x = u, y = v, u = m, v = n;
  }
  var gcd = b;
  if (gcd !== _1n) throw new Error('invert: does not exist');
  return mod(x, modulo);
}
function invertBatch(nums) {
  var p = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : CURVE.P;
  var scratch = new Array(nums.length);
  var lastMultiplied = nums.reduce(function (acc, num, i) {
    if (num === _0n) return acc;
    scratch[i] = acc;
    return mod(acc * num, p);
  }, _1n);
  var inverted = invert(lastMultiplied, p);
  nums.reduceRight(function (acc, num, i) {
    if (num === _0n) return acc;
    scratch[i] = mod(acc * scratch[i], p);
    return mod(acc * num, p);
  }, inverted);
  return scratch;
}
function bits2int_2(bytes) {
  var delta = bytes.length * 8 - groupLen * 8;
  var num = bytesToNumber(bytes);
  return delta > 0 ? num >> BigInt(delta) : num;
}
function truncateHash(hash) {
  var truncateOnly = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
  var h = bits2int_2(hash);
  if (truncateOnly) return h;
  var n = CURVE.n;
  return h >= n ? h - n : h;
}
var _sha256Sync;
var _hmacSha256Sync;
var HmacDrbg = /*#__PURE__*/function () {
  function HmacDrbg(hashLen, qByteLen) {
    _classCallCheck(this, HmacDrbg);
    this.hashLen = hashLen;
    this.qByteLen = qByteLen;
    if (typeof hashLen !== 'number' || hashLen < 2) throw new Error('hashLen must be a number');
    if (typeof qByteLen !== 'number' || qByteLen < 2) throw new Error('qByteLen must be a number');
    this.v = new Uint8Array(hashLen).fill(1);
    this.k = new Uint8Array(hashLen).fill(0);
    this.counter = 0;
  }
  return _createClass(HmacDrbg, [{
    key: "hmac",
    value: function hmac() {
      var _exports$utils;
      for (var _len2 = arguments.length, values = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
        values[_key2] = arguments[_key2];
      }
      return (_exports$utils = exports.utils).hmacSha256.apply(_exports$utils, [this.k].concat(values));
    }
  }, {
    key: "hmacSync",
    value: function hmacSync() {
      for (var _len3 = arguments.length, values = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
        values[_key3] = arguments[_key3];
      }
      return _hmacSha256Sync.apply(void 0, [this.k].concat(values));
    }
  }, {
    key: "checkSync",
    value: function checkSync() {
      if (typeof _hmacSha256Sync !== 'function') throw new ShaError('hmacSha256Sync needs to be set');
    }
  }, {
    key: "incr",
    value: function incr() {
      if (this.counter >= 1000) throw new Error('Tried 1,000 k values for sign(), all were invalid');
      this.counter += 1;
    }
  }, {
    key: "reseed",
    value: function () {
      var _reseed = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee() {
        var seed,
          _args = arguments;
        return _regeneratorRuntime().wrap(function _callee$(_context) {
          while (1) switch (_context.prev = _context.next) {
            case 0:
              seed = _args.length > 0 && _args[0] !== undefined ? _args[0] : new Uint8Array();
              _context.next = 3;
              return this.hmac(this.v, Uint8Array.from([0x00]), seed);
            case 3:
              this.k = _context.sent;
              _context.next = 6;
              return this.hmac(this.v);
            case 6:
              this.v = _context.sent;
              if (!(seed.length === 0)) {
                _context.next = 9;
                break;
              }
              return _context.abrupt("return");
            case 9:
              _context.next = 11;
              return this.hmac(this.v, Uint8Array.from([0x01]), seed);
            case 11:
              this.k = _context.sent;
              _context.next = 14;
              return this.hmac(this.v);
            case 14:
              this.v = _context.sent;
            case 15:
            case "end":
              return _context.stop();
          }
        }, _callee, this);
      }));
      function reseed() {
        return _reseed.apply(this, arguments);
      }
      return reseed;
    }()
  }, {
    key: "reseedSync",
    value: function reseedSync() {
      var seed = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : new Uint8Array();
      this.checkSync();
      this.k = this.hmacSync(this.v, Uint8Array.from([0x00]), seed);
      this.v = this.hmacSync(this.v);
      if (seed.length === 0) return;
      this.k = this.hmacSync(this.v, Uint8Array.from([0x01]), seed);
      this.v = this.hmacSync(this.v);
    }
  }, {
    key: "generate",
    value: function () {
      var _generate = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee2() {
        var len, out, sl;
        return _regeneratorRuntime().wrap(function _callee2$(_context2) {
          while (1) switch (_context2.prev = _context2.next) {
            case 0:
              this.incr();
              len = 0;
              out = [];
            case 3:
              if (!(len < this.qByteLen)) {
                _context2.next = 12;
                break;
              }
              _context2.next = 6;
              return this.hmac(this.v);
            case 6:
              this.v = _context2.sent;
              sl = this.v.slice();
              out.push(sl);
              len += this.v.length;
              _context2.next = 3;
              break;
            case 12:
              return _context2.abrupt("return", concatBytes.apply(void 0, out));
            case 13:
            case "end":
              return _context2.stop();
          }
        }, _callee2, this);
      }));
      function generate() {
        return _generate.apply(this, arguments);
      }
      return generate;
    }()
  }, {
    key: "generateSync",
    value: function generateSync() {
      this.checkSync();
      this.incr();
      var len = 0;
      var out = [];
      while (len < this.qByteLen) {
        this.v = this.hmacSync(this.v);
        var sl = this.v.slice();
        out.push(sl);
        len += this.v.length;
      }
      return concatBytes.apply(void 0, out);
    }
  }]);
}();
function isWithinCurveOrder(num) {
  return _0n < num && num < CURVE.n;
}
function isValidFieldElement(num) {
  return _0n < num && num < CURVE.P;
}
function kmdToSig(kBytes, m, d) {
  var lowS = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;
  var n = CURVE.n;
  var k = truncateHash(kBytes, true);
  if (!isWithinCurveOrder(k)) return;
  var kinv = invert(k, n);
  var q = Point.BASE.multiply(k);
  var r = mod(q.x, n);
  if (r === _0n) return;
  var s = mod(kinv * mod(m + d * r, n), n);
  if (s === _0n) return;
  var sig = new Signature(r, s);
  var recovery = (q.x === sig.r ? 0 : 2) | Number(q.y & _1n);
  if (lowS && sig.hasHighS()) {
    sig = sig.normalizeS();
    recovery ^= 1;
  }
  return {
    sig: sig,
    recovery: recovery
  };
}
function normalizePrivateKey(key) {
  var num;
  if (typeof key === 'bigint') {
    num = key;
  } else if (typeof key === 'number' && Number.isSafeInteger(key) && key > 0) {
    num = BigInt(key);
  } else if (typeof key === 'string') {
    if (key.length !== 2 * groupLen) throw new Error('Expected 32 bytes of private key');
    num = hexToNumber(key);
  } else if (key instanceof Uint8Array) {
    if (key.length !== groupLen) throw new Error('Expected 32 bytes of private key');
    num = bytesToNumber(key);
  } else {
    throw new TypeError('Expected valid private key');
  }
  if (!isWithinCurveOrder(num)) throw new Error('Expected private key: 0 < key < n');
  return num;
}
function normalizePublicKey(publicKey) {
  if (publicKey instanceof Point) {
    publicKey.assertValidity();
    return publicKey;
  } else {
    return Point.fromHex(publicKey);
  }
}
function normalizeSignature(signature) {
  if (signature instanceof Signature) {
    signature.assertValidity();
    return signature;
  }
  try {
    return Signature.fromDER(signature);
  } catch (error) {
    return Signature.fromCompact(signature);
  }
}
function getPublicKey(privateKey) {
  var isCompressed = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
  return Point.fromPrivateKey(privateKey).toRawBytes(isCompressed);
}
exports.getPublicKey = getPublicKey;
function recoverPublicKey(msgHash, signature, recovery) {
  var isCompressed = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;
  return Point.fromSignature(msgHash, signature, recovery).toRawBytes(isCompressed);
}
exports.recoverPublicKey = recoverPublicKey;
function isProbPub(item) {
  var arr = item instanceof Uint8Array;
  var str = typeof item === 'string';
  var len = (arr || str) && item.length;
  if (arr) return len === compressedLen || len === uncompressedLen;
  if (str) return len === compressedLen * 2 || len === uncompressedLen * 2;
  if (item instanceof Point) return true;
  return false;
}
function getSharedSecret(privateA, publicB) {
  var isCompressed = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
  if (isProbPub(privateA)) throw new TypeError('getSharedSecret: first arg must be private key');
  if (!isProbPub(publicB)) throw new TypeError('getSharedSecret: second arg must be public key');
  var b = normalizePublicKey(publicB);
  b.assertValidity();
  return b.multiply(normalizePrivateKey(privateA)).toRawBytes(isCompressed);
}
exports.getSharedSecret = getSharedSecret;
function bits2int(bytes) {
  var slice = bytes.length > fieldLen ? bytes.slice(0, fieldLen) : bytes;
  return bytesToNumber(slice);
}
function bits2octets(bytes) {
  var z1 = bits2int(bytes);
  var z2 = mod(z1, CURVE.n);
  return int2octets(z2 < _0n ? z1 : z2);
}
function int2octets(num) {
  return numTo32b(num);
}
function initSigArgs(msgHash, privateKey, extraEntropy) {
  if (msgHash == null) throw new Error("sign: expected valid message hash, not \"".concat(msgHash, "\""));
  var h1 = ensureBytes(msgHash);
  var d = normalizePrivateKey(privateKey);
  var seedArgs = [int2octets(d), bits2octets(h1)];
  if (extraEntropy != null) {
    if (extraEntropy === true) extraEntropy = exports.utils.randomBytes(fieldLen);
    var _e = ensureBytes(extraEntropy);
    if (_e.length !== fieldLen) throw new Error("sign: Expected ".concat(fieldLen, " bytes of extra data"));
    seedArgs.push(_e);
  }
  var seed = concatBytes.apply(void 0, seedArgs);
  var m = bits2int(h1);
  return {
    seed: seed,
    m: m,
    d: d
  };
}
function finalizeSig(recSig, opts) {
  var sig = recSig.sig,
    recovery = recSig.recovery;
  var _Object$assign = Object.assign({
      canonical: true,
      der: true
    }, opts),
    der = _Object$assign.der,
    recovered = _Object$assign.recovered;
  var hashed = der ? sig.toDERRawBytes() : sig.toCompactRawBytes();
  return recovered ? [hashed, recovery] : hashed;
}
function sign(_x, _x2) {
  return _sign.apply(this, arguments);
}
function _sign() {
  _sign = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee7(msgHash, privKey) {
    var opts,
      _initSigArgs2,
      seed,
      m,
      d,
      drbg,
      sig,
      _args7 = arguments;
    return _regeneratorRuntime().wrap(function _callee7$(_context7) {
      while (1) switch (_context7.prev = _context7.next) {
        case 0:
          opts = _args7.length > 2 && _args7[2] !== undefined ? _args7[2] : {};
          _initSigArgs2 = initSigArgs(msgHash, privKey, opts.extraEntropy), seed = _initSigArgs2.seed, m = _initSigArgs2.m, d = _initSigArgs2.d;
          drbg = new HmacDrbg(hashLen, groupLen);
          _context7.next = 5;
          return drbg.reseed(seed);
        case 5:
          _context7.t0 = kmdToSig;
          _context7.next = 8;
          return drbg.generate();
        case 8:
          _context7.t1 = _context7.sent;
          _context7.t2 = m;
          _context7.t3 = d;
          _context7.t4 = opts.canonical;
          if (sig = (0, _context7.t0)(_context7.t1, _context7.t2, _context7.t3, _context7.t4)) {
            _context7.next = 17;
            break;
          }
          _context7.next = 15;
          return drbg.reseed();
        case 15:
          _context7.next = 5;
          break;
        case 17:
          return _context7.abrupt("return", finalizeSig(sig, opts));
        case 18:
        case "end":
          return _context7.stop();
      }
    }, _callee7);
  }));
  return _sign.apply(this, arguments);
}
exports.sign = sign;
function signSync(msgHash, privKey) {
  var opts = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  var _initSigArgs = initSigArgs(msgHash, privKey, opts.extraEntropy),
    seed = _initSigArgs.seed,
    m = _initSigArgs.m,
    d = _initSigArgs.d;
  var drbg = new HmacDrbg(hashLen, groupLen);
  drbg.reseedSync(seed);
  var sig;
  while (!(sig = kmdToSig(drbg.generateSync(), m, d, opts.canonical))) drbg.reseedSync();
  return finalizeSig(sig, opts);
}
exports.signSync = signSync;
var vopts = {
  strict: true
};
function verify(signature, msgHash, publicKey) {
  var opts = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : vopts;
  var sig;
  try {
    sig = normalizeSignature(signature);
    msgHash = ensureBytes(msgHash);
  } catch (error) {
    return false;
  }
  var _sig = sig,
    r = _sig.r,
    s = _sig.s;
  if (opts.strict && sig.hasHighS()) return false;
  var h = truncateHash(msgHash);
  var P;
  try {
    P = normalizePublicKey(publicKey);
  } catch (error) {
    return false;
  }
  var n = CURVE.n;
  var sinv = invert(s, n);
  var u1 = mod(h * sinv, n);
  var u2 = mod(r * sinv, n);
  var R = Point.BASE.multiplyAndAddUnsafe(P, u1, u2);
  if (!R) return false;
  var v = mod(R.x, n);
  return v === r;
}
exports.verify = verify;
function schnorrChallengeFinalize(ch) {
  return mod(bytesToNumber(ch), CURVE.n);
}
var SchnorrSignature = /*#__PURE__*/function () {
  function SchnorrSignature(r, s) {
    _classCallCheck(this, SchnorrSignature);
    this.r = r;
    this.s = s;
    this.assertValidity();
  }
  return _createClass(SchnorrSignature, [{
    key: "assertValidity",
    value: function assertValidity() {
      var r = this.r,
        s = this.s;
      if (!isValidFieldElement(r) || !isWithinCurveOrder(s)) throw new Error('Invalid signature');
    }
  }, {
    key: "toHex",
    value: function toHex() {
      return numTo32bStr(this.r) + numTo32bStr(this.s);
    }
  }, {
    key: "toRawBytes",
    value: function toRawBytes() {
      return hexToBytes(this.toHex());
    }
  }], [{
    key: "fromHex",
    value: function fromHex(hex) {
      var bytes = ensureBytes(hex);
      if (bytes.length !== 64) throw new TypeError("SchnorrSignature.fromHex: expected 64 bytes, not ".concat(bytes.length));
      var r = bytesToNumber(bytes.subarray(0, 32));
      var s = bytesToNumber(bytes.subarray(32, 64));
      return new SchnorrSignature(r, s);
    }
  }]);
}();
function schnorrGetPublicKey(privateKey) {
  return Point.fromPrivateKey(privateKey).toRawX();
}
var InternalSchnorrSignature = /*#__PURE__*/function () {
  function InternalSchnorrSignature(message, privateKey) {
    var auxRand = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : exports.utils.randomBytes();
    _classCallCheck(this, InternalSchnorrSignature);
    if (message == null) throw new TypeError("sign: Expected valid message, not \"".concat(message, "\""));
    this.m = ensureBytes(message);
    var _this$getScalar = this.getScalar(normalizePrivateKey(privateKey)),
      x = _this$getScalar.x,
      scalar = _this$getScalar.scalar;
    this.px = x;
    this.d = scalar;
    this.rand = ensureBytes(auxRand);
    if (this.rand.length !== 32) throw new TypeError('sign: Expected 32 bytes of aux randomness');
  }
  return _createClass(InternalSchnorrSignature, [{
    key: "getScalar",
    value: function getScalar(priv) {
      var point = Point.fromPrivateKey(priv);
      var scalar = point.hasEvenY() ? priv : CURVE.n - priv;
      return {
        point: point,
        scalar: scalar,
        x: point.toRawX()
      };
    }
  }, {
    key: "initNonce",
    value: function initNonce(d, t0h) {
      return numTo32b(d ^ bytesToNumber(t0h));
    }
  }, {
    key: "finalizeNonce",
    value: function finalizeNonce(k0h) {
      var k0 = mod(bytesToNumber(k0h), CURVE.n);
      if (k0 === _0n) throw new Error('sign: Creation of signature failed. k is zero');
      var _this$getScalar2 = this.getScalar(k0),
        R = _this$getScalar2.point,
        rx = _this$getScalar2.x,
        k = _this$getScalar2.scalar;
      return {
        R: R,
        rx: rx,
        k: k
      };
    }
  }, {
    key: "finalizeSig",
    value: function finalizeSig(R, k, e, d) {
      return new SchnorrSignature(R.x, mod(k + e * d, CURVE.n)).toRawBytes();
    }
  }, {
    key: "error",
    value: function error() {
      throw new Error('sign: Invalid signature produced');
    }
  }, {
    key: "calc",
    value: function () {
      var _calc = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee3() {
        var m, d, px, rand, tag, t, _this$finalizeNonce, R, rx, k, e, sig;
        return _regeneratorRuntime().wrap(function _callee3$(_context3) {
          while (1) switch (_context3.prev = _context3.next) {
            case 0:
              m = this.m, d = this.d, px = this.px, rand = this.rand;
              tag = exports.utils.taggedHash;
              _context3.t0 = this;
              _context3.t1 = d;
              _context3.next = 6;
              return tag(TAGS.aux, rand);
            case 6:
              _context3.t2 = _context3.sent;
              t = _context3.t0.initNonce.call(_context3.t0, _context3.t1, _context3.t2);
              _context3.t3 = this;
              _context3.next = 11;
              return tag(TAGS.nonce, t, px, m);
            case 11:
              _context3.t4 = _context3.sent;
              _this$finalizeNonce = _context3.t3.finalizeNonce.call(_context3.t3, _context3.t4);
              R = _this$finalizeNonce.R;
              rx = _this$finalizeNonce.rx;
              k = _this$finalizeNonce.k;
              _context3.t5 = schnorrChallengeFinalize;
              _context3.next = 19;
              return tag(TAGS.challenge, rx, px, m);
            case 19:
              _context3.t6 = _context3.sent;
              e = (0, _context3.t5)(_context3.t6);
              sig = this.finalizeSig(R, k, e, d);
              _context3.next = 24;
              return schnorrVerify(sig, m, px);
            case 24:
              if (_context3.sent) {
                _context3.next = 26;
                break;
              }
              this.error();
            case 26:
              return _context3.abrupt("return", sig);
            case 27:
            case "end":
              return _context3.stop();
          }
        }, _callee3, this);
      }));
      function calc() {
        return _calc.apply(this, arguments);
      }
      return calc;
    }()
  }, {
    key: "calcSync",
    value: function calcSync() {
      var m = this.m,
        d = this.d,
        px = this.px,
        rand = this.rand;
      var tag = exports.utils.taggedHashSync;
      var t = this.initNonce(d, tag(TAGS.aux, rand));
      var _this$finalizeNonce2 = this.finalizeNonce(tag(TAGS.nonce, t, px, m)),
        R = _this$finalizeNonce2.R,
        rx = _this$finalizeNonce2.rx,
        k = _this$finalizeNonce2.k;
      var e = schnorrChallengeFinalize(tag(TAGS.challenge, rx, px, m));
      var sig = this.finalizeSig(R, k, e, d);
      if (!schnorrVerifySync(sig, m, px)) this.error();
      return sig;
    }
  }]);
}();
function schnorrSign(_x3, _x4, _x5) {
  return _schnorrSign.apply(this, arguments);
}
function _schnorrSign() {
  _schnorrSign = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee8(msg, privKey, auxRand) {
    return _regeneratorRuntime().wrap(function _callee8$(_context8) {
      while (1) switch (_context8.prev = _context8.next) {
        case 0:
          return _context8.abrupt("return", new InternalSchnorrSignature(msg, privKey, auxRand).calc());
        case 1:
        case "end":
          return _context8.stop();
      }
    }, _callee8);
  }));
  return _schnorrSign.apply(this, arguments);
}
function schnorrSignSync(msg, privKey, auxRand) {
  return new InternalSchnorrSignature(msg, privKey, auxRand).calcSync();
}
function initSchnorrVerify(signature, message, publicKey) {
  var raw = signature instanceof SchnorrSignature;
  var sig = raw ? signature : SchnorrSignature.fromHex(signature);
  if (raw) sig.assertValidity();
  return _objectSpread(_objectSpread({}, sig), {}, {
    m: ensureBytes(message),
    P: normalizePublicKey(publicKey)
  });
}
function finalizeSchnorrVerify(r, P, s, e) {
  var R = Point.BASE.multiplyAndAddUnsafe(P, normalizePrivateKey(s), mod(-e, CURVE.n));
  if (!R || !R.hasEvenY() || R.x !== r) return false;
  return true;
}
function schnorrVerify(_x6, _x7, _x8) {
  return _schnorrVerify.apply(this, arguments);
}
function _schnorrVerify() {
  _schnorrVerify = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee9(signature, message, publicKey) {
    var _initSchnorrVerify2, r, s, m, P, _e3;
    return _regeneratorRuntime().wrap(function _callee9$(_context9) {
      while (1) switch (_context9.prev = _context9.next) {
        case 0:
          _context9.prev = 0;
          _initSchnorrVerify2 = initSchnorrVerify(signature, message, publicKey), r = _initSchnorrVerify2.r, s = _initSchnorrVerify2.s, m = _initSchnorrVerify2.m, P = _initSchnorrVerify2.P;
          _context9.t0 = schnorrChallengeFinalize;
          _context9.next = 5;
          return exports.utils.taggedHash(TAGS.challenge, numTo32b(r), P.toRawX(), m);
        case 5:
          _context9.t1 = _context9.sent;
          _e3 = (0, _context9.t0)(_context9.t1);
          return _context9.abrupt("return", finalizeSchnorrVerify(r, P, s, _e3));
        case 10:
          _context9.prev = 10;
          _context9.t2 = _context9["catch"](0);
          return _context9.abrupt("return", false);
        case 13:
        case "end":
          return _context9.stop();
      }
    }, _callee9, null, [[0, 10]]);
  }));
  return _schnorrVerify.apply(this, arguments);
}
function schnorrVerifySync(signature, message, publicKey) {
  try {
    var _initSchnorrVerify = initSchnorrVerify(signature, message, publicKey),
      r = _initSchnorrVerify.r,
      s = _initSchnorrVerify.s,
      m = _initSchnorrVerify.m,
      P = _initSchnorrVerify.P;
    var _e2 = schnorrChallengeFinalize(exports.utils.taggedHashSync(TAGS.challenge, numTo32b(r), P.toRawX(), m));
    return finalizeSchnorrVerify(r, P, s, _e2);
  } catch (error) {
    if (error instanceof ShaError) throw error;
    return false;
  }
}
exports.schnorr = {
  Signature: SchnorrSignature,
  getPublicKey: schnorrGetPublicKey,
  sign: schnorrSign,
  verify: schnorrVerify,
  signSync: schnorrSignSync,
  verifySync: schnorrVerifySync
};
Point.BASE._setWindowSize(8);
var crypto = {
  node: nodeCrypto,
  web: (typeof self === "undefined" ? "undefined" : _typeof(self)) === 'object' && 'crypto' in self ? self.crypto : undefined
};
var TAGS = {
  challenge: 'BIP0340/challenge',
  aux: 'BIP0340/aux',
  nonce: 'BIP0340/nonce'
};
var TAGGED_HASH_PREFIXES = {};
exports.utils = {
  bytesToHex: bytesToHex,
  hexToBytes: hexToBytes,
  concatBytes: concatBytes,
  mod: mod,
  invert: invert,
  isValidPrivateKey: function isValidPrivateKey(privateKey) {
    try {
      normalizePrivateKey(privateKey);
      return true;
    } catch (error) {
      return false;
    }
  },
  _bigintTo32Bytes: numTo32b,
  _normalizePrivateKey: normalizePrivateKey,
  hashToPrivateKey: function hashToPrivateKey(hash) {
    hash = ensureBytes(hash);
    var minLen = groupLen + 8;
    if (hash.length < minLen || hash.length > 1024) {
      throw new Error("Expected valid bytes of private key as per FIPS 186");
    }
    var num = mod(bytesToNumber(hash), CURVE.n - _1n) + _1n;
    return numTo32b(num);
  },
  randomBytes: function randomBytes() {
    var bytesLength = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 32;
    if (crypto.web) {
      return crypto.web.getRandomValues(new Uint8Array(bytesLength));
    } else if (crypto.node) {
      var _randomBytes = crypto.node.randomBytes;
      return Uint8Array.from(_randomBytes(bytesLength));
    } else {
      throw new Error("The environment doesn't have randomBytes function");
    }
  },
  randomPrivateKey: function randomPrivateKey() {
    return exports.utils.hashToPrivateKey(exports.utils.randomBytes(groupLen + 8));
  },
  precompute: function precompute() {
    var windowSize = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 8;
    var point = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : Point.BASE;
    var cached = point === Point.BASE ? point : new Point(point.x, point.y);
    cached._setWindowSize(windowSize);
    cached.multiply(_3n);
    return cached;
  },
  sha256: function () {
    var _sha = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee4() {
      var _len4,
        messages,
        _key4,
        buffer,
        createHash,
        hash,
        _args4 = arguments;
      return _regeneratorRuntime().wrap(function _callee4$(_context4) {
        while (1) switch (_context4.prev = _context4.next) {
          case 0:
            for (_len4 = _args4.length, messages = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
              messages[_key4] = _args4[_key4];
            }
            if (!crypto.web) {
              _context4.next = 8;
              break;
            }
            _context4.next = 4;
            return crypto.web.subtle.digest('SHA-256', concatBytes.apply(void 0, messages));
          case 4:
            buffer = _context4.sent;
            return _context4.abrupt("return", new Uint8Array(buffer));
          case 8:
            if (!crypto.node) {
              _context4.next = 15;
              break;
            }
            createHash = crypto.node.createHash;
            hash = createHash('sha256');
            messages.forEach(function (m) {
              return hash.update(m);
            });
            return _context4.abrupt("return", Uint8Array.from(hash.digest()));
          case 15:
            throw new Error("The environment doesn't have sha256 function");
          case 16:
          case "end":
            return _context4.stop();
        }
      }, _callee4);
    }));
    function sha256() {
      return _sha.apply(this, arguments);
    }
    return sha256;
  }(),
  hmacSha256: function () {
    var _hmacSha = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee5(key) {
      var _len5,
        messages,
        _key5,
        ckey,
        message,
        buffer,
        createHmac,
        hash,
        _args5 = arguments;
      return _regeneratorRuntime().wrap(function _callee5$(_context5) {
        while (1) switch (_context5.prev = _context5.next) {
          case 0:
            for (_len5 = _args5.length, messages = new Array(_len5 > 1 ? _len5 - 1 : 0), _key5 = 1; _key5 < _len5; _key5++) {
              messages[_key5 - 1] = _args5[_key5];
            }
            if (!crypto.web) {
              _context5.next = 12;
              break;
            }
            _context5.next = 4;
            return crypto.web.subtle.importKey('raw', key, {
              name: 'HMAC',
              hash: {
                name: 'SHA-256'
              }
            }, false, ['sign']);
          case 4:
            ckey = _context5.sent;
            message = concatBytes.apply(void 0, messages);
            _context5.next = 8;
            return crypto.web.subtle.sign('HMAC', ckey, message);
          case 8:
            buffer = _context5.sent;
            return _context5.abrupt("return", new Uint8Array(buffer));
          case 12:
            if (!crypto.node) {
              _context5.next = 19;
              break;
            }
            createHmac = crypto.node.createHmac;
            hash = createHmac('sha256', key);
            messages.forEach(function (m) {
              return hash.update(m);
            });
            return _context5.abrupt("return", Uint8Array.from(hash.digest()));
          case 19:
            throw new Error("The environment doesn't have hmac-sha256 function");
          case 20:
          case "end":
            return _context5.stop();
        }
      }, _callee5);
    }));
    function hmacSha256(_x9) {
      return _hmacSha.apply(this, arguments);
    }
    return hmacSha256;
  }(),
  sha256Sync: undefined,
  hmacSha256Sync: undefined,
  taggedHash: function () {
    var _taggedHash = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee6(tag) {
      var _exports$utils2;
      var tagP,
        tagH,
        _len6,
        messages,
        _key6,
        _args6 = arguments;
      return _regeneratorRuntime().wrap(function _callee6$(_context6) {
        while (1) switch (_context6.prev = _context6.next) {
          case 0:
            tagP = TAGGED_HASH_PREFIXES[tag];
            if (!(tagP === undefined)) {
              _context6.next = 7;
              break;
            }
            _context6.next = 4;
            return exports.utils.sha256(Uint8Array.from(tag, function (c) {
              return c.charCodeAt(0);
            }));
          case 4:
            tagH = _context6.sent;
            tagP = concatBytes(tagH, tagH);
            TAGGED_HASH_PREFIXES[tag] = tagP;
          case 7:
            for (_len6 = _args6.length, messages = new Array(_len6 > 1 ? _len6 - 1 : 0), _key6 = 1; _key6 < _len6; _key6++) {
              messages[_key6 - 1] = _args6[_key6];
            }
            return _context6.abrupt("return", (_exports$utils2 = exports.utils).sha256.apply(_exports$utils2, [tagP].concat(messages)));
          case 9:
          case "end":
            return _context6.stop();
        }
      }, _callee6);
    }));
    function taggedHash(_x10) {
      return _taggedHash.apply(this, arguments);
    }
    return taggedHash;
  }(),
  taggedHashSync: function taggedHashSync(tag) {
    if (typeof _sha256Sync !== 'function') throw new ShaError('sha256Sync is undefined, you need to set it');
    var tagP = TAGGED_HASH_PREFIXES[tag];
    if (tagP === undefined) {
      var tagH = _sha256Sync(Uint8Array.from(tag, function (c) {
        return c.charCodeAt(0);
      }));
      tagP = concatBytes(tagH, tagH);
      TAGGED_HASH_PREFIXES[tag] = tagP;
    }
    for (var _len7 = arguments.length, messages = new Array(_len7 > 1 ? _len7 - 1 : 0), _key7 = 1; _key7 < _len7; _key7++) {
      messages[_key7 - 1] = arguments[_key7];
    }
    return _sha256Sync.apply(void 0, [tagP].concat(messages));
  },
  _JacobianPoint: JacobianPoint
};
Object.defineProperties(exports.utils, {
  sha256Sync: {
    configurable: false,
    get: function get() {
      return _sha256Sync;
    },
    set: function set(val) {
      if (!_sha256Sync) _sha256Sync = val;
    }
  },
  hmacSha256Sync: {
    configurable: false,
    get: function get() {
      return _hmacSha256Sync;
    },
    set: function set(val) {
      if (!_hmacSha256Sync) _hmacSha256Sync = val;
    }
  }
});

},{"crypto":97}],4:[function(require,module,exports){
"use strict";

function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.isBytes = isBytes;
exports.number = number;
exports.bool = bool;
exports.bytes = bytes;
exports.hash = hash;
exports.exists = exists;
exports.output = output;
function number(n) {
  if (!Number.isSafeInteger(n) || n < 0) throw new Error("positive integer expected, not ".concat(n));
}
function bool(b) {
  if (typeof b !== 'boolean') throw new Error("boolean expected, not ".concat(b));
}
// copied from utils
function isBytes(a) {
  return a instanceof Uint8Array || a != null && _typeof(a) === 'object' && a.constructor.name === 'Uint8Array';
}
function bytes(b) {
  if (!isBytes(b)) throw new Error('Uint8Array expected');
  for (var _len = arguments.length, lengths = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    lengths[_key - 1] = arguments[_key];
  }
  if (lengths.length > 0 && !lengths.includes(b.length)) throw new Error("Uint8Array expected of length ".concat(lengths, ", not of length=").concat(b.length));
}
function hash(h) {
  if (typeof h !== 'function' || typeof h.create !== 'function') throw new Error('Hash should be wrapped by utils.wrapConstructor');
  number(h.outputLen);
  number(h.blockLen);
}
function exists(instance) {
  var checkFinished = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
  if (instance.destroyed) throw new Error('Hash instance has been destroyed');
  if (checkFinished && instance.finished) throw new Error('Hash#digest() has already been called');
}
function output(out, instance) {
  bytes(out);
  var min = instance.outputLen;
  if (out.length < min) {
    throw new Error("digestInto() expects output buffer of length at least ".concat(min));
  }
}
var assert = {
  number: number,
  bool: bool,
  bytes: bytes,
  hash: hash,
  exists: exists,
  output: output
};
exports["default"] = assert;

},{}],5:[function(require,module,exports){
"use strict";

function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _toConsumableArray(r) { return _arrayWithoutHoles(r) || _iterableToArray(r) || _unsupportedIterableToArray(r) || _nonIterableSpread(); }
function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _unsupportedIterableToArray(r, a) { if (r) { if ("string" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }
function _iterableToArray(r) { if ("undefined" != typeof Symbol && null != r[Symbol.iterator] || null != r["@@iterator"]) return Array.from(r); }
function _arrayWithoutHoles(r) { if (Array.isArray(r)) return _arrayLikeToArray(r); }
function _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }
function _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function"); }
function _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }
function _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: !1 }), e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
function _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }
function _possibleConstructorReturn(t, e) { if (e && ("object" == _typeof(e) || "function" == typeof e)) return e; if (void 0 !== e) throw new TypeError("Derived constructors may only return object or undefined"); return _assertThisInitialized(t); }
function _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); return e; }
function _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }
function _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }
function _inherits(t, e) { if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, "prototype", { writable: !1 }), e && _setPrototypeOf(t, e); }
function _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.HashMD = exports.Maj = exports.Chi = void 0;
var _assert_js_1 = require("./_assert.js");
var utils_js_1 = require("./utils.js");
/**
 * Polyfill for Safari 14
 */
function setBigUint64(view, byteOffset, value, isLE) {
  if (typeof view.setBigUint64 === 'function') return view.setBigUint64(byteOffset, value, isLE);
  var _32n = BigInt(32);
  var _u32_max = BigInt(0xffffffff);
  var wh = Number(value >> _32n & _u32_max);
  var wl = Number(value & _u32_max);
  var h = isLE ? 4 : 0;
  var l = isLE ? 0 : 4;
  view.setUint32(byteOffset + h, wh, isLE);
  view.setUint32(byteOffset + l, wl, isLE);
}
/**
 * Choice: a ? b : c
 */
var Chi = function Chi(a, b, c) {
  return a & b ^ ~a & c;
};
exports.Chi = Chi;
/**
 * Majority function, true if any two inputs is true
 */
var Maj = function Maj(a, b, c) {
  return a & b ^ a & c ^ b & c;
};
exports.Maj = Maj;
/**
 * Merkle-Damgard hash construction base class.
 * Could be used to create MD5, RIPEMD, SHA1, SHA2.
 */
var HashMD = /*#__PURE__*/function (_utils_js_1$Hash) {
  function HashMD(blockLen, outputLen, padOffset, isLE) {
    var _this;
    _classCallCheck(this, HashMD);
    _this = _callSuper(this, HashMD);
    _this.blockLen = blockLen;
    _this.outputLen = outputLen;
    _this.padOffset = padOffset;
    _this.isLE = isLE;
    _this.finished = false;
    _this.length = 0;
    _this.pos = 0;
    _this.destroyed = false;
    _this.buffer = new Uint8Array(blockLen);
    _this.view = (0, utils_js_1.createView)(_this.buffer);
    return _this;
  }
  _inherits(HashMD, _utils_js_1$Hash);
  return _createClass(HashMD, [{
    key: "update",
    value: function update(data) {
      (0, _assert_js_1.exists)(this);
      var view = this.view,
        buffer = this.buffer,
        blockLen = this.blockLen;
      data = (0, utils_js_1.toBytes)(data);
      var len = data.length;
      for (var pos = 0; pos < len;) {
        var take = Math.min(blockLen - this.pos, len - pos);
        // Fast path: we have at least one block in input, cast it to view and process
        if (take === blockLen) {
          var dataView = (0, utils_js_1.createView)(data);
          for (; blockLen <= len - pos; pos += blockLen) this.process(dataView, pos);
          continue;
        }
        buffer.set(data.subarray(pos, pos + take), this.pos);
        this.pos += take;
        pos += take;
        if (this.pos === blockLen) {
          this.process(view, 0);
          this.pos = 0;
        }
      }
      this.length += data.length;
      this.roundClean();
      return this;
    }
  }, {
    key: "digestInto",
    value: function digestInto(out) {
      (0, _assert_js_1.exists)(this);
      (0, _assert_js_1.output)(out, this);
      this.finished = true;
      // Padding
      // We can avoid allocation of buffer for padding completely if it
      // was previously not allocated here. But it won't change performance.
      var buffer = this.buffer,
        view = this.view,
        blockLen = this.blockLen,
        isLE = this.isLE;
      var pos = this.pos;
      // append the bit '1' to the message
      buffer[pos++] = 128;
      this.buffer.subarray(pos).fill(0);
      // we have less than padOffset left in buffer, so we cannot put length in
      // current block, need process it and pad again
      if (this.padOffset > blockLen - pos) {
        this.process(view, 0);
        pos = 0;
      }
      // Pad until full block byte with zeros
      for (var i = pos; i < blockLen; i++) buffer[i] = 0;
      // Note: sha512 requires length to be 128bit integer, but length in JS will overflow before that
      // You need to write around 2 exabytes (u64_max / 8 / (1024**6)) for this to happen.
      // So we just write lowest 64 bits of that value.
      setBigUint64(view, blockLen - 8, BigInt(this.length * 8), isLE);
      this.process(view, 0);
      var oview = (0, utils_js_1.createView)(out);
      var len = this.outputLen;
      // NOTE: we do division by 4 later, which should be fused in single op with modulo by JIT
      if (len % 4) throw new Error('_sha2: outputLen should be aligned to 32bit');
      var outLen = len / 4;
      var state = this.get();
      if (outLen > state.length) throw new Error('_sha2: outputLen bigger than state');
      for (var _i = 0; _i < outLen; _i++) oview.setUint32(4 * _i, state[_i], isLE);
    }
  }, {
    key: "digest",
    value: function digest() {
      var buffer = this.buffer,
        outputLen = this.outputLen;
      this.digestInto(buffer);
      var res = buffer.slice(0, outputLen);
      this.destroy();
      return res;
    }
  }, {
    key: "_cloneInto",
    value: function _cloneInto(to) {
      var _to;
      to || (to = new this.constructor());
      (_to = to).set.apply(_to, _toConsumableArray(this.get()));
      var blockLen = this.blockLen,
        buffer = this.buffer,
        length = this.length,
        finished = this.finished,
        destroyed = this.destroyed,
        pos = this.pos;
      to.length = length;
      to.pos = pos;
      to.finished = finished;
      to.destroyed = destroyed;
      if (length % blockLen) to.buffer.set(buffer);
      return to;
    }
  }]);
}(utils_js_1.Hash);
exports.HashMD = HashMD;

},{"./_assert.js":4,"./utils.js":13}],6:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.add5L = exports.add5H = exports.add4H = exports.add4L = exports.add3H = exports.add3L = exports.rotlBL = exports.rotlBH = exports.rotlSL = exports.rotlSH = exports.rotr32L = exports.rotr32H = exports.rotrBL = exports.rotrBH = exports.rotrSL = exports.rotrSH = exports.shrSL = exports.shrSH = exports.toBig = void 0;
exports.fromBig = fromBig;
exports.split = split;
exports.add = add;
var U32_MASK64 = /* @__PURE__ */BigInt(Math.pow(2, 32) - 1);
var _32n = /* @__PURE__ */BigInt(32);
// We are not using BigUint64Array, because they are extremely slow as per 2022
function fromBig(n) {
  var le = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
  if (le) return {
    h: Number(n & U32_MASK64),
    l: Number(n >> _32n & U32_MASK64)
  };
  return {
    h: Number(n >> _32n & U32_MASK64) | 0,
    l: Number(n & U32_MASK64) | 0
  };
}
function split(lst) {
  var le = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
  var Ah = new Uint32Array(lst.length);
  var Al = new Uint32Array(lst.length);
  for (var i = 0; i < lst.length; i++) {
    var _fromBig = fromBig(lst[i], le),
      h = _fromBig.h,
      l = _fromBig.l;
    var _ref = [h, l];
    Ah[i] = _ref[0];
    Al[i] = _ref[1];
  }
  return [Ah, Al];
}
var toBig = function toBig(h, l) {
  return BigInt(h >>> 0) << _32n | BigInt(l >>> 0);
};
exports.toBig = toBig;
// for Shift in [0, 32)
var shrSH = function shrSH(h, _l, s) {
  return h >>> s;
};
exports.shrSH = shrSH;
var shrSL = function shrSL(h, l, s) {
  return h << 32 - s | l >>> s;
};
exports.shrSL = shrSL;
// Right rotate for Shift in [1, 32)
var rotrSH = function rotrSH(h, l, s) {
  return h >>> s | l << 32 - s;
};
exports.rotrSH = rotrSH;
var rotrSL = function rotrSL(h, l, s) {
  return h << 32 - s | l >>> s;
};
exports.rotrSL = rotrSL;
// Right rotate for Shift in (32, 64), NOTE: 32 is special case.
var rotrBH = function rotrBH(h, l, s) {
  return h << 64 - s | l >>> s - 32;
};
exports.rotrBH = rotrBH;
var rotrBL = function rotrBL(h, l, s) {
  return h >>> s - 32 | l << 64 - s;
};
exports.rotrBL = rotrBL;
// Right rotate for shift===32 (just swaps l&h)
var rotr32H = function rotr32H(_h, l) {
  return l;
};
exports.rotr32H = rotr32H;
var rotr32L = function rotr32L(h, _l) {
  return h;
};
exports.rotr32L = rotr32L;
// Left rotate for Shift in [1, 32)
var rotlSH = function rotlSH(h, l, s) {
  return h << s | l >>> 32 - s;
};
exports.rotlSH = rotlSH;
var rotlSL = function rotlSL(h, l, s) {
  return l << s | h >>> 32 - s;
};
exports.rotlSL = rotlSL;
// Left rotate for Shift in (32, 64), NOTE: 32 is special case.
var rotlBH = function rotlBH(h, l, s) {
  return l << s - 32 | h >>> 64 - s;
};
exports.rotlBH = rotlBH;
var rotlBL = function rotlBL(h, l, s) {
  return h << s - 32 | l >>> 64 - s;
};
exports.rotlBL = rotlBL;
// JS uses 32-bit signed integers for bitwise operations which means we cannot
// simple take carry out of low bit sum by shift, we need to use division.
function add(Ah, Al, Bh, Bl) {
  var l = (Al >>> 0) + (Bl >>> 0);
  return {
    h: Ah + Bh + (l / Math.pow(2, 32) | 0) | 0,
    l: l | 0
  };
}
// Addition with more than 2 elements
var add3L = function add3L(Al, Bl, Cl) {
  return (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0);
};
exports.add3L = add3L;
var add3H = function add3H(low, Ah, Bh, Ch) {
  return Ah + Bh + Ch + (low / Math.pow(2, 32) | 0) | 0;
};
exports.add3H = add3H;
var add4L = function add4L(Al, Bl, Cl, Dl) {
  return (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0);
};
exports.add4L = add4L;
var add4H = function add4H(low, Ah, Bh, Ch, Dh) {
  return Ah + Bh + Ch + Dh + (low / Math.pow(2, 32) | 0) | 0;
};
exports.add4H = add4H;
var add5L = function add5L(Al, Bl, Cl, Dl, El) {
  return (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0) + (El >>> 0);
};
exports.add5L = add5L;
var add5H = function add5H(low, Ah, Bh, Ch, Dh, Eh) {
  return Ah + Bh + Ch + Dh + Eh + (low / Math.pow(2, 32) | 0) | 0;
};
exports.add5H = add5H;
// prettier-ignore
var u64 = {
  fromBig: fromBig,
  split: split,
  toBig: toBig,
  shrSH: shrSH,
  shrSL: shrSL,
  rotrSH: rotrSH,
  rotrSL: rotrSL,
  rotrBH: rotrBH,
  rotrBL: rotrBL,
  rotr32H: rotr32H,
  rotr32L: rotr32L,
  rotlSH: rotlSH,
  rotlSL: rotlSL,
  rotlBH: rotlBH,
  rotlBL: rotlBL,
  add: add,
  add3L: add3L,
  add3H: add3H,
  add4L: add4L,
  add4H: add4H,
  add5H: add5H,
  add5L: add5L
};
exports["default"] = u64;

},{}],7:[function(require,module,exports){
"use strict";

function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.crypto = void 0;
exports.crypto = (typeof globalThis === "undefined" ? "undefined" : _typeof(globalThis)) === 'object' && 'crypto' in globalThis ? globalThis.crypto : undefined;

},{}],8:[function(require,module,exports){
"use strict";

function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function"); }
function _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }
function _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: !1 }), e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
function _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }
function _possibleConstructorReturn(t, e) { if (e && ("object" == _typeof(e) || "function" == typeof e)) return e; if (void 0 !== e) throw new TypeError("Derived constructors may only return object or undefined"); return _assertThisInitialized(t); }
function _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); return e; }
function _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }
function _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }
function _inherits(t, e) { if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, "prototype", { writable: !1 }), e && _setPrototypeOf(t, e); }
function _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.hmac = exports.HMAC = void 0;
var _assert_js_1 = require("./_assert.js");
var utils_js_1 = require("./utils.js");
// HMAC (RFC 2104)
var HMAC = /*#__PURE__*/function (_utils_js_1$Hash) {
  function HMAC(hash, _key) {
    var _this;
    _classCallCheck(this, HMAC);
    _this = _callSuper(this, HMAC);
    _this.finished = false;
    _this.destroyed = false;
    (0, _assert_js_1.hash)(hash);
    var key = (0, utils_js_1.toBytes)(_key);
    _this.iHash = hash.create();
    if (typeof _this.iHash.update !== 'function') throw new Error('Expected instance of class which extends utils.Hash');
    _this.blockLen = _this.iHash.blockLen;
    _this.outputLen = _this.iHash.outputLen;
    var blockLen = _this.blockLen;
    var pad = new Uint8Array(blockLen);
    // blockLen can be bigger than outputLen
    pad.set(key.length > blockLen ? hash.create().update(key).digest() : key);
    for (var i = 0; i < pad.length; i++) pad[i] ^= 0x36;
    _this.iHash.update(pad);
    // By doing update (processing of first block) of outer hash here we can re-use it between multiple calls via clone
    _this.oHash = hash.create();
    // Undo internal XOR && apply outer XOR
    for (var _i = 0; _i < pad.length; _i++) pad[_i] ^= 0x36 ^ 0x5c;
    _this.oHash.update(pad);
    pad.fill(0);
    return _this;
  }
  _inherits(HMAC, _utils_js_1$Hash);
  return _createClass(HMAC, [{
    key: "update",
    value: function update(buf) {
      (0, _assert_js_1.exists)(this);
      this.iHash.update(buf);
      return this;
    }
  }, {
    key: "digestInto",
    value: function digestInto(out) {
      (0, _assert_js_1.exists)(this);
      (0, _assert_js_1.bytes)(out, this.outputLen);
      this.finished = true;
      this.iHash.digestInto(out);
      this.oHash.update(out);
      this.oHash.digestInto(out);
      this.destroy();
    }
  }, {
    key: "digest",
    value: function digest() {
      var out = new Uint8Array(this.oHash.outputLen);
      this.digestInto(out);
      return out;
    }
  }, {
    key: "_cloneInto",
    value: function _cloneInto(to) {
      // Create new instance without calling constructor since key already in state and we don't know it.
      to || (to = Object.create(Object.getPrototypeOf(this), {}));
      var oHash = this.oHash,
        iHash = this.iHash,
        finished = this.finished,
        destroyed = this.destroyed,
        blockLen = this.blockLen,
        outputLen = this.outputLen;
      to = to;
      to.finished = finished;
      to.destroyed = destroyed;
      to.blockLen = blockLen;
      to.outputLen = outputLen;
      to.oHash = oHash._cloneInto(to.oHash);
      to.iHash = iHash._cloneInto(to.iHash);
      return to;
    }
  }, {
    key: "destroy",
    value: function destroy() {
      this.destroyed = true;
      this.oHash.destroy();
      this.iHash.destroy();
    }
  }]);
}(utils_js_1.Hash);
exports.HMAC = HMAC;
/**
 * HMAC: RFC2104 message authentication code.
 * @param hash - function that would be used e.g. sha256
 * @param key - message key
 * @param message - message data
 * @example
 * import { hmac } from '@noble/hashes/hmac';
 * import { sha256 } from '@noble/hashes/sha2';
 * const mac1 = hmac(sha256, 'key', 'message');
 */
var hmac = function hmac(hash, key, message) {
  return new HMAC(hash, key).update(message).digest();
};
exports.hmac = hmac;
exports.hmac.create = function (hash, key) {
  return new HMAC(hash, key);
};

},{"./_assert.js":4,"./utils.js":13}],9:[function(require,module,exports){
"use strict";

function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _regeneratorRuntime() { "use strict"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return e; }; var t, e = {}, r = Object.prototype, n = r.hasOwnProperty, o = Object.defineProperty || function (t, e, r) { t[e] = r.value; }, i = "function" == typeof Symbol ? Symbol : {}, a = i.iterator || "@@iterator", c = i.asyncIterator || "@@asyncIterator", u = i.toStringTag || "@@toStringTag"; function define(t, e, r) { return Object.defineProperty(t, e, { value: r, enumerable: !0, configurable: !0, writable: !0 }), t[e]; } try { define({}, ""); } catch (t) { define = function define(t, e, r) { return t[e] = r; }; } function wrap(t, e, r, n) { var i = e && e.prototype instanceof Generator ? e : Generator, a = Object.create(i.prototype), c = new Context(n || []); return o(a, "_invoke", { value: makeInvokeMethod(t, r, c) }), a; } function tryCatch(t, e, r) { try { return { type: "normal", arg: t.call(e, r) }; } catch (t) { return { type: "throw", arg: t }; } } e.wrap = wrap; var h = "suspendedStart", l = "suspendedYield", f = "executing", s = "completed", y = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var p = {}; define(p, a, function () { return this; }); var d = Object.getPrototypeOf, v = d && d(d(values([]))); v && v !== r && n.call(v, a) && (p = v); var g = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(p); function defineIteratorMethods(t) { ["next", "throw", "return"].forEach(function (e) { define(t, e, function (t) { return this._invoke(e, t); }); }); } function AsyncIterator(t, e) { function invoke(r, o, i, a) { var c = tryCatch(t[r], t, o); if ("throw" !== c.type) { var u = c.arg, h = u.value; return h && "object" == _typeof(h) && n.call(h, "__await") ? e.resolve(h.__await).then(function (t) { invoke("next", t, i, a); }, function (t) { invoke("throw", t, i, a); }) : e.resolve(h).then(function (t) { u.value = t, i(u); }, function (t) { return invoke("throw", t, i, a); }); } a(c.arg); } var r; o(this, "_invoke", { value: function value(t, n) { function callInvokeWithMethodAndArg() { return new e(function (e, r) { invoke(t, n, e, r); }); } return r = r ? r.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); } }); } function makeInvokeMethod(e, r, n) { var o = h; return function (i, a) { if (o === f) throw Error("Generator is already running"); if (o === s) { if ("throw" === i) throw a; return { value: t, done: !0 }; } for (n.method = i, n.arg = a;;) { var c = n.delegate; if (c) { var u = maybeInvokeDelegate(c, n); if (u) { if (u === y) continue; return u; } } if ("next" === n.method) n.sent = n._sent = n.arg;else if ("throw" === n.method) { if (o === h) throw o = s, n.arg; n.dispatchException(n.arg); } else "return" === n.method && n.abrupt("return", n.arg); o = f; var p = tryCatch(e, r, n); if ("normal" === p.type) { if (o = n.done ? s : l, p.arg === y) continue; return { value: p.arg, done: n.done }; } "throw" === p.type && (o = s, n.method = "throw", n.arg = p.arg); } }; } function maybeInvokeDelegate(e, r) { var n = r.method, o = e.iterator[n]; if (o === t) return r.delegate = null, "throw" === n && e.iterator["return"] && (r.method = "return", r.arg = t, maybeInvokeDelegate(e, r), "throw" === r.method) || "return" !== n && (r.method = "throw", r.arg = new TypeError("The iterator does not provide a '" + n + "' method")), y; var i = tryCatch(o, e.iterator, r.arg); if ("throw" === i.type) return r.method = "throw", r.arg = i.arg, r.delegate = null, y; var a = i.arg; return a ? a.done ? (r[e.resultName] = a.value, r.next = e.nextLoc, "return" !== r.method && (r.method = "next", r.arg = t), r.delegate = null, y) : a : (r.method = "throw", r.arg = new TypeError("iterator result is not an object"), r.delegate = null, y); } function pushTryEntry(t) { var e = { tryLoc: t[0] }; 1 in t && (e.catchLoc = t[1]), 2 in t && (e.finallyLoc = t[2], e.afterLoc = t[3]), this.tryEntries.push(e); } function resetTryEntry(t) { var e = t.completion || {}; e.type = "normal", delete e.arg, t.completion = e; } function Context(t) { this.tryEntries = [{ tryLoc: "root" }], t.forEach(pushTryEntry, this), this.reset(!0); } function values(e) { if (e || "" === e) { var r = e[a]; if (r) return r.call(e); if ("function" == typeof e.next) return e; if (!isNaN(e.length)) { var o = -1, i = function next() { for (; ++o < e.length;) if (n.call(e, o)) return next.value = e[o], next.done = !1, next; return next.value = t, next.done = !0, next; }; return i.next = i; } } throw new TypeError(_typeof(e) + " is not iterable"); } return GeneratorFunction.prototype = GeneratorFunctionPrototype, o(g, "constructor", { value: GeneratorFunctionPrototype, configurable: !0 }), o(GeneratorFunctionPrototype, "constructor", { value: GeneratorFunction, configurable: !0 }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, u, "GeneratorFunction"), e.isGeneratorFunction = function (t) { var e = "function" == typeof t && t.constructor; return !!e && (e === GeneratorFunction || "GeneratorFunction" === (e.displayName || e.name)); }, e.mark = function (t) { return Object.setPrototypeOf ? Object.setPrototypeOf(t, GeneratorFunctionPrototype) : (t.__proto__ = GeneratorFunctionPrototype, define(t, u, "GeneratorFunction")), t.prototype = Object.create(g), t; }, e.awrap = function (t) { return { __await: t }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, c, function () { return this; }), e.AsyncIterator = AsyncIterator, e.async = function (t, r, n, o, i) { void 0 === i && (i = Promise); var a = new AsyncIterator(wrap(t, r, n, o), i); return e.isGeneratorFunction(r) ? a : a.next().then(function (t) { return t.done ? t.value : a.next(); }); }, defineIteratorMethods(g), define(g, u, "Generator"), define(g, a, function () { return this; }), define(g, "toString", function () { return "[object Generator]"; }), e.keys = function (t) { var e = Object(t), r = []; for (var n in e) r.push(n); return r.reverse(), function next() { for (; r.length;) { var t = r.pop(); if (t in e) return next.value = t, next.done = !1, next; } return next.done = !0, next; }; }, e.values = values, Context.prototype = { constructor: Context, reset: function reset(e) { if (this.prev = 0, this.next = 0, this.sent = this._sent = t, this.done = !1, this.delegate = null, this.method = "next", this.arg = t, this.tryEntries.forEach(resetTryEntry), !e) for (var r in this) "t" === r.charAt(0) && n.call(this, r) && !isNaN(+r.slice(1)) && (this[r] = t); }, stop: function stop() { this.done = !0; var t = this.tryEntries[0].completion; if ("throw" === t.type) throw t.arg; return this.rval; }, dispatchException: function dispatchException(e) { if (this.done) throw e; var r = this; function handle(n, o) { return a.type = "throw", a.arg = e, r.next = n, o && (r.method = "next", r.arg = t), !!o; } for (var o = this.tryEntries.length - 1; o >= 0; --o) { var i = this.tryEntries[o], a = i.completion; if ("root" === i.tryLoc) return handle("end"); if (i.tryLoc <= this.prev) { var c = n.call(i, "catchLoc"), u = n.call(i, "finallyLoc"); if (c && u) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } else if (c) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); } else { if (!u) throw Error("try statement without catch or finally"); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } } } }, abrupt: function abrupt(t, e) { for (var r = this.tryEntries.length - 1; r >= 0; --r) { var o = this.tryEntries[r]; if (o.tryLoc <= this.prev && n.call(o, "finallyLoc") && this.prev < o.finallyLoc) { var i = o; break; } } i && ("break" === t || "continue" === t) && i.tryLoc <= e && e <= i.finallyLoc && (i = null); var a = i ? i.completion : {}; return a.type = t, a.arg = e, i ? (this.method = "next", this.next = i.finallyLoc, y) : this.complete(a); }, complete: function complete(t, e) { if ("throw" === t.type) throw t.arg; return "break" === t.type || "continue" === t.type ? this.next = t.arg : "return" === t.type ? (this.rval = this.arg = t.arg, this.method = "return", this.next = "end") : "normal" === t.type && e && (this.next = e), y; }, finish: function finish(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.finallyLoc === t) return this.complete(r.completion, r.afterLoc), resetTryEntry(r), y; } }, "catch": function _catch(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.tryLoc === t) { var n = r.completion; if ("throw" === n.type) { var o = n.arg; resetTryEntry(r); } return o; } } throw Error("illegal catch attempt"); }, delegateYield: function delegateYield(e, r, n) { return this.delegate = { iterator: values(e), resultName: r, nextLoc: n }, "next" === this.method && (this.arg = t), y; } }, e; }
function asyncGeneratorStep(n, t, e, r, o, a, c) { try { var i = n[a](c), u = i.value; } catch (n) { return void e(n); } i.done ? t(u) : Promise.resolve(u).then(r, o); }
function _asyncToGenerator(n) { return function () { var t = this, e = arguments; return new Promise(function (r, o) { var a = n.apply(t, e); function _next(n) { asyncGeneratorStep(a, r, o, _next, _throw, "next", n); } function _throw(n) { asyncGeneratorStep(a, r, o, _next, _throw, "throw", n); } _next(void 0); }); }; }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.pbkdf2 = pbkdf2;
exports.pbkdf2Async = pbkdf2Async;
var _assert_js_1 = require("./_assert.js");
var hmac_js_1 = require("./hmac.js");
var utils_js_1 = require("./utils.js");
// Common prologue and epilogue for sync/async functions
function pbkdf2Init(hash, _password, _salt, _opts) {
  (0, _assert_js_1.hash)(hash);
  var opts = (0, utils_js_1.checkOpts)({
    dkLen: 32,
    asyncTick: 10
  }, _opts);
  var c = opts.c,
    dkLen = opts.dkLen,
    asyncTick = opts.asyncTick;
  (0, _assert_js_1.number)(c);
  (0, _assert_js_1.number)(dkLen);
  (0, _assert_js_1.number)(asyncTick);
  if (c < 1) throw new Error('PBKDF2: iterations (c) should be >= 1');
  var password = (0, utils_js_1.toBytes)(_password);
  var salt = (0, utils_js_1.toBytes)(_salt);
  // DK = PBKDF2(PRF, Password, Salt, c, dkLen);
  var DK = new Uint8Array(dkLen);
  // U1 = PRF(Password, Salt + INT_32_BE(i))
  var PRF = hmac_js_1.hmac.create(hash, password);
  var PRFSalt = PRF._cloneInto().update(salt);
  return {
    c: c,
    dkLen: dkLen,
    asyncTick: asyncTick,
    DK: DK,
    PRF: PRF,
    PRFSalt: PRFSalt
  };
}
function pbkdf2Output(PRF, PRFSalt, DK, prfW, u) {
  PRF.destroy();
  PRFSalt.destroy();
  if (prfW) prfW.destroy();
  u.fill(0);
  return DK;
}
/**
 * PBKDF2-HMAC: RFC 2898 key derivation function
 * @param hash - hash function that would be used e.g. sha256
 * @param password - password from which a derived key is generated
 * @param salt - cryptographic salt
 * @param opts - {c, dkLen} where c is work factor and dkLen is output message size
 */
function pbkdf2(hash, password, salt, opts) {
  var _pbkdf2Init = pbkdf2Init(hash, password, salt, opts),
    c = _pbkdf2Init.c,
    dkLen = _pbkdf2Init.dkLen,
    DK = _pbkdf2Init.DK,
    PRF = _pbkdf2Init.PRF,
    PRFSalt = _pbkdf2Init.PRFSalt;
  var prfW; // Working copy
  var arr = new Uint8Array(4);
  var view = (0, utils_js_1.createView)(arr);
  var u = new Uint8Array(PRF.outputLen);
  // DK = T1 + T2 +  + Tdklen/hlen
  for (var ti = 1, pos = 0; pos < dkLen; ti++, pos += PRF.outputLen) {
    // Ti = F(Password, Salt, c, i)
    var Ti = DK.subarray(pos, pos + PRF.outputLen);
    view.setInt32(0, ti, false);
    // F(Password, Salt, c, i) = U1 ^ U2 ^  ^ Uc
    // U1 = PRF(Password, Salt + INT_32_BE(i))
    (prfW = PRFSalt._cloneInto(prfW)).update(arr).digestInto(u);
    Ti.set(u.subarray(0, Ti.length));
    for (var ui = 1; ui < c; ui++) {
      // Uc = PRF(Password, Uc1)
      PRF._cloneInto(prfW).update(u).digestInto(u);
      for (var i = 0; i < Ti.length; i++) Ti[i] ^= u[i];
    }
  }
  return pbkdf2Output(PRF, PRFSalt, DK, prfW, u);
}
function pbkdf2Async(_x, _x2, _x3, _x4) {
  return _pbkdf2Async.apply(this, arguments);
}
function _pbkdf2Async() {
  _pbkdf2Async = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee(hash, password, salt, opts) {
    var _pbkdf2Init2, c, dkLen, asyncTick, DK, PRF, PRFSalt, prfW, arr, view, u, _loop, ti, pos;
    return _regeneratorRuntime().wrap(function _callee$(_context2) {
      while (1) switch (_context2.prev = _context2.next) {
        case 0:
          _pbkdf2Init2 = pbkdf2Init(hash, password, salt, opts), c = _pbkdf2Init2.c, dkLen = _pbkdf2Init2.dkLen, asyncTick = _pbkdf2Init2.asyncTick, DK = _pbkdf2Init2.DK, PRF = _pbkdf2Init2.PRF, PRFSalt = _pbkdf2Init2.PRFSalt;
          // Working copy
          arr = new Uint8Array(4);
          view = (0, utils_js_1.createView)(arr);
          u = new Uint8Array(PRF.outputLen); // DK = T1 + T2 +  + Tdklen/hlen
          _loop = /*#__PURE__*/_regeneratorRuntime().mark(function _loop() {
            var Ti;
            return _regeneratorRuntime().wrap(function _loop$(_context) {
              while (1) switch (_context.prev = _context.next) {
                case 0:
                  // Ti = F(Password, Salt, c, i)
                  Ti = DK.subarray(pos, pos + PRF.outputLen);
                  view.setInt32(0, ti, false);
                  // F(Password, Salt, c, i) = U1 ^ U2 ^  ^ Uc
                  // U1 = PRF(Password, Salt + INT_32_BE(i))
                  (prfW = PRFSalt._cloneInto(prfW)).update(arr).digestInto(u);
                  Ti.set(u.subarray(0, Ti.length));
                  _context.next = 6;
                  return (0, utils_js_1.asyncLoop)(c - 1, asyncTick, function () {
                    // Uc = PRF(Password, Uc1)
                    PRF._cloneInto(prfW).update(u).digestInto(u);
                    for (var i = 0; i < Ti.length; i++) Ti[i] ^= u[i];
                  });
                case 6:
                case "end":
                  return _context.stop();
              }
            }, _loop);
          });
          ti = 1, pos = 0;
        case 6:
          if (!(pos < dkLen)) {
            _context2.next = 11;
            break;
          }
          return _context2.delegateYield(_loop(), "t0", 8);
        case 8:
          ti++, pos += PRF.outputLen;
          _context2.next = 6;
          break;
        case 11:
          return _context2.abrupt("return", pbkdf2Output(PRF, PRFSalt, DK, prfW, u));
        case 12:
        case "end":
          return _context2.stop();
      }
    }, _callee);
  }));
  return _pbkdf2Async.apply(this, arguments);
}

},{"./_assert.js":4,"./hmac.js":8,"./utils.js":13}],10:[function(require,module,exports){
"use strict";

function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function"); }
function _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }
function _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: !1 }), e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
function _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }
function _possibleConstructorReturn(t, e) { if (e && ("object" == _typeof(e) || "function" == typeof e)) return e; if (void 0 !== e) throw new TypeError("Derived constructors may only return object or undefined"); return _assertThisInitialized(t); }
function _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); return e; }
function _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }
function _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }
function _inherits(t, e) { if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, "prototype", { writable: !1 }), e && _setPrototypeOf(t, e); }
function _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ripemd160 = exports.RIPEMD160 = void 0;
var _md_js_1 = require("./_md.js");
var utils_js_1 = require("./utils.js");
// https://homes.esat.kuleuven.be/~bosselae/ripemd160.html
// https://homes.esat.kuleuven.be/~bosselae/ripemd160/pdf/AB-9601/AB-9601.pdf
var Rho = /* @__PURE__ */new Uint8Array([7, 4, 13, 1, 10, 6, 15, 3, 12, 0, 9, 5, 2, 14, 11, 8]);
var Id = /* @__PURE__ */new Uint8Array(new Array(16).fill(0).map(function (_, i) {
  return i;
}));
var Pi = /* @__PURE__ */Id.map(function (i) {
  return (9 * i + 5) % 16;
});
var idxL = [Id];
var idxR = [Pi];
for (var i = 0; i < 4; i++) for (var _i = 0, _arr = [idxL, idxR]; _i < _arr.length; _i++) {
  var j = _arr[_i];
  j.push(j[i].map(function (k) {
    return Rho[k];
  }));
}
var shifts = /* @__PURE__ */[[11, 14, 15, 12, 5, 8, 7, 9, 11, 13, 14, 15, 6, 7, 9, 8], [12, 13, 11, 15, 6, 9, 9, 7, 12, 15, 11, 13, 7, 8, 7, 7], [13, 15, 14, 11, 7, 7, 6, 8, 13, 14, 13, 12, 5, 5, 6, 9], [14, 11, 12, 14, 8, 6, 5, 5, 15, 12, 15, 14, 9, 9, 8, 6], [15, 12, 13, 13, 9, 5, 8, 6, 14, 11, 12, 11, 8, 6, 5, 5]].map(function (i) {
  return new Uint8Array(i);
});
var shiftsL = /* @__PURE__ */idxL.map(function (idx, i) {
  return idx.map(function (j) {
    return shifts[i][j];
  });
});
var shiftsR = /* @__PURE__ */idxR.map(function (idx, i) {
  return idx.map(function (j) {
    return shifts[i][j];
  });
});
var Kl = /* @__PURE__ */new Uint32Array([0x00000000, 0x5a827999, 0x6ed9eba1, 0x8f1bbcdc, 0xa953fd4e]);
var Kr = /* @__PURE__ */new Uint32Array([0x50a28be6, 0x5c4dd124, 0x6d703ef3, 0x7a6d76e9, 0x00000000]);
// It's called f() in spec.
function f(group, x, y, z) {
  if (group === 0) return x ^ y ^ z;else if (group === 1) return x & y | ~x & z;else if (group === 2) return (x | ~y) ^ z;else if (group === 3) return x & z | y & ~z;else return x ^ (y | ~z);
}
// Temporary buffer, not used to store anything between runs
var R_BUF = /* @__PURE__ */new Uint32Array(16);
var RIPEMD160 = /*#__PURE__*/function (_md_js_1$HashMD) {
  function RIPEMD160() {
    var _this;
    _classCallCheck(this, RIPEMD160);
    _this = _callSuper(this, RIPEMD160, [64, 20, 8, true]);
    _this.h0 = 0x67452301 | 0;
    _this.h1 = 0xefcdab89 | 0;
    _this.h2 = 0x98badcfe | 0;
    _this.h3 = 0x10325476 | 0;
    _this.h4 = 0xc3d2e1f0 | 0;
    return _this;
  }
  _inherits(RIPEMD160, _md_js_1$HashMD);
  return _createClass(RIPEMD160, [{
    key: "get",
    value: function get() {
      var h0 = this.h0,
        h1 = this.h1,
        h2 = this.h2,
        h3 = this.h3,
        h4 = this.h4;
      return [h0, h1, h2, h3, h4];
    }
  }, {
    key: "set",
    value: function set(h0, h1, h2, h3, h4) {
      this.h0 = h0 | 0;
      this.h1 = h1 | 0;
      this.h2 = h2 | 0;
      this.h3 = h3 | 0;
      this.h4 = h4 | 0;
    }
  }, {
    key: "process",
    value: function process(view, offset) {
      for (var _i2 = 0; _i2 < 16; _i2++, offset += 4) R_BUF[_i2] = view.getUint32(offset, true);
      // prettier-ignore
      var al = this.h0 | 0,
        ar = al,
        bl = this.h1 | 0,
        br = bl,
        cl = this.h2 | 0,
        cr = cl,
        dl = this.h3 | 0,
        dr = dl,
        el = this.h4 | 0,
        er = el;
      // Instead of iterating 0 to 80, we split it into 5 groups
      // And use the groups in constants, functions, etc. Much simpler
      for (var group = 0; group < 5; group++) {
        var rGroup = 4 - group;
        var hbl = Kl[group],
          hbr = Kr[group]; // prettier-ignore
        var rl = idxL[group],
          rr = idxR[group]; // prettier-ignore
        var sl = shiftsL[group],
          sr = shiftsR[group]; // prettier-ignore
        for (var _i3 = 0; _i3 < 16; _i3++) {
          var tl = (0, utils_js_1.rotl)(al + f(group, bl, cl, dl) + R_BUF[rl[_i3]] + hbl, sl[_i3]) + el | 0;
          al = el, el = dl, dl = (0, utils_js_1.rotl)(cl, 10) | 0, cl = bl, bl = tl; // prettier-ignore
        }
        // 2 loops are 10% faster
        for (var _i4 = 0; _i4 < 16; _i4++) {
          var tr = (0, utils_js_1.rotl)(ar + f(rGroup, br, cr, dr) + R_BUF[rr[_i4]] + hbr, sr[_i4]) + er | 0;
          ar = er, er = dr, dr = (0, utils_js_1.rotl)(cr, 10) | 0, cr = br, br = tr; // prettier-ignore
        }
      }
      // Add the compressed chunk to the current hash value
      this.set(this.h1 + cl + dr | 0, this.h2 + dl + er | 0, this.h3 + el + ar | 0, this.h4 + al + br | 0, this.h0 + bl + cr | 0);
    }
  }, {
    key: "roundClean",
    value: function roundClean() {
      R_BUF.fill(0);
    }
  }, {
    key: "destroy",
    value: function destroy() {
      this.destroyed = true;
      this.buffer.fill(0);
      this.set(0, 0, 0, 0, 0);
    }
  }]);
}(_md_js_1.HashMD);
exports.RIPEMD160 = RIPEMD160;
/**
 * RIPEMD-160 - a hash function from 1990s.
 * @param message - msg that would be hashed
 */
exports.ripemd160 = (0, utils_js_1.wrapConstructor)(function () {
  return new RIPEMD160();
});

},{"./_md.js":5,"./utils.js":13}],11:[function(require,module,exports){
"use strict";

function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function"); }
function _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }
function _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: !1 }), e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
function _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }
function _possibleConstructorReturn(t, e) { if (e && ("object" == _typeof(e) || "function" == typeof e)) return e; if (void 0 !== e) throw new TypeError("Derived constructors may only return object or undefined"); return _assertThisInitialized(t); }
function _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); return e; }
function _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }
function _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }
function _inherits(t, e) { if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, "prototype", { writable: !1 }), e && _setPrototypeOf(t, e); }
function _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.sha224 = exports.sha256 = exports.SHA256 = void 0;
var _md_js_1 = require("./_md.js");
var utils_js_1 = require("./utils.js");
// SHA2-256 need to try 2^128 hashes to execute birthday attack.
// BTC network is doing 2^67 hashes/sec as per early 2023.
// Round constants:
// first 32 bits of the fractional parts of the cube roots of the first 64 primes 2..311)
// prettier-ignore
var SHA256_K = /* @__PURE__ */new Uint32Array([0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5, 0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174, 0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da, 0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967, 0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85, 0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070, 0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3, 0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208, 0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2]);
// Initial state:
// first 32 bits of the fractional parts of the square roots of the first 8 primes 2..19
// prettier-ignore
var SHA256_IV = /* @__PURE__ */new Uint32Array([0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a, 0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19]);
// Temporary buffer, not used to store anything between runs
// Named this way because it matches specification.
var SHA256_W = /* @__PURE__ */new Uint32Array(64);
var SHA256 = /*#__PURE__*/function (_md_js_1$HashMD) {
  function SHA256() {
    var _this;
    _classCallCheck(this, SHA256);
    _this = _callSuper(this, SHA256, [64, 32, 8, false]);
    // We cannot use array here since array allows indexing by variable
    // which means optimizer/compiler cannot use registers.
    _this.A = SHA256_IV[0] | 0;
    _this.B = SHA256_IV[1] | 0;
    _this.C = SHA256_IV[2] | 0;
    _this.D = SHA256_IV[3] | 0;
    _this.E = SHA256_IV[4] | 0;
    _this.F = SHA256_IV[5] | 0;
    _this.G = SHA256_IV[6] | 0;
    _this.H = SHA256_IV[7] | 0;
    return _this;
  }
  _inherits(SHA256, _md_js_1$HashMD);
  return _createClass(SHA256, [{
    key: "get",
    value: function get() {
      var A = this.A,
        B = this.B,
        C = this.C,
        D = this.D,
        E = this.E,
        F = this.F,
        G = this.G,
        H = this.H;
      return [A, B, C, D, E, F, G, H];
    }
    // prettier-ignore
  }, {
    key: "set",
    value: function set(A, B, C, D, E, F, G, H) {
      this.A = A | 0;
      this.B = B | 0;
      this.C = C | 0;
      this.D = D | 0;
      this.E = E | 0;
      this.F = F | 0;
      this.G = G | 0;
      this.H = H | 0;
    }
  }, {
    key: "process",
    value: function process(view, offset) {
      // Extend the first 16 words into the remaining 48 words w[16..63] of the message schedule array
      for (var i = 0; i < 16; i++, offset += 4) SHA256_W[i] = view.getUint32(offset, false);
      for (var _i = 16; _i < 64; _i++) {
        var W15 = SHA256_W[_i - 15];
        var W2 = SHA256_W[_i - 2];
        var s0 = (0, utils_js_1.rotr)(W15, 7) ^ (0, utils_js_1.rotr)(W15, 18) ^ W15 >>> 3;
        var s1 = (0, utils_js_1.rotr)(W2, 17) ^ (0, utils_js_1.rotr)(W2, 19) ^ W2 >>> 10;
        SHA256_W[_i] = s1 + SHA256_W[_i - 7] + s0 + SHA256_W[_i - 16] | 0;
      }
      // Compression function main loop, 64 rounds
      var A = this.A,
        B = this.B,
        C = this.C,
        D = this.D,
        E = this.E,
        F = this.F,
        G = this.G,
        H = this.H;
      for (var _i2 = 0; _i2 < 64; _i2++) {
        var sigma1 = (0, utils_js_1.rotr)(E, 6) ^ (0, utils_js_1.rotr)(E, 11) ^ (0, utils_js_1.rotr)(E, 25);
        var T1 = H + sigma1 + (0, _md_js_1.Chi)(E, F, G) + SHA256_K[_i2] + SHA256_W[_i2] | 0;
        var sigma0 = (0, utils_js_1.rotr)(A, 2) ^ (0, utils_js_1.rotr)(A, 13) ^ (0, utils_js_1.rotr)(A, 22);
        var T2 = sigma0 + (0, _md_js_1.Maj)(A, B, C) | 0;
        H = G;
        G = F;
        F = E;
        E = D + T1 | 0;
        D = C;
        C = B;
        B = A;
        A = T1 + T2 | 0;
      }
      // Add the compressed chunk to the current hash value
      A = A + this.A | 0;
      B = B + this.B | 0;
      C = C + this.C | 0;
      D = D + this.D | 0;
      E = E + this.E | 0;
      F = F + this.F | 0;
      G = G + this.G | 0;
      H = H + this.H | 0;
      this.set(A, B, C, D, E, F, G, H);
    }
  }, {
    key: "roundClean",
    value: function roundClean() {
      SHA256_W.fill(0);
    }
  }, {
    key: "destroy",
    value: function destroy() {
      this.set(0, 0, 0, 0, 0, 0, 0, 0);
      this.buffer.fill(0);
    }
  }]);
}(_md_js_1.HashMD);
exports.SHA256 = SHA256;
// Constants from https://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.180-4.pdf
var SHA224 = /*#__PURE__*/function (_SHA) {
  function SHA224() {
    var _this2;
    _classCallCheck(this, SHA224);
    _this2 = _callSuper(this, SHA224);
    _this2.A = 0xc1059ed8 | 0;
    _this2.B = 0x367cd507 | 0;
    _this2.C = 0x3070dd17 | 0;
    _this2.D = 0xf70e5939 | 0;
    _this2.E = 0xffc00b31 | 0;
    _this2.F = 0x68581511 | 0;
    _this2.G = 0x64f98fa7 | 0;
    _this2.H = 0xbefa4fa4 | 0;
    _this2.outputLen = 28;
    return _this2;
  }
  _inherits(SHA224, _SHA);
  return _createClass(SHA224);
}(SHA256);
/**
 * SHA2-256 hash function
 * @param message - data that would be hashed
 */
exports.sha256 = (0, utils_js_1.wrapConstructor)(function () {
  return new SHA256();
});
/**
 * SHA2-224 hash function
 */
exports.sha224 = (0, utils_js_1.wrapConstructor)(function () {
  return new SHA224();
});

},{"./_md.js":5,"./utils.js":13}],12:[function(require,module,exports){
"use strict";

function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function"); }
function _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }
function _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: !1 }), e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
function _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }
function _possibleConstructorReturn(t, e) { if (e && ("object" == _typeof(e) || "function" == typeof e)) return e; if (void 0 !== e) throw new TypeError("Derived constructors may only return object or undefined"); return _assertThisInitialized(t); }
function _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); return e; }
function _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }
function _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }
function _inherits(t, e) { if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, "prototype", { writable: !1 }), e && _setPrototypeOf(t, e); }
function _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }
function _slicedToArray(r, e) { return _arrayWithHoles(r) || _iterableToArrayLimit(r, e) || _unsupportedIterableToArray(r, e) || _nonIterableRest(); }
function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _unsupportedIterableToArray(r, a) { if (r) { if ("string" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }
function _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }
function _iterableToArrayLimit(r, l) { var t = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (null != t) { var e, n, i, u, a = [], f = !0, o = !1; try { if (i = (t = t.call(r)).next, 0 === l) { if (Object(t) !== t) return; f = !1; } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0); } catch (r) { o = !0, n = r; } finally { try { if (!f && null != t["return"] && (u = t["return"](), Object(u) !== u)) return; } finally { if (o) throw n; } } return a; } }
function _arrayWithHoles(r) { if (Array.isArray(r)) return r; }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.sha384 = exports.sha512_256 = exports.sha512_224 = exports.sha512 = exports.SHA384 = exports.SHA512_256 = exports.SHA512_224 = exports.SHA512 = void 0;
var _md_js_1 = require("./_md.js");
var _u64_js_1 = require("./_u64.js");
var utils_js_1 = require("./utils.js");
// Round contants (first 32 bits of the fractional parts of the cube roots of the first 80 primes 2..409):
// prettier-ignore
var _ref = /* @__PURE__ */function () {
    return _u64_js_1["default"].split(['0x428a2f98d728ae22', '0x7137449123ef65cd', '0xb5c0fbcfec4d3b2f', '0xe9b5dba58189dbbc', '0x3956c25bf348b538', '0x59f111f1b605d019', '0x923f82a4af194f9b', '0xab1c5ed5da6d8118', '0xd807aa98a3030242', '0x12835b0145706fbe', '0x243185be4ee4b28c', '0x550c7dc3d5ffb4e2', '0x72be5d74f27b896f', '0x80deb1fe3b1696b1', '0x9bdc06a725c71235', '0xc19bf174cf692694', '0xe49b69c19ef14ad2', '0xefbe4786384f25e3', '0x0fc19dc68b8cd5b5', '0x240ca1cc77ac9c65', '0x2de92c6f592b0275', '0x4a7484aa6ea6e483', '0x5cb0a9dcbd41fbd4', '0x76f988da831153b5', '0x983e5152ee66dfab', '0xa831c66d2db43210', '0xb00327c898fb213f', '0xbf597fc7beef0ee4', '0xc6e00bf33da88fc2', '0xd5a79147930aa725', '0x06ca6351e003826f', '0x142929670a0e6e70', '0x27b70a8546d22ffc', '0x2e1b21385c26c926', '0x4d2c6dfc5ac42aed', '0x53380d139d95b3df', '0x650a73548baf63de', '0x766a0abb3c77b2a8', '0x81c2c92e47edaee6', '0x92722c851482353b', '0xa2bfe8a14cf10364', '0xa81a664bbc423001', '0xc24b8b70d0f89791', '0xc76c51a30654be30', '0xd192e819d6ef5218', '0xd69906245565a910', '0xf40e35855771202a', '0x106aa07032bbd1b8', '0x19a4c116b8d2d0c8', '0x1e376c085141ab53', '0x2748774cdf8eeb99', '0x34b0bcb5e19b48a8', '0x391c0cb3c5c95a63', '0x4ed8aa4ae3418acb', '0x5b9cca4f7763e373', '0x682e6ff3d6b2b8a3', '0x748f82ee5defb2fc', '0x78a5636f43172f60', '0x84c87814a1f0ab72', '0x8cc702081a6439ec', '0x90befffa23631e28', '0xa4506cebde82bde9', '0xbef9a3f7b2c67915', '0xc67178f2e372532b', '0xca273eceea26619c', '0xd186b8c721c0c207', '0xeada7dd6cde0eb1e', '0xf57d4f7fee6ed178', '0x06f067aa72176fba', '0x0a637dc5a2c898a6', '0x113f9804bef90dae', '0x1b710b35131c471b', '0x28db77f523047d84', '0x32caab7b40c72493', '0x3c9ebe0a15c9bebc', '0x431d67c49c100d4c', '0x4cc5d4becb3e42b6', '0x597f299cfc657e2a', '0x5fcb6fab3ad6faec', '0x6c44198c4a475817'].map(function (n) {
      return BigInt(n);
    }));
  }(),
  _ref2 = _slicedToArray(_ref, 2),
  SHA512_Kh = _ref2[0],
  SHA512_Kl = _ref2[1];
// Temporary buffer, not used to store anything between runs
var SHA512_W_H = /* @__PURE__ */new Uint32Array(80);
var SHA512_W_L = /* @__PURE__ */new Uint32Array(80);
var SHA512 = /*#__PURE__*/function (_md_js_1$HashMD) {
  function SHA512() {
    var _this;
    _classCallCheck(this, SHA512);
    _this = _callSuper(this, SHA512, [128, 64, 16, false]);
    // We cannot use array here since array allows indexing by variable which means optimizer/compiler cannot use registers.
    // Also looks cleaner and easier to verify with spec.
    // Initial state (first 32 bits of the fractional parts of the square roots of the first 8 primes 2..19):
    // h -- high 32 bits, l -- low 32 bits
    _this.Ah = 0x6a09e667 | 0;
    _this.Al = 0xf3bcc908 | 0;
    _this.Bh = 0xbb67ae85 | 0;
    _this.Bl = 0x84caa73b | 0;
    _this.Ch = 0x3c6ef372 | 0;
    _this.Cl = 0xfe94f82b | 0;
    _this.Dh = 0xa54ff53a | 0;
    _this.Dl = 0x5f1d36f1 | 0;
    _this.Eh = 0x510e527f | 0;
    _this.El = 0xade682d1 | 0;
    _this.Fh = 0x9b05688c | 0;
    _this.Fl = 0x2b3e6c1f | 0;
    _this.Gh = 0x1f83d9ab | 0;
    _this.Gl = 0xfb41bd6b | 0;
    _this.Hh = 0x5be0cd19 | 0;
    _this.Hl = 0x137e2179 | 0;
    return _this;
  }
  // prettier-ignore
  _inherits(SHA512, _md_js_1$HashMD);
  return _createClass(SHA512, [{
    key: "get",
    value: function get() {
      var Ah = this.Ah,
        Al = this.Al,
        Bh = this.Bh,
        Bl = this.Bl,
        Ch = this.Ch,
        Cl = this.Cl,
        Dh = this.Dh,
        Dl = this.Dl,
        Eh = this.Eh,
        El = this.El,
        Fh = this.Fh,
        Fl = this.Fl,
        Gh = this.Gh,
        Gl = this.Gl,
        Hh = this.Hh,
        Hl = this.Hl;
      return [Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl];
    }
    // prettier-ignore
  }, {
    key: "set",
    value: function set(Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl) {
      this.Ah = Ah | 0;
      this.Al = Al | 0;
      this.Bh = Bh | 0;
      this.Bl = Bl | 0;
      this.Ch = Ch | 0;
      this.Cl = Cl | 0;
      this.Dh = Dh | 0;
      this.Dl = Dl | 0;
      this.Eh = Eh | 0;
      this.El = El | 0;
      this.Fh = Fh | 0;
      this.Fl = Fl | 0;
      this.Gh = Gh | 0;
      this.Gl = Gl | 0;
      this.Hh = Hh | 0;
      this.Hl = Hl | 0;
    }
  }, {
    key: "process",
    value: function process(view, offset) {
      // Extend the first 16 words into the remaining 64 words w[16..79] of the message schedule array
      for (var i = 0; i < 16; i++, offset += 4) {
        SHA512_W_H[i] = view.getUint32(offset);
        SHA512_W_L[i] = view.getUint32(offset += 4);
      }
      for (var _i = 16; _i < 80; _i++) {
        // s0 := (w[i-15] rightrotate 1) xor (w[i-15] rightrotate 8) xor (w[i-15] rightshift 7)
        var W15h = SHA512_W_H[_i - 15] | 0;
        var W15l = SHA512_W_L[_i - 15] | 0;
        var s0h = _u64_js_1["default"].rotrSH(W15h, W15l, 1) ^ _u64_js_1["default"].rotrSH(W15h, W15l, 8) ^ _u64_js_1["default"].shrSH(W15h, W15l, 7);
        var s0l = _u64_js_1["default"].rotrSL(W15h, W15l, 1) ^ _u64_js_1["default"].rotrSL(W15h, W15l, 8) ^ _u64_js_1["default"].shrSL(W15h, W15l, 7);
        // s1 := (w[i-2] rightrotate 19) xor (w[i-2] rightrotate 61) xor (w[i-2] rightshift 6)
        var W2h = SHA512_W_H[_i - 2] | 0;
        var W2l = SHA512_W_L[_i - 2] | 0;
        var s1h = _u64_js_1["default"].rotrSH(W2h, W2l, 19) ^ _u64_js_1["default"].rotrBH(W2h, W2l, 61) ^ _u64_js_1["default"].shrSH(W2h, W2l, 6);
        var s1l = _u64_js_1["default"].rotrSL(W2h, W2l, 19) ^ _u64_js_1["default"].rotrBL(W2h, W2l, 61) ^ _u64_js_1["default"].shrSL(W2h, W2l, 6);
        // SHA256_W[i] = s0 + s1 + SHA256_W[i - 7] + SHA256_W[i - 16];
        var SUMl = _u64_js_1["default"].add4L(s0l, s1l, SHA512_W_L[_i - 7], SHA512_W_L[_i - 16]);
        var SUMh = _u64_js_1["default"].add4H(SUMl, s0h, s1h, SHA512_W_H[_i - 7], SHA512_W_H[_i - 16]);
        SHA512_W_H[_i] = SUMh | 0;
        SHA512_W_L[_i] = SUMl | 0;
      }
      var Ah = this.Ah,
        Al = this.Al,
        Bh = this.Bh,
        Bl = this.Bl,
        Ch = this.Ch,
        Cl = this.Cl,
        Dh = this.Dh,
        Dl = this.Dl,
        Eh = this.Eh,
        El = this.El,
        Fh = this.Fh,
        Fl = this.Fl,
        Gh = this.Gh,
        Gl = this.Gl,
        Hh = this.Hh,
        Hl = this.Hl;
      // Compression function main loop, 80 rounds
      for (var _i2 = 0; _i2 < 80; _i2++) {
        // S1 := (e rightrotate 14) xor (e rightrotate 18) xor (e rightrotate 41)
        var sigma1h = _u64_js_1["default"].rotrSH(Eh, El, 14) ^ _u64_js_1["default"].rotrSH(Eh, El, 18) ^ _u64_js_1["default"].rotrBH(Eh, El, 41);
        var sigma1l = _u64_js_1["default"].rotrSL(Eh, El, 14) ^ _u64_js_1["default"].rotrSL(Eh, El, 18) ^ _u64_js_1["default"].rotrBL(Eh, El, 41);
        //const T1 = (H + sigma1 + Chi(E, F, G) + SHA256_K[i] + SHA256_W[i]) | 0;
        var CHIh = Eh & Fh ^ ~Eh & Gh;
        var CHIl = El & Fl ^ ~El & Gl;
        // T1 = H + sigma1 + Chi(E, F, G) + SHA512_K[i] + SHA512_W[i]
        // prettier-ignore
        var T1ll = _u64_js_1["default"].add5L(Hl, sigma1l, CHIl, SHA512_Kl[_i2], SHA512_W_L[_i2]);
        var T1h = _u64_js_1["default"].add5H(T1ll, Hh, sigma1h, CHIh, SHA512_Kh[_i2], SHA512_W_H[_i2]);
        var T1l = T1ll | 0;
        // S0 := (a rightrotate 28) xor (a rightrotate 34) xor (a rightrotate 39)
        var sigma0h = _u64_js_1["default"].rotrSH(Ah, Al, 28) ^ _u64_js_1["default"].rotrBH(Ah, Al, 34) ^ _u64_js_1["default"].rotrBH(Ah, Al, 39);
        var sigma0l = _u64_js_1["default"].rotrSL(Ah, Al, 28) ^ _u64_js_1["default"].rotrBL(Ah, Al, 34) ^ _u64_js_1["default"].rotrBL(Ah, Al, 39);
        var MAJh = Ah & Bh ^ Ah & Ch ^ Bh & Ch;
        var MAJl = Al & Bl ^ Al & Cl ^ Bl & Cl;
        Hh = Gh | 0;
        Hl = Gl | 0;
        Gh = Fh | 0;
        Gl = Fl | 0;
        Fh = Eh | 0;
        Fl = El | 0;
        var _u64_js_1$default$add = _u64_js_1["default"].add(Dh | 0, Dl | 0, T1h | 0, T1l | 0);
        Eh = _u64_js_1$default$add.h;
        El = _u64_js_1$default$add.l;
        Dh = Ch | 0;
        Dl = Cl | 0;
        Ch = Bh | 0;
        Cl = Bl | 0;
        Bh = Ah | 0;
        Bl = Al | 0;
        var All = _u64_js_1["default"].add3L(T1l, sigma0l, MAJl);
        Ah = _u64_js_1["default"].add3H(All, T1h, sigma0h, MAJh);
        Al = All | 0;
      }
      // Add the compressed chunk to the current hash value
      var _u64_js_1$default$add2 = _u64_js_1["default"].add(this.Ah | 0, this.Al | 0, Ah | 0, Al | 0);
      Ah = _u64_js_1$default$add2.h;
      Al = _u64_js_1$default$add2.l;
      var _u64_js_1$default$add3 = _u64_js_1["default"].add(this.Bh | 0, this.Bl | 0, Bh | 0, Bl | 0);
      Bh = _u64_js_1$default$add3.h;
      Bl = _u64_js_1$default$add3.l;
      var _u64_js_1$default$add4 = _u64_js_1["default"].add(this.Ch | 0, this.Cl | 0, Ch | 0, Cl | 0);
      Ch = _u64_js_1$default$add4.h;
      Cl = _u64_js_1$default$add4.l;
      var _u64_js_1$default$add5 = _u64_js_1["default"].add(this.Dh | 0, this.Dl | 0, Dh | 0, Dl | 0);
      Dh = _u64_js_1$default$add5.h;
      Dl = _u64_js_1$default$add5.l;
      var _u64_js_1$default$add6 = _u64_js_1["default"].add(this.Eh | 0, this.El | 0, Eh | 0, El | 0);
      Eh = _u64_js_1$default$add6.h;
      El = _u64_js_1$default$add6.l;
      var _u64_js_1$default$add7 = _u64_js_1["default"].add(this.Fh | 0, this.Fl | 0, Fh | 0, Fl | 0);
      Fh = _u64_js_1$default$add7.h;
      Fl = _u64_js_1$default$add7.l;
      var _u64_js_1$default$add8 = _u64_js_1["default"].add(this.Gh | 0, this.Gl | 0, Gh | 0, Gl | 0);
      Gh = _u64_js_1$default$add8.h;
      Gl = _u64_js_1$default$add8.l;
      var _u64_js_1$default$add9 = _u64_js_1["default"].add(this.Hh | 0, this.Hl | 0, Hh | 0, Hl | 0);
      Hh = _u64_js_1$default$add9.h;
      Hl = _u64_js_1$default$add9.l;
      this.set(Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl);
    }
  }, {
    key: "roundClean",
    value: function roundClean() {
      SHA512_W_H.fill(0);
      SHA512_W_L.fill(0);
    }
  }, {
    key: "destroy",
    value: function destroy() {
      this.buffer.fill(0);
      this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
    }
  }]);
}(_md_js_1.HashMD);
exports.SHA512 = SHA512;
var SHA512_224 = /*#__PURE__*/function (_SHA) {
  function SHA512_224() {
    var _this2;
    _classCallCheck(this, SHA512_224);
    _this2 = _callSuper(this, SHA512_224);
    // h -- high 32 bits, l -- low 32 bits
    _this2.Ah = 0x8c3d37c8 | 0;
    _this2.Al = 0x19544da2 | 0;
    _this2.Bh = 0x73e19966 | 0;
    _this2.Bl = 0x89dcd4d6 | 0;
    _this2.Ch = 0x1dfab7ae | 0;
    _this2.Cl = 0x32ff9c82 | 0;
    _this2.Dh = 0x679dd514 | 0;
    _this2.Dl = 0x582f9fcf | 0;
    _this2.Eh = 0x0f6d2b69 | 0;
    _this2.El = 0x7bd44da8 | 0;
    _this2.Fh = 0x77e36f73 | 0;
    _this2.Fl = 0x04c48942 | 0;
    _this2.Gh = 0x3f9d85a8 | 0;
    _this2.Gl = 0x6a1d36c8 | 0;
    _this2.Hh = 0x1112e6ad | 0;
    _this2.Hl = 0x91d692a1 | 0;
    _this2.outputLen = 28;
    return _this2;
  }
  _inherits(SHA512_224, _SHA);
  return _createClass(SHA512_224);
}(SHA512);
exports.SHA512_224 = SHA512_224;
var SHA512_256 = /*#__PURE__*/function (_SHA2) {
  function SHA512_256() {
    var _this3;
    _classCallCheck(this, SHA512_256);
    _this3 = _callSuper(this, SHA512_256);
    // h -- high 32 bits, l -- low 32 bits
    _this3.Ah = 0x22312194 | 0;
    _this3.Al = 0xfc2bf72c | 0;
    _this3.Bh = 0x9f555fa3 | 0;
    _this3.Bl = 0xc84c64c2 | 0;
    _this3.Ch = 0x2393b86b | 0;
    _this3.Cl = 0x6f53b151 | 0;
    _this3.Dh = 0x96387719 | 0;
    _this3.Dl = 0x5940eabd | 0;
    _this3.Eh = 0x96283ee2 | 0;
    _this3.El = 0xa88effe3 | 0;
    _this3.Fh = 0xbe5e1e25 | 0;
    _this3.Fl = 0x53863992 | 0;
    _this3.Gh = 0x2b0199fc | 0;
    _this3.Gl = 0x2c85b8aa | 0;
    _this3.Hh = 0x0eb72ddc | 0;
    _this3.Hl = 0x81c52ca2 | 0;
    _this3.outputLen = 32;
    return _this3;
  }
  _inherits(SHA512_256, _SHA2);
  return _createClass(SHA512_256);
}(SHA512);
exports.SHA512_256 = SHA512_256;
var SHA384 = /*#__PURE__*/function (_SHA3) {
  function SHA384() {
    var _this4;
    _classCallCheck(this, SHA384);
    _this4 = _callSuper(this, SHA384);
    // h -- high 32 bits, l -- low 32 bits
    _this4.Ah = 0xcbbb9d5d | 0;
    _this4.Al = 0xc1059ed8 | 0;
    _this4.Bh = 0x629a292a | 0;
    _this4.Bl = 0x367cd507 | 0;
    _this4.Ch = 0x9159015a | 0;
    _this4.Cl = 0x3070dd17 | 0;
    _this4.Dh = 0x152fecd8 | 0;
    _this4.Dl = 0xf70e5939 | 0;
    _this4.Eh = 0x67332667 | 0;
    _this4.El = 0xffc00b31 | 0;
    _this4.Fh = 0x8eb44a87 | 0;
    _this4.Fl = 0x68581511 | 0;
    _this4.Gh = 0xdb0c2e0d | 0;
    _this4.Gl = 0x64f98fa7 | 0;
    _this4.Hh = 0x47b5481d | 0;
    _this4.Hl = 0xbefa4fa4 | 0;
    _this4.outputLen = 48;
    return _this4;
  }
  _inherits(SHA384, _SHA3);
  return _createClass(SHA384);
}(SHA512);
exports.SHA384 = SHA384;
exports.sha512 = (0, utils_js_1.wrapConstructor)(function () {
  return new SHA512();
});
exports.sha512_224 = (0, utils_js_1.wrapConstructor)(function () {
  return new SHA512_224();
});
exports.sha512_256 = (0, utils_js_1.wrapConstructor)(function () {
  return new SHA512_256();
});
exports.sha384 = (0, utils_js_1.wrapConstructor)(function () {
  return new SHA384();
});

},{"./_md.js":5,"./_u64.js":6,"./utils.js":13}],13:[function(require,module,exports){
"use strict";

/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */
function _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function"); }
function _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }
function _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: !1 }), e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
function _regeneratorRuntime() { "use strict"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return e; }; var t, e = {}, r = Object.prototype, n = r.hasOwnProperty, o = Object.defineProperty || function (t, e, r) { t[e] = r.value; }, i = "function" == typeof Symbol ? Symbol : {}, a = i.iterator || "@@iterator", c = i.asyncIterator || "@@asyncIterator", u = i.toStringTag || "@@toStringTag"; function define(t, e, r) { return Object.defineProperty(t, e, { value: r, enumerable: !0, configurable: !0, writable: !0 }), t[e]; } try { define({}, ""); } catch (t) { define = function define(t, e, r) { return t[e] = r; }; } function wrap(t, e, r, n) { var i = e && e.prototype instanceof Generator ? e : Generator, a = Object.create(i.prototype), c = new Context(n || []); return o(a, "_invoke", { value: makeInvokeMethod(t, r, c) }), a; } function tryCatch(t, e, r) { try { return { type: "normal", arg: t.call(e, r) }; } catch (t) { return { type: "throw", arg: t }; } } e.wrap = wrap; var h = "suspendedStart", l = "suspendedYield", f = "executing", s = "completed", y = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var p = {}; define(p, a, function () { return this; }); var d = Object.getPrototypeOf, v = d && d(d(values([]))); v && v !== r && n.call(v, a) && (p = v); var g = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(p); function defineIteratorMethods(t) { ["next", "throw", "return"].forEach(function (e) { define(t, e, function (t) { return this._invoke(e, t); }); }); } function AsyncIterator(t, e) { function invoke(r, o, i, a) { var c = tryCatch(t[r], t, o); if ("throw" !== c.type) { var u = c.arg, h = u.value; return h && "object" == _typeof(h) && n.call(h, "__await") ? e.resolve(h.__await).then(function (t) { invoke("next", t, i, a); }, function (t) { invoke("throw", t, i, a); }) : e.resolve(h).then(function (t) { u.value = t, i(u); }, function (t) { return invoke("throw", t, i, a); }); } a(c.arg); } var r; o(this, "_invoke", { value: function value(t, n) { function callInvokeWithMethodAndArg() { return new e(function (e, r) { invoke(t, n, e, r); }); } return r = r ? r.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); } }); } function makeInvokeMethod(e, r, n) { var o = h; return function (i, a) { if (o === f) throw Error("Generator is already running"); if (o === s) { if ("throw" === i) throw a; return { value: t, done: !0 }; } for (n.method = i, n.arg = a;;) { var c = n.delegate; if (c) { var u = maybeInvokeDelegate(c, n); if (u) { if (u === y) continue; return u; } } if ("next" === n.method) n.sent = n._sent = n.arg;else if ("throw" === n.method) { if (o === h) throw o = s, n.arg; n.dispatchException(n.arg); } else "return" === n.method && n.abrupt("return", n.arg); o = f; var p = tryCatch(e, r, n); if ("normal" === p.type) { if (o = n.done ? s : l, p.arg === y) continue; return { value: p.arg, done: n.done }; } "throw" === p.type && (o = s, n.method = "throw", n.arg = p.arg); } }; } function maybeInvokeDelegate(e, r) { var n = r.method, o = e.iterator[n]; if (o === t) return r.delegate = null, "throw" === n && e.iterator["return"] && (r.method = "return", r.arg = t, maybeInvokeDelegate(e, r), "throw" === r.method) || "return" !== n && (r.method = "throw", r.arg = new TypeError("The iterator does not provide a '" + n + "' method")), y; var i = tryCatch(o, e.iterator, r.arg); if ("throw" === i.type) return r.method = "throw", r.arg = i.arg, r.delegate = null, y; var a = i.arg; return a ? a.done ? (r[e.resultName] = a.value, r.next = e.nextLoc, "return" !== r.method && (r.method = "next", r.arg = t), r.delegate = null, y) : a : (r.method = "throw", r.arg = new TypeError("iterator result is not an object"), r.delegate = null, y); } function pushTryEntry(t) { var e = { tryLoc: t[0] }; 1 in t && (e.catchLoc = t[1]), 2 in t && (e.finallyLoc = t[2], e.afterLoc = t[3]), this.tryEntries.push(e); } function resetTryEntry(t) { var e = t.completion || {}; e.type = "normal", delete e.arg, t.completion = e; } function Context(t) { this.tryEntries = [{ tryLoc: "root" }], t.forEach(pushTryEntry, this), this.reset(!0); } function values(e) { if (e || "" === e) { var r = e[a]; if (r) return r.call(e); if ("function" == typeof e.next) return e; if (!isNaN(e.length)) { var o = -1, i = function next() { for (; ++o < e.length;) if (n.call(e, o)) return next.value = e[o], next.done = !1, next; return next.value = t, next.done = !0, next; }; return i.next = i; } } throw new TypeError(_typeof(e) + " is not iterable"); } return GeneratorFunction.prototype = GeneratorFunctionPrototype, o(g, "constructor", { value: GeneratorFunctionPrototype, configurable: !0 }), o(GeneratorFunctionPrototype, "constructor", { value: GeneratorFunction, configurable: !0 }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, u, "GeneratorFunction"), e.isGeneratorFunction = function (t) { var e = "function" == typeof t && t.constructor; return !!e && (e === GeneratorFunction || "GeneratorFunction" === (e.displayName || e.name)); }, e.mark = function (t) { return Object.setPrototypeOf ? Object.setPrototypeOf(t, GeneratorFunctionPrototype) : (t.__proto__ = GeneratorFunctionPrototype, define(t, u, "GeneratorFunction")), t.prototype = Object.create(g), t; }, e.awrap = function (t) { return { __await: t }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, c, function () { return this; }), e.AsyncIterator = AsyncIterator, e.async = function (t, r, n, o, i) { void 0 === i && (i = Promise); var a = new AsyncIterator(wrap(t, r, n, o), i); return e.isGeneratorFunction(r) ? a : a.next().then(function (t) { return t.done ? t.value : a.next(); }); }, defineIteratorMethods(g), define(g, u, "Generator"), define(g, a, function () { return this; }), define(g, "toString", function () { return "[object Generator]"; }), e.keys = function (t) { var e = Object(t), r = []; for (var n in e) r.push(n); return r.reverse(), function next() { for (; r.length;) { var t = r.pop(); if (t in e) return next.value = t, next.done = !1, next; } return next.done = !0, next; }; }, e.values = values, Context.prototype = { constructor: Context, reset: function reset(e) { if (this.prev = 0, this.next = 0, this.sent = this._sent = t, this.done = !1, this.delegate = null, this.method = "next", this.arg = t, this.tryEntries.forEach(resetTryEntry), !e) for (var r in this) "t" === r.charAt(0) && n.call(this, r) && !isNaN(+r.slice(1)) && (this[r] = t); }, stop: function stop() { this.done = !0; var t = this.tryEntries[0].completion; if ("throw" === t.type) throw t.arg; return this.rval; }, dispatchException: function dispatchException(e) { if (this.done) throw e; var r = this; function handle(n, o) { return a.type = "throw", a.arg = e, r.next = n, o && (r.method = "next", r.arg = t), !!o; } for (var o = this.tryEntries.length - 1; o >= 0; --o) { var i = this.tryEntries[o], a = i.completion; if ("root" === i.tryLoc) return handle("end"); if (i.tryLoc <= this.prev) { var c = n.call(i, "catchLoc"), u = n.call(i, "finallyLoc"); if (c && u) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } else if (c) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); } else { if (!u) throw Error("try statement without catch or finally"); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } } } }, abrupt: function abrupt(t, e) { for (var r = this.tryEntries.length - 1; r >= 0; --r) { var o = this.tryEntries[r]; if (o.tryLoc <= this.prev && n.call(o, "finallyLoc") && this.prev < o.finallyLoc) { var i = o; break; } } i && ("break" === t || "continue" === t) && i.tryLoc <= e && e <= i.finallyLoc && (i = null); var a = i ? i.completion : {}; return a.type = t, a.arg = e, i ? (this.method = "next", this.next = i.finallyLoc, y) : this.complete(a); }, complete: function complete(t, e) { if ("throw" === t.type) throw t.arg; return "break" === t.type || "continue" === t.type ? this.next = t.arg : "return" === t.type ? (this.rval = this.arg = t.arg, this.method = "return", this.next = "end") : "normal" === t.type && e && (this.next = e), y; }, finish: function finish(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.finallyLoc === t) return this.complete(r.completion, r.afterLoc), resetTryEntry(r), y; } }, "catch": function _catch(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.tryLoc === t) { var n = r.completion; if ("throw" === n.type) { var o = n.arg; resetTryEntry(r); } return o; } } throw Error("illegal catch attempt"); }, delegateYield: function delegateYield(e, r, n) { return this.delegate = { iterator: values(e), resultName: r, nextLoc: n }, "next" === this.method && (this.arg = t), y; } }, e; }
function asyncGeneratorStep(n, t, e, r, o, a, c) { try { var i = n[a](c), u = i.value; } catch (n) { return void e(n); } i.done ? t(u) : Promise.resolve(u).then(r, o); }
function _asyncToGenerator(n) { return function () { var t = this, e = arguments; return new Promise(function (r, o) { var a = n.apply(t, e); function _next(n) { asyncGeneratorStep(a, r, o, _next, _throw, "next", n); } function _throw(n) { asyncGeneratorStep(a, r, o, _next, _throw, "throw", n); } _next(void 0); }); }; }
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Hash = exports.nextTick = exports.byteSwapIfBE = exports.byteSwap = exports.isLE = exports.rotl = exports.rotr = exports.createView = exports.u32 = exports.u8 = void 0;
exports.isBytes = isBytes;
exports.byteSwap32 = byteSwap32;
exports.bytesToHex = bytesToHex;
exports.hexToBytes = hexToBytes;
exports.asyncLoop = asyncLoop;
exports.utf8ToBytes = utf8ToBytes;
exports.toBytes = toBytes;
exports.concatBytes = concatBytes;
exports.checkOpts = checkOpts;
exports.wrapConstructor = wrapConstructor;
exports.wrapConstructorWithOpts = wrapConstructorWithOpts;
exports.wrapXOFConstructorWithOpts = wrapXOFConstructorWithOpts;
exports.randomBytes = randomBytes;
// We use WebCrypto aka globalThis.crypto, which exists in browsers and node.js 16+.
// node.js versions earlier than v19 don't declare it in global scope.
// For node.js, package.json#exports field mapping rewrites import
// from `crypto` to `cryptoNode`, which imports native module.
// Makes the utils un-importable in browsers without a bundler.
// Once node.js 18 is deprecated (2025-04-30), we can just drop the import.
var crypto_1 = require("@noble/hashes/crypto");
var _assert_js_1 = require("./_assert.js");
// export { isBytes } from './_assert.js';
// We can't reuse isBytes from _assert, because somehow this causes huge perf issues
function isBytes(a) {
  return a instanceof Uint8Array || a != null && _typeof(a) === 'object' && a.constructor.name === 'Uint8Array';
}
// Cast array to different type
var u8 = function u8(arr) {
  return new Uint8Array(arr.buffer, arr.byteOffset, arr.byteLength);
};
exports.u8 = u8;
var u32 = function u32(arr) {
  return new Uint32Array(arr.buffer, arr.byteOffset, Math.floor(arr.byteLength / 4));
};
exports.u32 = u32;
// Cast array to view
var createView = function createView(arr) {
  return new DataView(arr.buffer, arr.byteOffset, arr.byteLength);
};
exports.createView = createView;
// The rotate right (circular right shift) operation for uint32
var rotr = function rotr(word, shift) {
  return word << 32 - shift | word >>> shift;
};
exports.rotr = rotr;
// The rotate left (circular left shift) operation for uint32
var rotl = function rotl(word, shift) {
  return word << shift | word >>> 32 - shift >>> 0;
};
exports.rotl = rotl;
exports.isLE = new Uint8Array(new Uint32Array([0x11223344]).buffer)[0] === 0x44;
// The byte swap operation for uint32
var byteSwap = function byteSwap(word) {
  return word << 24 & 0xff000000 | word << 8 & 0xff0000 | word >>> 8 & 0xff00 | word >>> 24 & 0xff;
};
exports.byteSwap = byteSwap;
// Conditionally byte swap if on a big-endian platform
exports.byteSwapIfBE = exports.isLE ? function (n) {
  return n;
} : function (n) {
  return (0, exports.byteSwap)(n);
};
// In place byte swap for Uint32Array
function byteSwap32(arr) {
  for (var i = 0; i < arr.length; i++) {
    arr[i] = (0, exports.byteSwap)(arr[i]);
  }
}
// Array where index 0xf0 (240) is mapped to string 'f0'
var hexes = /* @__PURE__ */Array.from({
  length: 256
}, function (_, i) {
  return i.toString(16).padStart(2, '0');
});
/**
 * @example bytesToHex(Uint8Array.from([0xca, 0xfe, 0x01, 0x23])) // 'cafe0123'
 */
function bytesToHex(bytes) {
  (0, _assert_js_1.bytes)(bytes);
  // pre-caching improves the speed 6x
  var hex = '';
  for (var i = 0; i < bytes.length; i++) {
    hex += hexes[bytes[i]];
  }
  return hex;
}
// We use optimized technique to convert hex string to byte array
var asciis = {
  _0: 48,
  _9: 57,
  _A: 65,
  _F: 70,
  _a: 97,
  _f: 102
};
function asciiToBase16(_char) {
  if (_char >= asciis._0 && _char <= asciis._9) return _char - asciis._0;
  if (_char >= asciis._A && _char <= asciis._F) return _char - (asciis._A - 10);
  if (_char >= asciis._a && _char <= asciis._f) return _char - (asciis._a - 10);
  return;
}
/**
 * @example hexToBytes('cafe0123') // Uint8Array.from([0xca, 0xfe, 0x01, 0x23])
 */
function hexToBytes(hex) {
  if (typeof hex !== 'string') throw new Error('hex string expected, got ' + _typeof(hex));
  var hl = hex.length;
  var al = hl / 2;
  if (hl % 2) throw new Error('padded hex string expected, got unpadded hex of length ' + hl);
  var array = new Uint8Array(al);
  for (var ai = 0, hi = 0; ai < al; ai++, hi += 2) {
    var n1 = asciiToBase16(hex.charCodeAt(hi));
    var n2 = asciiToBase16(hex.charCodeAt(hi + 1));
    if (n1 === undefined || n2 === undefined) {
      var _char2 = hex[hi] + hex[hi + 1];
      throw new Error('hex string expected, got non-hex character "' + _char2 + '" at index ' + hi);
    }
    array[ai] = n1 * 16 + n2;
  }
  return array;
}
// There is no setImmediate in browser and setTimeout is slow.
// call of async fn will return Promise, which will be fullfiled only on
// next scheduler queue processing step and this is exactly what we need.
var nextTick = /*#__PURE__*/function () {
  var _ref = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee() {
    return _regeneratorRuntime().wrap(function _callee$(_context) {
      while (1) switch (_context.prev = _context.next) {
        case 0:
        case "end":
          return _context.stop();
      }
    }, _callee);
  }));
  return function nextTick() {
    return _ref.apply(this, arguments);
  };
}();
exports.nextTick = nextTick;
// Returns control to thread each 'tick' ms to avoid blocking
function asyncLoop(_x, _x2, _x3) {
  return _asyncLoop.apply(this, arguments);
}
/**
 * @example utf8ToBytes('abc') // new Uint8Array([97, 98, 99])
 */
function _asyncLoop() {
  _asyncLoop = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee2(iters, tick, cb) {
    var ts, i, diff;
    return _regeneratorRuntime().wrap(function _callee2$(_context2) {
      while (1) switch (_context2.prev = _context2.next) {
        case 0:
          ts = Date.now();
          i = 0;
        case 2:
          if (!(i < iters)) {
            _context2.next = 13;
            break;
          }
          cb(i);
          // Date.now() is not monotonic, so in case if clock goes backwards we return return control too
          diff = Date.now() - ts;
          if (!(diff >= 0 && diff < tick)) {
            _context2.next = 7;
            break;
          }
          return _context2.abrupt("continue", 10);
        case 7:
          _context2.next = 9;
          return (0, exports.nextTick)();
        case 9:
          ts += diff;
        case 10:
          i++;
          _context2.next = 2;
          break;
        case 13:
        case "end":
          return _context2.stop();
      }
    }, _callee2);
  }));
  return _asyncLoop.apply(this, arguments);
}
function utf8ToBytes(str) {
  if (typeof str !== 'string') throw new Error("utf8ToBytes expected string, got ".concat(_typeof(str)));
  return new Uint8Array(new TextEncoder().encode(str)); // https://bugzil.la/1681809
}
/**
 * Normalizes (non-hex) string or Uint8Array to Uint8Array.
 * Warning: when Uint8Array is passed, it would NOT get copied.
 * Keep in mind for future mutable operations.
 */
function toBytes(data) {
  if (typeof data === 'string') data = utf8ToBytes(data);
  (0, _assert_js_1.bytes)(data);
  return data;
}
/**
 * Copies several Uint8Arrays into one.
 */
function concatBytes() {
  var sum = 0;
  for (var i = 0; i < arguments.length; i++) {
    var a = i < 0 || arguments.length <= i ? undefined : arguments[i];
    (0, _assert_js_1.bytes)(a);
    sum += a.length;
  }
  var res = new Uint8Array(sum);
  for (var _i = 0, pad = 0; _i < arguments.length; _i++) {
    var _a = _i < 0 || arguments.length <= _i ? undefined : arguments[_i];
    res.set(_a, pad);
    pad += _a.length;
  }
  return res;
}
// For runtime check if class implements interface
var Hash = /*#__PURE__*/function () {
  function Hash() {
    _classCallCheck(this, Hash);
  }
  return _createClass(Hash, [{
    key: "clone",
    value:
    // Safe version that clones internal state
    function clone() {
      return this._cloneInto();
    }
  }]);
}();
exports.Hash = Hash;
var toStr = {}.toString;
function checkOpts(defaults, opts) {
  if (opts !== undefined && toStr.call(opts) !== '[object Object]') throw new Error('Options should be object or undefined');
  var merged = Object.assign(defaults, opts);
  return merged;
}
function wrapConstructor(hashCons) {
  var hashC = function hashC(msg) {
    return hashCons().update(toBytes(msg)).digest();
  };
  var tmp = hashCons();
  hashC.outputLen = tmp.outputLen;
  hashC.blockLen = tmp.blockLen;
  hashC.create = function () {
    return hashCons();
  };
  return hashC;
}
function wrapConstructorWithOpts(hashCons) {
  var hashC = function hashC(msg, opts) {
    return hashCons(opts).update(toBytes(msg)).digest();
  };
  var tmp = hashCons({});
  hashC.outputLen = tmp.outputLen;
  hashC.blockLen = tmp.blockLen;
  hashC.create = function (opts) {
    return hashCons(opts);
  };
  return hashC;
}
function wrapXOFConstructorWithOpts(hashCons) {
  var hashC = function hashC(msg, opts) {
    return hashCons(opts).update(toBytes(msg)).digest();
  };
  var tmp = hashCons({});
  hashC.outputLen = tmp.outputLen;
  hashC.blockLen = tmp.blockLen;
  hashC.create = function (opts) {
    return hashCons(opts);
  };
  return hashC;
}
/**
 * Secure PRNG. Uses `crypto.getRandomValues`, which defers to OS.
 */
function randomBytes() {
  var bytesLength = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 32;
  if (crypto_1.crypto && typeof crypto_1.crypto.getRandomValues === 'function') {
    return crypto_1.crypto.getRandomValues(new Uint8Array(bytesLength));
  }
  // Legacy Node.js compatibility
  if (crypto_1.crypto && typeof crypto_1.crypto.randomBytes === 'function') {
    return crypto_1.crypto.randomBytes(bytesLength);
  }
  throw new Error('crypto.getRandomValues must be defined');
}

},{"./_assert.js":4,"@noble/hashes/crypto":7}],14:[function(require,module,exports){
"use strict";

/*! scure-base - MIT License (c) 2022 Paul Miller (paulmillr.com) */
function _createForOfIteratorHelper(r, e) { var t = "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (!t) { if (Array.isArray(r) || (t = _unsupportedIterableToArray(r)) || e && r && "number" == typeof r.length) { t && (r = t); var _n = 0, F = function F() {}; return { s: F, n: function n() { return _n >= r.length ? { done: !0 } : { done: !1, value: r[_n++] }; }, e: function e(r) { throw r; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var o, a = !0, u = !1; return { s: function s() { t = t.call(r); }, n: function n() { var r = t.next(); return a = r.done, r; }, e: function e(r) { u = !0, o = r; }, f: function f() { try { a || null == t["return"] || t["return"](); } finally { if (u) throw o; } } }; }
function _unsupportedIterableToArray(r, a) { if (r) { if ("string" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }
function _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.bytes = exports.stringToBytes = exports.str = exports.bytesToString = exports.hex = exports.utf8 = exports.bech32m = exports.bech32 = exports.base58check = exports.createBase58check = exports.base58xmr = exports.base58xrp = exports.base58flickr = exports.base58 = exports.base64urlnopad = exports.base64url = exports.base64nopad = exports.base64 = exports.base32crockford = exports.base32hexnopad = exports.base32hex = exports.base32nopad = exports.base32 = exports.base16 = exports.utils = void 0;
exports.assertNumber = assertNumber;
// Utilities
/**
 * @__NO_SIDE_EFFECTS__
 */
function assertNumber(n) {
  if (!Number.isSafeInteger(n)) throw new Error("Wrong integer: ".concat(n));
}
function isBytes(a) {
  return a instanceof Uint8Array || a != null && _typeof(a) === 'object' && a.constructor.name === 'Uint8Array';
}
/**
 * @__NO_SIDE_EFFECTS__
 */
function chain() {
  var id = function id(a) {
    return a;
  };
  // Wrap call in closure so JIT can inline calls
  var wrap = function wrap(a, b) {
    return function (c) {
      return a(b(c));
    };
  };
  // Construct chain of args[-1].encode(args[-2].encode([...]))
  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
    args[_key] = arguments[_key];
  }
  var encode = args.map(function (x) {
    return x.encode;
  }).reduceRight(wrap, id);
  // Construct chain of args[0].decode(args[1].decode(...))
  var decode = args.map(function (x) {
    return x.decode;
  }).reduce(wrap, id);
  return {
    encode: encode,
    decode: decode
  };
}
/**
 * Encodes integer radix representation to array of strings using alphabet and back
 * @__NO_SIDE_EFFECTS__
 */
function alphabet(alphabet) {
  return {
    encode: function encode(digits) {
      if (!Array.isArray(digits) || digits.length && typeof digits[0] !== 'number') throw new Error('alphabet.encode input should be an array of numbers');
      return digits.map(function (i) {
        assertNumber(i);
        if (i < 0 || i >= alphabet.length) throw new Error("Digit index outside alphabet: ".concat(i, " (alphabet: ").concat(alphabet.length, ")"));
        return alphabet[i];
      });
    },
    decode: function decode(input) {
      if (!Array.isArray(input) || input.length && typeof input[0] !== 'string') throw new Error('alphabet.decode input should be array of strings');
      return input.map(function (letter) {
        if (typeof letter !== 'string') throw new Error("alphabet.decode: not string element=".concat(letter));
        var index = alphabet.indexOf(letter);
        if (index === -1) throw new Error("Unknown letter: \"".concat(letter, "\". Allowed: ").concat(alphabet));
        return index;
      });
    }
  };
}
/**
 * @__NO_SIDE_EFFECTS__
 */
function join() {
  var separator = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';
  if (typeof separator !== 'string') throw new Error('join separator should be string');
  return {
    encode: function encode(from) {
      if (!Array.isArray(from) || from.length && typeof from[0] !== 'string') throw new Error('join.encode input should be array of strings');
      var _iterator = _createForOfIteratorHelper(from),
        _step;
      try {
        for (_iterator.s(); !(_step = _iterator.n()).done;) {
          var i = _step.value;
          if (typeof i !== 'string') throw new Error("join.encode: non-string input=".concat(i));
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }
      return from.join(separator);
    },
    decode: function decode(to) {
      if (typeof to !== 'string') throw new Error('join.decode input should be string');
      return to.split(separator);
    }
  };
}
/**
 * Pad strings array so it has integer number of bits
 * @__NO_SIDE_EFFECTS__
 */
function padding(bits) {
  var chr = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '=';
  assertNumber(bits);
  if (typeof chr !== 'string') throw new Error('padding chr should be string');
  return {
    encode: function encode(data) {
      if (!Array.isArray(data) || data.length && typeof data[0] !== 'string') throw new Error('padding.encode input should be array of strings');
      var _iterator2 = _createForOfIteratorHelper(data),
        _step2;
      try {
        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
          var i = _step2.value;
          if (typeof i !== 'string') throw new Error("padding.encode: non-string input=".concat(i));
        }
      } catch (err) {
        _iterator2.e(err);
      } finally {
        _iterator2.f();
      }
      while (data.length * bits % 8) data.push(chr);
      return data;
    },
    decode: function decode(input) {
      if (!Array.isArray(input) || input.length && typeof input[0] !== 'string') throw new Error('padding.encode input should be array of strings');
      var _iterator3 = _createForOfIteratorHelper(input),
        _step3;
      try {
        for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
          var i = _step3.value;
          if (typeof i !== 'string') throw new Error("padding.decode: non-string input=".concat(i));
        }
      } catch (err) {
        _iterator3.e(err);
      } finally {
        _iterator3.f();
      }
      var end = input.length;
      if (end * bits % 8) throw new Error('Invalid padding: string should have whole number of bytes');
      for (; end > 0 && input[end - 1] === chr; end--) {
        if (!((end - 1) * bits % 8)) throw new Error('Invalid padding: string has too much padding');
      }
      return input.slice(0, end);
    }
  };
}
/**
 * @__NO_SIDE_EFFECTS__
 */
function normalize(fn) {
  if (typeof fn !== 'function') throw new Error('normalize fn should be function');
  return {
    encode: function encode(from) {
      return from;
    },
    decode: function decode(to) {
      return fn(to);
    }
  };
}
/**
 * Slow: O(n^2) time complexity
 * @__NO_SIDE_EFFECTS__
 */
function convertRadix(data, from, to) {
  // base 1 is impossible
  if (from < 2) throw new Error("convertRadix: wrong from=".concat(from, ", base cannot be less than 2"));
  if (to < 2) throw new Error("convertRadix: wrong to=".concat(to, ", base cannot be less than 2"));
  if (!Array.isArray(data)) throw new Error('convertRadix: data should be array');
  if (!data.length) return [];
  var pos = 0;
  var res = [];
  var digits = Array.from(data);
  digits.forEach(function (d) {
    assertNumber(d);
    if (d < 0 || d >= from) throw new Error("Wrong integer: ".concat(d));
  });
  while (true) {
    var carry = 0;
    var done = true;
    for (var i = pos; i < digits.length; i++) {
      var digit = digits[i];
      var digitBase = from * carry + digit;
      if (!Number.isSafeInteger(digitBase) || from * carry / from !== carry || digitBase - digit !== from * carry) {
        throw new Error('convertRadix: carry overflow');
      }
      carry = digitBase % to;
      var rounded = Math.floor(digitBase / to);
      digits[i] = rounded;
      if (!Number.isSafeInteger(rounded) || rounded * to + carry !== digitBase) throw new Error('convertRadix: carry overflow');
      if (!done) continue;else if (!rounded) pos = i;else done = false;
    }
    res.push(carry);
    if (done) break;
  }
  for (var _i = 0; _i < data.length - 1 && data[_i] === 0; _i++) res.push(0);
  return res.reverse();
}
var _gcd = /* @__NO_SIDE_EFFECTS__ */function gcd(a, b) {
  return !b ? a : _gcd(b, a % b);
};
var radix2carry = /*@__NO_SIDE_EFFECTS__ */function radix2carry(from, to) {
  return from + (to - _gcd(from, to));
};
/**
 * Implemented with numbers, because BigInt is 5x slower
 * @__NO_SIDE_EFFECTS__
 */
function convertRadix2(data, from, to, padding) {
  if (!Array.isArray(data)) throw new Error('convertRadix2: data should be array');
  if (from <= 0 || from > 32) throw new Error("convertRadix2: wrong from=".concat(from));
  if (to <= 0 || to > 32) throw new Error("convertRadix2: wrong to=".concat(to));
  if (radix2carry(from, to) > 32) {
    throw new Error("convertRadix2: carry overflow from=".concat(from, " to=").concat(to, " carryBits=").concat(radix2carry(from, to)));
  }
  var carry = 0;
  var pos = 0; // bitwise position in current element
  var mask = Math.pow(2, to) - 1;
  var res = [];
  var _iterator4 = _createForOfIteratorHelper(data),
    _step4;
  try {
    for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {
      var n = _step4.value;
      assertNumber(n);
      if (n >= Math.pow(2, from)) throw new Error("convertRadix2: invalid data word=".concat(n, " from=").concat(from));
      carry = carry << from | n;
      if (pos + from > 32) throw new Error("convertRadix2: carry overflow pos=".concat(pos, " from=").concat(from));
      pos += from;
      for (; pos >= to; pos -= to) res.push((carry >> pos - to & mask) >>> 0);
      carry &= Math.pow(2, pos) - 1; // clean carry, otherwise it will cause overflow
    }
  } catch (err) {
    _iterator4.e(err);
  } finally {
    _iterator4.f();
  }
  carry = carry << to - pos & mask;
  if (!padding && pos >= from) throw new Error('Excess padding');
  if (!padding && carry) throw new Error("Non-zero padding: ".concat(carry));
  if (padding && pos > 0) res.push(carry >>> 0);
  return res;
}
/**
 * @__NO_SIDE_EFFECTS__
 */
function radix(num) {
  assertNumber(num);
  return {
    encode: function encode(bytes) {
      if (!isBytes(bytes)) throw new Error('radix.encode input should be Uint8Array');
      return convertRadix(Array.from(bytes), Math.pow(2, 8), num);
    },
    decode: function decode(digits) {
      if (!Array.isArray(digits) || digits.length && typeof digits[0] !== 'number') throw new Error('radix.decode input should be array of numbers');
      return Uint8Array.from(convertRadix(digits, num, Math.pow(2, 8)));
    }
  };
}
/**
 * If both bases are power of same number (like `2**8 <-> 2**64`),
 * there is a linear algorithm. For now we have implementation for power-of-two bases only.
 * @__NO_SIDE_EFFECTS__
 */
function radix2(bits) {
  var revPadding = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
  assertNumber(bits);
  if (bits <= 0 || bits > 32) throw new Error('radix2: bits should be in (0..32]');
  if (radix2carry(8, bits) > 32 || radix2carry(bits, 8) > 32) throw new Error('radix2: carry overflow');
  return {
    encode: function encode(bytes) {
      if (!isBytes(bytes)) throw new Error('radix2.encode input should be Uint8Array');
      return convertRadix2(Array.from(bytes), 8, bits, !revPadding);
    },
    decode: function decode(digits) {
      if (!Array.isArray(digits) || digits.length && typeof digits[0] !== 'number') throw new Error('radix2.decode input should be array of numbers');
      return Uint8Array.from(convertRadix2(digits, bits, 8, revPadding));
    }
  };
}
/**
 * @__NO_SIDE_EFFECTS__
 */
function unsafeWrapper(fn) {
  if (typeof fn !== 'function') throw new Error('unsafeWrapper fn should be function');
  return function () {
    try {
      for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
        args[_key2] = arguments[_key2];
      }
      return fn.apply(null, args);
    } catch (e) {}
  };
}
/**
 * @__NO_SIDE_EFFECTS__
 */
function checksum(len, fn) {
  assertNumber(len);
  if (typeof fn !== 'function') throw new Error('checksum fn should be function');
  return {
    encode: function encode(data) {
      if (!isBytes(data)) throw new Error('checksum.encode: input should be Uint8Array');
      var checksum = fn(data).slice(0, len);
      var res = new Uint8Array(data.length + len);
      res.set(data);
      res.set(checksum, data.length);
      return res;
    },
    decode: function decode(data) {
      if (!isBytes(data)) throw new Error('checksum.decode: input should be Uint8Array');
      var payload = data.slice(0, -len);
      var newChecksum = fn(payload).slice(0, len);
      var oldChecksum = data.slice(-len);
      for (var i = 0; i < len; i++) if (newChecksum[i] !== oldChecksum[i]) throw new Error('Invalid checksum');
      return payload;
    }
  };
}
// prettier-ignore
exports.utils = {
  alphabet: alphabet,
  chain: chain,
  checksum: checksum,
  convertRadix: convertRadix,
  convertRadix2: convertRadix2,
  radix: radix,
  radix2: radix2,
  join: join,
  padding: padding
};
// RFC 4648 aka RFC 3548
// ---------------------
exports.base16 = chain(radix2(4), alphabet('0123456789ABCDEF'), join(''));
exports.base32 = chain(radix2(5), alphabet('ABCDEFGHIJKLMNOPQRSTUVWXYZ234567'), padding(5), join(''));
exports.base32nopad = chain(radix2(5), alphabet('ABCDEFGHIJKLMNOPQRSTUVWXYZ234567'), join(''));
exports.base32hex = chain(radix2(5), alphabet('0123456789ABCDEFGHIJKLMNOPQRSTUV'), padding(5), join(''));
exports.base32hexnopad = chain(radix2(5), alphabet('0123456789ABCDEFGHIJKLMNOPQRSTUV'), join(''));
exports.base32crockford = chain(radix2(5), alphabet('0123456789ABCDEFGHJKMNPQRSTVWXYZ'), join(''), normalize(function (s) {
  return s.toUpperCase().replace(/O/g, '0').replace(/[IL]/g, '1');
}));
exports.base64 = chain(radix2(6), alphabet('ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'), padding(6), join(''));
exports.base64nopad = chain(radix2(6), alphabet('ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'), join(''));
exports.base64url = chain(radix2(6), alphabet('ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_'), padding(6), join(''));
exports.base64urlnopad = chain(radix2(6), alphabet('ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_'), join(''));
// base58 code
// -----------
var genBase58 = function genBase58(abc) {
  return chain(radix(58), alphabet(abc), join(''));
};
exports.base58 = genBase58('123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz');
exports.base58flickr = genBase58('123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ');
exports.base58xrp = genBase58('rpshnaf39wBUDNEGHJKLM4PQRST7VWXYZ2bcdeCg65jkm8oFqi1tuvAxyz');
// xmr ver is done in 8-byte blocks (which equals 11 chars in decoding). Last (non-full) block padded with '1' to size in XMR_BLOCK_LEN.
// Block encoding significantly reduces quadratic complexity of base58.
// Data len (index) -> encoded block len
var XMR_BLOCK_LEN = [0, 2, 3, 5, 6, 7, 9, 10, 11];
exports.base58xmr = {
  encode: function encode(data) {
    var res = '';
    for (var i = 0; i < data.length; i += 8) {
      var block = data.subarray(i, i + 8);
      res += exports.base58.encode(block).padStart(XMR_BLOCK_LEN[block.length], '1');
    }
    return res;
  },
  decode: function decode(str) {
    var res = [];
    for (var i = 0; i < str.length; i += 11) {
      var slice = str.slice(i, i + 11);
      var blockLen = XMR_BLOCK_LEN.indexOf(slice.length);
      var block = exports.base58.decode(slice);
      for (var j = 0; j < block.length - blockLen; j++) {
        if (block[j] !== 0) throw new Error('base58xmr: wrong padding');
      }
      res = res.concat(Array.from(block.slice(block.length - blockLen)));
    }
    return Uint8Array.from(res);
  }
};
var createBase58check = function createBase58check(sha256) {
  return chain(checksum(4, function (data) {
    return sha256(sha256(data));
  }), exports.base58);
};
exports.createBase58check = createBase58check;
// legacy export, bad name
exports.base58check = exports.createBase58check;
var BECH_ALPHABET = /* @__PURE__ */chain(alphabet('qpzry9x8gf2tvdw0s3jn54khce6mua7l'), join(''));
var POLYMOD_GENERATORS = [0x3b6a57b2, 0x26508e6d, 0x1ea119fa, 0x3d4233dd, 0x2a1462b3];
/**
 * @__NO_SIDE_EFFECTS__
 */
function bech32Polymod(pre) {
  var b = pre >> 25;
  var chk = (pre & 0x1ffffff) << 5;
  for (var i = 0; i < POLYMOD_GENERATORS.length; i++) {
    if ((b >> i & 1) === 1) chk ^= POLYMOD_GENERATORS[i];
  }
  return chk;
}
/**
 * @__NO_SIDE_EFFECTS__
 */
function bechChecksum(prefix, words) {
  var encodingConst = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;
  var len = prefix.length;
  var chk = 1;
  for (var i = 0; i < len; i++) {
    var c = prefix.charCodeAt(i);
    if (c < 33 || c > 126) throw new Error("Invalid prefix (".concat(prefix, ")"));
    chk = bech32Polymod(chk) ^ c >> 5;
  }
  chk = bech32Polymod(chk);
  for (var _i2 = 0; _i2 < len; _i2++) chk = bech32Polymod(chk) ^ prefix.charCodeAt(_i2) & 0x1f;
  var _iterator5 = _createForOfIteratorHelper(words),
    _step5;
  try {
    for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {
      var v = _step5.value;
      chk = bech32Polymod(chk) ^ v;
    }
  } catch (err) {
    _iterator5.e(err);
  } finally {
    _iterator5.f();
  }
  for (var _i3 = 0; _i3 < 6; _i3++) chk = bech32Polymod(chk);
  chk ^= encodingConst;
  return BECH_ALPHABET.encode(convertRadix2([chk % Math.pow(2, 30)], 30, 5, false));
}
/**
 * @__NO_SIDE_EFFECTS__
 */
function genBech32(encoding) {
  var ENCODING_CONST = encoding === 'bech32' ? 1 : 0x2bc830a3;
  var _words = radix2(5);
  var fromWords = _words.decode;
  var toWords = _words.encode;
  var fromWordsUnsafe = unsafeWrapper(fromWords);
  function encode(prefix, words) {
    var limit = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 90;
    if (typeof prefix !== 'string') throw new Error("bech32.encode prefix should be string, not ".concat(_typeof(prefix)));
    if (words instanceof Uint8Array) words = Array.from(words);
    if (!Array.isArray(words) || words.length && typeof words[0] !== 'number') throw new Error("bech32.encode words should be array of numbers, not ".concat(_typeof(words)));
    if (prefix.length === 0) throw new TypeError("Invalid prefix length ".concat(prefix.length));
    var actualLength = prefix.length + 7 + words.length;
    if (limit !== false && actualLength > limit) throw new TypeError("Length ".concat(actualLength, " exceeds limit ").concat(limit));
    var lowered = prefix.toLowerCase();
    var sum = bechChecksum(lowered, words, ENCODING_CONST);
    return "".concat(lowered, "1").concat(BECH_ALPHABET.encode(words)).concat(sum);
  }
  function decode(str) {
    var limit = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 90;
    if (typeof str !== 'string') throw new Error("bech32.decode input should be string, not ".concat(_typeof(str)));
    if (str.length < 8 || limit !== false && str.length > limit) throw new TypeError("Wrong string length: ".concat(str.length, " (").concat(str, "). Expected (8..").concat(limit, ")"));
    // don't allow mixed case
    var lowered = str.toLowerCase();
    if (str !== lowered && str !== str.toUpperCase()) throw new Error("String must be lowercase or uppercase");
    var sepIndex = lowered.lastIndexOf('1');
    if (sepIndex === 0 || sepIndex === -1) throw new Error("Letter \"1\" must be present between prefix and data only");
    var prefix = lowered.slice(0, sepIndex);
    var data = lowered.slice(sepIndex + 1);
    if (data.length < 6) throw new Error('Data must be at least 6 characters long');
    var words = BECH_ALPHABET.decode(data).slice(0, -6);
    var sum = bechChecksum(prefix, words, ENCODING_CONST);
    if (!data.endsWith(sum)) throw new Error("Invalid checksum in ".concat(str, ": expected \"").concat(sum, "\""));
    return {
      prefix: prefix,
      words: words
    };
  }
  var decodeUnsafe = unsafeWrapper(decode);
  function decodeToBytes(str) {
    var _decode = decode(str, false),
      prefix = _decode.prefix,
      words = _decode.words;
    return {
      prefix: prefix,
      words: words,
      bytes: fromWords(words)
    };
  }
  function encodeFromBytes(prefix, bytes) {
    return encode(prefix, toWords(bytes));
  }
  return {
    encode: encode,
    decode: decode,
    encodeFromBytes: encodeFromBytes,
    decodeToBytes: decodeToBytes,
    decodeUnsafe: decodeUnsafe,
    fromWords: fromWords,
    fromWordsUnsafe: fromWordsUnsafe,
    toWords: toWords
  };
}
exports.bech32 = genBech32('bech32');
exports.bech32m = genBech32('bech32m');
exports.utf8 = {
  encode: function encode(data) {
    return new TextDecoder().decode(data);
  },
  decode: function decode(str) {
    return new TextEncoder().encode(str);
  }
};
exports.hex = chain(radix2(4), alphabet('0123456789abcdef'), join(''), normalize(function (s) {
  if (typeof s !== 'string' || s.length % 2) throw new TypeError("hex.decode: expected string, got ".concat(_typeof(s), " with length ").concat(s.length));
  return s.toLowerCase();
}));
// prettier-ignore
var CODERS = {
  utf8: exports.utf8,
  hex: exports.hex,
  base16: exports.base16,
  base32: exports.base32,
  base64: exports.base64,
  base64url: exports.base64url,
  base58: exports.base58,
  base58xmr: exports.base58xmr
};
var coderTypeError = 'Invalid encoding type. Available types: utf8, hex, base16, base32, base64, base64url, base58, base58xmr';
var bytesToString = function bytesToString(type, bytes) {
  if (typeof type !== 'string' || !CODERS.hasOwnProperty(type)) throw new TypeError(coderTypeError);
  if (!isBytes(bytes)) throw new TypeError('bytesToString() expects Uint8Array');
  return CODERS[type].encode(bytes);
};
exports.bytesToString = bytesToString;
exports.str = exports.bytesToString; // as in python, but for bytes only
var stringToBytes = function stringToBytes(type, str) {
  if (!CODERS.hasOwnProperty(type)) throw new TypeError(coderTypeError);
  if (typeof str !== 'string') throw new TypeError('stringToBytes() expects string');
  return CODERS[type].decode(str);
};
exports.stringToBytes = stringToBytes;
exports.bytes = exports.stringToBytes;

},{}],15:[function(require,module,exports){
'use strict';

// base-x encoding / decoding
// Copyright (c) 2018 base-x contributors
// Copyright (c) 2014-2018 The Bitcoin Core developers (base58.cpp)
// Distributed under the MIT software license, see the accompanying
// file LICENSE or http://www.opensource.org/licenses/mit-license.php.
Object.defineProperty(exports, '__esModule', {
  value: true
});
function base(ALPHABET) {
  if (ALPHABET.length >= 255) {
    throw new TypeError('Alphabet too long');
  }
  var BASE_MAP = new Uint8Array(256);
  for (var j = 0; j < BASE_MAP.length; j++) {
    BASE_MAP[j] = 255;
  }
  for (var i = 0; i < ALPHABET.length; i++) {
    var x = ALPHABET.charAt(i);
    var xc = x.charCodeAt(0);
    if (BASE_MAP[xc] !== 255) {
      throw new TypeError(x + ' is ambiguous');
    }
    BASE_MAP[xc] = i;
  }
  var BASE = ALPHABET.length;
  var LEADER = ALPHABET.charAt(0);
  var FACTOR = Math.log(BASE) / Math.log(256); // log(BASE) / log(256), rounded up
  var iFACTOR = Math.log(256) / Math.log(BASE); // log(256) / log(BASE), rounded up
  function encode(source) {
    // eslint-disable-next-line no-empty
    if (source instanceof Uint8Array) {} else if (ArrayBuffer.isView(source)) {
      source = new Uint8Array(source.buffer, source.byteOffset, source.byteLength);
    } else if (Array.isArray(source)) {
      source = Uint8Array.from(source);
    }
    if (!(source instanceof Uint8Array)) {
      throw new TypeError('Expected Uint8Array');
    }
    if (source.length === 0) {
      return '';
    }
    // Skip & count leading zeroes.
    var zeroes = 0;
    var length = 0;
    var pbegin = 0;
    var pend = source.length;
    while (pbegin !== pend && source[pbegin] === 0) {
      pbegin++;
      zeroes++;
    }
    // Allocate enough space in big-endian base58 representation.
    var size = (pend - pbegin) * iFACTOR + 1 >>> 0;
    var b58 = new Uint8Array(size);
    // Process the bytes.
    while (pbegin !== pend) {
      var carry = source[pbegin];
      // Apply "b58 = b58 * 256 + ch".
      var _i = 0;
      for (var it1 = size - 1; (carry !== 0 || _i < length) && it1 !== -1; it1--, _i++) {
        carry += 256 * b58[it1] >>> 0;
        b58[it1] = carry % BASE >>> 0;
        carry = carry / BASE >>> 0;
      }
      if (carry !== 0) {
        throw new Error('Non-zero carry');
      }
      length = _i;
      pbegin++;
    }
    // Skip leading zeroes in base58 result.
    var it2 = size - length;
    while (it2 !== size && b58[it2] === 0) {
      it2++;
    }
    // Translate the result into a string.
    var str = LEADER.repeat(zeroes);
    for (; it2 < size; ++it2) {
      str += ALPHABET.charAt(b58[it2]);
    }
    return str;
  }
  function decodeUnsafe(source) {
    if (typeof source !== 'string') {
      throw new TypeError('Expected String');
    }
    if (source.length === 0) {
      return new Uint8Array();
    }
    var psz = 0;
    // Skip and count leading '1's.
    var zeroes = 0;
    var length = 0;
    while (source[psz] === LEADER) {
      zeroes++;
      psz++;
    }
    // Allocate enough space in big-endian base256 representation.
    var size = (source.length - psz) * FACTOR + 1 >>> 0; // log(58) / log(256), rounded up.
    var b256 = new Uint8Array(size);
    // Process the characters.
    while (source[psz]) {
      // Decode character
      var carry = BASE_MAP[source.charCodeAt(psz)];
      // Invalid character
      if (carry === 255) {
        return;
      }
      var _i2 = 0;
      for (var it3 = size - 1; (carry !== 0 || _i2 < length) && it3 !== -1; it3--, _i2++) {
        carry += BASE * b256[it3] >>> 0;
        b256[it3] = carry % 256 >>> 0;
        carry = carry / 256 >>> 0;
      }
      if (carry !== 0) {
        throw new Error('Non-zero carry');
      }
      length = _i2;
      psz++;
    }
    // Skip leading zeroes in b256.
    var it4 = size - length;
    while (it4 !== size && b256[it4] === 0) {
      it4++;
    }
    var vch = new Uint8Array(zeroes + (size - it4));
    var j = zeroes;
    while (it4 !== size) {
      vch[j++] = b256[it4++];
    }
    return vch;
  }
  function decode(string) {
    var buffer = decodeUnsafe(string);
    if (buffer) {
      return buffer;
    }
    throw new Error('Non-base' + BASE + ' character');
  }
  return {
    encode: encode,
    decodeUnsafe: decodeUnsafe,
    decode: decode
  };
}
exports["default"] = base;

},{}],16:[function(require,module,exports){
'use strict';

exports.byteLength = byteLength;
exports.toByteArray = toByteArray;
exports.fromByteArray = fromByteArray;
var lookup = [];
var revLookup = [];
var Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array;
var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';
for (var i = 0, len = code.length; i < len; ++i) {
  lookup[i] = code[i];
  revLookup[code.charCodeAt(i)] = i;
}

// Support decoding URL-safe base64 strings, as Node.js does.
// See: https://en.wikipedia.org/wiki/Base64#URL_applications
revLookup['-'.charCodeAt(0)] = 62;
revLookup['_'.charCodeAt(0)] = 63;
function getLens(b64) {
  var len = b64.length;
  if (len % 4 > 0) {
    throw new Error('Invalid string. Length must be a multiple of 4');
  }

  // Trim off extra bytes after placeholder bytes are found
  // See: https://github.com/beatgammit/base64-js/issues/42
  var validLen = b64.indexOf('=');
  if (validLen === -1) validLen = len;
  var placeHoldersLen = validLen === len ? 0 : 4 - validLen % 4;
  return [validLen, placeHoldersLen];
}

// base64 is 4/3 + up to two characters of the original data
function byteLength(b64) {
  var lens = getLens(b64);
  var validLen = lens[0];
  var placeHoldersLen = lens[1];
  return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
}
function _byteLength(b64, validLen, placeHoldersLen) {
  return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
}
function toByteArray(b64) {
  var tmp;
  var lens = getLens(b64);
  var validLen = lens[0];
  var placeHoldersLen = lens[1];
  var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen));
  var curByte = 0;

  // if there are placeholders, only get up to the last complete 4 chars
  var len = placeHoldersLen > 0 ? validLen - 4 : validLen;
  var i;
  for (i = 0; i < len; i += 4) {
    tmp = revLookup[b64.charCodeAt(i)] << 18 | revLookup[b64.charCodeAt(i + 1)] << 12 | revLookup[b64.charCodeAt(i + 2)] << 6 | revLookup[b64.charCodeAt(i + 3)];
    arr[curByte++] = tmp >> 16 & 0xFF;
    arr[curByte++] = tmp >> 8 & 0xFF;
    arr[curByte++] = tmp & 0xFF;
  }
  if (placeHoldersLen === 2) {
    tmp = revLookup[b64.charCodeAt(i)] << 2 | revLookup[b64.charCodeAt(i + 1)] >> 4;
    arr[curByte++] = tmp & 0xFF;
  }
  if (placeHoldersLen === 1) {
    tmp = revLookup[b64.charCodeAt(i)] << 10 | revLookup[b64.charCodeAt(i + 1)] << 4 | revLookup[b64.charCodeAt(i + 2)] >> 2;
    arr[curByte++] = tmp >> 8 & 0xFF;
    arr[curByte++] = tmp & 0xFF;
  }
  return arr;
}
function tripletToBase64(num) {
  return lookup[num >> 18 & 0x3F] + lookup[num >> 12 & 0x3F] + lookup[num >> 6 & 0x3F] + lookup[num & 0x3F];
}
function encodeChunk(uint8, start, end) {
  var tmp;
  var output = [];
  for (var i = start; i < end; i += 3) {
    tmp = (uint8[i] << 16 & 0xFF0000) + (uint8[i + 1] << 8 & 0xFF00) + (uint8[i + 2] & 0xFF);
    output.push(tripletToBase64(tmp));
  }
  return output.join('');
}
function fromByteArray(uint8) {
  var tmp;
  var len = uint8.length;
  var extraBytes = len % 3; // if we have 1 byte left, pad 2 bytes
  var parts = [];
  var maxChunkLength = 16383; // must be multiple of 3

  // go through the array every three bytes, we'll deal with trailing stuff later
  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
    parts.push(encodeChunk(uint8, i, i + maxChunkLength > len2 ? len2 : i + maxChunkLength));
  }

  // pad the end with zeros, but make sure to not forget the extra bytes
  if (extraBytes === 1) {
    tmp = uint8[len - 1];
    parts.push(lookup[tmp >> 2] + lookup[tmp << 4 & 0x3F] + '==');
  } else if (extraBytes === 2) {
    tmp = (uint8[len - 2] << 8) + uint8[len - 1];
    parts.push(lookup[tmp >> 10] + lookup[tmp >> 4 & 0x3F] + lookup[tmp << 2 & 0x3F] + '=');
  }
  return parts.join('');
}

},{}],17:[function(require,module,exports){
'use strict';

function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.bech32m = exports.bech32 = void 0;
var ALPHABET = 'qpzry9x8gf2tvdw0s3jn54khce6mua7l';
var ALPHABET_MAP = {};
for (var z = 0; z < ALPHABET.length; z++) {
  var x = ALPHABET.charAt(z);
  ALPHABET_MAP[x] = z;
}
function polymodStep(pre) {
  var b = pre >> 25;
  return (pre & 0x1ffffff) << 5 ^ -(b >> 0 & 1) & 0x3b6a57b2 ^ -(b >> 1 & 1) & 0x26508e6d ^ -(b >> 2 & 1) & 0x1ea119fa ^ -(b >> 3 & 1) & 0x3d4233dd ^ -(b >> 4 & 1) & 0x2a1462b3;
}
function prefixChk(prefix) {
  var chk = 1;
  for (var i = 0; i < prefix.length; ++i) {
    var c = prefix.charCodeAt(i);
    if (c < 33 || c > 126) return 'Invalid prefix (' + prefix + ')';
    chk = polymodStep(chk) ^ c >> 5;
  }
  chk = polymodStep(chk);
  for (var _i = 0; _i < prefix.length; ++_i) {
    var v = prefix.charCodeAt(_i);
    chk = polymodStep(chk) ^ v & 0x1f;
  }
  return chk;
}
function convert(data, inBits, outBits, pad) {
  var value = 0;
  var bits = 0;
  var maxV = (1 << outBits) - 1;
  var result = [];
  for (var i = 0; i < data.length; ++i) {
    value = value << inBits | data[i];
    bits += inBits;
    while (bits >= outBits) {
      bits -= outBits;
      result.push(value >> bits & maxV);
    }
  }
  if (pad) {
    if (bits > 0) {
      result.push(value << outBits - bits & maxV);
    }
  } else {
    if (bits >= inBits) return 'Excess padding';
    if (value << outBits - bits & maxV) return 'Non-zero padding';
  }
  return result;
}
function toWords(bytes) {
  return convert(bytes, 8, 5, true);
}
function fromWordsUnsafe(words) {
  var res = convert(words, 5, 8, false);
  if (Array.isArray(res)) return res;
}
function fromWords(words) {
  var res = convert(words, 5, 8, false);
  if (Array.isArray(res)) return res;
  throw new Error(res);
}
function getLibraryFromEncoding(encoding) {
  var ENCODING_CONST;
  if (encoding === 'bech32') {
    ENCODING_CONST = 1;
  } else {
    ENCODING_CONST = 0x2bc830a3;
  }
  function encode(prefix, words, LIMIT) {
    LIMIT = LIMIT || 90;
    if (prefix.length + 7 + words.length > LIMIT) throw new TypeError('Exceeds length limit');
    prefix = prefix.toLowerCase();
    // determine chk mod
    var chk = prefixChk(prefix);
    if (typeof chk === 'string') throw new Error(chk);
    var result = prefix + '1';
    for (var i = 0; i < words.length; ++i) {
      var _x = words[i];
      if (_x >> 5 !== 0) throw new Error('Non 5-bit word');
      chk = polymodStep(chk) ^ _x;
      result += ALPHABET.charAt(_x);
    }
    for (var _i2 = 0; _i2 < 6; ++_i2) {
      chk = polymodStep(chk);
    }
    chk ^= ENCODING_CONST;
    for (var _i3 = 0; _i3 < 6; ++_i3) {
      var v = chk >> (5 - _i3) * 5 & 0x1f;
      result += ALPHABET.charAt(v);
    }
    return result;
  }
  function __decode(str, LIMIT) {
    LIMIT = LIMIT || 90;
    if (str.length < 8) return str + ' too short';
    if (str.length > LIMIT) return 'Exceeds length limit';
    // don't allow mixed case
    var lowered = str.toLowerCase();
    var uppered = str.toUpperCase();
    if (str !== lowered && str !== uppered) return 'Mixed-case string ' + str;
    str = lowered;
    var split = str.lastIndexOf('1');
    if (split === -1) return 'No separator character for ' + str;
    if (split === 0) return 'Missing prefix for ' + str;
    var prefix = str.slice(0, split);
    var wordChars = str.slice(split + 1);
    if (wordChars.length < 6) return 'Data too short';
    var chk = prefixChk(prefix);
    if (typeof chk === 'string') return chk;
    var words = [];
    for (var i = 0; i < wordChars.length; ++i) {
      var c = wordChars.charAt(i);
      var v = ALPHABET_MAP[c];
      if (v === undefined) return 'Unknown character ' + c;
      chk = polymodStep(chk) ^ v;
      // not in the checksum?
      if (i + 6 >= wordChars.length) continue;
      words.push(v);
    }
    if (chk !== ENCODING_CONST) return 'Invalid checksum for ' + str;
    return {
      prefix: prefix,
      words: words
    };
  }
  function decodeUnsafe(str, LIMIT) {
    var res = __decode(str, LIMIT);
    if (_typeof(res) === 'object') return res;
  }
  function decode(str, LIMIT) {
    var res = __decode(str, LIMIT);
    if (_typeof(res) === 'object') return res;
    throw new Error(res);
  }
  return {
    decodeUnsafe: decodeUnsafe,
    decode: decode,
    encode: encode,
    toWords: toWords,
    fromWordsUnsafe: fromWordsUnsafe,
    fromWords: fromWords
  };
}
exports.bech32 = getLibraryFromEncoding('bech32');
exports.bech32m = getLibraryFromEncoding('bech32m');

},{}],18:[function(require,module,exports){
(function (Buffer){(function (){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.readInt64 = exports.readInt32 = exports.readInt16 = exports.readInt8 = exports.writeInt64 = exports.writeInt32 = exports.writeInt16 = exports.writeInt8 = exports.readUInt64 = exports.readUInt32 = exports.readUInt16 = exports.readUInt8 = exports.writeUInt64 = exports.writeUInt32 = exports.writeUInt16 = exports.writeUInt8 = exports.compare = exports.fromBase64 = exports.toBase64 = exports.fromHex = exports.toHex = exports.concat = exports.fromUtf8 = exports.toUtf8 = void 0;
function toUtf8(bytes) {
  return Buffer.from(bytes || []).toString();
}
exports.toUtf8 = toUtf8;
function fromUtf8(s) {
  return Uint8Array.from(Buffer.from(s || "", "utf8"));
}
exports.fromUtf8 = fromUtf8;
function concat(arrays) {
  return Uint8Array.from(Buffer.concat(arrays));
}
exports.concat = concat;
function toHex(bytes) {
  return Buffer.from(bytes || []).toString("hex");
}
exports.toHex = toHex;
function fromHex(hexString) {
  return Uint8Array.from(Buffer.from(hexString || "", "hex"));
}
exports.fromHex = fromHex;
function toBase64(bytes) {
  return Buffer.from(bytes).toString("base64");
}
exports.toBase64 = toBase64;
function fromBase64(base64) {
  return Uint8Array.from(Buffer.from(base64 || "", "base64"));
}
exports.fromBase64 = fromBase64;
function compare(v1, v2) {
  return Buffer.from(v1).compare(Buffer.from(v2));
}
exports.compare = compare;
function writeUInt8(buffer, offset, value) {
  if (offset + 1 > buffer.length) {
    throw new Error("Offset is outside the bounds of Uint8Array");
  }
  var buf = Buffer.alloc(1);
  buf.writeUInt8(value, 0);
  buffer.set(Uint8Array.from(buf), offset);
  return offset + 1;
}
exports.writeUInt8 = writeUInt8;
function writeUInt16(buffer, offset, value, littleEndian) {
  if (offset + 2 > buffer.length) {
    throw new Error("Offset is outside the bounds of Uint8Array");
  }
  littleEndian = littleEndian.toUpperCase();
  var buf = Buffer.alloc(2);
  if (littleEndian === "LE") {
    buf.writeUInt16LE(value, 0);
  } else {
    buf.writeUInt16BE(value, 0);
  }
  buffer.set(Uint8Array.from(buf), offset);
  return offset + 2;
}
exports.writeUInt16 = writeUInt16;
function writeUInt32(buffer, offset, value, littleEndian) {
  if (offset + 4 > buffer.length) {
    throw new Error("Offset is outside the bounds of Uint8Array");
  }
  littleEndian = littleEndian.toUpperCase();
  var buf = Buffer.alloc(4);
  if (littleEndian === "LE") {
    buf.writeUInt32LE(value, 0);
  } else {
    buf.writeUInt32BE(value, 0);
  }
  buffer.set(Uint8Array.from(buf), offset);
  return offset + 4;
}
exports.writeUInt32 = writeUInt32;
function writeUInt64(buffer, offset, value, littleEndian) {
  if (offset + 8 > buffer.length) {
    throw new Error("Offset is outside the bounds of Uint8Array");
  }
  littleEndian = littleEndian.toUpperCase();
  var buf = Buffer.alloc(8);
  if (value > 0xffffffffffffffffn) {
    throw new Error("The value of \"value\" is out of range. It must be >= 0 and <= ".concat(0xffffffffffffffffn, ". Received ", value));
  }
  if (littleEndian === "LE") {
    buf.writeBigUInt64LE(value, 0);
  } else {
    buf.writeBigUInt64BE(value, 0);
  }
  buffer.set(Uint8Array.from(buf), offset);
  return offset + 8;
}
exports.writeUInt64 = writeUInt64;
function readUInt8(buffer, offset) {
  if (offset + 1 > buffer.length) {
    throw new Error("Offset is outside the bounds of Uint8Array");
  }
  var buf = Buffer.from(buffer);
  return buf.readUInt8(offset);
}
exports.readUInt8 = readUInt8;
function readUInt16(buffer, offset, littleEndian) {
  if (offset + 2 > buffer.length) {
    throw new Error("Offset is outside the bounds of Uint8Array");
  }
  littleEndian = littleEndian.toUpperCase();
  var buf = Buffer.from(buffer);
  if (littleEndian === "LE") {
    return buf.readUInt16LE(offset);
  } else {
    return buf.readUInt16BE(offset);
  }
}
exports.readUInt16 = readUInt16;
function readUInt32(buffer, offset, littleEndian) {
  if (offset + 4 > buffer.length) {
    throw new Error("Offset is outside the bounds of Uint8Array");
  }
  littleEndian = littleEndian.toUpperCase();
  var buf = Buffer.from(buffer);
  if (littleEndian === "LE") {
    return buf.readUInt32LE(offset);
  } else {
    return buf.readUInt32BE(offset);
  }
}
exports.readUInt32 = readUInt32;
function readUInt64(buffer, offset, littleEndian) {
  if (offset + 8 > buffer.length) {
    throw new Error("Offset is outside the bounds of Uint8Array");
  }
  littleEndian = littleEndian.toUpperCase();
  var buf = Buffer.from(buffer);
  if (littleEndian === "LE") {
    return buf.readBigUInt64LE(offset);
  } else {
    return buf.readBigUInt64BE(offset);
  }
}
exports.readUInt64 = readUInt64;
function writeInt8(buffer, offset, value) {
  if (offset + 1 > buffer.length) {
    throw new Error("Offset is outside the bounds of Uint8Array");
  }
  var buf = Buffer.alloc(1);
  buf.writeInt8(value, 0);
  buffer.set(Uint8Array.from(buf), offset);
  return offset + 1;
}
exports.writeInt8 = writeInt8;
function writeInt16(buffer, offset, value, littleEndian) {
  if (offset + 2 > buffer.length) {
    throw new Error("Offset is outside the bounds of Uint8Array");
  }
  littleEndian = littleEndian.toUpperCase();
  var buf = Buffer.alloc(2);
  if (littleEndian === "LE") {
    buf.writeInt16LE(value, 0);
  } else {
    buf.writeInt16BE(value, 0);
  }
  buffer.set(Uint8Array.from(buf), offset);
  return offset + 2;
}
exports.writeInt16 = writeInt16;
function writeInt32(buffer, offset, value, littleEndian) {
  if (offset + 4 > buffer.length) {
    throw new Error("Offset is outside the bounds of Uint8Array");
  }
  littleEndian = littleEndian.toUpperCase();
  var buf = Buffer.alloc(4);
  if (littleEndian === "LE") {
    buf.writeInt32LE(value, 0);
  } else {
    buf.writeInt32BE(value, 0);
  }
  buffer.set(Uint8Array.from(buf), offset);
  return offset + 4;
}
exports.writeInt32 = writeInt32;
function writeInt64(buffer, offset, value, littleEndian) {
  if (offset + 8 > buffer.length) {
    throw new Error("Offset is outside the bounds of Uint8Array");
  }
  if (value > 0x7fffffffffffffffn || value < -0x8000000000000000n) {
    throw new Error("The value of \"value\" is out of range. It must be >= ".concat(-0x8000000000000000n, " and <= ", 0x7fffffffffffffffn, ". Received ").concat(value));
  }
  littleEndian = littleEndian.toUpperCase();
  var buf = Buffer.alloc(8);
  if (littleEndian === "LE") {
    buf.writeBigInt64LE(value, 0);
  } else {
    buf.writeBigInt64BE(value, 0);
  }
  buffer.set(Uint8Array.from(buf), offset);
  return offset + 8;
}
exports.writeInt64 = writeInt64;
function readInt8(buffer, offset) {
  if (offset + 1 > buffer.length) {
    throw new Error("Offset is outside the bounds of Uint8Array");
  }
  var buf = Buffer.from(buffer);
  return buf.readInt8(offset);
}
exports.readInt8 = readInt8;
function readInt16(buffer, offset, littleEndian) {
  if (offset + 2 > buffer.length) {
    throw new Error("Offset is outside the bounds of Uint8Array");
  }
  littleEndian = littleEndian.toUpperCase();
  if (littleEndian === "LE") {
    return Buffer.from(buffer).readInt16LE(offset);
  } else {
    return Buffer.from(buffer).readInt16BE(offset);
  }
}
exports.readInt16 = readInt16;
function readInt32(buffer, offset, littleEndian) {
  if (offset + 4 > buffer.length) {
    throw new Error("Offset is outside the bounds of Uint8Array");
  }
  littleEndian = littleEndian.toUpperCase();
  if (littleEndian === "LE") {
    return Buffer.from(buffer).readInt32LE(offset);
  } else {
    return Buffer.from(buffer).readInt32BE(offset);
  }
}
exports.readInt32 = readInt32;
function readInt64(buffer, offset, littleEndian) {
  if (offset + 8 > buffer.length) {
    throw new Error("Offset is outside the bounds of Uint8Array");
  }
  littleEndian = littleEndian.toUpperCase();
  if (littleEndian === "LE") {
    return Buffer.from(buffer).readBigInt64LE(offset);
  } else {
    return Buffer.from(buffer).readBigInt64BE(offset);
  }
}
exports.readInt64 = readInt64;

}).call(this)}).call(this,require("buffer").Buffer)
},{"buffer":"buffer"}],19:[function(require,module,exports){
'use strict';

function _createForOfIteratorHelper(r, e) { var t = "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (!t) { if (Array.isArray(r) || (t = _unsupportedIterableToArray(r)) || e && r && "number" == typeof r.length) { t && (r = t); var _n = 0, F = function F() {}; return { s: F, n: function n() { return _n >= r.length ? { done: !0 } : { done: !1, value: r[_n++] }; }, e: function e(r) { throw r; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var o, a = !0, u = !1; return { s: function s() { t = t.call(r); }, n: function n() { var r = t.next(); return a = r.done, r; }, e: function e(r) { u = !0, o = r; }, f: function f() { try { a || null == t["return"] || t["return"](); } finally { if (u) throw o; } } }; }
function _unsupportedIterableToArray(r, a) { if (r) { if ("string" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }
function _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }
var __importStar = void 0 && (void 0).__importStar || function (mod) {
  if (mod && mod.__esModule) return mod;
  var result = {};
  if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
  result['default'] = mod;
  return result;
};
Object.defineProperty(exports, '__esModule', {
  value: true
});
var index_js_1 = require('../parser/index.cjs');
var tools = __importStar(require('uint8array-tools'));
function combine(psbts) {
  var self = psbts[0];
  var selfKeyVals = index_js_1.psbtToKeyVals(self);
  var others = psbts.slice(1);
  if (others.length === 0) throw new Error('Combine: Nothing to combine');
  var selfTx = getTx(self);
  if (selfTx === undefined) {
    throw new Error('Combine: Self missing transaction');
  }
  var selfGlobalSet = getKeySet(selfKeyVals.globalKeyVals);
  var selfInputSets = selfKeyVals.inputKeyVals.map(getKeySet);
  var selfOutputSets = selfKeyVals.outputKeyVals.map(getKeySet);
  var _iterator = _createForOfIteratorHelper(others),
    _step;
  try {
    var _loop = function _loop() {
      var other = _step.value;
      var otherTx = getTx(other);
      if (otherTx === undefined || tools.compare(otherTx.toBuffer(), selfTx.toBuffer()) !== 0) {
        throw new Error('Combine: One of the Psbts does not have the same transaction.');
      }
      var otherKeyVals = index_js_1.psbtToKeyVals(other);
      var otherGlobalSet = getKeySet(otherKeyVals.globalKeyVals);
      otherGlobalSet.forEach(keyPusher(selfGlobalSet, selfKeyVals.globalKeyVals, otherKeyVals.globalKeyVals));
      var otherInputSets = otherKeyVals.inputKeyVals.map(getKeySet);
      otherInputSets.forEach(function (inputSet, idx) {
        return inputSet.forEach(keyPusher(selfInputSets[idx], selfKeyVals.inputKeyVals[idx], otherKeyVals.inputKeyVals[idx]));
      });
      var otherOutputSets = otherKeyVals.outputKeyVals.map(getKeySet);
      otherOutputSets.forEach(function (outputSet, idx) {
        return outputSet.forEach(keyPusher(selfOutputSets[idx], selfKeyVals.outputKeyVals[idx], otherKeyVals.outputKeyVals[idx]));
      });
    };
    for (_iterator.s(); !(_step = _iterator.n()).done;) {
      _loop();
    }
  } catch (err) {
    _iterator.e(err);
  } finally {
    _iterator.f();
  }
  return index_js_1.psbtFromKeyVals(selfTx, {
    globalMapKeyVals: selfKeyVals.globalKeyVals,
    inputKeyVals: selfKeyVals.inputKeyVals,
    outputKeyVals: selfKeyVals.outputKeyVals
  });
}
exports.combine = combine;
function keyPusher(selfSet, selfKeyVals, otherKeyVals) {
  return function (key) {
    if (selfSet.has(key)) return;
    var newKv = otherKeyVals.filter(function (kv) {
      return tools.toHex(kv.key) === key;
    })[0];
    selfKeyVals.push(newKv);
    selfSet.add(key);
  };
}
function getTx(psbt) {
  return psbt.globalMap.unsignedTx;
}
function getKeySet(keyVals) {
  var set = new Set();
  keyVals.forEach(function (keyVal) {
    var hex = tools.toHex(keyVal.key);
    if (set.has(hex)) throw new Error('Combine: KeyValue Map keys should be unique');
    set.add(hex);
  });
  return set;
}

},{"../parser/index.cjs":43,"uint8array-tools":18}],20:[function(require,module,exports){
'use strict';

function _createForOfIteratorHelper(r, e) { var t = "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (!t) { if (Array.isArray(r) || (t = _unsupportedIterableToArray(r)) || e && r && "number" == typeof r.length) { t && (r = t); var _n = 0, F = function F() {}; return { s: F, n: function n() { return _n >= r.length ? { done: !0 } : { done: !1, value: r[_n++] }; }, e: function e(r) { throw r; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var o, a = !0, u = !1; return { s: function s() { t = t.call(r); }, n: function n() { var r = t.next(); return a = r.done, r; }, e: function e(r) { u = !0, o = r; }, f: function f() { try { a || null == t["return"] || t["return"](); } finally { if (u) throw o; } } }; }
function _toConsumableArray(r) { return _arrayWithoutHoles(r) || _iterableToArray(r) || _unsupportedIterableToArray(r) || _nonIterableSpread(); }
function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _unsupportedIterableToArray(r, a) { if (r) { if ("string" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }
function _iterableToArray(r) { if ("undefined" != typeof Symbol && null != r[Symbol.iterator] || null != r["@@iterator"]) return Array.from(r); }
function _arrayWithoutHoles(r) { if (Array.isArray(r)) return _arrayLikeToArray(r); }
function _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }
var __importStar = void 0 && (void 0).__importStar || function (mod) {
  if (mod && mod.__esModule) return mod;
  var result = {};
  if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
  result['default'] = mod;
  return result;
};
Object.defineProperty(exports, '__esModule', {
  value: true
});
var typeFields_js_1 = require('../../typeFields.cjs');
var tools = __importStar(require('uint8array-tools'));
var range = function range(n) {
  return _toConsumableArray(Array(n).keys());
};
function decode(keyVal) {
  if (keyVal.key[0] !== typeFields_js_1.GlobalTypes.GLOBAL_XPUB) {
    throw new Error('Decode Error: could not decode globalXpub with key 0x' + tools.toHex(keyVal.key));
  }
  if (keyVal.key.length !== 79 || ![2, 3].includes(keyVal.key[46])) {
    throw new Error('Decode Error: globalXpub has invalid extended pubkey in key 0x' + tools.toHex(keyVal.key));
  }
  if (keyVal.value.length / 4 % 1 !== 0) {
    throw new Error('Decode Error: Global GLOBAL_XPUB value length should be multiple of 4');
  }
  var extendedPubkey = keyVal.key.slice(1);
  var data = {
    masterFingerprint: keyVal.value.slice(0, 4),
    extendedPubkey: extendedPubkey,
    path: 'm'
  };
  var _iterator = _createForOfIteratorHelper(range(keyVal.value.length / 4 - 1)),
    _step;
  try {
    for (_iterator.s(); !(_step = _iterator.n()).done;) {
      var i = _step.value;
      var val = tools.readUInt32(keyVal.value, i * 4 + 4, 'LE');
      var isHard = !!(val & 0x80000000);
      var idx = val & 0x7fffffff;
      data.path += '/' + idx.toString(10) + (isHard ? "'" : '');
    }
  } catch (err) {
    _iterator.e(err);
  } finally {
    _iterator.f();
  }
  return data;
}
exports.decode = decode;
function encode(data) {
  var head = new Uint8Array([typeFields_js_1.GlobalTypes.GLOBAL_XPUB]);
  var key = tools.concat([head, data.extendedPubkey]);
  var splitPath = data.path.split('/');
  var value = new Uint8Array(splitPath.length * 4);
  value.set(data.masterFingerprint, 0);
  var offset = 4;
  splitPath.slice(1).forEach(function (level) {
    var isHard = level.slice(-1) === "'";
    var num = 0x7fffffff & parseInt(isHard ? level.slice(0, -1) : level, 10);
    if (isHard) num += 0x80000000;
    tools.writeUInt32(value, offset, num, 'LE');
    offset += 4;
  });
  return {
    key: key,
    value: value
  };
}
exports.encode = encode;
exports.expected = '{ masterFingerprint: Uint8Array; extendedPubkey: Uint8Array; path: string; }';
function check(data) {
  var epk = data.extendedPubkey;
  var mfp = data.masterFingerprint;
  var p = data.path;
  return epk instanceof Uint8Array && epk.length === 78 && [2, 3].indexOf(epk[45]) > -1 && mfp instanceof Uint8Array && mfp.length === 4 && typeof p === 'string' && !!p.match(/^m(\/\d+'?)*$/);
}
exports.check = check;
function canAddToArray(array, item, dupeSet) {
  var dupeString = tools.toHex(item.extendedPubkey);
  if (dupeSet.has(dupeString)) return false;
  dupeSet.add(dupeString);
  return array.filter(function (v) {
    return tools.compare(v.extendedPubkey, item.extendedPubkey);
  }).length === 0;
}
exports.canAddToArray = canAddToArray;

},{"../../typeFields.cjs":46,"uint8array-tools":18}],21:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});
var typeFields_js_1 = require('../../typeFields.cjs');
function encode(data) {
  return {
    key: new Uint8Array([typeFields_js_1.GlobalTypes.UNSIGNED_TX]),
    value: data.toBuffer()
  };
}
exports.encode = encode;

},{"../../typeFields.cjs":46}],22:[function(require,module,exports){
'use strict';

var __importStar = void 0 && (void 0).__importStar || function (mod) {
  if (mod && mod.__esModule) return mod;
  var result = {};
  if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
  result['default'] = mod;
  return result;
};
Object.defineProperty(exports, '__esModule', {
  value: true
});
var typeFields_js_1 = require('../typeFields.cjs');
var globalXpub = __importStar(require('./global/globalXpub.cjs'));
var unsignedTx = __importStar(require('./global/unsignedTx.cjs'));
var finalScriptSig = __importStar(require('./input/finalScriptSig.cjs'));
var finalScriptWitness = __importStar(require('./input/finalScriptWitness.cjs'));
var nonWitnessUtxo = __importStar(require('./input/nonWitnessUtxo.cjs'));
var partialSig = __importStar(require('./input/partialSig.cjs'));
var porCommitment = __importStar(require('./input/porCommitment.cjs'));
var sighashType = __importStar(require('./input/sighashType.cjs'));
var tapKeySig = __importStar(require('./input/tapKeySig.cjs'));
var tapLeafScript = __importStar(require('./input/tapLeafScript.cjs'));
var tapMerkleRoot = __importStar(require('./input/tapMerkleRoot.cjs'));
var tapScriptSig = __importStar(require('./input/tapScriptSig.cjs'));
var witnessUtxo = __importStar(require('./input/witnessUtxo.cjs'));
var tapTree = __importStar(require('./output/tapTree.cjs'));
var bip32Derivation = __importStar(require('./shared/bip32Derivation.cjs'));
var checkPubkey = __importStar(require('./shared/checkPubkey.cjs'));
var redeemScript = __importStar(require('./shared/redeemScript.cjs'));
var tapBip32Derivation = __importStar(require('./shared/tapBip32Derivation.cjs'));
var tapInternalKey = __importStar(require('./shared/tapInternalKey.cjs'));
var witnessScript = __importStar(require('./shared/witnessScript.cjs'));
var globals = {
  unsignedTx: unsignedTx,
  globalXpub: globalXpub,
  // pass an Array of key bytes that require pubkey beside the key
  checkPubkey: checkPubkey.makeChecker([])
};
exports.globals = globals;
var inputs = {
  nonWitnessUtxo: nonWitnessUtxo,
  partialSig: partialSig,
  sighashType: sighashType,
  finalScriptSig: finalScriptSig,
  finalScriptWitness: finalScriptWitness,
  porCommitment: porCommitment,
  witnessUtxo: witnessUtxo,
  bip32Derivation: bip32Derivation.makeConverter(typeFields_js_1.InputTypes.BIP32_DERIVATION),
  redeemScript: redeemScript.makeConverter(typeFields_js_1.InputTypes.REDEEM_SCRIPT),
  witnessScript: witnessScript.makeConverter(typeFields_js_1.InputTypes.WITNESS_SCRIPT),
  checkPubkey: checkPubkey.makeChecker([typeFields_js_1.InputTypes.PARTIAL_SIG, typeFields_js_1.InputTypes.BIP32_DERIVATION]),
  tapKeySig: tapKeySig,
  tapScriptSig: tapScriptSig,
  tapLeafScript: tapLeafScript,
  tapBip32Derivation: tapBip32Derivation.makeConverter(typeFields_js_1.InputTypes.TAP_BIP32_DERIVATION),
  tapInternalKey: tapInternalKey.makeConverter(typeFields_js_1.InputTypes.TAP_INTERNAL_KEY),
  tapMerkleRoot: tapMerkleRoot
};
exports.inputs = inputs;
var outputs = {
  bip32Derivation: bip32Derivation.makeConverter(typeFields_js_1.OutputTypes.BIP32_DERIVATION),
  redeemScript: redeemScript.makeConverter(typeFields_js_1.OutputTypes.REDEEM_SCRIPT),
  witnessScript: witnessScript.makeConverter(typeFields_js_1.OutputTypes.WITNESS_SCRIPT),
  checkPubkey: checkPubkey.makeChecker([typeFields_js_1.OutputTypes.BIP32_DERIVATION]),
  tapBip32Derivation: tapBip32Derivation.makeConverter(typeFields_js_1.OutputTypes.TAP_BIP32_DERIVATION),
  tapTree: tapTree,
  tapInternalKey: tapInternalKey.makeConverter(typeFields_js_1.OutputTypes.TAP_INTERNAL_KEY)
};
exports.outputs = outputs;

},{"../typeFields.cjs":46,"./global/globalXpub.cjs":20,"./global/unsignedTx.cjs":21,"./input/finalScriptSig.cjs":23,"./input/finalScriptWitness.cjs":24,"./input/nonWitnessUtxo.cjs":25,"./input/partialSig.cjs":26,"./input/porCommitment.cjs":27,"./input/sighashType.cjs":28,"./input/tapKeySig.cjs":29,"./input/tapLeafScript.cjs":30,"./input/tapMerkleRoot.cjs":31,"./input/tapScriptSig.cjs":32,"./input/witnessUtxo.cjs":33,"./output/tapTree.cjs":34,"./shared/bip32Derivation.cjs":35,"./shared/checkPubkey.cjs":36,"./shared/redeemScript.cjs":37,"./shared/tapBip32Derivation.cjs":38,"./shared/tapInternalKey.cjs":39,"./shared/witnessScript.cjs":40}],23:[function(require,module,exports){
'use strict';

var __importStar = void 0 && (void 0).__importStar || function (mod) {
  if (mod && mod.__esModule) return mod;
  var result = {};
  if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
  result['default'] = mod;
  return result;
};
Object.defineProperty(exports, '__esModule', {
  value: true
});
var typeFields_js_1 = require('../../typeFields.cjs');
var tools = __importStar(require('uint8array-tools'));
function decode(keyVal) {
  if (keyVal.key[0] !== typeFields_js_1.InputTypes.FINAL_SCRIPTSIG) {
    throw new Error('Decode Error: could not decode finalScriptSig with key 0x' + tools.toHex(keyVal.key));
  }
  return keyVal.value;
}
exports.decode = decode;
function encode(data) {
  var key = new Uint8Array([typeFields_js_1.InputTypes.FINAL_SCRIPTSIG]);
  return {
    key: key,
    value: data
  };
}
exports.encode = encode;
exports.expected = 'Uint8Array';
function check(data) {
  return data instanceof Uint8Array;
}
exports.check = check;
function canAdd(currentData, newData) {
  return !!currentData && !!newData && currentData.finalScriptSig === undefined;
}
exports.canAdd = canAdd;

},{"../../typeFields.cjs":46,"uint8array-tools":18}],24:[function(require,module,exports){
'use strict';

var __importStar = void 0 && (void 0).__importStar || function (mod) {
  if (mod && mod.__esModule) return mod;
  var result = {};
  if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
  result['default'] = mod;
  return result;
};
Object.defineProperty(exports, '__esModule', {
  value: true
});
var typeFields_js_1 = require('../../typeFields.cjs');
var tools = __importStar(require('uint8array-tools'));
function decode(keyVal) {
  if (keyVal.key[0] !== typeFields_js_1.InputTypes.FINAL_SCRIPTWITNESS) {
    throw new Error('Decode Error: could not decode finalScriptWitness with key 0x' + tools.toHex(keyVal.key));
  }
  return keyVal.value;
}
exports.decode = decode;
function encode(data) {
  var key = new Uint8Array([typeFields_js_1.InputTypes.FINAL_SCRIPTWITNESS]);
  return {
    key: key,
    value: data
  };
}
exports.encode = encode;
exports.expected = 'Uint8Array';
function check(data) {
  return data instanceof Uint8Array;
}
exports.check = check;
function canAdd(currentData, newData) {
  return !!currentData && !!newData && currentData.finalScriptWitness === undefined;
}
exports.canAdd = canAdd;

},{"../../typeFields.cjs":46,"uint8array-tools":18}],25:[function(require,module,exports){
'use strict';

var __importStar = void 0 && (void 0).__importStar || function (mod) {
  if (mod && mod.__esModule) return mod;
  var result = {};
  if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
  result['default'] = mod;
  return result;
};
Object.defineProperty(exports, '__esModule', {
  value: true
});
var typeFields_js_1 = require('../../typeFields.cjs');
var tools = __importStar(require('uint8array-tools'));
function decode(keyVal) {
  if (keyVal.key[0] !== typeFields_js_1.InputTypes.NON_WITNESS_UTXO) {
    throw new Error('Decode Error: could not decode nonWitnessUtxo with key 0x' + tools.toHex(keyVal.key));
  }
  return keyVal.value;
}
exports.decode = decode;
function encode(data) {
  return {
    key: new Uint8Array([typeFields_js_1.InputTypes.NON_WITNESS_UTXO]),
    value: data
  };
}
exports.encode = encode;
exports.expected = 'Uint8Array';
function check(data) {
  return data instanceof Uint8Array;
}
exports.check = check;
function canAdd(currentData, newData) {
  return !!currentData && !!newData && currentData.nonWitnessUtxo === undefined;
}
exports.canAdd = canAdd;

},{"../../typeFields.cjs":46,"uint8array-tools":18}],26:[function(require,module,exports){
'use strict';

var __importStar = void 0 && (void 0).__importStar || function (mod) {
  if (mod && mod.__esModule) return mod;
  var result = {};
  if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
  result['default'] = mod;
  return result;
};
Object.defineProperty(exports, '__esModule', {
  value: true
});
var typeFields_js_1 = require('../../typeFields.cjs');
var tools = __importStar(require('uint8array-tools'));
function decode(keyVal) {
  if (keyVal.key[0] !== typeFields_js_1.InputTypes.PARTIAL_SIG) {
    throw new Error('Decode Error: could not decode partialSig with key 0x' + tools.toHex(keyVal.key));
  }
  if (!(keyVal.key.length === 34 || keyVal.key.length === 66) || ![2, 3, 4].includes(keyVal.key[1])) {
    throw new Error('Decode Error: partialSig has invalid pubkey in key 0x' + tools.toHex(keyVal.key));
  }
  var pubkey = keyVal.key.slice(1);
  return {
    pubkey: pubkey,
    signature: keyVal.value
  };
}
exports.decode = decode;
function encode(pSig) {
  var head = new Uint8Array([typeFields_js_1.InputTypes.PARTIAL_SIG]);
  return {
    key: tools.concat([head, pSig.pubkey]),
    value: pSig.signature
  };
}
exports.encode = encode;
exports.expected = '{ pubkey: Uint8Array; signature: Uint8Array; }';
function check(data) {
  return data.pubkey instanceof Uint8Array && data.signature instanceof Uint8Array && [33, 65].includes(data.pubkey.length) && [2, 3, 4].includes(data.pubkey[0]) && isDerSigWithSighash(data.signature);
}
exports.check = check;
function isDerSigWithSighash(buf) {
  if (!(buf instanceof Uint8Array) || buf.length < 9) return false;
  if (buf[0] !== 0x30) return false;
  if (buf.length !== buf[1] + 3) return false;
  if (buf[2] !== 0x02) return false;
  var rLen = buf[3];
  if (rLen > 33 || rLen < 1) return false;
  if (buf[3 + rLen + 1] !== 0x02) return false;
  var sLen = buf[3 + rLen + 2];
  if (sLen > 33 || sLen < 1) return false;
  if (buf.length !== 3 + rLen + 2 + sLen + 2) return false;
  return true;
}
function canAddToArray(array, item, dupeSet) {
  var dupeString = tools.toHex(item.pubkey);
  if (dupeSet.has(dupeString)) return false;
  dupeSet.add(dupeString);
  return array.filter(function (v) {
    return tools.compare(v.pubkey, item.pubkey) === 0;
  }).length === 0;
}
exports.canAddToArray = canAddToArray;

},{"../../typeFields.cjs":46,"uint8array-tools":18}],27:[function(require,module,exports){
'use strict';

var __importStar = void 0 && (void 0).__importStar || function (mod) {
  if (mod && mod.__esModule) return mod;
  var result = {};
  if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
  result['default'] = mod;
  return result;
};
Object.defineProperty(exports, '__esModule', {
  value: true
});
var typeFields_js_1 = require('../../typeFields.cjs');
var tools = __importStar(require('uint8array-tools'));
function decode(keyVal) {
  if (keyVal.key[0] !== typeFields_js_1.InputTypes.POR_COMMITMENT) {
    throw new Error('Decode Error: could not decode porCommitment with key 0x' + tools.toHex(keyVal.key));
  }
  return tools.toUtf8(keyVal.value);
}
exports.decode = decode;
function encode(data) {
  var key = new Uint8Array([typeFields_js_1.InputTypes.POR_COMMITMENT]);
  return {
    key: key,
    value: tools.fromUtf8(data)
  };
}
exports.encode = encode;
exports.expected = 'string';
function check(data) {
  return typeof data === 'string';
}
exports.check = check;
function canAdd(currentData, newData) {
  return !!currentData && !!newData && currentData.porCommitment === undefined;
}
exports.canAdd = canAdd;

},{"../../typeFields.cjs":46,"uint8array-tools":18}],28:[function(require,module,exports){
'use strict';

var __importStar = void 0 && (void 0).__importStar || function (mod) {
  if (mod && mod.__esModule) return mod;
  var result = {};
  if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
  result['default'] = mod;
  return result;
};
Object.defineProperty(exports, '__esModule', {
  value: true
});
var typeFields_js_1 = require('../../typeFields.cjs');
var tools = __importStar(require('uint8array-tools'));
function decode(keyVal) {
  if (keyVal.key[0] !== typeFields_js_1.InputTypes.SIGHASH_TYPE) {
    throw new Error('Decode Error: could not decode sighashType with key 0x' + tools.toHex(keyVal.key));
  }
  return Number(tools.readUInt32(keyVal.value, 0, 'LE'));
}
exports.decode = decode;
function encode(data) {
  var key = Uint8Array.from([typeFields_js_1.InputTypes.SIGHASH_TYPE]);
  var value = new Uint8Array(4);
  tools.writeUInt32(value, 0, data, 'LE');
  return {
    key: key,
    value: value
  };
}
exports.encode = encode;
exports.expected = 'number';
function check(data) {
  return typeof data === 'number';
}
exports.check = check;
function canAdd(currentData, newData) {
  return !!currentData && !!newData && currentData.sighashType === undefined;
}
exports.canAdd = canAdd;

},{"../../typeFields.cjs":46,"uint8array-tools":18}],29:[function(require,module,exports){
'use strict';

var __importStar = void 0 && (void 0).__importStar || function (mod) {
  if (mod && mod.__esModule) return mod;
  var result = {};
  if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
  result['default'] = mod;
  return result;
};
Object.defineProperty(exports, '__esModule', {
  value: true
});
var typeFields_js_1 = require('../../typeFields.cjs');
var tools = __importStar(require('uint8array-tools'));
function decode(keyVal) {
  if (keyVal.key[0] !== typeFields_js_1.InputTypes.TAP_KEY_SIG || keyVal.key.length !== 1) {
    throw new Error('Decode Error: could not decode tapKeySig with key 0x' + tools.toHex(keyVal.key));
  }
  if (!check(keyVal.value)) {
    throw new Error('Decode Error: tapKeySig not a valid 64-65-byte BIP340 signature');
  }
  return keyVal.value;
}
exports.decode = decode;
function encode(value) {
  var key = Uint8Array.from([typeFields_js_1.InputTypes.TAP_KEY_SIG]);
  return {
    key: key,
    value: value
  };
}
exports.encode = encode;
exports.expected = 'Uint8Array';
function check(data) {
  return data instanceof Uint8Array && (data.length === 64 || data.length === 65);
}
exports.check = check;
function canAdd(currentData, newData) {
  return !!currentData && !!newData && currentData.tapKeySig === undefined;
}
exports.canAdd = canAdd;

},{"../../typeFields.cjs":46,"uint8array-tools":18}],30:[function(require,module,exports){
'use strict';

var __importStar = void 0 && (void 0).__importStar || function (mod) {
  if (mod && mod.__esModule) return mod;
  var result = {};
  if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
  result['default'] = mod;
  return result;
};
Object.defineProperty(exports, '__esModule', {
  value: true
});
var typeFields_js_1 = require('../../typeFields.cjs');
var tools = __importStar(require('uint8array-tools'));
function decode(keyVal) {
  if (keyVal.key[0] !== typeFields_js_1.InputTypes.TAP_LEAF_SCRIPT) {
    throw new Error('Decode Error: could not decode tapLeafScript with key 0x' + tools.toHex(keyVal.key));
  }
  if ((keyVal.key.length - 2) % 32 !== 0) {
    throw new Error('Decode Error: tapLeafScript has invalid control block in key 0x' + tools.toHex(keyVal.key));
  }
  var leafVersion = keyVal.value[keyVal.value.length - 1];
  if ((keyVal.key[1] & 0xfe) !== leafVersion) {
    throw new Error('Decode Error: tapLeafScript bad leaf version in key 0x' + tools.toHex(keyVal.key));
  }
  var script = keyVal.value.slice(0, -1);
  var controlBlock = keyVal.key.slice(1);
  return {
    controlBlock: controlBlock,
    script: script,
    leafVersion: leafVersion
  };
}
exports.decode = decode;
function encode(tScript) {
  var head = Uint8Array.from([typeFields_js_1.InputTypes.TAP_LEAF_SCRIPT]);
  var verBuf = Uint8Array.from([tScript.leafVersion]);
  return {
    key: tools.concat([head, tScript.controlBlock]),
    value: tools.concat([tScript.script, verBuf])
  };
}
exports.encode = encode;
exports.expected = '{ controlBlock: Uint8Array; leafVersion: number, script: Uint8Array; }';
function check(data) {
  return data.controlBlock instanceof Uint8Array && (data.controlBlock.length - 1) % 32 === 0 && (data.controlBlock[0] & 0xfe) === data.leafVersion && data.script instanceof Uint8Array;
}
exports.check = check;
function canAddToArray(array, item, dupeSet) {
  var dupeString = tools.toHex(item.controlBlock);
  if (dupeSet.has(dupeString)) return false;
  dupeSet.add(dupeString);
  return array.filter(function (v) {
    return tools.compare(v.controlBlock, item.controlBlock) === 0;
  }).length === 0;
}
exports.canAddToArray = canAddToArray;

},{"../../typeFields.cjs":46,"uint8array-tools":18}],31:[function(require,module,exports){
'use strict';

var __importStar = void 0 && (void 0).__importStar || function (mod) {
  if (mod && mod.__esModule) return mod;
  var result = {};
  if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
  result['default'] = mod;
  return result;
};
Object.defineProperty(exports, '__esModule', {
  value: true
});
var typeFields_js_1 = require('../../typeFields.cjs');
var tools = __importStar(require('uint8array-tools'));
function decode(keyVal) {
  if (keyVal.key[0] !== typeFields_js_1.InputTypes.TAP_MERKLE_ROOT || keyVal.key.length !== 1) {
    throw new Error('Decode Error: could not decode tapMerkleRoot with key 0x' + tools.toHex(keyVal.key));
  }
  if (!check(keyVal.value)) {
    throw new Error('Decode Error: tapMerkleRoot not a 32-byte hash');
  }
  return keyVal.value;
}
exports.decode = decode;
function encode(value) {
  var key = Uint8Array.from([typeFields_js_1.InputTypes.TAP_MERKLE_ROOT]);
  return {
    key: key,
    value: value
  };
}
exports.encode = encode;
exports.expected = 'Uint8Array';
function check(data) {
  return data instanceof Uint8Array && data.length === 32;
}
exports.check = check;
function canAdd(currentData, newData) {
  return !!currentData && !!newData && currentData.tapMerkleRoot === undefined;
}
exports.canAdd = canAdd;

},{"../../typeFields.cjs":46,"uint8array-tools":18}],32:[function(require,module,exports){
'use strict';

var __importStar = void 0 && (void 0).__importStar || function (mod) {
  if (mod && mod.__esModule) return mod;
  var result = {};
  if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
  result['default'] = mod;
  return result;
};
Object.defineProperty(exports, '__esModule', {
  value: true
});
var typeFields_js_1 = require('../../typeFields.cjs');
var tools = __importStar(require('uint8array-tools'));
function decode(keyVal) {
  if (keyVal.key[0] !== typeFields_js_1.InputTypes.TAP_SCRIPT_SIG) {
    throw new Error('Decode Error: could not decode tapScriptSig with key 0x' + tools.toHex(keyVal.key));
  }
  if (keyVal.key.length !== 65) {
    throw new Error('Decode Error: tapScriptSig has invalid key 0x' + tools.toHex(keyVal.key));
  }
  if (keyVal.value.length !== 64 && keyVal.value.length !== 65) {
    throw new Error('Decode Error: tapScriptSig has invalid signature in key 0x' + tools.toHex(keyVal.key));
  }
  var pubkey = keyVal.key.slice(1, 33);
  var leafHash = keyVal.key.slice(33);
  return {
    pubkey: pubkey,
    leafHash: leafHash,
    signature: keyVal.value
  };
}
exports.decode = decode;
function encode(tSig) {
  var head = Uint8Array.from([typeFields_js_1.InputTypes.TAP_SCRIPT_SIG]);
  return {
    key: tools.concat([head, tSig.pubkey, tSig.leafHash]),
    value: tSig.signature
  };
}
exports.encode = encode;
exports.expected = '{ pubkey: Uint8Array; leafHash: Uint8Array; signature: Uint8Array; }';
function check(data) {
  return data.pubkey instanceof Uint8Array && data.leafHash instanceof Uint8Array && data.signature instanceof Uint8Array && data.pubkey.length === 32 && data.leafHash.length === 32 && (data.signature.length === 64 || data.signature.length === 65);
}
exports.check = check;
function canAddToArray(array, item, dupeSet) {
  var dupeString = tools.toHex(item.pubkey) + tools.toHex(item.leafHash);
  if (dupeSet.has(dupeString)) return false;
  dupeSet.add(dupeString);
  return array.filter(function (v) {
    return tools.compare(v.pubkey, item.pubkey) === 0 && tools.compare(v.leafHash, item.leafHash) === 0;
  }).length === 0;
}
exports.canAddToArray = canAddToArray;

},{"../../typeFields.cjs":46,"uint8array-tools":18}],33:[function(require,module,exports){
'use strict';

var __importStar = void 0 && (void 0).__importStar || function (mod) {
  if (mod && mod.__esModule) return mod;
  var result = {};
  if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
  result['default'] = mod;
  return result;
};
Object.defineProperty(exports, '__esModule', {
  value: true
});
var typeFields_js_1 = require('../../typeFields.cjs');
var tools = __importStar(require('uint8array-tools'));
var varuint = __importStar(require('varuint-bitcoin'));
function decode(keyVal) {
  if (keyVal.key[0] !== typeFields_js_1.InputTypes.WITNESS_UTXO) {
    throw new Error('Decode Error: could not decode witnessUtxo with key 0x' + tools.toHex(keyVal.key));
  }
  var value = tools.readInt64(keyVal.value, 0, 'LE');
  var _offset = 8;
  var _varuint$decode = varuint.decode(keyVal.value, _offset),
    scriptLen = _varuint$decode.numberValue,
    bytes = _varuint$decode.bytes;
  _offset += bytes;
  var script = keyVal.value.slice(_offset);
  if (script.length !== scriptLen) {
    throw new Error('Decode Error: WITNESS_UTXO script is not proper length');
  }
  return {
    script: script,
    value: value
  };
}
exports.decode = decode;
function encode(data) {
  var script = data.script,
    value = data.value;
  var varuintlen = varuint.encodingLength(script.length);
  var result = new Uint8Array(8 + varuintlen + script.length);
  tools.writeInt64(result, 0, BigInt(value), 'LE');
  varuint.encode(script.length, result, 8);
  result.set(script, 8 + varuintlen);
  return {
    key: Uint8Array.from([typeFields_js_1.InputTypes.WITNESS_UTXO]),
    value: result
  };
}
exports.encode = encode;
exports.expected = '{ script: Uint8Array; value: bigint; }';
function check(data) {
  return data.script instanceof Uint8Array && typeof data.value === 'bigint';
}
exports.check = check;
function canAdd(currentData, newData) {
  return !!currentData && !!newData && currentData.witnessUtxo === undefined;
}
exports.canAdd = canAdd;

},{"../../typeFields.cjs":46,"uint8array-tools":18,"varuint-bitcoin":109}],34:[function(require,module,exports){
'use strict';

function _toConsumableArray(r) { return _arrayWithoutHoles(r) || _iterableToArray(r) || _unsupportedIterableToArray(r) || _nonIterableSpread(); }
function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _unsupportedIterableToArray(r, a) { if (r) { if ("string" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }
function _iterableToArray(r) { if ("undefined" != typeof Symbol && null != r[Symbol.iterator] || null != r["@@iterator"]) return Array.from(r); }
function _arrayWithoutHoles(r) { if (Array.isArray(r)) return _arrayLikeToArray(r); }
function _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }
var __importStar = void 0 && (void 0).__importStar || function (mod) {
  if (mod && mod.__esModule) return mod;
  var result = {};
  if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
  result['default'] = mod;
  return result;
};
Object.defineProperty(exports, '__esModule', {
  value: true
});
var typeFields_js_1 = require('../../typeFields.cjs');
var varuint = __importStar(require('varuint-bitcoin'));
var tools = __importStar(require('uint8array-tools'));
function decode(keyVal) {
  if (keyVal.key[0] !== typeFields_js_1.OutputTypes.TAP_TREE || keyVal.key.length !== 1) {
    throw new Error('Decode Error: could not decode tapTree with key 0x' + tools.toHex(keyVal.key));
  }
  var _offset = 0;
  var data = [];
  while (_offset < keyVal.value.length) {
    var depth = keyVal.value[_offset++];
    var leafVersion = keyVal.value[_offset++];
    var _varuint$decode = varuint.decode(keyVal.value, _offset),
      scriptLen = _varuint$decode.numberValue,
      bytes = _varuint$decode.bytes;
    _offset += bytes;
    data.push({
      depth: depth,
      leafVersion: leafVersion,
      script: keyVal.value.slice(_offset, _offset + scriptLen)
    });
    _offset += scriptLen;
  }
  return {
    leaves: data
  };
}
exports.decode = decode;
function encode(tree) {
  var _ref;
  var key = Uint8Array.from([typeFields_js_1.OutputTypes.TAP_TREE]);
  var bufs = (_ref = []).concat.apply(_ref, _toConsumableArray(tree.leaves.map(function (tapLeaf) {
    return [Uint8Array.of(tapLeaf.depth, tapLeaf.leafVersion), varuint.encode(BigInt(tapLeaf.script.length)).buffer, tapLeaf.script];
  })));
  return {
    key: key,
    value: tools.concat(bufs)
  };
}
exports.encode = encode;
exports.expected = '{ leaves: [{ depth: number; leafVersion: number, script: Uint8Array; }] }';
function check(data) {
  return Array.isArray(data.leaves) && data.leaves.every(function (tapLeaf) {
    return tapLeaf.depth >= 0 && tapLeaf.depth <= 128 && (tapLeaf.leafVersion & 0xfe) === tapLeaf.leafVersion && tapLeaf.script instanceof Uint8Array;
  });
}
exports.check = check;
function canAdd(currentData, newData) {
  return !!currentData && !!newData && currentData.tapTree === undefined;
}
exports.canAdd = canAdd;

},{"../../typeFields.cjs":46,"uint8array-tools":18,"varuint-bitcoin":109}],35:[function(require,module,exports){
'use strict';

function _createForOfIteratorHelper(r, e) { var t = "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (!t) { if (Array.isArray(r) || (t = _unsupportedIterableToArray(r)) || e && r && "number" == typeof r.length) { t && (r = t); var _n = 0, F = function F() {}; return { s: F, n: function n() { return _n >= r.length ? { done: !0 } : { done: !1, value: r[_n++] }; }, e: function e(r) { throw r; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var o, a = !0, u = !1; return { s: function s() { t = t.call(r); }, n: function n() { var r = t.next(); return a = r.done, r; }, e: function e(r) { u = !0, o = r; }, f: function f() { try { a || null == t["return"] || t["return"](); } finally { if (u) throw o; } } }; }
function _toConsumableArray(r) { return _arrayWithoutHoles(r) || _iterableToArray(r) || _unsupportedIterableToArray(r) || _nonIterableSpread(); }
function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _unsupportedIterableToArray(r, a) { if (r) { if ("string" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }
function _iterableToArray(r) { if ("undefined" != typeof Symbol && null != r[Symbol.iterator] || null != r["@@iterator"]) return Array.from(r); }
function _arrayWithoutHoles(r) { if (Array.isArray(r)) return _arrayLikeToArray(r); }
function _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }
var __importStar = void 0 && (void 0).__importStar || function (mod) {
  if (mod && mod.__esModule) return mod;
  var result = {};
  if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
  result['default'] = mod;
  return result;
};
Object.defineProperty(exports, '__esModule', {
  value: true
});
var tools = __importStar(require('uint8array-tools'));
var range = function range(n) {
  return _toConsumableArray(Array(n).keys());
};
var isValidDERKey = function isValidDERKey(pubkey) {
  return pubkey.length === 33 && [2, 3].includes(pubkey[0]) || pubkey.length === 65 && 4 === pubkey[0];
};
function makeConverter(TYPE_BYTE) {
  var isValidPubkey = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : isValidDERKey;
  function decode(keyVal) {
    if (keyVal.key[0] !== TYPE_BYTE) {
      throw new Error('Decode Error: could not decode bip32Derivation with key 0x' + tools.toHex(keyVal.key));
    }
    var pubkey = keyVal.key.slice(1);
    if (!isValidPubkey(pubkey)) {
      throw new Error('Decode Error: bip32Derivation has invalid pubkey in key 0x' + tools.toHex(keyVal.key));
    }
    if (keyVal.value.length / 4 % 1 !== 0) {
      throw new Error('Decode Error: Input BIP32_DERIVATION value length should be multiple of 4');
    }
    var data = {
      masterFingerprint: keyVal.value.slice(0, 4),
      pubkey: pubkey,
      path: 'm'
    };
    var _iterator = _createForOfIteratorHelper(range(keyVal.value.length / 4 - 1)),
      _step;
    try {
      for (_iterator.s(); !(_step = _iterator.n()).done;) {
        var i = _step.value;
        var val = tools.readUInt32(keyVal.value, i * 4 + 4, 'LE');
        var isHard = !!(val & 0x80000000);
        var idx = val & 0x7fffffff;
        data.path += '/' + idx.toString(10) + (isHard ? "'" : '');
      }
    } catch (err) {
      _iterator.e(err);
    } finally {
      _iterator.f();
    }
    return data;
  }
  function encode(data) {
    var head = Uint8Array.from([TYPE_BYTE]);
    var key = tools.concat([head, data.pubkey]);
    var splitPath = data.path.split('/');
    var value = new Uint8Array(splitPath.length * 4);
    value.set(data.masterFingerprint, 0);
    var offset = 4;
    splitPath.slice(1).forEach(function (level) {
      var isHard = level.slice(-1) === "'";
      var num = 0x7fffffff & parseInt(isHard ? level.slice(0, -1) : level, 10);
      if (isHard) num += 0x80000000;
      tools.writeUInt32(value, offset, num, 'LE');
      offset += 4;
    });
    return {
      key: key,
      value: value
    };
  }
  var expected = '{ masterFingerprint: Uint8Array; pubkey: Uint8Array; path: string; }';
  function check(data) {
    return data.pubkey instanceof Uint8Array && data.masterFingerprint instanceof Uint8Array && typeof data.path === 'string' && isValidPubkey(data.pubkey) && data.masterFingerprint.length === 4;
  }
  function canAddToArray(array, item, dupeSet) {
    var dupeString = tools.toHex(item.pubkey);
    if (dupeSet.has(dupeString)) return false;
    dupeSet.add(dupeString);
    return array.filter(function (v) {
      return tools.compare(v.pubkey, item.pubkey) === 0;
    }).length === 0;
  }
  return {
    decode: decode,
    encode: encode,
    check: check,
    expected: expected,
    canAddToArray: canAddToArray
  };
}
exports.makeConverter = makeConverter;

},{"uint8array-tools":18}],36:[function(require,module,exports){
'use strict';

var __importStar = void 0 && (void 0).__importStar || function (mod) {
  if (mod && mod.__esModule) return mod;
  var result = {};
  if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
  result['default'] = mod;
  return result;
};
Object.defineProperty(exports, '__esModule', {
  value: true
});
var tools = __importStar(require('uint8array-tools'));
function makeChecker(pubkeyTypes) {
  return checkPubkey;
  function checkPubkey(keyVal) {
    var pubkey;
    if (pubkeyTypes.includes(keyVal.key[0])) {
      pubkey = keyVal.key.slice(1);
      if (!(pubkey.length === 33 || pubkey.length === 65) || ![2, 3, 4].includes(pubkey[0])) {
        throw new Error('Format Error: invalid pubkey in key 0x' + tools.toHex(keyVal.key));
      }
    }
    return pubkey;
  }
}
exports.makeChecker = makeChecker;

},{"uint8array-tools":18}],37:[function(require,module,exports){
'use strict';

var __importStar = void 0 && (void 0).__importStar || function (mod) {
  if (mod && mod.__esModule) return mod;
  var result = {};
  if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
  result['default'] = mod;
  return result;
};
Object.defineProperty(exports, '__esModule', {
  value: true
});
var tools = __importStar(require('uint8array-tools'));
function makeConverter(TYPE_BYTE) {
  function decode(keyVal) {
    if (keyVal.key[0] !== TYPE_BYTE) {
      throw new Error('Decode Error: could not decode redeemScript with key 0x' + tools.toHex(keyVal.key));
    }
    return keyVal.value;
  }
  function encode(data) {
    var key = Uint8Array.from([TYPE_BYTE]);
    return {
      key: key,
      value: data
    };
  }
  var expected = 'Uint8Array';
  function check(data) {
    return data instanceof Uint8Array;
  }
  function canAdd(currentData, newData) {
    return !!currentData && !!newData && currentData.redeemScript === undefined;
  }
  return {
    decode: decode,
    encode: encode,
    check: check,
    expected: expected,
    canAdd: canAdd
  };
}
exports.makeConverter = makeConverter;

},{"uint8array-tools":18}],38:[function(require,module,exports){
'use strict';

function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _toConsumableArray(r) { return _arrayWithoutHoles(r) || _iterableToArray(r) || _unsupportedIterableToArray(r) || _nonIterableSpread(); }
function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _unsupportedIterableToArray(r, a) { if (r) { if ("string" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }
function _iterableToArray(r) { if ("undefined" != typeof Symbol && null != r[Symbol.iterator] || null != r["@@iterator"]) return Array.from(r); }
function _arrayWithoutHoles(r) { if (Array.isArray(r)) return _arrayLikeToArray(r); }
function _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }
function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
function _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
var __importStar = void 0 && (void 0).__importStar || function (mod) {
  if (mod && mod.__esModule) return mod;
  var result = {};
  if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
  result['default'] = mod;
  return result;
};
Object.defineProperty(exports, '__esModule', {
  value: true
});
var varuint = __importStar(require('varuint-bitcoin'));
var tools = __importStar(require('uint8array-tools'));
var bip32Derivation = __importStar(require('./bip32Derivation.cjs'));
var isValidBIP340Key = function isValidBIP340Key(pubkey) {
  return pubkey.length === 32;
};
function makeConverter(TYPE_BYTE) {
  var parent = bip32Derivation.makeConverter(TYPE_BYTE, isValidBIP340Key);
  function decode(keyVal) {
    var _varuint$decode = varuint.decode(keyVal.value),
      nHashes = _varuint$decode.numberValue,
      nHashesLen = _varuint$decode.bytes;
    var base = parent.decode({
      key: keyVal.key,
      value: keyVal.value.slice(nHashesLen + Number(nHashes) * 32)
    });
    var leafHashes = new Array(Number(nHashes));
    for (var i = 0, _offset = nHashesLen; i < nHashes; i++, _offset += 32) {
      leafHashes[i] = keyVal.value.slice(_offset, _offset + 32);
    }
    return _objectSpread(_objectSpread({}, base), {}, {
      leafHashes: leafHashes
    });
  }
  function encode(data) {
    var base = parent.encode(data);
    var nHashesLen = varuint.encodingLength(data.leafHashes.length);
    var nHashesBuf = new Uint8Array(nHashesLen);
    varuint.encode(data.leafHashes.length, nHashesBuf);
    var value = tools.concat([nHashesBuf].concat(_toConsumableArray(data.leafHashes), [base.value]));
    return _objectSpread(_objectSpread({}, base), {}, {
      value: value
    });
  }
  var expected = '{ ' + 'masterFingerprint: Uint8Array; ' + 'pubkey: Uint8Array; ' + 'path: string; ' + 'leafHashes: Uint8Array[]; ' + '}';
  function check(data) {
    return Array.isArray(data.leafHashes) && data.leafHashes.every(function (leafHash) {
      return leafHash instanceof Uint8Array && leafHash.length === 32;
    }) && parent.check(data);
  }
  return {
    decode: decode,
    encode: encode,
    check: check,
    expected: expected,
    canAddToArray: parent.canAddToArray
  };
}
exports.makeConverter = makeConverter;

},{"./bip32Derivation.cjs":35,"uint8array-tools":18,"varuint-bitcoin":109}],39:[function(require,module,exports){
'use strict';

var __importStar = void 0 && (void 0).__importStar || function (mod) {
  if (mod && mod.__esModule) return mod;
  var result = {};
  if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
  result['default'] = mod;
  return result;
};
Object.defineProperty(exports, '__esModule', {
  value: true
});
var tools = __importStar(require('uint8array-tools'));
function makeConverter(TYPE_BYTE) {
  function decode(keyVal) {
    if (keyVal.key[0] !== TYPE_BYTE || keyVal.key.length !== 1) {
      throw new Error('Decode Error: could not decode tapInternalKey with key 0x' + tools.toHex(keyVal.key));
    }
    if (keyVal.value.length !== 32) {
      throw new Error('Decode Error: tapInternalKey not a 32-byte x-only pubkey');
    }
    return keyVal.value;
  }
  function encode(value) {
    var key = Uint8Array.from([TYPE_BYTE]);
    return {
      key: key,
      value: value
    };
  }
  var expected = 'Uint8Array';
  function check(data) {
    return data instanceof Uint8Array && data.length === 32;
  }
  function canAdd(currentData, newData) {
    return !!currentData && !!newData && currentData.tapInternalKey === undefined;
  }
  return {
    decode: decode,
    encode: encode,
    check: check,
    expected: expected,
    canAdd: canAdd
  };
}
exports.makeConverter = makeConverter;

},{"uint8array-tools":18}],40:[function(require,module,exports){
'use strict';

var __importStar = void 0 && (void 0).__importStar || function (mod) {
  if (mod && mod.__esModule) return mod;
  var result = {};
  if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
  result['default'] = mod;
  return result;
};
Object.defineProperty(exports, '__esModule', {
  value: true
});
var tools = __importStar(require('uint8array-tools'));
function makeConverter(TYPE_BYTE) {
  function decode(keyVal) {
    if (keyVal.key[0] !== TYPE_BYTE) {
      throw new Error('Decode Error: could not decode witnessScript with key 0x' + tools.toHex(keyVal.key));
    }
    return keyVal.value;
  }
  function encode(data) {
    var key = Uint8Array.from([TYPE_BYTE]);
    return {
      key: key,
      value: data
    };
  }
  var expected = 'Uint8Array';
  function check(data) {
    return data instanceof Uint8Array;
  }
  function canAdd(currentData, newData) {
    return !!currentData && !!newData && currentData.witnessScript === undefined;
  }
  return {
    decode: decode,
    encode: encode,
    check: check,
    expected: expected,
    canAdd: canAdd
  };
}
exports.makeConverter = makeConverter;

},{"uint8array-tools":18}],41:[function(require,module,exports){
'use strict';

function _toConsumableArray(r) { return _arrayWithoutHoles(r) || _iterableToArray(r) || _unsupportedIterableToArray(r) || _nonIterableSpread(); }
function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _unsupportedIterableToArray(r, a) { if (r) { if ("string" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }
function _iterableToArray(r) { if ("undefined" != typeof Symbol && null != r[Symbol.iterator] || null != r["@@iterator"]) return Array.from(r); }
function _arrayWithoutHoles(r) { if (Array.isArray(r)) return _arrayLikeToArray(r); }
function _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }
var __importStar = void 0 && (void 0).__importStar || function (mod) {
  if (mod && mod.__esModule) return mod;
  var result = {};
  if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
  result['default'] = mod;
  return result;
};
Object.defineProperty(exports, '__esModule', {
  value: true
});
var varuint = __importStar(require('varuint-bitcoin'));
var tools = __importStar(require('uint8array-tools'));
exports.range = function (n) {
  return _toConsumableArray(Array(n).keys());
};
function reverseBuffer(buffer) {
  if (buffer.length < 1) return buffer;
  var j = buffer.length - 1;
  var tmp = 0;
  for (var i = 0; i < buffer.length / 2; i++) {
    tmp = buffer[i];
    buffer[i] = buffer[j];
    buffer[j] = tmp;
    j--;
  }
  return buffer;
}
exports.reverseBuffer = reverseBuffer;
function keyValsToBuffer(keyVals) {
  var buffers = keyVals.map(keyValToBuffer);
  buffers.push(Uint8Array.from([0]));
  return tools.concat(buffers);
}
exports.keyValsToBuffer = keyValsToBuffer;
function keyValToBuffer(keyVal) {
  var keyLen = keyVal.key.length;
  var valLen = keyVal.value.length;
  var keyVarIntLen = varuint.encodingLength(keyLen);
  var valVarIntLen = varuint.encodingLength(valLen);
  var buffer = new Uint8Array(keyVarIntLen + keyLen + valVarIntLen + valLen);
  varuint.encode(keyLen, buffer, 0);
  buffer.set(keyVal.key, keyVarIntLen);
  varuint.encode(valLen, buffer, keyVarIntLen + keyLen);
  buffer.set(keyVal.value, keyVarIntLen + keyLen + valVarIntLen);
  return buffer;
}
exports.keyValToBuffer = keyValToBuffer;

},{"uint8array-tools":18,"varuint-bitcoin":109}],42:[function(require,module,exports){
'use strict';

function _createForOfIteratorHelper(r, e) { var t = "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (!t) { if (Array.isArray(r) || (t = _unsupportedIterableToArray(r)) || e && r && "number" == typeof r.length) { t && (r = t); var _n = 0, F = function F() {}; return { s: F, n: function n() { return _n >= r.length ? { done: !0 } : { done: !1, value: r[_n++] }; }, e: function e(r) { throw r; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var o, a = !0, u = !1; return { s: function s() { t = t.call(r); }, n: function n() { var r = t.next(); return a = r.done, r; }, e: function e(r) { u = !0, o = r; }, f: function f() { try { a || null == t["return"] || t["return"](); } finally { if (u) throw o; } } }; }
function _unsupportedIterableToArray(r, a) { if (r) { if ("string" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }
function _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }
var __importStar = void 0 && (void 0).__importStar || function (mod) {
  if (mod && mod.__esModule) return mod;
  var result = {};
  if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
  result['default'] = mod;
  return result;
};
Object.defineProperty(exports, '__esModule', {
  value: true
});
var convert = __importStar(require('../converter/index.cjs'));
var tools_js_1 = require('../converter/tools.cjs');
var varuint = __importStar(require('varuint-bitcoin'));
var tools = __importStar(require('uint8array-tools'));
var typeFields_js_1 = require('../typeFields.cjs');
function psbtFromBuffer(buffer, txGetter) {
  var offset = 0;
  function varSlice() {
    var _varuint$decode = varuint.decode(buffer, offset),
      keyLen = _varuint$decode.numberValue,
      bytes = _varuint$decode.bytes;
    offset += bytes;
    var key = buffer.slice(offset, offset + Number(keyLen));
    offset += Number(keyLen);
    return key;
  }
  function readUInt32BE() {
    var num = tools.readUInt32(buffer, offset, 'BE');
    offset += 4;
    return num;
  }
  function readUInt8() {
    var num = tools.readUInt8(buffer, offset);
    offset += 1;
    return num;
  }
  function getKeyValue() {
    var key = varSlice();
    var value = varSlice();
    return {
      key: key,
      value: value
    };
  }
  function checkEndOfKeyValPairs() {
    if (offset >= buffer.length) {
      throw new Error('Format Error: Unexpected End of PSBT');
    }
    var isEnd = tools.readUInt8(buffer, offset) === 0;
    if (isEnd) {
      offset++;
    }
    return isEnd;
  }
  if (readUInt32BE() !== 0x70736274) {
    throw new Error('Format Error: Invalid Magic Number');
  }
  if (readUInt8() !== 0xff) {
    throw new Error('Format Error: Magic Number must be followed by 0xff separator');
  }
  var globalMapKeyVals = [];
  var globalKeyIndex = {};
  while (!checkEndOfKeyValPairs()) {
    var keyVal = getKeyValue();
    var hexKey = tools.toHex(keyVal.key);
    if (globalKeyIndex[hexKey]) {
      throw new Error('Format Error: Keys must be unique for global keymap: key ' + hexKey);
    }
    globalKeyIndex[hexKey] = 1;
    globalMapKeyVals.push(keyVal);
  }
  var unsignedTxMaps = globalMapKeyVals.filter(function (keyVal) {
    return keyVal.key[0] === typeFields_js_1.GlobalTypes.UNSIGNED_TX;
  });
  if (unsignedTxMaps.length !== 1) {
    throw new Error('Format Error: Only one UNSIGNED_TX allowed');
  }
  var unsignedTx = txGetter(unsignedTxMaps[0].value);
  // Get input and output counts to loop the respective fields
  var _unsignedTx$getInputO = unsignedTx.getInputOutputCounts(),
    inputCount = _unsignedTx$getInputO.inputCount,
    outputCount = _unsignedTx$getInputO.outputCount;
  var inputKeyVals = [];
  var outputKeyVals = [];
  // Get input fields
  var _iterator = _createForOfIteratorHelper(tools_js_1.range(inputCount)),
    _step;
  try {
    for (_iterator.s(); !(_step = _iterator.n()).done;) {
      var index = _step.value;
      var inputKeyIndex = {};
      var input = [];
      while (!checkEndOfKeyValPairs()) {
        var _keyVal = getKeyValue();
        var _hexKey = tools.toHex(_keyVal.key);
        if (inputKeyIndex[_hexKey]) {
          throw new Error('Format Error: Keys must be unique for each input: ' + 'input index ' + index + ' key ' + _hexKey);
        }
        inputKeyIndex[_hexKey] = 1;
        input.push(_keyVal);
      }
      inputKeyVals.push(input);
    }
  } catch (err) {
    _iterator.e(err);
  } finally {
    _iterator.f();
  }
  var _iterator2 = _createForOfIteratorHelper(tools_js_1.range(outputCount)),
    _step2;
  try {
    for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
      var _index = _step2.value;
      var outputKeyIndex = {};
      var output = [];
      while (!checkEndOfKeyValPairs()) {
        var _keyVal2 = getKeyValue();
        var _hexKey2 = tools.toHex(_keyVal2.key);
        if (outputKeyIndex[_hexKey2]) {
          throw new Error('Format Error: Keys must be unique for each output: ' + 'output index ' + _index + ' key ' + _hexKey2);
        }
        outputKeyIndex[_hexKey2] = 1;
        output.push(_keyVal2);
      }
      outputKeyVals.push(output);
    }
  } catch (err) {
    _iterator2.e(err);
  } finally {
    _iterator2.f();
  }
  return psbtFromKeyVals(unsignedTx, {
    globalMapKeyVals: globalMapKeyVals,
    inputKeyVals: inputKeyVals,
    outputKeyVals: outputKeyVals
  });
}
exports.psbtFromBuffer = psbtFromBuffer;
function checkKeyBuffer(type, keyBuf, keyNum) {
  if (tools.compare(keyBuf, Uint8Array.from([keyNum]))) {
    throw new Error(// `Format Error: Invalid ${type} key: ${keyBuf.toString('hex')}`,
    "Format Error: Invalid ".concat(type, " key: ").concat(tools.toHex(keyBuf)));
  }
}
exports.checkKeyBuffer = checkKeyBuffer;
function psbtFromKeyVals(unsignedTx, _ref) {
  var globalMapKeyVals = _ref.globalMapKeyVals,
    inputKeyVals = _ref.inputKeyVals,
    outputKeyVals = _ref.outputKeyVals;
  // That was easy :-)
  var globalMap = {
    unsignedTx: unsignedTx
  };
  var txCount = 0;
  var _iterator3 = _createForOfIteratorHelper(globalMapKeyVals),
    _step3;
  try {
    for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
      var keyVal = _step3.value;
      // If a globalMap item needs pubkey, uncomment
      // const pubkey = convert.globals.checkPubkey(keyVal);
      switch (keyVal.key[0]) {
        case typeFields_js_1.GlobalTypes.UNSIGNED_TX:
          checkKeyBuffer('global', keyVal.key, typeFields_js_1.GlobalTypes.UNSIGNED_TX);
          if (txCount > 0) {
            throw new Error('Format Error: GlobalMap has multiple UNSIGNED_TX');
          }
          txCount++;
          break;
        case typeFields_js_1.GlobalTypes.GLOBAL_XPUB:
          if (globalMap.globalXpub === undefined) {
            globalMap.globalXpub = [];
          }
          globalMap.globalXpub.push(convert.globals.globalXpub.decode(keyVal));
          break;
        default:
          // This will allow inclusion during serialization.
          if (!globalMap.unknownKeyVals) globalMap.unknownKeyVals = [];
          globalMap.unknownKeyVals.push(keyVal);
      }
    }
    // Get input and output counts to loop the respective fields
  } catch (err) {
    _iterator3.e(err);
  } finally {
    _iterator3.f();
  }
  var inputCount = inputKeyVals.length;
  var outputCount = outputKeyVals.length;
  var inputs = [];
  var outputs = [];
  // Get input fields
  var _iterator4 = _createForOfIteratorHelper(tools_js_1.range(inputCount)),
    _step4;
  try {
    for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {
      var index = _step4.value;
      var input = {};
      var _iterator6 = _createForOfIteratorHelper(inputKeyVals[index]),
        _step6;
      try {
        for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {
          var _keyVal3 = _step6.value;
          convert.inputs.checkPubkey(_keyVal3);
          switch (_keyVal3.key[0]) {
            case typeFields_js_1.InputTypes.NON_WITNESS_UTXO:
              checkKeyBuffer('input', _keyVal3.key, typeFields_js_1.InputTypes.NON_WITNESS_UTXO);
              if (input.nonWitnessUtxo !== undefined) {
                throw new Error('Format Error: Input has multiple NON_WITNESS_UTXO');
              }
              input.nonWitnessUtxo = convert.inputs.nonWitnessUtxo.decode(_keyVal3);
              break;
            case typeFields_js_1.InputTypes.WITNESS_UTXO:
              checkKeyBuffer('input', _keyVal3.key, typeFields_js_1.InputTypes.WITNESS_UTXO);
              if (input.witnessUtxo !== undefined) {
                throw new Error('Format Error: Input has multiple WITNESS_UTXO');
              }
              input.witnessUtxo = convert.inputs.witnessUtxo.decode(_keyVal3);
              break;
            case typeFields_js_1.InputTypes.PARTIAL_SIG:
              if (input.partialSig === undefined) {
                input.partialSig = [];
              }
              input.partialSig.push(convert.inputs.partialSig.decode(_keyVal3));
              break;
            case typeFields_js_1.InputTypes.SIGHASH_TYPE:
              checkKeyBuffer('input', _keyVal3.key, typeFields_js_1.InputTypes.SIGHASH_TYPE);
              if (input.sighashType !== undefined) {
                throw new Error('Format Error: Input has multiple SIGHASH_TYPE');
              }
              input.sighashType = convert.inputs.sighashType.decode(_keyVal3);
              break;
            case typeFields_js_1.InputTypes.REDEEM_SCRIPT:
              checkKeyBuffer('input', _keyVal3.key, typeFields_js_1.InputTypes.REDEEM_SCRIPT);
              if (input.redeemScript !== undefined) {
                throw new Error('Format Error: Input has multiple REDEEM_SCRIPT');
              }
              input.redeemScript = convert.inputs.redeemScript.decode(_keyVal3);
              break;
            case typeFields_js_1.InputTypes.WITNESS_SCRIPT:
              checkKeyBuffer('input', _keyVal3.key, typeFields_js_1.InputTypes.WITNESS_SCRIPT);
              if (input.witnessScript !== undefined) {
                throw new Error('Format Error: Input has multiple WITNESS_SCRIPT');
              }
              input.witnessScript = convert.inputs.witnessScript.decode(_keyVal3);
              break;
            case typeFields_js_1.InputTypes.BIP32_DERIVATION:
              if (input.bip32Derivation === undefined) {
                input.bip32Derivation = [];
              }
              input.bip32Derivation.push(convert.inputs.bip32Derivation.decode(_keyVal3));
              break;
            case typeFields_js_1.InputTypes.FINAL_SCRIPTSIG:
              checkKeyBuffer('input', _keyVal3.key, typeFields_js_1.InputTypes.FINAL_SCRIPTSIG);
              input.finalScriptSig = convert.inputs.finalScriptSig.decode(_keyVal3);
              break;
            case typeFields_js_1.InputTypes.FINAL_SCRIPTWITNESS:
              checkKeyBuffer('input', _keyVal3.key, typeFields_js_1.InputTypes.FINAL_SCRIPTWITNESS);
              input.finalScriptWitness = convert.inputs.finalScriptWitness.decode(_keyVal3);
              break;
            case typeFields_js_1.InputTypes.POR_COMMITMENT:
              checkKeyBuffer('input', _keyVal3.key, typeFields_js_1.InputTypes.POR_COMMITMENT);
              input.porCommitment = convert.inputs.porCommitment.decode(_keyVal3);
              break;
            case typeFields_js_1.InputTypes.TAP_KEY_SIG:
              checkKeyBuffer('input', _keyVal3.key, typeFields_js_1.InputTypes.TAP_KEY_SIG);
              input.tapKeySig = convert.inputs.tapKeySig.decode(_keyVal3);
              break;
            case typeFields_js_1.InputTypes.TAP_SCRIPT_SIG:
              if (input.tapScriptSig === undefined) {
                input.tapScriptSig = [];
              }
              input.tapScriptSig.push(convert.inputs.tapScriptSig.decode(_keyVal3));
              break;
            case typeFields_js_1.InputTypes.TAP_LEAF_SCRIPT:
              if (input.tapLeafScript === undefined) {
                input.tapLeafScript = [];
              }
              input.tapLeafScript.push(convert.inputs.tapLeafScript.decode(_keyVal3));
              break;
            case typeFields_js_1.InputTypes.TAP_BIP32_DERIVATION:
              if (input.tapBip32Derivation === undefined) {
                input.tapBip32Derivation = [];
              }
              input.tapBip32Derivation.push(convert.inputs.tapBip32Derivation.decode(_keyVal3));
              break;
            case typeFields_js_1.InputTypes.TAP_INTERNAL_KEY:
              checkKeyBuffer('input', _keyVal3.key, typeFields_js_1.InputTypes.TAP_INTERNAL_KEY);
              input.tapInternalKey = convert.inputs.tapInternalKey.decode(_keyVal3);
              break;
            case typeFields_js_1.InputTypes.TAP_MERKLE_ROOT:
              checkKeyBuffer('input', _keyVal3.key, typeFields_js_1.InputTypes.TAP_MERKLE_ROOT);
              input.tapMerkleRoot = convert.inputs.tapMerkleRoot.decode(_keyVal3);
              break;
            default:
              // This will allow inclusion during serialization.
              if (!input.unknownKeyVals) input.unknownKeyVals = [];
              input.unknownKeyVals.push(_keyVal3);
          }
        }
      } catch (err) {
        _iterator6.e(err);
      } finally {
        _iterator6.f();
      }
      inputs.push(input);
    }
  } catch (err) {
    _iterator4.e(err);
  } finally {
    _iterator4.f();
  }
  var _iterator5 = _createForOfIteratorHelper(tools_js_1.range(outputCount)),
    _step5;
  try {
    for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {
      var _index2 = _step5.value;
      var output = {};
      var _iterator7 = _createForOfIteratorHelper(outputKeyVals[_index2]),
        _step7;
      try {
        for (_iterator7.s(); !(_step7 = _iterator7.n()).done;) {
          var _keyVal4 = _step7.value;
          convert.outputs.checkPubkey(_keyVal4);
          switch (_keyVal4.key[0]) {
            case typeFields_js_1.OutputTypes.REDEEM_SCRIPT:
              checkKeyBuffer('output', _keyVal4.key, typeFields_js_1.OutputTypes.REDEEM_SCRIPT);
              if (output.redeemScript !== undefined) {
                throw new Error('Format Error: Output has multiple REDEEM_SCRIPT');
              }
              output.redeemScript = convert.outputs.redeemScript.decode(_keyVal4);
              break;
            case typeFields_js_1.OutputTypes.WITNESS_SCRIPT:
              checkKeyBuffer('output', _keyVal4.key, typeFields_js_1.OutputTypes.WITNESS_SCRIPT);
              if (output.witnessScript !== undefined) {
                throw new Error('Format Error: Output has multiple WITNESS_SCRIPT');
              }
              output.witnessScript = convert.outputs.witnessScript.decode(_keyVal4);
              break;
            case typeFields_js_1.OutputTypes.BIP32_DERIVATION:
              if (output.bip32Derivation === undefined) {
                output.bip32Derivation = [];
              }
              output.bip32Derivation.push(convert.outputs.bip32Derivation.decode(_keyVal4));
              break;
            case typeFields_js_1.OutputTypes.TAP_INTERNAL_KEY:
              checkKeyBuffer('output', _keyVal4.key, typeFields_js_1.OutputTypes.TAP_INTERNAL_KEY);
              output.tapInternalKey = convert.outputs.tapInternalKey.decode(_keyVal4);
              break;
            case typeFields_js_1.OutputTypes.TAP_TREE:
              checkKeyBuffer('output', _keyVal4.key, typeFields_js_1.OutputTypes.TAP_TREE);
              output.tapTree = convert.outputs.tapTree.decode(_keyVal4);
              break;
            case typeFields_js_1.OutputTypes.TAP_BIP32_DERIVATION:
              if (output.tapBip32Derivation === undefined) {
                output.tapBip32Derivation = [];
              }
              output.tapBip32Derivation.push(convert.outputs.tapBip32Derivation.decode(_keyVal4));
              break;
            default:
              if (!output.unknownKeyVals) output.unknownKeyVals = [];
              output.unknownKeyVals.push(_keyVal4);
          }
        }
      } catch (err) {
        _iterator7.e(err);
      } finally {
        _iterator7.f();
      }
      outputs.push(output);
    }
  } catch (err) {
    _iterator5.e(err);
  } finally {
    _iterator5.f();
  }
  return {
    globalMap: globalMap,
    inputs: inputs,
    outputs: outputs
  };
}
exports.psbtFromKeyVals = psbtFromKeyVals;

},{"../converter/index.cjs":22,"../converter/tools.cjs":41,"../typeFields.cjs":46,"uint8array-tools":18,"varuint-bitcoin":109}],43:[function(require,module,exports){
'use strict';

function __export(m) {
  for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, '__esModule', {
  value: true
});
__export(require('./fromBuffer.cjs'));
__export(require('./toBuffer.cjs'));

},{"./fromBuffer.cjs":42,"./toBuffer.cjs":44}],44:[function(require,module,exports){
'use strict';

function _slicedToArray(r, e) { return _arrayWithHoles(r) || _iterableToArrayLimit(r, e) || _unsupportedIterableToArray(r, e) || _nonIterableRest(); }
function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _unsupportedIterableToArray(r, a) { if (r) { if ("string" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }
function _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }
function _iterableToArrayLimit(r, l) { var t = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (null != t) { var e, n, i, u, a = [], f = !0, o = !1; try { if (i = (t = t.call(r)).next, 0 === l) { if (Object(t) !== t) return; f = !1; } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0); } catch (r) { o = !0, n = r; } finally { try { if (!f && null != t["return"] && (u = t["return"](), Object(u) !== u)) return; } finally { if (o) throw n; } } return a; } }
function _arrayWithHoles(r) { if (Array.isArray(r)) return r; }
var __importStar = void 0 && (void 0).__importStar || function (mod) {
  if (mod && mod.__esModule) return mod;
  var result = {};
  if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
  result['default'] = mod;
  return result;
};
Object.defineProperty(exports, '__esModule', {
  value: true
});
var convert = __importStar(require('../converter/index.cjs'));
var tools_js_1 = require('../converter/tools.cjs');
var tools = __importStar(require('uint8array-tools'));
function psbtToBuffer(_ref) {
  var globalMap = _ref.globalMap,
    inputs = _ref.inputs,
    outputs = _ref.outputs;
  var _psbtToKeyVals = psbtToKeyVals({
      globalMap: globalMap,
      inputs: inputs,
      outputs: outputs
    }),
    globalKeyVals = _psbtToKeyVals.globalKeyVals,
    inputKeyVals = _psbtToKeyVals.inputKeyVals,
    outputKeyVals = _psbtToKeyVals.outputKeyVals;
  var globalBuffer = tools_js_1.keyValsToBuffer(globalKeyVals);
  var keyValsOrEmptyToBuffer = function keyValsOrEmptyToBuffer(keyVals) {
    return keyVals.length === 0 ? [Uint8Array.from([0])] : keyVals.map(tools_js_1.keyValsToBuffer);
  };
  var inputBuffers = keyValsOrEmptyToBuffer(inputKeyVals);
  var outputBuffers = keyValsOrEmptyToBuffer(outputKeyVals);
  var header = new Uint8Array(5);
  header.set([0x70, 0x73, 0x62, 0x74, 0xff], 0);
  return tools.concat([header, globalBuffer].concat(inputBuffers, outputBuffers));
}
exports.psbtToBuffer = psbtToBuffer;
var sortKeyVals = function sortKeyVals(a, b) {
  return tools.compare(a.key, b.key);
};
function keyValsFromMap(keyValMap, converterFactory) {
  var keyHexSet = new Set();
  var keyVals = Object.entries(keyValMap).reduce(function (result, _ref2) {
    var _ref3 = _slicedToArray(_ref2, 2),
      key = _ref3[0],
      value = _ref3[1];
    if (key === 'unknownKeyVals') return result;
    // We are checking for undefined anyways. So ignore TS error
    // @ts-ignore
    var converter = converterFactory[key];
    if (converter === undefined) return result;
    var encodedKeyVals = (Array.isArray(value) ? value : [value]).map(converter.encode);
    var keyHexes = encodedKeyVals.map(function (kv) {
      return tools.toHex(kv.key);
    });
    keyHexes.forEach(function (hex) {
      if (keyHexSet.has(hex)) throw new Error('Serialize Error: Duplicate key: ' + hex);
      keyHexSet.add(hex);
    });
    return result.concat(encodedKeyVals);
  }, []);
  // Get other keyVals that have not yet been gotten
  var otherKeyVals = keyValMap.unknownKeyVals ? keyValMap.unknownKeyVals.filter(function (keyVal) {
    return !keyHexSet.has(tools.toHex(keyVal.key));
  }) : [];
  return keyVals.concat(otherKeyVals).sort(sortKeyVals);
}
function psbtToKeyVals(_ref4) {
  var globalMap = _ref4.globalMap,
    inputs = _ref4.inputs,
    outputs = _ref4.outputs;
  // First parse the global keyVals
  // Get any extra keyvals to pass along
  return {
    globalKeyVals: keyValsFromMap(globalMap, convert.globals),
    inputKeyVals: inputs.map(function (i) {
      return keyValsFromMap(i, convert.inputs);
    }),
    outputKeyVals: outputs.map(function (o) {
      return keyValsFromMap(o, convert.outputs);
    })
  };
}
exports.psbtToKeyVals = psbtToKeyVals;

},{"../converter/index.cjs":22,"../converter/tools.cjs":41,"uint8array-tools":18}],45:[function(require,module,exports){
'use strict';

function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function"); }
function _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }
function _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: !1 }), e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
var __importStar = void 0 && (void 0).__importStar || function (mod) {
  if (mod && mod.__esModule) return mod;
  var result = {};
  if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
  result['default'] = mod;
  return result;
};
Object.defineProperty(exports, '__esModule', {
  value: true
});
var index_js_1 = require('./combiner/index.cjs');
var index_js_2 = require('./parser/index.cjs');
var typeFields_js_1 = require('./typeFields.cjs');
var utils_js_1 = require('./utils.cjs');
var tools = __importStar(require('uint8array-tools'));
var Psbt = /*#__PURE__*/function () {
  function Psbt(tx) {
    _classCallCheck(this, Psbt);
    this.inputs = [];
    this.outputs = [];
    this.globalMap = {
      unsignedTx: tx
    };
  }
  return _createClass(Psbt, [{
    key: "toBase64",
    value: function toBase64() {
      var buffer = this.toBuffer();
      return tools.toBase64(buffer);
    }
  }, {
    key: "toHex",
    value: function toHex() {
      var buffer = this.toBuffer();
      return tools.toHex(buffer);
    }
  }, {
    key: "toBuffer",
    value: function toBuffer() {
      return index_js_2.psbtToBuffer(this);
    }
  }, {
    key: "updateGlobal",
    value: function updateGlobal(updateData) {
      utils_js_1.updateGlobal(updateData, this.globalMap);
      return this;
    }
  }, {
    key: "updateInput",
    value: function updateInput(inputIndex, updateData) {
      var input = utils_js_1.checkForInput(this.inputs, inputIndex);
      utils_js_1.updateInput(updateData, input);
      return this;
    }
  }, {
    key: "updateOutput",
    value: function updateOutput(outputIndex, updateData) {
      var output = utils_js_1.checkForOutput(this.outputs, outputIndex);
      utils_js_1.updateOutput(updateData, output);
      return this;
    }
  }, {
    key: "addUnknownKeyValToGlobal",
    value: function addUnknownKeyValToGlobal(keyVal) {
      utils_js_1.checkHasKey(keyVal, this.globalMap.unknownKeyVals, utils_js_1.getEnumLength(typeFields_js_1.GlobalTypes));
      if (!this.globalMap.unknownKeyVals) this.globalMap.unknownKeyVals = [];
      this.globalMap.unknownKeyVals.push(keyVal);
      return this;
    }
  }, {
    key: "addUnknownKeyValToInput",
    value: function addUnknownKeyValToInput(inputIndex, keyVal) {
      var input = utils_js_1.checkForInput(this.inputs, inputIndex);
      utils_js_1.checkHasKey(keyVal, input.unknownKeyVals, utils_js_1.getEnumLength(typeFields_js_1.InputTypes));
      if (!input.unknownKeyVals) input.unknownKeyVals = [];
      input.unknownKeyVals.push(keyVal);
      return this;
    }
  }, {
    key: "addUnknownKeyValToOutput",
    value: function addUnknownKeyValToOutput(outputIndex, keyVal) {
      var output = utils_js_1.checkForOutput(this.outputs, outputIndex);
      utils_js_1.checkHasKey(keyVal, output.unknownKeyVals, utils_js_1.getEnumLength(typeFields_js_1.OutputTypes));
      if (!output.unknownKeyVals) output.unknownKeyVals = [];
      output.unknownKeyVals.push(keyVal);
      return this;
    }
  }, {
    key: "addInput",
    value: function addInput(inputData) {
      var _this = this;
      this.globalMap.unsignedTx.addInput(inputData);
      this.inputs.push({
        unknownKeyVals: []
      });
      var addKeyVals = inputData.unknownKeyVals || [];
      var inputIndex = this.inputs.length - 1;
      if (!Array.isArray(addKeyVals)) {
        throw new Error('unknownKeyVals must be an Array');
      }
      addKeyVals.forEach(function (keyVal) {
        return _this.addUnknownKeyValToInput(inputIndex, keyVal);
      });
      utils_js_1.addInputAttributes(this.inputs, inputData);
      return this;
    }
  }, {
    key: "addOutput",
    value: function addOutput(outputData) {
      var _this2 = this;
      this.globalMap.unsignedTx.addOutput(outputData);
      this.outputs.push({
        unknownKeyVals: []
      });
      var addKeyVals = outputData.unknownKeyVals || [];
      var outputIndex = this.outputs.length - 1;
      if (!Array.isArray(addKeyVals)) {
        throw new Error('unknownKeyVals must be an Array');
      }
      addKeyVals.forEach(function (keyVal) {
        return _this2.addUnknownKeyValToOutput(outputIndex, keyVal);
      });
      utils_js_1.addOutputAttributes(this.outputs, outputData);
      return this;
    }
  }, {
    key: "clearFinalizedInput",
    value: function clearFinalizedInput(inputIndex) {
      var input = utils_js_1.checkForInput(this.inputs, inputIndex);
      utils_js_1.inputCheckUncleanFinalized(inputIndex, input);
      for (var _i = 0, _Object$keys = Object.keys(input); _i < _Object$keys.length; _i++) {
        var key = _Object$keys[_i];
        if (!['witnessUtxo', 'nonWitnessUtxo', 'finalScriptSig', 'finalScriptWitness', 'unknownKeyVals'].includes(key)) {
          // @ts-ignore
          delete input[key];
        }
      }
      return this;
    }
  }, {
    key: "combine",
    value: function combine() {
      for (var _len = arguments.length, those = new Array(_len), _key = 0; _key < _len; _key++) {
        those[_key] = arguments[_key];
      }
      // Combine this with those.
      // Return self for chaining.
      var result = index_js_1.combine([this].concat(those));
      Object.assign(this, result);
      return this;
    }
  }, {
    key: "getTransaction",
    value: function getTransaction() {
      return this.globalMap.unsignedTx.toBuffer();
    }
  }], [{
    key: "fromBase64",
    value: function fromBase64(data, txFromBuffer) {
      var buffer = tools.fromBase64(data);
      return this.fromBuffer(buffer, txFromBuffer);
    }
  }, {
    key: "fromHex",
    value: function fromHex(data, txFromBuffer) {
      var buffer = tools.fromHex(data);
      return this.fromBuffer(buffer, txFromBuffer);
    }
  }, {
    key: "fromBuffer",
    value: function fromBuffer(buffer, txFromBuffer) {
      var results = index_js_2.psbtFromBuffer(buffer, txFromBuffer);
      var psbt = new this(results.globalMap.unsignedTx);
      Object.assign(psbt, results);
      return psbt;
    }
  }]);
}();
exports.Psbt = Psbt;
var utils_js_2 = require('./utils.cjs');
exports.checkForInput = utils_js_2.checkForInput;
exports.checkForOutput = utils_js_2.checkForOutput;

},{"./combiner/index.cjs":19,"./parser/index.cjs":43,"./typeFields.cjs":46,"./utils.cjs":47,"uint8array-tools":18}],46:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});
var GlobalTypes;
(function (GlobalTypes) {
  GlobalTypes[GlobalTypes['UNSIGNED_TX'] = 0] = 'UNSIGNED_TX';
  GlobalTypes[GlobalTypes['GLOBAL_XPUB'] = 1] = 'GLOBAL_XPUB';
})(GlobalTypes = exports.GlobalTypes || (exports.GlobalTypes = {}));
exports.GLOBAL_TYPE_NAMES = ['unsignedTx', 'globalXpub'];
var InputTypes;
(function (InputTypes) {
  InputTypes[InputTypes['NON_WITNESS_UTXO'] = 0] = 'NON_WITNESS_UTXO';
  InputTypes[InputTypes['WITNESS_UTXO'] = 1] = 'WITNESS_UTXO';
  InputTypes[InputTypes['PARTIAL_SIG'] = 2] = 'PARTIAL_SIG';
  InputTypes[InputTypes['SIGHASH_TYPE'] = 3] = 'SIGHASH_TYPE';
  InputTypes[InputTypes['REDEEM_SCRIPT'] = 4] = 'REDEEM_SCRIPT';
  InputTypes[InputTypes['WITNESS_SCRIPT'] = 5] = 'WITNESS_SCRIPT';
  InputTypes[InputTypes['BIP32_DERIVATION'] = 6] = 'BIP32_DERIVATION';
  InputTypes[InputTypes['FINAL_SCRIPTSIG'] = 7] = 'FINAL_SCRIPTSIG';
  InputTypes[InputTypes['FINAL_SCRIPTWITNESS'] = 8] = 'FINAL_SCRIPTWITNESS';
  InputTypes[InputTypes['POR_COMMITMENT'] = 9] = 'POR_COMMITMENT';
  InputTypes[InputTypes['TAP_KEY_SIG'] = 19] = 'TAP_KEY_SIG';
  InputTypes[InputTypes['TAP_SCRIPT_SIG'] = 20] = 'TAP_SCRIPT_SIG';
  InputTypes[InputTypes['TAP_LEAF_SCRIPT'] = 21] = 'TAP_LEAF_SCRIPT';
  InputTypes[InputTypes['TAP_BIP32_DERIVATION'] = 22] = 'TAP_BIP32_DERIVATION';
  InputTypes[InputTypes['TAP_INTERNAL_KEY'] = 23] = 'TAP_INTERNAL_KEY';
  InputTypes[InputTypes['TAP_MERKLE_ROOT'] = 24] = 'TAP_MERKLE_ROOT';
})(InputTypes = exports.InputTypes || (exports.InputTypes = {}));
exports.INPUT_TYPE_NAMES = ['nonWitnessUtxo', 'witnessUtxo', 'partialSig', 'sighashType', 'redeemScript', 'witnessScript', 'bip32Derivation', 'finalScriptSig', 'finalScriptWitness', 'porCommitment', 'tapKeySig', 'tapScriptSig', 'tapLeafScript', 'tapBip32Derivation', 'tapInternalKey', 'tapMerkleRoot'];
var OutputTypes;
(function (OutputTypes) {
  OutputTypes[OutputTypes['REDEEM_SCRIPT'] = 0] = 'REDEEM_SCRIPT';
  OutputTypes[OutputTypes['WITNESS_SCRIPT'] = 1] = 'WITNESS_SCRIPT';
  OutputTypes[OutputTypes['BIP32_DERIVATION'] = 2] = 'BIP32_DERIVATION';
  OutputTypes[OutputTypes['TAP_INTERNAL_KEY'] = 5] = 'TAP_INTERNAL_KEY';
  OutputTypes[OutputTypes['TAP_TREE'] = 6] = 'TAP_TREE';
  OutputTypes[OutputTypes['TAP_BIP32_DERIVATION'] = 7] = 'TAP_BIP32_DERIVATION';
})(OutputTypes = exports.OutputTypes || (exports.OutputTypes = {}));
exports.OUTPUT_TYPE_NAMES = ['redeemScript', 'witnessScript', 'bip32Derivation', 'tapInternalKey', 'tapTree', 'tapBip32Derivation'];

},{}],47:[function(require,module,exports){
'use strict';

var __importStar = void 0 && (void 0).__importStar || function (mod) {
  if (mod && mod.__esModule) return mod;
  var result = {};
  if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
  result['default'] = mod;
  return result;
};
Object.defineProperty(exports, '__esModule', {
  value: true
});
var converter = __importStar(require('./converter/index.cjs'));
var tools = __importStar(require('uint8array-tools'));
function checkForInput(inputs, inputIndex) {
  var input = inputs[inputIndex];
  if (input === undefined) throw new Error("No input #".concat(inputIndex));
  return input;
}
exports.checkForInput = checkForInput;
function checkForOutput(outputs, outputIndex) {
  var output = outputs[outputIndex];
  if (output === undefined) throw new Error("No output #".concat(outputIndex));
  return output;
}
exports.checkForOutput = checkForOutput;
function checkHasKey(checkKeyVal, keyVals, enumLength) {
  if (checkKeyVal.key[0] < enumLength) {
    throw new Error("Use the method for your specific key instead of addUnknownKeyVal*");
  }
  if (keyVals && keyVals.filter(function (kv) {
    return tools.compare(kv.key, checkKeyVal.key) === 0;
  }).length !== 0) {
    throw new Error("Duplicate Key: ".concat(tools.toHex(checkKeyVal.key)));
  }
}
exports.checkHasKey = checkHasKey;
function getEnumLength(myenum) {
  var count = 0;
  Object.keys(myenum).forEach(function (val) {
    if (Number(isNaN(Number(val)))) {
      count++;
    }
  });
  return count;
}
exports.getEnumLength = getEnumLength;
function inputCheckUncleanFinalized(inputIndex, input) {
  var result = false;
  if (input.nonWitnessUtxo || input.witnessUtxo) {
    var needScriptSig = !!input.redeemScript;
    var needWitnessScript = !!input.witnessScript;
    var scriptSigOK = !needScriptSig || !!input.finalScriptSig;
    var witnessScriptOK = !needWitnessScript || !!input.finalScriptWitness;
    var hasOneFinal = !!input.finalScriptSig || !!input.finalScriptWitness;
    result = scriptSigOK && witnessScriptOK && hasOneFinal;
  }
  if (result === false) {
    throw new Error("Input #".concat(inputIndex, " has too much or too little data to clean"));
  }
}
exports.inputCheckUncleanFinalized = inputCheckUncleanFinalized;
function throwForUpdateMaker(typeName, name, expected, data) {
  throw new Error("Data for ".concat(typeName, " key ").concat(name, " is incorrect: Expected ") + "".concat(expected, " and got ").concat(JSON.stringify(data)));
}
function updateMaker(typeName) {
  return function (updateData, mainData) {
    var _loop = function _loop() {
      var name = _Object$keys[_i];
      // @ts-ignore
      var data = updateData[name];
      // @ts-ignore
      var _ref =
        // @ts-ignore
        converter[typeName + 's'][name] || {},
        canAdd = _ref.canAdd,
        canAddToArray = _ref.canAddToArray,
        check = _ref.check,
        expected = _ref.expected;
      var isArray = !!canAddToArray;
      // If unknown data. ignore and do not add
      if (check) {
        if (isArray) {
          if (!Array.isArray(data) ||
          // @ts-ignore
          mainData[name] && !Array.isArray(mainData[name])) {
            throw new Error("Key type ".concat(name, " must be an array"));
          }
          if (!data.every(check)) {
            throwForUpdateMaker(typeName, name, expected, data);
          }
          // @ts-ignore
          var arr = mainData[name] || [];
          var dupeCheckSet = new Set();
          if (!data.every(function (v) {
            return canAddToArray(arr, v, dupeCheckSet);
          })) {
            throw new Error('Can not add duplicate data to array');
          }
          // @ts-ignore
          mainData[name] = arr.concat(data);
        } else {
          if (!check(data)) {
            throwForUpdateMaker(typeName, name, expected, data);
          }
          if (!canAdd(mainData, data)) {
            throw new Error("Can not add duplicate data to ".concat(typeName));
          }
          // @ts-ignore
          mainData[name] = data;
        }
      }
    };
    // @ts-ignore
    for (var _i = 0, _Object$keys = Object.keys(updateData); _i < _Object$keys.length; _i++) {
      _loop();
    }
  };
}
exports.updateGlobal = updateMaker('global');
exports.updateInput = updateMaker('input');
exports.updateOutput = updateMaker('output');
function addInputAttributes(inputs, data) {
  var index = inputs.length - 1;
  var input = checkForInput(inputs, index);
  exports.updateInput(data, input);
}
exports.addInputAttributes = addInputAttributes;
function addOutputAttributes(outputs, data) {
  var index = outputs.length - 1;
  var output = checkForOutput(outputs, index);
  exports.updateOutput(data, output);
}
exports.addOutputAttributes = addOutputAttributes;
function defaultVersionSetter(version, txBuf) {
  if (!(txBuf instanceof Uint8Array) || txBuf.length < 4) {
    throw new Error('Set Version: Invalid Transaction');
  }
  tools.writeUInt32(txBuf, 0, version, 'LE');
  return txBuf;
}
exports.defaultVersionSetter = defaultVersionSetter;
function defaultLocktimeSetter(locktime, txBuf) {
  if (!(txBuf instanceof Uint8Array) || txBuf.length < 4) {
    throw new Error('Set Locktime: Invalid Transaction');
  }
  tools.writeUInt32(txBuf, txBuf.length - 4, locktime, 'LE');
  return txBuf;
}
exports.defaultLocktimeSetter = defaultLocktimeSetter;

},{"./converter/index.cjs":22,"uint8array-tools":18}],48:[function(require,module,exports){
"use strict";

function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }
function _possibleConstructorReturn(t, e) { if (e && ("object" == _typeof(e) || "function" == typeof e)) return e; if (void 0 !== e) throw new TypeError("Derived constructors may only return object or undefined"); return _assertThisInitialized(t); }
function _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); return e; }
function _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }
function _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }
function _inherits(t, e) { if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, "prototype", { writable: !1 }), e && _setPrototypeOf(t, e); }
function _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }
function _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function"); }
function _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }
function _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: !1 }), e; }
function _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
var __createBinding = void 0 && (void 0).__createBinding || (Object.create ? function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  var desc = Object.getOwnPropertyDescriptor(m, k);
  if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
    desc = {
      enumerable: true,
      get: function get() {
        return m[k];
      }
    };
  }
  Object.defineProperty(o, k2, desc);
} : function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  o[k2] = m[k];
});
var __setModuleDefault = void 0 && (void 0).__setModuleDefault || (Object.create ? function (o, v) {
  Object.defineProperty(o, "default", {
    enumerable: true,
    value: v
  });
} : function (o, v) {
  o["default"] = v;
});
var __importStar = void 0 && (void 0).__importStar || function (mod) {
  if (mod && mod.__esModule) return mod;
  var result = {};
  if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
  __setModuleDefault(result, mod);
  return result;
};
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.BIP32Factory = BIP32Factory;
var crypto = __importStar(require("./crypto.cjs"));
var testecc_js_1 = require("./testecc.cjs");
var base_1 = require("@scure/base");
var sha256_1 = require("@noble/hashes/sha256");
var v = __importStar(require("valibot"));
var types_js_1 = require("./types.cjs");
var wif = __importStar(require("wif"));
var tools = __importStar(require("uint8array-tools"));
var _bs58check = (0, base_1.base58check)(sha256_1.sha256);
var bs58check = {
  encode: function encode(data) {
    return _bs58check.encode(data);
  },
  decode: function decode(str) {
    return _bs58check.decode(str);
  }
};
function BIP32Factory(ecc) {
  (0, testecc_js_1.testEcc)(ecc);
  var BITCOIN = {
    messagePrefix: '\x18Bitcoin Signed Message:\n',
    bech32: 'bc',
    bip32: {
      "public": 0x0488b21e,
      "private": 0x0488ade4
    },
    pubKeyHash: 0x00,
    scriptHash: 0x05,
    wif: 0x80
  };
  var HIGHEST_BIT = 0x80000000;
  function toXOnly(pubKey) {
    return pubKey.length === 32 ? pubKey : pubKey.slice(1, 33);
  }
  var Bip32Signer = /*#__PURE__*/function () {
    function Bip32Signer(__D, __Q) {
      _classCallCheck(this, Bip32Signer);
      _defineProperty(this, "__D", void 0);
      _defineProperty(this, "__Q", void 0);
      _defineProperty(this, "lowR", false);
      this.__D = __D;
      this.__Q = __Q;
    }
    return _createClass(Bip32Signer, [{
      key: "publicKey",
      get: function get() {
        if (this.__Q === undefined) this.__Q = ecc.pointFromScalar(this.__D, true);
        return this.__Q;
      }
    }, {
      key: "privateKey",
      get: function get() {
        return this.__D;
      }
    }, {
      key: "sign",
      value: function sign(hash, lowR) {
        if (!this.privateKey) throw new Error('Missing private key');
        if (lowR === undefined) lowR = this.lowR;
        if (lowR === false) {
          return ecc.sign(hash, this.privateKey);
        } else {
          var sig = ecc.sign(hash, this.privateKey);
          var extraData = new Uint8Array(32);
          var counter = 0;
          // if first try is lowR, skip the loop
          // for second try and on, add extra entropy counting up
          while (sig[0] > 0x7f) {
            counter++;
            tools.writeUInt32(extraData, 0, counter, 'LE');
            sig = ecc.sign(hash, this.privateKey, extraData);
          }
          return sig;
        }
      }
    }, {
      key: "signSchnorr",
      value: function signSchnorr(hash) {
        if (!this.privateKey) throw new Error('Missing private key');
        if (!ecc.signSchnorr) throw new Error('signSchnorr not supported by ecc library');
        return ecc.signSchnorr(hash, this.privateKey);
      }
    }, {
      key: "verify",
      value: function verify(hash, signature) {
        return ecc.verify(hash, this.publicKey, signature);
      }
    }, {
      key: "verifySchnorr",
      value: function verifySchnorr(hash, signature) {
        if (!ecc.verifySchnorr) throw new Error('verifySchnorr not supported by ecc library');
        return ecc.verifySchnorr(hash, this.publicKey.subarray(1, 33), signature);
      }
    }]);
  }();
  var BIP32 = /*#__PURE__*/function (_Bip32Signer2) {
    function BIP32(__D, __Q, chainCode, network) {
      var _this;
      var __DEPTH = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 0;
      var __INDEX = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 0;
      var __PARENT_FINGERPRINT = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : 0x00000000;
      _classCallCheck(this, BIP32);
      _this = _callSuper(this, BIP32, [__D, __Q]);
      _defineProperty(_this, "chainCode", void 0);
      _defineProperty(_this, "network", void 0);
      _defineProperty(_this, "__DEPTH", void 0);
      _defineProperty(_this, "__INDEX", void 0);
      _defineProperty(_this, "__PARENT_FINGERPRINT", void 0);
      _this.chainCode = chainCode;
      _this.network = network;
      _this.__DEPTH = __DEPTH;
      _this.__INDEX = __INDEX;
      _this.__PARENT_FINGERPRINT = __PARENT_FINGERPRINT;
      v.parse(types_js_1.NetworkSchema, network);
      return _this;
    }
    _inherits(BIP32, _Bip32Signer2);
    return _createClass(BIP32, [{
      key: "depth",
      get: function get() {
        return this.__DEPTH;
      }
    }, {
      key: "index",
      get: function get() {
        return this.__INDEX;
      }
    }, {
      key: "parentFingerprint",
      get: function get() {
        return this.__PARENT_FINGERPRINT;
      }
    }, {
      key: "identifier",
      get: function get() {
        return crypto.hash160(this.publicKey);
      }
    }, {
      key: "fingerprint",
      get: function get() {
        return this.identifier.slice(0, 4);
      }
    }, {
      key: "compressed",
      get: function get() {
        return true;
      }
      // Private === not neutered
      // Public === neutered
    }, {
      key: "isNeutered",
      value: function isNeutered() {
        return this.__D === undefined;
      }
    }, {
      key: "neutered",
      value: function neutered() {
        return fromPublicKeyLocal(this.publicKey, this.chainCode, this.network, this.depth, this.index, this.parentFingerprint);
      }
    }, {
      key: "toBase58",
      value: function toBase58() {
        var network = this.network;
        var version = !this.isNeutered() ? network.bip32["private"] : network.bip32["public"];
        var buffer = new Uint8Array(78);
        // 4 bytes: version bytes
        tools.writeUInt32(buffer, 0, version, 'BE');
        // 1 byte: depth: 0x00 for master nodes, 0x01 for level-1 descendants, ....
        tools.writeUInt8(buffer, 4, this.depth);
        // 4 bytes: the fingerprint of the parent's key (0x00000000 if master key)
        tools.writeUInt32(buffer, 5, this.parentFingerprint, 'BE');
        // 4 bytes: child number. This is the number i in xi = xpar/i, with xi the key being serialized.
        // This is encoded in big endian. (0x00000000 if master key)
        tools.writeUInt32(buffer, 9, this.index, 'BE');
        // 32 bytes: the chain code
        buffer.set(this.chainCode, 13);
        // 33 bytes: the public key or private key data
        if (!this.isNeutered()) {
          // 0x00 + k for private keys
          tools.writeUInt8(buffer, 45, 0);
          buffer.set(this.privateKey, 46);
          // 33 bytes: the public key
        } else {
          // X9.62 encoding for public keys
          buffer.set(this.publicKey, 45);
        }
        return bs58check.encode(buffer);
      }
    }, {
      key: "toWIF",
      value: function toWIF() {
        if (!this.privateKey) throw new TypeError('Missing private key');
        return wif.encode({
          version: this.network.wif,
          privateKey: this.privateKey,
          compressed: true
        });
      }
      // https://github.com/bitcoin/bips/blob/master/bip-0032.mediawiki#child-key-derivation-ckd-functions
    }, {
      key: "derive",
      value: function derive(index) {
        v.parse(types_js_1.Uint32Schema, index);
        var isHardened = index >= HIGHEST_BIT;
        var data = new Uint8Array(37);
        // Hardened child
        if (isHardened) {
          if (this.isNeutered()) throw new TypeError('Missing private key for hardened child key');
          // data = 0x00 || ser256(kpar) || ser32(index)
          data[0] = 0x00;
          data.set(this.privateKey, 1);
          tools.writeUInt32(data, 33, index, 'BE');
          // Normal child
        } else {
          // data = serP(point(kpar)) || ser32(index)
          //      = serP(Kpar) || ser32(index)
          data.set(this.publicKey, 0);
          tools.writeUInt32(data, 33, index, 'BE');
        }
        var I = crypto.hmacSHA512(this.chainCode, data);
        var IL = I.slice(0, 32);
        var IR = I.slice(32);
        // if parse256(IL) >= n, proceed with the next value for i
        if (!ecc.isPrivate(IL)) return this.derive(index + 1);
        // Private parent key -> private child key
        var hd;
        if (!this.isNeutered()) {
          // ki = parse256(IL) + kpar (mod n)
          var ki = ecc.privateAdd(this.privateKey, IL);
          // In case ki == 0, proceed with the next value for i
          if (ki == null) return this.derive(index + 1);
          hd = fromPrivateKeyLocal(ki, IR, this.network, this.depth + 1, index, tools.readUInt32(this.fingerprint, 0, 'BE'));
          // Public parent key -> public child key
        } else {
          // Ki = point(parse256(IL)) + Kpar
          //    = G*IL + Kpar
          var Ki = ecc.pointAddScalar(this.publicKey, IL, true);
          // In case Ki is the point at infinity, proceed with the next value for i
          if (Ki === null) return this.derive(index + 1);
          hd = fromPublicKeyLocal(Ki, IR, this.network, this.depth + 1, index, tools.readUInt32(this.fingerprint, 0, 'BE'));
        }
        return hd;
      }
    }, {
      key: "deriveHardened",
      value: function deriveHardened(index) {
        if (typeof v.parse(types_js_1.Uint31Schema, index) === 'number')
          // Only derives hardened private keys by default
          return this.derive(index + HIGHEST_BIT);
        throw new TypeError('Expected UInt31, got ' + index);
      }
    }, {
      key: "derivePath",
      value: function derivePath(path) {
        v.parse(types_js_1.Bip32PathSchema, path);
        var splitPath = path.split('/');
        if (splitPath[0] === 'm') {
          if (this.parentFingerprint) throw new TypeError('Expected master, got child');
          splitPath = splitPath.slice(1);
        }
        return splitPath.reduce(function (prevHd, indexStr) {
          var index;
          if (indexStr.slice(-1) === "'") {
            index = parseInt(indexStr.slice(0, -1), 10);
            return prevHd.deriveHardened(index);
          } else {
            index = parseInt(indexStr, 10);
            return prevHd.derive(index);
          }
        }, this);
      }
    }, {
      key: "tweak",
      value: function tweak(t) {
        if (this.privateKey) return this.tweakFromPrivateKey(t);
        return this.tweakFromPublicKey(t);
      }
    }, {
      key: "tweakFromPublicKey",
      value: function tweakFromPublicKey(t) {
        var xOnlyPubKey = toXOnly(this.publicKey);
        if (!ecc.xOnlyPointAddTweak) throw new Error('xOnlyPointAddTweak not supported by ecc library');
        var tweakedPublicKey = ecc.xOnlyPointAddTweak(xOnlyPubKey, t);
        if (!tweakedPublicKey || tweakedPublicKey.xOnlyPubkey === null) throw new Error('Cannot tweak public key!');
        var parityByte = Uint8Array.from([tweakedPublicKey.parity === 0 ? 0x02 : 0x03]);
        var tweakedPublicKeyCompresed = tools.concat([parityByte, tweakedPublicKey.xOnlyPubkey]);
        return new Bip32Signer(undefined, tweakedPublicKeyCompresed);
      }
    }, {
      key: "tweakFromPrivateKey",
      value: function tweakFromPrivateKey(t) {
        var _this2 = this;
        var hasOddY = this.publicKey[0] === 3 || this.publicKey[0] === 4 && (this.publicKey[64] & 1) === 1;
        var privateKey = function () {
          if (!hasOddY) return _this2.privateKey;else if (!ecc.privateNegate) throw new Error('privateNegate not supported by ecc library');else return ecc.privateNegate(_this2.privateKey);
        }();
        var tweakedPrivateKey = ecc.privateAdd(privateKey, t);
        if (!tweakedPrivateKey) throw new Error('Invalid tweaked private key!');
        return new Bip32Signer(tweakedPrivateKey, undefined);
      }
    }]);
  }(Bip32Signer);
  function fromBase58(inString, network) {
    var buffer = bs58check.decode(inString);
    if (buffer.length !== 78) throw new TypeError('Invalid buffer length');
    network = network || BITCOIN;
    // 4 bytes: version bytes
    var version = tools.readUInt32(buffer, 0, 'BE');
    if (version !== network.bip32["private"] && version !== network.bip32["public"]) throw new TypeError('Invalid network version');
    // 1 byte: depth: 0x00 for master nodes, 0x01 for level-1 descendants, ...
    var depth = buffer[4];
    // 4 bytes: the fingerprint of the parent's key (0x00000000 if master key)
    var parentFingerprint = tools.readUInt32(buffer, 5, 'BE');
    if (depth === 0) {
      if (parentFingerprint !== 0x00000000) throw new TypeError('Invalid parent fingerprint');
    }
    // 4 bytes: child number. This is the number i in xi = xpar/i, with xi the key being serialized.
    // This is encoded in MSB order. (0x00000000 if master key)
    var index = tools.readUInt32(buffer, 9, 'BE');
    if (depth === 0 && index !== 0) throw new TypeError('Invalid index');
    // 32 bytes: the chain code
    var chainCode = buffer.slice(13, 45);
    var hd;
    // 33 bytes: private key data (0x00 + k)
    if (version === network.bip32["private"]) {
      if (buffer[45] !== 0x00) throw new TypeError('Invalid private key');
      var k = buffer.slice(46, 78);
      hd = fromPrivateKeyLocal(k, chainCode, network, depth, index, parentFingerprint);
      // 33 bytes: public key data (0x02 + X or 0x03 + X)
    } else {
      var X = buffer.slice(45, 78);
      hd = fromPublicKeyLocal(X, chainCode, network, depth, index, parentFingerprint);
    }
    return hd;
  }
  function fromPrivateKey(privateKey, chainCode, network) {
    return fromPrivateKeyLocal(privateKey, chainCode, network);
  }
  function fromPrivateKeyLocal(privateKey, chainCode, network, depth, index, parentFingerprint) {
    v.parse(types_js_1.Buffer256Bit, privateKey);
    v.parse(types_js_1.Buffer256Bit, chainCode);
    network = network || BITCOIN;
    if (!ecc.isPrivate(privateKey)) throw new TypeError('Private key not in range [1, n)');
    return new BIP32(privateKey, undefined, chainCode, network, depth, index, parentFingerprint);
  }
  function fromPublicKey(publicKey, chainCode, network) {
    return fromPublicKeyLocal(publicKey, chainCode, network);
  }
  function fromPublicKeyLocal(publicKey, chainCode, network, depth, index, parentFingerprint) {
    v.parse(types_js_1.Buffer33Bytes, publicKey);
    v.parse(types_js_1.Buffer256Bit, chainCode);
    network = network || BITCOIN;
    // verify the X coordinate is a point on the curve
    if (!ecc.isPoint(publicKey)) throw new TypeError('Point is not on the curve');
    return new BIP32(undefined, publicKey, chainCode, network, depth, index, parentFingerprint);
  }
  function fromSeed(seed, network) {
    v.parse(v.instance(Uint8Array), seed);
    if (seed.length < 16) throw new TypeError('Seed should be at least 128 bits');
    if (seed.length > 64) throw new TypeError('Seed should be at most 512 bits');
    network = network || BITCOIN;
    var I = crypto.hmacSHA512(tools.fromUtf8('Bitcoin seed'), seed);
    var IL = I.slice(0, 32);
    var IR = I.slice(32);
    return fromPrivateKey(IL, IR, network);
  }
  return {
    fromSeed: fromSeed,
    fromBase58: fromBase58,
    fromPublicKey: fromPublicKey,
    fromPrivateKey: fromPrivateKey
  };
}

},{"./crypto.cjs":49,"./testecc.cjs":51,"./types.cjs":52,"@noble/hashes/sha256":11,"@scure/base":14,"uint8array-tools":107,"valibot":108,"wif":110}],49:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.hash160 = hash160;
exports.hmacSHA512 = hmacSHA512;
var hmac_1 = require("@noble/hashes/hmac");
var ripemd160_1 = require("@noble/hashes/ripemd160");
var sha256_1 = require("@noble/hashes/sha256");
var sha512_1 = require("@noble/hashes/sha512");
function hash160(buffer) {
  return (0, ripemd160_1.ripemd160)((0, sha256_1.sha256)(buffer));
}
function hmacSHA512(key, data) {
  return (0, hmac_1.hmac)(sha512_1.sha512, key, data);
}

},{"@noble/hashes/hmac":8,"@noble/hashes/ripemd160":10,"@noble/hashes/sha256":11,"@noble/hashes/sha512":12}],50:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.BIP32Factory = exports["default"] = void 0;
var bip32_js_1 = require("./bip32.cjs");
Object.defineProperty(exports, "default", {
  enumerable: true,
  get: function get() {
    return bip32_js_1.BIP32Factory;
  }
});
Object.defineProperty(exports, "BIP32Factory", {
  enumerable: true,
  get: function get() {
    return bip32_js_1.BIP32Factory;
  }
});

},{"./bip32.cjs":48}],51:[function(require,module,exports){
"use strict";

var __createBinding = void 0 && (void 0).__createBinding || (Object.create ? function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  var desc = Object.getOwnPropertyDescriptor(m, k);
  if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
    desc = {
      enumerable: true,
      get: function get() {
        return m[k];
      }
    };
  }
  Object.defineProperty(o, k2, desc);
} : function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  o[k2] = m[k];
});
var __setModuleDefault = void 0 && (void 0).__setModuleDefault || (Object.create ? function (o, v) {
  Object.defineProperty(o, "default", {
    enumerable: true,
    value: v
  });
} : function (o, v) {
  o["default"] = v;
});
var __importStar = void 0 && (void 0).__importStar || function (mod) {
  if (mod && mod.__esModule) return mod;
  var result = {};
  if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
  __setModuleDefault(result, mod);
  return result;
};
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.testEcc = testEcc;
var tools = __importStar(require("uint8array-tools"));
var h = function h(hex) {
  return tools.fromHex(hex);
};
function testEcc(ecc) {
  assert(ecc.isPoint(h('0279be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798')));
  assert(!ecc.isPoint(h('030000000000000000000000000000000000000000000000000000000000000005')));
  assert(ecc.isPrivate(h('79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798')));
  // order - 1
  assert(ecc.isPrivate(h('fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364140')));
  // 0
  assert(!ecc.isPrivate(h('0000000000000000000000000000000000000000000000000000000000000000')));
  // order
  assert(!ecc.isPrivate(h('fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141')));
  // order + 1
  assert(!ecc.isPrivate(h('fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364142')));
  assert(tools.compare(ecc.pointFromScalar(h('b1121e4088a66a28f5b6b0f5844943ecd9f610196d7bb83b25214b60452c09af')), h('02b07ba9dca9523b7ef4bd97703d43d20399eb698e194704791a25ce77a400df99')) === 0);
  if (ecc.xOnlyPointAddTweak) {
    assert(ecc.xOnlyPointAddTweak(h('79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798'), h('fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364140')) === null);
    var xOnlyRes = ecc.xOnlyPointAddTweak(h('1617d38ed8d8657da4d4761e8057bc396ea9e4b9d29776d4be096016dbd2509b'), h('a8397a935f0dfceba6ba9618f6451ef4d80637abf4e6af2669fbc9de6a8fd2ac'));
    assert(tools.compare(xOnlyRes.xOnlyPubkey, h('e478f99dab91052ab39a33ea35fd5e6e4933f4d28023cd597c9a1f6760346adf')) === 0 && xOnlyRes.parity === 1);
    xOnlyRes = ecc.xOnlyPointAddTweak(h('2c0b7cf95324a07d05398b240174dc0c2be444d96b159aa6c7f7b1e668680991'), h('823c3cd2142744b075a87eade7e1b8678ba308d566226a0056ca2b7a76f86b47'));
  }
  assert(tools.compare(ecc.pointAddScalar(h('0379be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798'), h('0000000000000000000000000000000000000000000000000000000000000003')), h('02c6047f9441ed7d6d3045406e95c07cd85c778e4b8cef3ca7abac09b95c709ee5')) === 0);
  assert(tools.compare(ecc.privateAdd(h('fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd036413e'), h('0000000000000000000000000000000000000000000000000000000000000002')), h('fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364140')) === 0);
  if (ecc.privateNegate) {
    assert(tools.compare(ecc.privateNegate(h('0000000000000000000000000000000000000000000000000000000000000001')), h('fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364140')) === 0);
    assert(tools.compare(ecc.privateNegate(h('fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd036413e')), h('0000000000000000000000000000000000000000000000000000000000000003')) === 0);
    assert(tools.compare(ecc.privateNegate(h('b1121e4088a66a28f5b6b0f5844943ecd9f610196d7bb83b25214b60452c09af')), h('4eede1bf775995d70a494f0a7bb6bc11e0b8cccd41cce8009ab1132c8b0a3792')) === 0);
  }
  assert(tools.compare(ecc.sign(h('5e9f0a0d593efdcf78ac923bc3313e4e7d408d574354ee2b3288c0da9fbba6ed'), h('fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364140')), h('54c4a33c6423d689378f160a7ff8b61330444abb58fb470f96ea16d99d4a2fed07082304410efa6b2943111b6a4e0aaa7b7db55a07e9861d1fb3cb1f421044a5')) === 0);
  assert(ecc.verify(h('5e9f0a0d593efdcf78ac923bc3313e4e7d408d574354ee2b3288c0da9fbba6ed'), h('0379be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798'), h('54c4a33c6423d689378f160a7ff8b61330444abb58fb470f96ea16d99d4a2fed07082304410efa6b2943111b6a4e0aaa7b7db55a07e9861d1fb3cb1f421044a5')));
  if (ecc.signSchnorr) {
    assert(tools.compare(ecc.signSchnorr(h('7e2d58d8b3bcdf1abadec7829054f90dda9805aab56c77333024b9d0a508b75c'), h('c90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b14e5c9'), h('c87aa53824b4d7ae2eb035a2b5bbbccc080e76cdc6d1692c4b0b62d798e6d906')), h('5831aaeed7b44bb74e5eab94ba9d4294c49bcf2a60728d8b4c200f50dd313c1bab745879a5ad954a72c45a91c3a51d3c7adea98d82f8481e0e1e03674a6f3fb7')) === 0);
  }
  if (ecc.verifySchnorr) {
    assert(ecc.verifySchnorr(h('7e2d58d8b3bcdf1abadec7829054f90dda9805aab56c77333024b9d0a508b75c'), h('dd308afec5777e13121fa72b9cc1b7cc0139715309b086c960e18fd969774eb8'), h('5831aaeed7b44bb74e5eab94ba9d4294c49bcf2a60728d8b4c200f50dd313c1bab745879a5ad954a72c45a91c3a51d3c7adea98d82f8481e0e1e03674a6f3fb7')));
  }
}
function assert(bool) {
  if (!bool) throw new Error('ecc library invalid');
}

},{"uint8array-tools":107}],52:[function(require,module,exports){
"use strict";

var __createBinding = void 0 && (void 0).__createBinding || (Object.create ? function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  var desc = Object.getOwnPropertyDescriptor(m, k);
  if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
    desc = {
      enumerable: true,
      get: function get() {
        return m[k];
      }
    };
  }
  Object.defineProperty(o, k2, desc);
} : function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  o[k2] = m[k];
});
var __setModuleDefault = void 0 && (void 0).__setModuleDefault || (Object.create ? function (o, v) {
  Object.defineProperty(o, "default", {
    enumerable: true,
    value: v
  });
} : function (o, v) {
  o["default"] = v;
});
var __importStar = void 0 && (void 0).__importStar || function (mod) {
  if (mod && mod.__esModule) return mod;
  var result = {};
  if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
  __setModuleDefault(result, mod);
  return result;
};
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Bip32PathSchema = exports.NetworkSchema = exports.Buffer33Bytes = exports.Buffer256Bit = exports.Uint31Schema = exports.Uint32Schema = void 0;
var v = __importStar(require("valibot"));
exports.Uint32Schema = v.pipe(v.number(), v.integer(), v.minValue(0), v.maxValue(0xffffffff));
exports.Uint31Schema = v.pipe(v.number(), v.integer(), v.minValue(0), v.maxValue(0x7fffffff));
var Uint8Schema = v.pipe(v.number(), v.integer(), v.minValue(0), v.maxValue(0xff));
exports.Buffer256Bit = v.pipe(v.instance(Uint8Array), v.length(32));
exports.Buffer33Bytes = v.pipe(v.instance(Uint8Array), v.length(33));
exports.NetworkSchema = v.object({
  wif: Uint8Schema,
  bip32: v.object({
    "public": exports.Uint32Schema,
    "private": exports.Uint32Schema
  })
});
exports.Bip32PathSchema = v.pipe(v.string(), v.regex(/^(m\/)?(\d+'?\/)*\d+'?$/));

},{"valibot":108}],53:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
// browserify by default only pulls in files that are hard coded in requires
// In order of last to first in this file, the default wordlist will be chosen
// based on what is present. (Bundles may remove wordlists they don't need)
var wordlists = {};
exports.wordlists = wordlists;
var _default;
exports._default = _default;
try {
  exports._default = _default = require('./wordlists/czech.json');
  wordlists.czech = _default;
} catch (err) {}
try {
  exports._default = _default = require('./wordlists/chinese_simplified.json');
  wordlists.chinese_simplified = _default;
} catch (err) {}
try {
  exports._default = _default = require('./wordlists/chinese_traditional.json');
  wordlists.chinese_traditional = _default;
} catch (err) {}
try {
  exports._default = _default = require('./wordlists/korean.json');
  wordlists.korean = _default;
} catch (err) {}
try {
  exports._default = _default = require('./wordlists/french.json');
  wordlists.french = _default;
} catch (err) {}
try {
  exports._default = _default = require('./wordlists/italian.json');
  wordlists.italian = _default;
} catch (err) {}
try {
  exports._default = _default = require('./wordlists/spanish.json');
  wordlists.spanish = _default;
} catch (err) {}
try {
  exports._default = _default = require('./wordlists/japanese.json');
  wordlists.japanese = _default;
  wordlists.JA = _default;
} catch (err) {}
try {
  exports._default = _default = require('./wordlists/portuguese.json');
  wordlists.portuguese = _default;
} catch (err) {}
try {
  exports._default = _default = require('./wordlists/english.json');
  wordlists.english = _default;
  wordlists.EN = _default;
} catch (err) {}

},{"./wordlists/chinese_simplified.json":55,"./wordlists/chinese_traditional.json":56,"./wordlists/czech.json":57,"./wordlists/english.json":58,"./wordlists/french.json":59,"./wordlists/italian.json":60,"./wordlists/japanese.json":61,"./wordlists/korean.json":62,"./wordlists/portuguese.json":63,"./wordlists/spanish.json":64}],54:[function(require,module,exports){
(function (Buffer){(function (){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
var sha256_1 = require("@noble/hashes/sha256");
var sha512_1 = require("@noble/hashes/sha512");
var pbkdf2_1 = require("@noble/hashes/pbkdf2");
var utils_1 = require("@noble/hashes/utils");
var _wordlists_1 = require("./_wordlists");
var DEFAULT_WORDLIST = _wordlists_1._default;
var INVALID_MNEMONIC = 'Invalid mnemonic';
var INVALID_ENTROPY = 'Invalid entropy';
var INVALID_CHECKSUM = 'Invalid mnemonic checksum';
var WORDLIST_REQUIRED = 'A wordlist is required but a default could not be found.\n' + 'Please pass a 2048 word array explicitly.';
function normalize(str) {
  return (str || '').normalize('NFKD');
}
function lpad(str, padString, length) {
  while (str.length < length) {
    str = padString + str;
  }
  return str;
}
function binaryToByte(bin) {
  return parseInt(bin, 2);
}
function bytesToBinary(bytes) {
  return bytes.map(function (x) {
    return lpad(x.toString(2), '0', 8);
  }).join('');
}
function deriveChecksumBits(entropyBuffer) {
  var ENT = entropyBuffer.length * 8;
  var CS = ENT / 32;
  var hash = sha256_1.sha256(Uint8Array.from(entropyBuffer));
  return bytesToBinary(Array.from(hash)).slice(0, CS);
}
function salt(password) {
  return 'mnemonic' + (password || '');
}
function mnemonicToSeedSync(mnemonic, password) {
  var mnemonicBuffer = Uint8Array.from(Buffer.from(normalize(mnemonic), 'utf8'));
  var saltBuffer = Uint8Array.from(Buffer.from(salt(normalize(password)), 'utf8'));
  var res = pbkdf2_1.pbkdf2(sha512_1.sha512, mnemonicBuffer, saltBuffer, {
    c: 2048,
    dkLen: 64
  });
  return Buffer.from(res);
}
exports.mnemonicToSeedSync = mnemonicToSeedSync;
function mnemonicToSeed(mnemonic, password) {
  var mnemonicBuffer = Uint8Array.from(Buffer.from(normalize(mnemonic), 'utf8'));
  var saltBuffer = Uint8Array.from(Buffer.from(salt(normalize(password)), 'utf8'));
  return pbkdf2_1.pbkdf2Async(sha512_1.sha512, mnemonicBuffer, saltBuffer, {
    c: 2048,
    dkLen: 64
  }).then(function (res) {
    return Buffer.from(res);
  });
}
exports.mnemonicToSeed = mnemonicToSeed;
function mnemonicToEntropy(mnemonic, wordlist) {
  wordlist = wordlist || DEFAULT_WORDLIST;
  if (!wordlist) {
    throw new Error(WORDLIST_REQUIRED);
  }
  var words = normalize(mnemonic).split(' ');
  if (words.length % 3 !== 0) {
    throw new Error(INVALID_MNEMONIC);
  }
  // convert word indices to 11 bit binary strings
  var bits = words.map(function (word) {
    var index = wordlist.indexOf(word);
    if (index === -1) {
      throw new Error(INVALID_MNEMONIC);
    }
    return lpad(index.toString(2), '0', 11);
  }).join('');
  // split the binary string into ENT/CS
  var dividerIndex = Math.floor(bits.length / 33) * 32;
  var entropyBits = bits.slice(0, dividerIndex);
  var checksumBits = bits.slice(dividerIndex);
  // calculate the checksum and compare
  var entropyBytes = entropyBits.match(/(.{1,8})/g).map(binaryToByte);
  if (entropyBytes.length < 16) {
    throw new Error(INVALID_ENTROPY);
  }
  if (entropyBytes.length > 32) {
    throw new Error(INVALID_ENTROPY);
  }
  if (entropyBytes.length % 4 !== 0) {
    throw new Error(INVALID_ENTROPY);
  }
  var entropy = Buffer.from(entropyBytes);
  var newChecksum = deriveChecksumBits(entropy);
  if (newChecksum !== checksumBits) {
    throw new Error(INVALID_CHECKSUM);
  }
  return entropy.toString('hex');
}
exports.mnemonicToEntropy = mnemonicToEntropy;
function entropyToMnemonic(entropy, wordlist) {
  if (!Buffer.isBuffer(entropy)) {
    entropy = Buffer.from(entropy, 'hex');
  }
  wordlist = wordlist || DEFAULT_WORDLIST;
  if (!wordlist) {
    throw new Error(WORDLIST_REQUIRED);
  }
  // 128 <= ENT <= 256
  if (entropy.length < 16) {
    throw new TypeError(INVALID_ENTROPY);
  }
  if (entropy.length > 32) {
    throw new TypeError(INVALID_ENTROPY);
  }
  if (entropy.length % 4 !== 0) {
    throw new TypeError(INVALID_ENTROPY);
  }
  var entropyBits = bytesToBinary(Array.from(entropy));
  var checksumBits = deriveChecksumBits(entropy);
  var bits = entropyBits + checksumBits;
  var chunks = bits.match(/(.{1,11})/g);
  var words = chunks.map(function (binary) {
    var index = binaryToByte(binary);
    return wordlist[index];
  });
  return wordlist[0] === "\u3042\u3044\u3053\u304F\u3057\u3093" // Japanese wordlist
  ? words.join("\u3000") : words.join(' ');
}
exports.entropyToMnemonic = entropyToMnemonic;
function generateMnemonic(strength, rng, wordlist) {
  strength = strength || 128;
  if (strength % 32 !== 0) {
    throw new TypeError(INVALID_ENTROPY);
  }
  rng = rng || function (size) {
    return Buffer.from(utils_1.randomBytes(size));
  };
  return entropyToMnemonic(rng(strength / 8), wordlist);
}
exports.generateMnemonic = generateMnemonic;
function validateMnemonic(mnemonic, wordlist) {
  try {
    mnemonicToEntropy(mnemonic, wordlist);
  } catch (e) {
    return false;
  }
  return true;
}
exports.validateMnemonic = validateMnemonic;
function setDefaultWordlist(language) {
  var result = _wordlists_1.wordlists[language];
  if (result) {
    DEFAULT_WORDLIST = result;
  } else {
    throw new Error('Could not find wordlist for language "' + language + '"');
  }
}
exports.setDefaultWordlist = setDefaultWordlist;
function getDefaultWordlist() {
  if (!DEFAULT_WORDLIST) {
    throw new Error('No Default Wordlist set');
  }
  return Object.keys(_wordlists_1.wordlists).filter(function (lang) {
    if (lang === 'JA' || lang === 'EN') {
      return false;
    }
    return _wordlists_1.wordlists[lang].every(function (word, index) {
      return word === DEFAULT_WORDLIST[index];
    });
  })[0];
}
exports.getDefaultWordlist = getDefaultWordlist;
var _wordlists_2 = require("./_wordlists");
exports.wordlists = _wordlists_2.wordlists;

}).call(this)}).call(this,require("buffer").Buffer)
},{"./_wordlists":53,"@noble/hashes/pbkdf2":9,"@noble/hashes/sha256":11,"@noble/hashes/sha512":12,"@noble/hashes/utils":13,"buffer":"buffer"}],55:[function(require,module,exports){
module.exports=[
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    ""
]

},{}],56:[function(require,module,exports){
module.exports=[
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    ""
]

},{}],57:[function(require,module,exports){
module.exports=[
    "abdikace",
    "abeceda",
    "adresa",
    "agrese",
    "akce",
    "aktovka",
    "alej",
    "alkohol",
    "amputace",
    "ananas",
    "andulka",
    "anekdota",
    "anketa",
    "antika",
    "anulovat",
    "archa",
    "arogance",
    "asfalt",
    "asistent",
    "aspirace",
    "astma",
    "astronom",
    "atlas",
    "atletika",
    "atol",
    "autobus",
    "azyl",
    "babka",
    "bachor",
    "bacil",
    "baculka",
    "badatel",
    "bageta",
    "bagr",
    "bahno",
    "bakterie",
    "balada",
    "baletka",
    "balkon",
    "balonek",
    "balvan",
    "balza",
    "bambus",
    "bankomat",
    "barbar",
    "baret",
    "barman",
    "baroko",
    "barva",
    "baterka",
    "batoh",
    "bavlna",
    "bazalka",
    "bazilika",
    "bazuka",
    "bedna",
    "beran",
    "beseda",
    "bestie",
    "beton",
    "bezinka",
    "bezmoc",
    "beztak",
    "bicykl",
    "bidlo",
    "biftek",
    "bikiny",
    "bilance",
    "biograf",
    "biolog",
    "bitva",
    "bizon",
    "blahobyt",
    "blatouch",
    "blecha",
    "bledule",
    "blesk",
    "blikat",
    "blizna",
    "blokovat",
    "bloudit",
    "blud",
    "bobek",
    "bobr",
    "bodlina",
    "bodnout",
    "bohatost",
    "bojkot",
    "bojovat",
    "bokorys",
    "bolest",
    "borec",
    "borovice",
    "bota",
    "boubel",
    "bouchat",
    "bouda",
    "boule",
    "bourat",
    "boxer",
    "bradavka",
    "brambora",
    "branka",
    "bratr",
    "brepta",
    "briketa",
    "brko",
    "brloh",
    "bronz",
    "broskev",
    "brunetka",
    "brusinka",
    "brzda",
    "brzy",
    "bublina",
    "bubnovat",
    "buchta",
    "buditel",
    "budka",
    "budova",
    "bufet",
    "bujarost",
    "bukvice",
    "buldok",
    "bulva",
    "bunda",
    "bunkr",
    "burza",
    "butik",
    "buvol",
    "buzola",
    "bydlet",
    "bylina",
    "bytovka",
    "bzukot",
    "capart",
    "carevna",
    "cedr",
    "cedule",
    "cejch",
    "cejn",
    "cela",
    "celer",
    "celkem",
    "celnice",
    "cenina",
    "cennost",
    "cenovka",
    "centrum",
    "cenzor",
    "cestopis",
    "cetka",
    "chalupa",
    "chapadlo",
    "charita",
    "chata",
    "chechtat",
    "chemie",
    "chichot",
    "chirurg",
    "chlad",
    "chleba",
    "chlubit",
    "chmel",
    "chmura",
    "chobot",
    "chochol",
    "chodba",
    "cholera",
    "chomout",
    "chopit",
    "choroba",
    "chov",
    "chrapot",
    "chrlit",
    "chrt",
    "chrup",
    "chtivost",
    "chudina",
    "chutnat",
    "chvat",
    "chvilka",
    "chvost",
    "chyba",
    "chystat",
    "chytit",
    "cibule",
    "cigareta",
    "cihelna",
    "cihla",
    "cinkot",
    "cirkus",
    "cisterna",
    "citace",
    "citrus",
    "cizinec",
    "cizost",
    "clona",
    "cokoliv",
    "couvat",
    "ctitel",
    "ctnost",
    "cudnost",
    "cuketa",
    "cukr",
    "cupot",
    "cvaknout",
    "cval",
    "cvik",
    "cvrkot",
    "cyklista",
    "daleko",
    "dareba",
    "datel",
    "datum",
    "dcera",
    "debata",
    "dechovka",
    "decibel",
    "deficit",
    "deflace",
    "dekl",
    "dekret",
    "demokrat",
    "deprese",
    "derby",
    "deska",
    "detektiv",
    "dikobraz",
    "diktovat",
    "dioda",
    "diplom",
    "disk",
    "displej",
    "divadlo",
    "divoch",
    "dlaha",
    "dlouho",
    "dluhopis",
    "dnes",
    "dobro",
    "dobytek",
    "docent",
    "dochutit",
    "dodnes",
    "dohled",
    "dohoda",
    "dohra",
    "dojem",
    "dojnice",
    "doklad",
    "dokola",
    "doktor",
    "dokument",
    "dolar",
    "doleva",
    "dolina",
    "doma",
    "dominant",
    "domluvit",
    "domov",
    "donutit",
    "dopad",
    "dopis",
    "doplnit",
    "doposud",
    "doprovod",
    "dopustit",
    "dorazit",
    "dorost",
    "dort",
    "dosah",
    "doslov",
    "dostatek",
    "dosud",
    "dosyta",
    "dotaz",
    "dotek",
    "dotknout",
    "doufat",
    "doutnat",
    "dovozce",
    "dozadu",
    "doznat",
    "dozorce",
    "drahota",
    "drak",
    "dramatik",
    "dravec",
    "draze",
    "drdol",
    "drobnost",
    "drogerie",
    "drozd",
    "drsnost",
    "drtit",
    "drzost",
    "duben",
    "duchovno",
    "dudek",
    "duha",
    "duhovka",
    "dusit",
    "dusno",
    "dutost",
    "dvojice",
    "dvorec",
    "dynamit",
    "ekolog",
    "ekonomie",
    "elektron",
    "elipsa",
    "email",
    "emise",
    "emoce",
    "empatie",
    "epizoda",
    "epocha",
    "epopej",
    "epos",
    "esej",
    "esence",
    "eskorta",
    "eskymo",
    "etiketa",
    "euforie",
    "evoluce",
    "exekuce",
    "exkurze",
    "expedice",
    "exploze",
    "export",
    "extrakt",
    "facka",
    "fajfka",
    "fakulta",
    "fanatik",
    "fantazie",
    "farmacie",
    "favorit",
    "fazole",
    "federace",
    "fejeton",
    "fenka",
    "fialka",
    "figurant",
    "filozof",
    "filtr",
    "finance",
    "finta",
    "fixace",
    "fjord",
    "flanel",
    "flirt",
    "flotila",
    "fond",
    "fosfor",
    "fotbal",
    "fotka",
    "foton",
    "frakce",
    "freska",
    "fronta",
    "fukar",
    "funkce",
    "fyzika",
    "galeje",
    "garant",
    "genetika",
    "geolog",
    "gilotina",
    "glazura",
    "glejt",
    "golem",
    "golfista",
    "gotika",
    "graf",
    "gramofon",
    "granule",
    "grep",
    "gril",
    "grog",
    "groteska",
    "guma",
    "hadice",
    "hadr",
    "hala",
    "halenka",
    "hanba",
    "hanopis",
    "harfa",
    "harpuna",
    "havran",
    "hebkost",
    "hejkal",
    "hejno",
    "hejtman",
    "hektar",
    "helma",
    "hematom",
    "herec",
    "herna",
    "heslo",
    "hezky",
    "historik",
    "hladovka",
    "hlasivky",
    "hlava",
    "hledat",
    "hlen",
    "hlodavec",
    "hloh",
    "hloupost",
    "hltat",
    "hlubina",
    "hluchota",
    "hmat",
    "hmota",
    "hmyz",
    "hnis",
    "hnojivo",
    "hnout",
    "hoblina",
    "hoboj",
    "hoch",
    "hodiny",
    "hodlat",
    "hodnota",
    "hodovat",
    "hojnost",
    "hokej",
    "holinka",
    "holka",
    "holub",
    "homole",
    "honitba",
    "honorace",
    "horal",
    "horda",
    "horizont",
    "horko",
    "horlivec",
    "hormon",
    "hornina",
    "horoskop",
    "horstvo",
    "hospoda",
    "hostina",
    "hotovost",
    "houba",
    "houf",
    "houpat",
    "houska",
    "hovor",
    "hradba",
    "hranice",
    "hravost",
    "hrazda",
    "hrbolek",
    "hrdina",
    "hrdlo",
    "hrdost",
    "hrnek",
    "hrobka",
    "hromada",
    "hrot",
    "hrouda",
    "hrozen",
    "hrstka",
    "hrubost",
    "hryzat",
    "hubenost",
    "hubnout",
    "hudba",
    "hukot",
    "humr",
    "husita",
    "hustota",
    "hvozd",
    "hybnost",
    "hydrant",
    "hygiena",
    "hymna",
    "hysterik",
    "idylka",
    "ihned",
    "ikona",
    "iluze",
    "imunita",
    "infekce",
    "inflace",
    "inkaso",
    "inovace",
    "inspekce",
    "internet",
    "invalida",
    "investor",
    "inzerce",
    "ironie",
    "jablko",
    "jachta",
    "jahoda",
    "jakmile",
    "jakost",
    "jalovec",
    "jantar",
    "jarmark",
    "jaro",
    "jasan",
    "jasno",
    "jatka",
    "javor",
    "jazyk",
    "jedinec",
    "jedle",
    "jednatel",
    "jehlan",
    "jekot",
    "jelen",
    "jelito",
    "jemnost",
    "jenom",
    "jepice",
    "jeseter",
    "jevit",
    "jezdec",
    "jezero",
    "jinak",
    "jindy",
    "jinoch",
    "jiskra",
    "jistota",
    "jitrnice",
    "jizva",
    "jmenovat",
    "jogurt",
    "jurta",
    "kabaret",
    "kabel",
    "kabinet",
    "kachna",
    "kadet",
    "kadidlo",
    "kahan",
    "kajak",
    "kajuta",
    "kakao",
    "kaktus",
    "kalamita",
    "kalhoty",
    "kalibr",
    "kalnost",
    "kamera",
    "kamkoliv",
    "kamna",
    "kanibal",
    "kanoe",
    "kantor",
    "kapalina",
    "kapela",
    "kapitola",
    "kapka",
    "kaple",
    "kapota",
    "kapr",
    "kapusta",
    "kapybara",
    "karamel",
    "karotka",
    "karton",
    "kasa",
    "katalog",
    "katedra",
    "kauce",
    "kauza",
    "kavalec",
    "kazajka",
    "kazeta",
    "kazivost",
    "kdekoliv",
    "kdesi",
    "kedluben",
    "kemp",
    "keramika",
    "kino",
    "klacek",
    "kladivo",
    "klam",
    "klapot",
    "klasika",
    "klaun",
    "klec",
    "klenba",
    "klepat",
    "klesnout",
    "klid",
    "klima",
    "klisna",
    "klobouk",
    "klokan",
    "klopa",
    "kloub",
    "klubovna",
    "klusat",
    "kluzkost",
    "kmen",
    "kmitat",
    "kmotr",
    "kniha",
    "knot",
    "koalice",
    "koberec",
    "kobka",
    "kobliha",
    "kobyla",
    "kocour",
    "kohout",
    "kojenec",
    "kokos",
    "koktejl",
    "kolaps",
    "koleda",
    "kolize",
    "kolo",
    "komando",
    "kometa",
    "komik",
    "komnata",
    "komora",
    "kompas",
    "komunita",
    "konat",
    "koncept",
    "kondice",
    "konec",
    "konfese",
    "kongres",
    "konina",
    "konkurs",
    "kontakt",
    "konzerva",
    "kopanec",
    "kopie",
    "kopnout",
    "koprovka",
    "korbel",
    "korektor",
    "kormidlo",
    "koroptev",
    "korpus",
    "koruna",
    "koryto",
    "korzet",
    "kosatec",
    "kostka",
    "kotel",
    "kotleta",
    "kotoul",
    "koukat",
    "koupelna",
    "kousek",
    "kouzlo",
    "kovboj",
    "koza",
    "kozoroh",
    "krabice",
    "krach",
    "krajina",
    "kralovat",
    "krasopis",
    "kravata",
    "kredit",
    "krejcar",
    "kresba",
    "kreveta",
    "kriket",
    "kritik",
    "krize",
    "krkavec",
    "krmelec",
    "krmivo",
    "krocan",
    "krok",
    "kronika",
    "kropit",
    "kroupa",
    "krovka",
    "krtek",
    "kruhadlo",
    "krupice",
    "krutost",
    "krvinka",
    "krychle",
    "krypta",
    "krystal",
    "kryt",
    "kudlanka",
    "kufr",
    "kujnost",
    "kukla",
    "kulajda",
    "kulich",
    "kulka",
    "kulomet",
    "kultura",
    "kuna",
    "kupodivu",
    "kurt",
    "kurzor",
    "kutil",
    "kvalita",
    "kvasinka",
    "kvestor",
    "kynolog",
    "kyselina",
    "kytara",
    "kytice",
    "kytka",
    "kytovec",
    "kyvadlo",
    "labrador",
    "lachtan",
    "ladnost",
    "laik",
    "lakomec",
    "lamela",
    "lampa",
    "lanovka",
    "lasice",
    "laso",
    "lastura",
    "latinka",
    "lavina",
    "lebka",
    "leckdy",
    "leden",
    "lednice",
    "ledovka",
    "ledvina",
    "legenda",
    "legie",
    "legrace",
    "lehce",
    "lehkost",
    "lehnout",
    "lektvar",
    "lenochod",
    "lentilka",
    "lepenka",
    "lepidlo",
    "letadlo",
    "letec",
    "letmo",
    "letokruh",
    "levhart",
    "levitace",
    "levobok",
    "libra",
    "lichotka",
    "lidojed",
    "lidskost",
    "lihovina",
    "lijavec",
    "lilek",
    "limetka",
    "linie",
    "linka",
    "linoleum",
    "listopad",
    "litina",
    "litovat",
    "lobista",
    "lodivod",
    "logika",
    "logoped",
    "lokalita",
    "loket",
    "lomcovat",
    "lopata",
    "lopuch",
    "lord",
    "losos",
    "lotr",
    "loudal",
    "louh",
    "louka",
    "louskat",
    "lovec",
    "lstivost",
    "lucerna",
    "lucifer",
    "lump",
    "lusk",
    "lustrace",
    "lvice",
    "lyra",
    "lyrika",
    "lysina",
    "madam",
    "madlo",
    "magistr",
    "mahagon",
    "majetek",
    "majitel",
    "majorita",
    "makak",
    "makovice",
    "makrela",
    "malba",
    "malina",
    "malovat",
    "malvice",
    "maminka",
    "mandle",
    "manko",
    "marnost",
    "masakr",
    "maskot",
    "masopust",
    "matice",
    "matrika",
    "maturita",
    "mazanec",
    "mazivo",
    "mazlit",
    "mazurka",
    "mdloba",
    "mechanik",
    "meditace",
    "medovina",
    "melasa",
    "meloun",
    "mentolka",
    "metla",
    "metoda",
    "metr",
    "mezera",
    "migrace",
    "mihnout",
    "mihule",
    "mikina",
    "mikrofon",
    "milenec",
    "milimetr",
    "milost",
    "mimika",
    "mincovna",
    "minibar",
    "minomet",
    "minulost",
    "miska",
    "mistr",
    "mixovat",
    "mladost",
    "mlha",
    "mlhovina",
    "mlok",
    "mlsat",
    "mluvit",
    "mnich",
    "mnohem",
    "mobil",
    "mocnost",
    "modelka",
    "modlitba",
    "mohyla",
    "mokro",
    "molekula",
    "momentka",
    "monarcha",
    "monokl",
    "monstrum",
    "montovat",
    "monzun",
    "mosaz",
    "moskyt",
    "most",
    "motivace",
    "motorka",
    "motyka",
    "moucha",
    "moudrost",
    "mozaika",
    "mozek",
    "mozol",
    "mramor",
    "mravenec",
    "mrkev",
    "mrtvola",
    "mrzet",
    "mrzutost",
    "mstitel",
    "mudrc",
    "muflon",
    "mulat",
    "mumie",
    "munice",
    "muset",
    "mutace",
    "muzeum",
    "muzikant",
    "myslivec",
    "mzda",
    "nabourat",
    "nachytat",
    "nadace",
    "nadbytek",
    "nadhoz",
    "nadobro",
    "nadpis",
    "nahlas",
    "nahnat",
    "nahodile",
    "nahradit",
    "naivita",
    "najednou",
    "najisto",
    "najmout",
    "naklonit",
    "nakonec",
    "nakrmit",
    "nalevo",
    "namazat",
    "namluvit",
    "nanometr",
    "naoko",
    "naopak",
    "naostro",
    "napadat",
    "napevno",
    "naplnit",
    "napnout",
    "naposled",
    "naprosto",
    "narodit",
    "naruby",
    "narychlo",
    "nasadit",
    "nasekat",
    "naslepo",
    "nastat",
    "natolik",
    "navenek",
    "navrch",
    "navzdory",
    "nazvat",
    "nebe",
    "nechat",
    "necky",
    "nedaleko",
    "nedbat",
    "neduh",
    "negace",
    "nehet",
    "nehoda",
    "nejen",
    "nejprve",
    "neklid",
    "nelibost",
    "nemilost",
    "nemoc",
    "neochota",
    "neonka",
    "nepokoj",
    "nerost",
    "nerv",
    "nesmysl",
    "nesoulad",
    "netvor",
    "neuron",
    "nevina",
    "nezvykle",
    "nicota",
    "nijak",
    "nikam",
    "nikdy",
    "nikl",
    "nikterak",
    "nitro",
    "nocleh",
    "nohavice",
    "nominace",
    "nora",
    "norek",
    "nositel",
    "nosnost",
    "nouze",
    "noviny",
    "novota",
    "nozdra",
    "nuda",
    "nudle",
    "nuget",
    "nutit",
    "nutnost",
    "nutrie",
    "nymfa",
    "obal",
    "obarvit",
    "obava",
    "obdiv",
    "obec",
    "obehnat",
    "obejmout",
    "obezita",
    "obhajoba",
    "obilnice",
    "objasnit",
    "objekt",
    "obklopit",
    "oblast",
    "oblek",
    "obliba",
    "obloha",
    "obluda",
    "obnos",
    "obohatit",
    "obojek",
    "obout",
    "obrazec",
    "obrna",
    "obruba",
    "obrys",
    "obsah",
    "obsluha",
    "obstarat",
    "obuv",
    "obvaz",
    "obvinit",
    "obvod",
    "obvykle",
    "obyvatel",
    "obzor",
    "ocas",
    "ocel",
    "ocenit",
    "ochladit",
    "ochota",
    "ochrana",
    "ocitnout",
    "odboj",
    "odbyt",
    "odchod",
    "odcizit",
    "odebrat",
    "odeslat",
    "odevzdat",
    "odezva",
    "odhadce",
    "odhodit",
    "odjet",
    "odjinud",
    "odkaz",
    "odkoupit",
    "odliv",
    "odluka",
    "odmlka",
    "odolnost",
    "odpad",
    "odpis",
    "odplout",
    "odpor",
    "odpustit",
    "odpykat",
    "odrazka",
    "odsoudit",
    "odstup",
    "odsun",
    "odtok",
    "odtud",
    "odvaha",
    "odveta",
    "odvolat",
    "odvracet",
    "odznak",
    "ofina",
    "ofsajd",
    "ohlas",
    "ohnisko",
    "ohrada",
    "ohrozit",
    "ohryzek",
    "okap",
    "okenice",
    "oklika",
    "okno",
    "okouzlit",
    "okovy",
    "okrasa",
    "okres",
    "okrsek",
    "okruh",
    "okupant",
    "okurka",
    "okusit",
    "olejnina",
    "olizovat",
    "omak",
    "omeleta",
    "omezit",
    "omladina",
    "omlouvat",
    "omluva",
    "omyl",
    "onehdy",
    "opakovat",
    "opasek",
    "operace",
    "opice",
    "opilost",
    "opisovat",
    "opora",
    "opozice",
    "opravdu",
    "oproti",
    "orbital",
    "orchestr",
    "orgie",
    "orlice",
    "orloj",
    "ortel",
    "osada",
    "oschnout",
    "osika",
    "osivo",
    "oslava",
    "oslepit",
    "oslnit",
    "oslovit",
    "osnova",
    "osoba",
    "osolit",
    "ospalec",
    "osten",
    "ostraha",
    "ostuda",
    "ostych",
    "osvojit",
    "oteplit",
    "otisk",
    "otop",
    "otrhat",
    "otrlost",
    "otrok",
    "otruby",
    "otvor",
    "ovanout",
    "ovar",
    "oves",
    "ovlivnit",
    "ovoce",
    "oxid",
    "ozdoba",
    "pachatel",
    "pacient",
    "padouch",
    "pahorek",
    "pakt",
    "palanda",
    "palec",
    "palivo",
    "paluba",
    "pamflet",
    "pamlsek",
    "panenka",
    "panika",
    "panna",
    "panovat",
    "panstvo",
    "pantofle",
    "paprika",
    "parketa",
    "parodie",
    "parta",
    "paruka",
    "paryba",
    "paseka",
    "pasivita",
    "pastelka",
    "patent",
    "patrona",
    "pavouk",
    "pazneht",
    "pazourek",
    "pecka",
    "pedagog",
    "pejsek",
    "peklo",
    "peloton",
    "penalta",
    "pendrek",
    "penze",
    "periskop",
    "pero",
    "pestrost",
    "petarda",
    "petice",
    "petrolej",
    "pevnina",
    "pexeso",
    "pianista",
    "piha",
    "pijavice",
    "pikle",
    "piknik",
    "pilina",
    "pilnost",
    "pilulka",
    "pinzeta",
    "pipeta",
    "pisatel",
    "pistole",
    "pitevna",
    "pivnice",
    "pivovar",
    "placenta",
    "plakat",
    "plamen",
    "planeta",
    "plastika",
    "platit",
    "plavidlo",
    "plaz",
    "plech",
    "plemeno",
    "plenta",
    "ples",
    "pletivo",
    "plevel",
    "plivat",
    "plnit",
    "plno",
    "plocha",
    "plodina",
    "plomba",
    "plout",
    "pluk",
    "plyn",
    "pobavit",
    "pobyt",
    "pochod",
    "pocit",
    "poctivec",
    "podat",
    "podcenit",
    "podepsat",
    "podhled",
    "podivit",
    "podklad",
    "podmanit",
    "podnik",
    "podoba",
    "podpora",
    "podraz",
    "podstata",
    "podvod",
    "podzim",
    "poezie",
    "pohanka",
    "pohnutka",
    "pohovor",
    "pohroma",
    "pohyb",
    "pointa",
    "pojistka",
    "pojmout",
    "pokazit",
    "pokles",
    "pokoj",
    "pokrok",
    "pokuta",
    "pokyn",
    "poledne",
    "polibek",
    "polknout",
    "poloha",
    "polynom",
    "pomalu",
    "pominout",
    "pomlka",
    "pomoc",
    "pomsta",
    "pomyslet",
    "ponechat",
    "ponorka",
    "ponurost",
    "popadat",
    "popel",
    "popisek",
    "poplach",
    "poprosit",
    "popsat",
    "popud",
    "poradce",
    "porce",
    "porod",
    "porucha",
    "poryv",
    "posadit",
    "posed",
    "posila",
    "poskok",
    "poslanec",
    "posoudit",
    "pospolu",
    "postava",
    "posudek",
    "posyp",
    "potah",
    "potkan",
    "potlesk",
    "potomek",
    "potrava",
    "potupa",
    "potvora",
    "poukaz",
    "pouto",
    "pouzdro",
    "povaha",
    "povidla",
    "povlak",
    "povoz",
    "povrch",
    "povstat",
    "povyk",
    "povzdech",
    "pozdrav",
    "pozemek",
    "poznatek",
    "pozor",
    "pozvat",
    "pracovat",
    "prahory",
    "praktika",
    "prales",
    "praotec",
    "praporek",
    "prase",
    "pravda",
    "princip",
    "prkno",
    "probudit",
    "procento",
    "prodej",
    "profese",
    "prohra",
    "projekt",
    "prolomit",
    "promile",
    "pronikat",
    "propad",
    "prorok",
    "prosba",
    "proton",
    "proutek",
    "provaz",
    "prskavka",
    "prsten",
    "prudkost",
    "prut",
    "prvek",
    "prvohory",
    "psanec",
    "psovod",
    "pstruh",
    "ptactvo",
    "puberta",
    "puch",
    "pudl",
    "pukavec",
    "puklina",
    "pukrle",
    "pult",
    "pumpa",
    "punc",
    "pupen",
    "pusa",
    "pusinka",
    "pustina",
    "putovat",
    "putyka",
    "pyramida",
    "pysk",
    "pytel",
    "racek",
    "rachot",
    "radiace",
    "radnice",
    "radon",
    "raft",
    "ragby",
    "raketa",
    "rakovina",
    "rameno",
    "rampouch",
    "rande",
    "rarach",
    "rarita",
    "rasovna",
    "rastr",
    "ratolest",
    "razance",
    "razidlo",
    "reagovat",
    "reakce",
    "recept",
    "redaktor",
    "referent",
    "reflex",
    "rejnok",
    "reklama",
    "rekord",
    "rekrut",
    "rektor",
    "reputace",
    "revize",
    "revma",
    "revolver",
    "rezerva",
    "riskovat",
    "riziko",
    "robotika",
    "rodokmen",
    "rohovka",
    "rokle",
    "rokoko",
    "romaneto",
    "ropovod",
    "ropucha",
    "rorejs",
    "rosol",
    "rostlina",
    "rotmistr",
    "rotoped",
    "rotunda",
    "roubenka",
    "roucho",
    "roup",
    "roura",
    "rovina",
    "rovnice",
    "rozbor",
    "rozchod",
    "rozdat",
    "rozeznat",
    "rozhodce",
    "rozinka",
    "rozjezd",
    "rozkaz",
    "rozloha",
    "rozmar",
    "rozpad",
    "rozruch",
    "rozsah",
    "roztok",
    "rozum",
    "rozvod",
    "rubrika",
    "ruchadlo",
    "rukavice",
    "rukopis",
    "ryba",
    "rybolov",
    "rychlost",
    "rydlo",
    "rypadlo",
    "rytina",
    "ryzost",
    "sadista",
    "sahat",
    "sako",
    "samec",
    "samizdat",
    "samota",
    "sanitka",
    "sardinka",
    "sasanka",
    "satelit",
    "sazba",
    "sazenice",
    "sbor",
    "schovat",
    "sebranka",
    "secese",
    "sedadlo",
    "sediment",
    "sedlo",
    "sehnat",
    "sejmout",
    "sekera",
    "sekta",
    "sekunda",
    "sekvoje",
    "semeno",
    "seno",
    "servis",
    "sesadit",
    "seshora",
    "seskok",
    "seslat",
    "sestra",
    "sesuv",
    "sesypat",
    "setba",
    "setina",
    "setkat",
    "setnout",
    "setrvat",
    "sever",
    "seznam",
    "shoda",
    "shrnout",
    "sifon",
    "silnice",
    "sirka",
    "sirotek",
    "sirup",
    "situace",
    "skafandr",
    "skalisko",
    "skanzen",
    "skaut",
    "skeptik",
    "skica",
    "skladba",
    "sklenice",
    "sklo",
    "skluz",
    "skoba",
    "skokan",
    "skoro",
    "skripta",
    "skrz",
    "skupina",
    "skvost",
    "skvrna",
    "slabika",
    "sladidlo",
    "slanina",
    "slast",
    "slavnost",
    "sledovat",
    "slepec",
    "sleva",
    "slezina",
    "slib",
    "slina",
    "sliznice",
    "slon",
    "sloupek",
    "slovo",
    "sluch",
    "sluha",
    "slunce",
    "slupka",
    "slza",
    "smaragd",
    "smetana",
    "smilstvo",
    "smlouva",
    "smog",
    "smrad",
    "smrk",
    "smrtka",
    "smutek",
    "smysl",
    "snad",
    "snaha",
    "snob",
    "sobota",
    "socha",
    "sodovka",
    "sokol",
    "sopka",
    "sotva",
    "souboj",
    "soucit",
    "soudce",
    "souhlas",
    "soulad",
    "soumrak",
    "souprava",
    "soused",
    "soutok",
    "souviset",
    "spalovna",
    "spasitel",
    "spis",
    "splav",
    "spodek",
    "spojenec",
    "spolu",
    "sponzor",
    "spornost",
    "spousta",
    "sprcha",
    "spustit",
    "sranda",
    "sraz",
    "srdce",
    "srna",
    "srnec",
    "srovnat",
    "srpen",
    "srst",
    "srub",
    "stanice",
    "starosta",
    "statika",
    "stavba",
    "stehno",
    "stezka",
    "stodola",
    "stolek",
    "stopa",
    "storno",
    "stoupat",
    "strach",
    "stres",
    "strhnout",
    "strom",
    "struna",
    "studna",
    "stupnice",
    "stvol",
    "styk",
    "subjekt",
    "subtropy",
    "suchar",
    "sudost",
    "sukno",
    "sundat",
    "sunout",
    "surikata",
    "surovina",
    "svah",
    "svalstvo",
    "svetr",
    "svatba",
    "svazek",
    "svisle",
    "svitek",
    "svoboda",
    "svodidlo",
    "svorka",
    "svrab",
    "sykavka",
    "sykot",
    "synek",
    "synovec",
    "sypat",
    "sypkost",
    "syrovost",
    "sysel",
    "sytost",
    "tabletka",
    "tabule",
    "tahoun",
    "tajemno",
    "tajfun",
    "tajga",
    "tajit",
    "tajnost",
    "taktika",
    "tamhle",
    "tampon",
    "tancovat",
    "tanec",
    "tanker",
    "tapeta",
    "tavenina",
    "tazatel",
    "technika",
    "tehdy",
    "tekutina",
    "telefon",
    "temnota",
    "tendence",
    "tenista",
    "tenor",
    "teplota",
    "tepna",
    "teprve",
    "terapie",
    "termoska",
    "textil",
    "ticho",
    "tiskopis",
    "titulek",
    "tkadlec",
    "tkanina",
    "tlapka",
    "tleskat",
    "tlukot",
    "tlupa",
    "tmel",
    "toaleta",
    "topinka",
    "topol",
    "torzo",
    "touha",
    "toulec",
    "tradice",
    "traktor",
    "tramp",
    "trasa",
    "traverza",
    "trefit",
    "trest",
    "trezor",
    "trhavina",
    "trhlina",
    "trochu",
    "trojice",
    "troska",
    "trouba",
    "trpce",
    "trpitel",
    "trpkost",
    "trubec",
    "truchlit",
    "truhlice",
    "trus",
    "trvat",
    "tudy",
    "tuhnout",
    "tuhost",
    "tundra",
    "turista",
    "turnaj",
    "tuzemsko",
    "tvaroh",
    "tvorba",
    "tvrdost",
    "tvrz",
    "tygr",
    "tykev",
    "ubohost",
    "uboze",
    "ubrat",
    "ubrousek",
    "ubrus",
    "ubytovna",
    "ucho",
    "uctivost",
    "udivit",
    "uhradit",
    "ujednat",
    "ujistit",
    "ujmout",
    "ukazatel",
    "uklidnit",
    "uklonit",
    "ukotvit",
    "ukrojit",
    "ulice",
    "ulita",
    "ulovit",
    "umyvadlo",
    "unavit",
    "uniforma",
    "uniknout",
    "upadnout",
    "uplatnit",
    "uplynout",
    "upoutat",
    "upravit",
    "uran",
    "urazit",
    "usednout",
    "usilovat",
    "usmrtit",
    "usnadnit",
    "usnout",
    "usoudit",
    "ustlat",
    "ustrnout",
    "utahovat",
    "utkat",
    "utlumit",
    "utonout",
    "utopenec",
    "utrousit",
    "uvalit",
    "uvolnit",
    "uvozovka",
    "uzdravit",
    "uzel",
    "uzenina",
    "uzlina",
    "uznat",
    "vagon",
    "valcha",
    "valoun",
    "vana",
    "vandal",
    "vanilka",
    "varan",
    "varhany",
    "varovat",
    "vcelku",
    "vchod",
    "vdova",
    "vedro",
    "vegetace",
    "vejce",
    "velbloud",
    "veletrh",
    "velitel",
    "velmoc",
    "velryba",
    "venkov",
    "veranda",
    "verze",
    "veselka",
    "veskrze",
    "vesnice",
    "vespodu",
    "vesta",
    "veterina",
    "veverka",
    "vibrace",
    "vichr",
    "videohra",
    "vidina",
    "vidle",
    "vila",
    "vinice",
    "viset",
    "vitalita",
    "vize",
    "vizitka",
    "vjezd",
    "vklad",
    "vkus",
    "vlajka",
    "vlak",
    "vlasec",
    "vlevo",
    "vlhkost",
    "vliv",
    "vlnovka",
    "vloupat",
    "vnucovat",
    "vnuk",
    "voda",
    "vodivost",
    "vodoznak",
    "vodstvo",
    "vojensky",
    "vojna",
    "vojsko",
    "volant",
    "volba",
    "volit",
    "volno",
    "voskovka",
    "vozidlo",
    "vozovna",
    "vpravo",
    "vrabec",
    "vracet",
    "vrah",
    "vrata",
    "vrba",
    "vrcholek",
    "vrhat",
    "vrstva",
    "vrtule",
    "vsadit",
    "vstoupit",
    "vstup",
    "vtip",
    "vybavit",
    "vybrat",
    "vychovat",
    "vydat",
    "vydra",
    "vyfotit",
    "vyhledat",
    "vyhnout",
    "vyhodit",
    "vyhradit",
    "vyhubit",
    "vyjasnit",
    "vyjet",
    "vyjmout",
    "vyklopit",
    "vykonat",
    "vylekat",
    "vymazat",
    "vymezit",
    "vymizet",
    "vymyslet",
    "vynechat",
    "vynikat",
    "vynutit",
    "vypadat",
    "vyplatit",
    "vypravit",
    "vypustit",
    "vyrazit",
    "vyrovnat",
    "vyrvat",
    "vyslovit",
    "vysoko",
    "vystavit",
    "vysunout",
    "vysypat",
    "vytasit",
    "vytesat",
    "vytratit",
    "vyvinout",
    "vyvolat",
    "vyvrhel",
    "vyzdobit",
    "vyznat",
    "vzadu",
    "vzbudit",
    "vzchopit",
    "vzdor",
    "vzduch",
    "vzdychat",
    "vzestup",
    "vzhledem",
    "vzkaz",
    "vzlykat",
    "vznik",
    "vzorek",
    "vzpoura",
    "vztah",
    "vztek",
    "xylofon",
    "zabrat",
    "zabydlet",
    "zachovat",
    "zadarmo",
    "zadusit",
    "zafoukat",
    "zahltit",
    "zahodit",
    "zahrada",
    "zahynout",
    "zajatec",
    "zajet",
    "zajistit",
    "zaklepat",
    "zakoupit",
    "zalepit",
    "zamezit",
    "zamotat",
    "zamyslet",
    "zanechat",
    "zanikat",
    "zaplatit",
    "zapojit",
    "zapsat",
    "zarazit",
    "zastavit",
    "zasunout",
    "zatajit",
    "zatemnit",
    "zatknout",
    "zaujmout",
    "zavalit",
    "zavelet",
    "zavinit",
    "zavolat",
    "zavrtat",
    "zazvonit",
    "zbavit",
    "zbrusu",
    "zbudovat",
    "zbytek",
    "zdaleka",
    "zdarma",
    "zdatnost",
    "zdivo",
    "zdobit",
    "zdroj",
    "zdvih",
    "zdymadlo",
    "zelenina",
    "zeman",
    "zemina",
    "zeptat",
    "zezadu",
    "zezdola",
    "zhatit",
    "zhltnout",
    "zhluboka",
    "zhotovit",
    "zhruba",
    "zima",
    "zimnice",
    "zjemnit",
    "zklamat",
    "zkoumat",
    "zkratka",
    "zkumavka",
    "zlato",
    "zlehka",
    "zloba",
    "zlom",
    "zlost",
    "zlozvyk",
    "zmapovat",
    "zmar",
    "zmatek",
    "zmije",
    "zmizet",
    "zmocnit",
    "zmodrat",
    "zmrzlina",
    "zmutovat",
    "znak",
    "znalost",
    "znamenat",
    "znovu",
    "zobrazit",
    "zotavit",
    "zoubek",
    "zoufale",
    "zplodit",
    "zpomalit",
    "zprava",
    "zprostit",
    "zprudka",
    "zprvu",
    "zrada",
    "zranit",
    "zrcadlo",
    "zrnitost",
    "zrno",
    "zrovna",
    "zrychlit",
    "zrzavost",
    "zticha",
    "ztratit",
    "zubovina",
    "zubr",
    "zvednout",
    "zvenku",
    "zvesela",
    "zvon",
    "zvrat",
    "zvukovod",
    "zvyk"
]

},{}],58:[function(require,module,exports){
module.exports=[
    "abandon",
    "ability",
    "able",
    "about",
    "above",
    "absent",
    "absorb",
    "abstract",
    "absurd",
    "abuse",
    "access",
    "accident",
    "account",
    "accuse",
    "achieve",
    "acid",
    "acoustic",
    "acquire",
    "across",
    "act",
    "action",
    "actor",
    "actress",
    "actual",
    "adapt",
    "add",
    "addict",
    "address",
    "adjust",
    "admit",
    "adult",
    "advance",
    "advice",
    "aerobic",
    "affair",
    "afford",
    "afraid",
    "again",
    "age",
    "agent",
    "agree",
    "ahead",
    "aim",
    "air",
    "airport",
    "aisle",
    "alarm",
    "album",
    "alcohol",
    "alert",
    "alien",
    "all",
    "alley",
    "allow",
    "almost",
    "alone",
    "alpha",
    "already",
    "also",
    "alter",
    "always",
    "amateur",
    "amazing",
    "among",
    "amount",
    "amused",
    "analyst",
    "anchor",
    "ancient",
    "anger",
    "angle",
    "angry",
    "animal",
    "ankle",
    "announce",
    "annual",
    "another",
    "answer",
    "antenna",
    "antique",
    "anxiety",
    "any",
    "apart",
    "apology",
    "appear",
    "apple",
    "approve",
    "april",
    "arch",
    "arctic",
    "area",
    "arena",
    "argue",
    "arm",
    "armed",
    "armor",
    "army",
    "around",
    "arrange",
    "arrest",
    "arrive",
    "arrow",
    "art",
    "artefact",
    "artist",
    "artwork",
    "ask",
    "aspect",
    "assault",
    "asset",
    "assist",
    "assume",
    "asthma",
    "athlete",
    "atom",
    "attack",
    "attend",
    "attitude",
    "attract",
    "auction",
    "audit",
    "august",
    "aunt",
    "author",
    "auto",
    "autumn",
    "average",
    "avocado",
    "avoid",
    "awake",
    "aware",
    "away",
    "awesome",
    "awful",
    "awkward",
    "axis",
    "baby",
    "bachelor",
    "bacon",
    "badge",
    "bag",
    "balance",
    "balcony",
    "ball",
    "bamboo",
    "banana",
    "banner",
    "bar",
    "barely",
    "bargain",
    "barrel",
    "base",
    "basic",
    "basket",
    "battle",
    "beach",
    "bean",
    "beauty",
    "because",
    "become",
    "beef",
    "before",
    "begin",
    "behave",
    "behind",
    "believe",
    "below",
    "belt",
    "bench",
    "benefit",
    "best",
    "betray",
    "better",
    "between",
    "beyond",
    "bicycle",
    "bid",
    "bike",
    "bind",
    "biology",
    "bird",
    "birth",
    "bitter",
    "black",
    "blade",
    "blame",
    "blanket",
    "blast",
    "bleak",
    "bless",
    "blind",
    "blood",
    "blossom",
    "blouse",
    "blue",
    "blur",
    "blush",
    "board",
    "boat",
    "body",
    "boil",
    "bomb",
    "bone",
    "bonus",
    "book",
    "boost",
    "border",
    "boring",
    "borrow",
    "boss",
    "bottom",
    "bounce",
    "box",
    "boy",
    "bracket",
    "brain",
    "brand",
    "brass",
    "brave",
    "bread",
    "breeze",
    "brick",
    "bridge",
    "brief",
    "bright",
    "bring",
    "brisk",
    "broccoli",
    "broken",
    "bronze",
    "broom",
    "brother",
    "brown",
    "brush",
    "bubble",
    "buddy",
    "budget",
    "buffalo",
    "build",
    "bulb",
    "bulk",
    "bullet",
    "bundle",
    "bunker",
    "burden",
    "burger",
    "burst",
    "bus",
    "business",
    "busy",
    "butter",
    "buyer",
    "buzz",
    "cabbage",
    "cabin",
    "cable",
    "cactus",
    "cage",
    "cake",
    "call",
    "calm",
    "camera",
    "camp",
    "can",
    "canal",
    "cancel",
    "candy",
    "cannon",
    "canoe",
    "canvas",
    "canyon",
    "capable",
    "capital",
    "captain",
    "car",
    "carbon",
    "card",
    "cargo",
    "carpet",
    "carry",
    "cart",
    "case",
    "cash",
    "casino",
    "castle",
    "casual",
    "cat",
    "catalog",
    "catch",
    "category",
    "cattle",
    "caught",
    "cause",
    "caution",
    "cave",
    "ceiling",
    "celery",
    "cement",
    "census",
    "century",
    "cereal",
    "certain",
    "chair",
    "chalk",
    "champion",
    "change",
    "chaos",
    "chapter",
    "charge",
    "chase",
    "chat",
    "cheap",
    "check",
    "cheese",
    "chef",
    "cherry",
    "chest",
    "chicken",
    "chief",
    "child",
    "chimney",
    "choice",
    "choose",
    "chronic",
    "chuckle",
    "chunk",
    "churn",
    "cigar",
    "cinnamon",
    "circle",
    "citizen",
    "city",
    "civil",
    "claim",
    "clap",
    "clarify",
    "claw",
    "clay",
    "clean",
    "clerk",
    "clever",
    "click",
    "client",
    "cliff",
    "climb",
    "clinic",
    "clip",
    "clock",
    "clog",
    "close",
    "cloth",
    "cloud",
    "clown",
    "club",
    "clump",
    "cluster",
    "clutch",
    "coach",
    "coast",
    "coconut",
    "code",
    "coffee",
    "coil",
    "coin",
    "collect",
    "color",
    "column",
    "combine",
    "come",
    "comfort",
    "comic",
    "common",
    "company",
    "concert",
    "conduct",
    "confirm",
    "congress",
    "connect",
    "consider",
    "control",
    "convince",
    "cook",
    "cool",
    "copper",
    "copy",
    "coral",
    "core",
    "corn",
    "correct",
    "cost",
    "cotton",
    "couch",
    "country",
    "couple",
    "course",
    "cousin",
    "cover",
    "coyote",
    "crack",
    "cradle",
    "craft",
    "cram",
    "crane",
    "crash",
    "crater",
    "crawl",
    "crazy",
    "cream",
    "credit",
    "creek",
    "crew",
    "cricket",
    "crime",
    "crisp",
    "critic",
    "crop",
    "cross",
    "crouch",
    "crowd",
    "crucial",
    "cruel",
    "cruise",
    "crumble",
    "crunch",
    "crush",
    "cry",
    "crystal",
    "cube",
    "culture",
    "cup",
    "cupboard",
    "curious",
    "current",
    "curtain",
    "curve",
    "cushion",
    "custom",
    "cute",
    "cycle",
    "dad",
    "damage",
    "damp",
    "dance",
    "danger",
    "daring",
    "dash",
    "daughter",
    "dawn",
    "day",
    "deal",
    "debate",
    "debris",
    "decade",
    "december",
    "decide",
    "decline",
    "decorate",
    "decrease",
    "deer",
    "defense",
    "define",
    "defy",
    "degree",
    "delay",
    "deliver",
    "demand",
    "demise",
    "denial",
    "dentist",
    "deny",
    "depart",
    "depend",
    "deposit",
    "depth",
    "deputy",
    "derive",
    "describe",
    "desert",
    "design",
    "desk",
    "despair",
    "destroy",
    "detail",
    "detect",
    "develop",
    "device",
    "devote",
    "diagram",
    "dial",
    "diamond",
    "diary",
    "dice",
    "diesel",
    "diet",
    "differ",
    "digital",
    "dignity",
    "dilemma",
    "dinner",
    "dinosaur",
    "direct",
    "dirt",
    "disagree",
    "discover",
    "disease",
    "dish",
    "dismiss",
    "disorder",
    "display",
    "distance",
    "divert",
    "divide",
    "divorce",
    "dizzy",
    "doctor",
    "document",
    "dog",
    "doll",
    "dolphin",
    "domain",
    "donate",
    "donkey",
    "donor",
    "door",
    "dose",
    "double",
    "dove",
    "draft",
    "dragon",
    "drama",
    "drastic",
    "draw",
    "dream",
    "dress",
    "drift",
    "drill",
    "drink",
    "drip",
    "drive",
    "drop",
    "drum",
    "dry",
    "duck",
    "dumb",
    "dune",
    "during",
    "dust",
    "dutch",
    "duty",
    "dwarf",
    "dynamic",
    "eager",
    "eagle",
    "early",
    "earn",
    "earth",
    "easily",
    "east",
    "easy",
    "echo",
    "ecology",
    "economy",
    "edge",
    "edit",
    "educate",
    "effort",
    "egg",
    "eight",
    "either",
    "elbow",
    "elder",
    "electric",
    "elegant",
    "element",
    "elephant",
    "elevator",
    "elite",
    "else",
    "embark",
    "embody",
    "embrace",
    "emerge",
    "emotion",
    "employ",
    "empower",
    "empty",
    "enable",
    "enact",
    "end",
    "endless",
    "endorse",
    "enemy",
    "energy",
    "enforce",
    "engage",
    "engine",
    "enhance",
    "enjoy",
    "enlist",
    "enough",
    "enrich",
    "enroll",
    "ensure",
    "enter",
    "entire",
    "entry",
    "envelope",
    "episode",
    "equal",
    "equip",
    "era",
    "erase",
    "erode",
    "erosion",
    "error",
    "erupt",
    "escape",
    "essay",
    "essence",
    "estate",
    "eternal",
    "ethics",
    "evidence",
    "evil",
    "evoke",
    "evolve",
    "exact",
    "example",
    "excess",
    "exchange",
    "excite",
    "exclude",
    "excuse",
    "execute",
    "exercise",
    "exhaust",
    "exhibit",
    "exile",
    "exist",
    "exit",
    "exotic",
    "expand",
    "expect",
    "expire",
    "explain",
    "expose",
    "express",
    "extend",
    "extra",
    "eye",
    "eyebrow",
    "fabric",
    "face",
    "faculty",
    "fade",
    "faint",
    "faith",
    "fall",
    "false",
    "fame",
    "family",
    "famous",
    "fan",
    "fancy",
    "fantasy",
    "farm",
    "fashion",
    "fat",
    "fatal",
    "father",
    "fatigue",
    "fault",
    "favorite",
    "feature",
    "february",
    "federal",
    "fee",
    "feed",
    "feel",
    "female",
    "fence",
    "festival",
    "fetch",
    "fever",
    "few",
    "fiber",
    "fiction",
    "field",
    "figure",
    "file",
    "film",
    "filter",
    "final",
    "find",
    "fine",
    "finger",
    "finish",
    "fire",
    "firm",
    "first",
    "fiscal",
    "fish",
    "fit",
    "fitness",
    "fix",
    "flag",
    "flame",
    "flash",
    "flat",
    "flavor",
    "flee",
    "flight",
    "flip",
    "float",
    "flock",
    "floor",
    "flower",
    "fluid",
    "flush",
    "fly",
    "foam",
    "focus",
    "fog",
    "foil",
    "fold",
    "follow",
    "food",
    "foot",
    "force",
    "forest",
    "forget",
    "fork",
    "fortune",
    "forum",
    "forward",
    "fossil",
    "foster",
    "found",
    "fox",
    "fragile",
    "frame",
    "frequent",
    "fresh",
    "friend",
    "fringe",
    "frog",
    "front",
    "frost",
    "frown",
    "frozen",
    "fruit",
    "fuel",
    "fun",
    "funny",
    "furnace",
    "fury",
    "future",
    "gadget",
    "gain",
    "galaxy",
    "gallery",
    "game",
    "gap",
    "garage",
    "garbage",
    "garden",
    "garlic",
    "garment",
    "gas",
    "gasp",
    "gate",
    "gather",
    "gauge",
    "gaze",
    "general",
    "genius",
    "genre",
    "gentle",
    "genuine",
    "gesture",
    "ghost",
    "giant",
    "gift",
    "giggle",
    "ginger",
    "giraffe",
    "girl",
    "give",
    "glad",
    "glance",
    "glare",
    "glass",
    "glide",
    "glimpse",
    "globe",
    "gloom",
    "glory",
    "glove",
    "glow",
    "glue",
    "goat",
    "goddess",
    "gold",
    "good",
    "goose",
    "gorilla",
    "gospel",
    "gossip",
    "govern",
    "gown",
    "grab",
    "grace",
    "grain",
    "grant",
    "grape",
    "grass",
    "gravity",
    "great",
    "green",
    "grid",
    "grief",
    "grit",
    "grocery",
    "group",
    "grow",
    "grunt",
    "guard",
    "guess",
    "guide",
    "guilt",
    "guitar",
    "gun",
    "gym",
    "habit",
    "hair",
    "half",
    "hammer",
    "hamster",
    "hand",
    "happy",
    "harbor",
    "hard",
    "harsh",
    "harvest",
    "hat",
    "have",
    "hawk",
    "hazard",
    "head",
    "health",
    "heart",
    "heavy",
    "hedgehog",
    "height",
    "hello",
    "helmet",
    "help",
    "hen",
    "hero",
    "hidden",
    "high",
    "hill",
    "hint",
    "hip",
    "hire",
    "history",
    "hobby",
    "hockey",
    "hold",
    "hole",
    "holiday",
    "hollow",
    "home",
    "honey",
    "hood",
    "hope",
    "horn",
    "horror",
    "horse",
    "hospital",
    "host",
    "hotel",
    "hour",
    "hover",
    "hub",
    "huge",
    "human",
    "humble",
    "humor",
    "hundred",
    "hungry",
    "hunt",
    "hurdle",
    "hurry",
    "hurt",
    "husband",
    "hybrid",
    "ice",
    "icon",
    "idea",
    "identify",
    "idle",
    "ignore",
    "ill",
    "illegal",
    "illness",
    "image",
    "imitate",
    "immense",
    "immune",
    "impact",
    "impose",
    "improve",
    "impulse",
    "inch",
    "include",
    "income",
    "increase",
    "index",
    "indicate",
    "indoor",
    "industry",
    "infant",
    "inflict",
    "inform",
    "inhale",
    "inherit",
    "initial",
    "inject",
    "injury",
    "inmate",
    "inner",
    "innocent",
    "input",
    "inquiry",
    "insane",
    "insect",
    "inside",
    "inspire",
    "install",
    "intact",
    "interest",
    "into",
    "invest",
    "invite",
    "involve",
    "iron",
    "island",
    "isolate",
    "issue",
    "item",
    "ivory",
    "jacket",
    "jaguar",
    "jar",
    "jazz",
    "jealous",
    "jeans",
    "jelly",
    "jewel",
    "job",
    "join",
    "joke",
    "journey",
    "joy",
    "judge",
    "juice",
    "jump",
    "jungle",
    "junior",
    "junk",
    "just",
    "kangaroo",
    "keen",
    "keep",
    "ketchup",
    "key",
    "kick",
    "kid",
    "kidney",
    "kind",
    "kingdom",
    "kiss",
    "kit",
    "kitchen",
    "kite",
    "kitten",
    "kiwi",
    "knee",
    "knife",
    "knock",
    "know",
    "lab",
    "label",
    "labor",
    "ladder",
    "lady",
    "lake",
    "lamp",
    "language",
    "laptop",
    "large",
    "later",
    "latin",
    "laugh",
    "laundry",
    "lava",
    "law",
    "lawn",
    "lawsuit",
    "layer",
    "lazy",
    "leader",
    "leaf",
    "learn",
    "leave",
    "lecture",
    "left",
    "leg",
    "legal",
    "legend",
    "leisure",
    "lemon",
    "lend",
    "length",
    "lens",
    "leopard",
    "lesson",
    "letter",
    "level",
    "liar",
    "liberty",
    "library",
    "license",
    "life",
    "lift",
    "light",
    "like",
    "limb",
    "limit",
    "link",
    "lion",
    "liquid",
    "list",
    "little",
    "live",
    "lizard",
    "load",
    "loan",
    "lobster",
    "local",
    "lock",
    "logic",
    "lonely",
    "long",
    "loop",
    "lottery",
    "loud",
    "lounge",
    "love",
    "loyal",
    "lucky",
    "luggage",
    "lumber",
    "lunar",
    "lunch",
    "luxury",
    "lyrics",
    "machine",
    "mad",
    "magic",
    "magnet",
    "maid",
    "mail",
    "main",
    "major",
    "make",
    "mammal",
    "man",
    "manage",
    "mandate",
    "mango",
    "mansion",
    "manual",
    "maple",
    "marble",
    "march",
    "margin",
    "marine",
    "market",
    "marriage",
    "mask",
    "mass",
    "master",
    "match",
    "material",
    "math",
    "matrix",
    "matter",
    "maximum",
    "maze",
    "meadow",
    "mean",
    "measure",
    "meat",
    "mechanic",
    "medal",
    "media",
    "melody",
    "melt",
    "member",
    "memory",
    "mention",
    "menu",
    "mercy",
    "merge",
    "merit",
    "merry",
    "mesh",
    "message",
    "metal",
    "method",
    "middle",
    "midnight",
    "milk",
    "million",
    "mimic",
    "mind",
    "minimum",
    "minor",
    "minute",
    "miracle",
    "mirror",
    "misery",
    "miss",
    "mistake",
    "mix",
    "mixed",
    "mixture",
    "mobile",
    "model",
    "modify",
    "mom",
    "moment",
    "monitor",
    "monkey",
    "monster",
    "month",
    "moon",
    "moral",
    "more",
    "morning",
    "mosquito",
    "mother",
    "motion",
    "motor",
    "mountain",
    "mouse",
    "move",
    "movie",
    "much",
    "muffin",
    "mule",
    "multiply",
    "muscle",
    "museum",
    "mushroom",
    "music",
    "must",
    "mutual",
    "myself",
    "mystery",
    "myth",
    "naive",
    "name",
    "napkin",
    "narrow",
    "nasty",
    "nation",
    "nature",
    "near",
    "neck",
    "need",
    "negative",
    "neglect",
    "neither",
    "nephew",
    "nerve",
    "nest",
    "net",
    "network",
    "neutral",
    "never",
    "news",
    "next",
    "nice",
    "night",
    "noble",
    "noise",
    "nominee",
    "noodle",
    "normal",
    "north",
    "nose",
    "notable",
    "note",
    "nothing",
    "notice",
    "novel",
    "now",
    "nuclear",
    "number",
    "nurse",
    "nut",
    "oak",
    "obey",
    "object",
    "oblige",
    "obscure",
    "observe",
    "obtain",
    "obvious",
    "occur",
    "ocean",
    "october",
    "odor",
    "off",
    "offer",
    "office",
    "often",
    "oil",
    "okay",
    "old",
    "olive",
    "olympic",
    "omit",
    "once",
    "one",
    "onion",
    "online",
    "only",
    "open",
    "opera",
    "opinion",
    "oppose",
    "option",
    "orange",
    "orbit",
    "orchard",
    "order",
    "ordinary",
    "organ",
    "orient",
    "original",
    "orphan",
    "ostrich",
    "other",
    "outdoor",
    "outer",
    "output",
    "outside",
    "oval",
    "oven",
    "over",
    "own",
    "owner",
    "oxygen",
    "oyster",
    "ozone",
    "pact",
    "paddle",
    "page",
    "pair",
    "palace",
    "palm",
    "panda",
    "panel",
    "panic",
    "panther",
    "paper",
    "parade",
    "parent",
    "park",
    "parrot",
    "party",
    "pass",
    "patch",
    "path",
    "patient",
    "patrol",
    "pattern",
    "pause",
    "pave",
    "payment",
    "peace",
    "peanut",
    "pear",
    "peasant",
    "pelican",
    "pen",
    "penalty",
    "pencil",
    "people",
    "pepper",
    "perfect",
    "permit",
    "person",
    "pet",
    "phone",
    "photo",
    "phrase",
    "physical",
    "piano",
    "picnic",
    "picture",
    "piece",
    "pig",
    "pigeon",
    "pill",
    "pilot",
    "pink",
    "pioneer",
    "pipe",
    "pistol",
    "pitch",
    "pizza",
    "place",
    "planet",
    "plastic",
    "plate",
    "play",
    "please",
    "pledge",
    "pluck",
    "plug",
    "plunge",
    "poem",
    "poet",
    "point",
    "polar",
    "pole",
    "police",
    "pond",
    "pony",
    "pool",
    "popular",
    "portion",
    "position",
    "possible",
    "post",
    "potato",
    "pottery",
    "poverty",
    "powder",
    "power",
    "practice",
    "praise",
    "predict",
    "prefer",
    "prepare",
    "present",
    "pretty",
    "prevent",
    "price",
    "pride",
    "primary",
    "print",
    "priority",
    "prison",
    "private",
    "prize",
    "problem",
    "process",
    "produce",
    "profit",
    "program",
    "project",
    "promote",
    "proof",
    "property",
    "prosper",
    "protect",
    "proud",
    "provide",
    "public",
    "pudding",
    "pull",
    "pulp",
    "pulse",
    "pumpkin",
    "punch",
    "pupil",
    "puppy",
    "purchase",
    "purity",
    "purpose",
    "purse",
    "push",
    "put",
    "puzzle",
    "pyramid",
    "quality",
    "quantum",
    "quarter",
    "question",
    "quick",
    "quit",
    "quiz",
    "quote",
    "rabbit",
    "raccoon",
    "race",
    "rack",
    "radar",
    "radio",
    "rail",
    "rain",
    "raise",
    "rally",
    "ramp",
    "ranch",
    "random",
    "range",
    "rapid",
    "rare",
    "rate",
    "rather",
    "raven",
    "raw",
    "razor",
    "ready",
    "real",
    "reason",
    "rebel",
    "rebuild",
    "recall",
    "receive",
    "recipe",
    "record",
    "recycle",
    "reduce",
    "reflect",
    "reform",
    "refuse",
    "region",
    "regret",
    "regular",
    "reject",
    "relax",
    "release",
    "relief",
    "rely",
    "remain",
    "remember",
    "remind",
    "remove",
    "render",
    "renew",
    "rent",
    "reopen",
    "repair",
    "repeat",
    "replace",
    "report",
    "require",
    "rescue",
    "resemble",
    "resist",
    "resource",
    "response",
    "result",
    "retire",
    "retreat",
    "return",
    "reunion",
    "reveal",
    "review",
    "reward",
    "rhythm",
    "rib",
    "ribbon",
    "rice",
    "rich",
    "ride",
    "ridge",
    "rifle",
    "right",
    "rigid",
    "ring",
    "riot",
    "ripple",
    "risk",
    "ritual",
    "rival",
    "river",
    "road",
    "roast",
    "robot",
    "robust",
    "rocket",
    "romance",
    "roof",
    "rookie",
    "room",
    "rose",
    "rotate",
    "rough",
    "round",
    "route",
    "royal",
    "rubber",
    "rude",
    "rug",
    "rule",
    "run",
    "runway",
    "rural",
    "sad",
    "saddle",
    "sadness",
    "safe",
    "sail",
    "salad",
    "salmon",
    "salon",
    "salt",
    "salute",
    "same",
    "sample",
    "sand",
    "satisfy",
    "satoshi",
    "sauce",
    "sausage",
    "save",
    "say",
    "scale",
    "scan",
    "scare",
    "scatter",
    "scene",
    "scheme",
    "school",
    "science",
    "scissors",
    "scorpion",
    "scout",
    "scrap",
    "screen",
    "script",
    "scrub",
    "sea",
    "search",
    "season",
    "seat",
    "second",
    "secret",
    "section",
    "security",
    "seed",
    "seek",
    "segment",
    "select",
    "sell",
    "seminar",
    "senior",
    "sense",
    "sentence",
    "series",
    "service",
    "session",
    "settle",
    "setup",
    "seven",
    "shadow",
    "shaft",
    "shallow",
    "share",
    "shed",
    "shell",
    "sheriff",
    "shield",
    "shift",
    "shine",
    "ship",
    "shiver",
    "shock",
    "shoe",
    "shoot",
    "shop",
    "short",
    "shoulder",
    "shove",
    "shrimp",
    "shrug",
    "shuffle",
    "shy",
    "sibling",
    "sick",
    "side",
    "siege",
    "sight",
    "sign",
    "silent",
    "silk",
    "silly",
    "silver",
    "similar",
    "simple",
    "since",
    "sing",
    "siren",
    "sister",
    "situate",
    "six",
    "size",
    "skate",
    "sketch",
    "ski",
    "skill",
    "skin",
    "skirt",
    "skull",
    "slab",
    "slam",
    "sleep",
    "slender",
    "slice",
    "slide",
    "slight",
    "slim",
    "slogan",
    "slot",
    "slow",
    "slush",
    "small",
    "smart",
    "smile",
    "smoke",
    "smooth",
    "snack",
    "snake",
    "snap",
    "sniff",
    "snow",
    "soap",
    "soccer",
    "social",
    "sock",
    "soda",
    "soft",
    "solar",
    "soldier",
    "solid",
    "solution",
    "solve",
    "someone",
    "song",
    "soon",
    "sorry",
    "sort",
    "soul",
    "sound",
    "soup",
    "source",
    "south",
    "space",
    "spare",
    "spatial",
    "spawn",
    "speak",
    "special",
    "speed",
    "spell",
    "spend",
    "sphere",
    "spice",
    "spider",
    "spike",
    "spin",
    "spirit",
    "split",
    "spoil",
    "sponsor",
    "spoon",
    "sport",
    "spot",
    "spray",
    "spread",
    "spring",
    "spy",
    "square",
    "squeeze",
    "squirrel",
    "stable",
    "stadium",
    "staff",
    "stage",
    "stairs",
    "stamp",
    "stand",
    "start",
    "state",
    "stay",
    "steak",
    "steel",
    "stem",
    "step",
    "stereo",
    "stick",
    "still",
    "sting",
    "stock",
    "stomach",
    "stone",
    "stool",
    "story",
    "stove",
    "strategy",
    "street",
    "strike",
    "strong",
    "struggle",
    "student",
    "stuff",
    "stumble",
    "style",
    "subject",
    "submit",
    "subway",
    "success",
    "such",
    "sudden",
    "suffer",
    "sugar",
    "suggest",
    "suit",
    "summer",
    "sun",
    "sunny",
    "sunset",
    "super",
    "supply",
    "supreme",
    "sure",
    "surface",
    "surge",
    "surprise",
    "surround",
    "survey",
    "suspect",
    "sustain",
    "swallow",
    "swamp",
    "swap",
    "swarm",
    "swear",
    "sweet",
    "swift",
    "swim",
    "swing",
    "switch",
    "sword",
    "symbol",
    "symptom",
    "syrup",
    "system",
    "table",
    "tackle",
    "tag",
    "tail",
    "talent",
    "talk",
    "tank",
    "tape",
    "target",
    "task",
    "taste",
    "tattoo",
    "taxi",
    "teach",
    "team",
    "tell",
    "ten",
    "tenant",
    "tennis",
    "tent",
    "term",
    "test",
    "text",
    "thank",
    "that",
    "theme",
    "then",
    "theory",
    "there",
    "they",
    "thing",
    "this",
    "thought",
    "three",
    "thrive",
    "throw",
    "thumb",
    "thunder",
    "ticket",
    "tide",
    "tiger",
    "tilt",
    "timber",
    "time",
    "tiny",
    "tip",
    "tired",
    "tissue",
    "title",
    "toast",
    "tobacco",
    "today",
    "toddler",
    "toe",
    "together",
    "toilet",
    "token",
    "tomato",
    "tomorrow",
    "tone",
    "tongue",
    "tonight",
    "tool",
    "tooth",
    "top",
    "topic",
    "topple",
    "torch",
    "tornado",
    "tortoise",
    "toss",
    "total",
    "tourist",
    "toward",
    "tower",
    "town",
    "toy",
    "track",
    "trade",
    "traffic",
    "tragic",
    "train",
    "transfer",
    "trap",
    "trash",
    "travel",
    "tray",
    "treat",
    "tree",
    "trend",
    "trial",
    "tribe",
    "trick",
    "trigger",
    "trim",
    "trip",
    "trophy",
    "trouble",
    "truck",
    "true",
    "truly",
    "trumpet",
    "trust",
    "truth",
    "try",
    "tube",
    "tuition",
    "tumble",
    "tuna",
    "tunnel",
    "turkey",
    "turn",
    "turtle",
    "twelve",
    "twenty",
    "twice",
    "twin",
    "twist",
    "two",
    "type",
    "typical",
    "ugly",
    "umbrella",
    "unable",
    "unaware",
    "uncle",
    "uncover",
    "under",
    "undo",
    "unfair",
    "unfold",
    "unhappy",
    "uniform",
    "unique",
    "unit",
    "universe",
    "unknown",
    "unlock",
    "until",
    "unusual",
    "unveil",
    "update",
    "upgrade",
    "uphold",
    "upon",
    "upper",
    "upset",
    "urban",
    "urge",
    "usage",
    "use",
    "used",
    "useful",
    "useless",
    "usual",
    "utility",
    "vacant",
    "vacuum",
    "vague",
    "valid",
    "valley",
    "valve",
    "van",
    "vanish",
    "vapor",
    "various",
    "vast",
    "vault",
    "vehicle",
    "velvet",
    "vendor",
    "venture",
    "venue",
    "verb",
    "verify",
    "version",
    "very",
    "vessel",
    "veteran",
    "viable",
    "vibrant",
    "vicious",
    "victory",
    "video",
    "view",
    "village",
    "vintage",
    "violin",
    "virtual",
    "virus",
    "visa",
    "visit",
    "visual",
    "vital",
    "vivid",
    "vocal",
    "voice",
    "void",
    "volcano",
    "volume",
    "vote",
    "voyage",
    "wage",
    "wagon",
    "wait",
    "walk",
    "wall",
    "walnut",
    "want",
    "warfare",
    "warm",
    "warrior",
    "wash",
    "wasp",
    "waste",
    "water",
    "wave",
    "way",
    "wealth",
    "weapon",
    "wear",
    "weasel",
    "weather",
    "web",
    "wedding",
    "weekend",
    "weird",
    "welcome",
    "west",
    "wet",
    "whale",
    "what",
    "wheat",
    "wheel",
    "when",
    "where",
    "whip",
    "whisper",
    "wide",
    "width",
    "wife",
    "wild",
    "will",
    "win",
    "window",
    "wine",
    "wing",
    "wink",
    "winner",
    "winter",
    "wire",
    "wisdom",
    "wise",
    "wish",
    "witness",
    "wolf",
    "woman",
    "wonder",
    "wood",
    "wool",
    "word",
    "work",
    "world",
    "worry",
    "worth",
    "wrap",
    "wreck",
    "wrestle",
    "wrist",
    "write",
    "wrong",
    "yard",
    "year",
    "yellow",
    "you",
    "young",
    "youth",
    "zebra",
    "zero",
    "zone",
    "zoo"
]

},{}],59:[function(require,module,exports){
module.exports=[
    "abaisser",
    "abandon",
    "abdiquer",
    "abeille",
    "abolir",
    "aborder",
    "aboutir",
    "aboyer",
    "abrasif",
    "abreuver",
    "abriter",
    "abroger",
    "abrupt",
    "absence",
    "absolu",
    "absurde",
    "abusif",
    "abyssal",
    "academie",
    "acajou",
    "acarien",
    "accabler",
    "accepter",
    "acclamer",
    "accolade",
    "accroche",
    "accuser",
    "acerbe",
    "achat",
    "acheter",
    "aciduler",
    "acier",
    "acompte",
    "acquerir",
    "acronyme",
    "acteur",
    "actif",
    "actuel",
    "adepte",
    "adequat",
    "adhesif",
    "adjectif",
    "adjuger",
    "admettre",
    "admirer",
    "adopter",
    "adorer",
    "adoucir",
    "adresse",
    "adroit",
    "adulte",
    "adverbe",
    "aerer",
    "aeronef",
    "affaire",
    "affecter",
    "affiche",
    "affreux",
    "affubler",
    "agacer",
    "agencer",
    "agile",
    "agiter",
    "agrafer",
    "agreable",
    "agrume",
    "aider",
    "aiguille",
    "ailier",
    "aimable",
    "aisance",
    "ajouter",
    "ajuster",
    "alarmer",
    "alchimie",
    "alerte",
    "algebre",
    "algue",
    "aliener",
    "aliment",
    "alleger",
    "alliage",
    "allouer",
    "allumer",
    "alourdir",
    "alpaga",
    "altesse",
    "alveole",
    "amateur",
    "ambigu",
    "ambre",
    "amenager",
    "amertume",
    "amidon",
    "amiral",
    "amorcer",
    "amour",
    "amovible",
    "amphibie",
    "ampleur",
    "amusant",
    "analyse",
    "anaphore",
    "anarchie",
    "anatomie",
    "ancien",
    "aneantir",
    "angle",
    "angoisse",
    "anguleux",
    "animal",
    "annexer",
    "annonce",
    "annuel",
    "anodin",
    "anomalie",
    "anonyme",
    "anormal",
    "antenne",
    "antidote",
    "anxieux",
    "apaiser",
    "aperitif",
    "aplanir",
    "apologie",
    "appareil",
    "appeler",
    "apporter",
    "appuyer",
    "aquarium",
    "aqueduc",
    "arbitre",
    "arbuste",
    "ardeur",
    "ardoise",
    "argent",
    "arlequin",
    "armature",
    "armement",
    "armoire",
    "armure",
    "arpenter",
    "arracher",
    "arriver",
    "arroser",
    "arsenic",
    "arteriel",
    "article",
    "aspect",
    "asphalte",
    "aspirer",
    "assaut",
    "asservir",
    "assiette",
    "associer",
    "assurer",
    "asticot",
    "astre",
    "astuce",
    "atelier",
    "atome",
    "atrium",
    "atroce",
    "attaque",
    "attentif",
    "attirer",
    "attraper",
    "aubaine",
    "auberge",
    "audace",
    "audible",
    "augurer",
    "aurore",
    "automne",
    "autruche",
    "avaler",
    "avancer",
    "avarice",
    "avenir",
    "averse",
    "aveugle",
    "aviateur",
    "avide",
    "avion",
    "aviser",
    "avoine",
    "avouer",
    "avril",
    "axial",
    "axiome",
    "badge",
    "bafouer",
    "bagage",
    "baguette",
    "baignade",
    "balancer",
    "balcon",
    "baleine",
    "balisage",
    "bambin",
    "bancaire",
    "bandage",
    "banlieue",
    "banniere",
    "banquier",
    "barbier",
    "baril",
    "baron",
    "barque",
    "barrage",
    "bassin",
    "bastion",
    "bataille",
    "bateau",
    "batterie",
    "baudrier",
    "bavarder",
    "belette",
    "belier",
    "belote",
    "benefice",
    "berceau",
    "berger",
    "berline",
    "bermuda",
    "besace",
    "besogne",
    "betail",
    "beurre",
    "biberon",
    "bicycle",
    "bidule",
    "bijou",
    "bilan",
    "bilingue",
    "billard",
    "binaire",
    "biologie",
    "biopsie",
    "biotype",
    "biscuit",
    "bison",
    "bistouri",
    "bitume",
    "bizarre",
    "blafard",
    "blague",
    "blanchir",
    "blessant",
    "blinder",
    "blond",
    "bloquer",
    "blouson",
    "bobard",
    "bobine",
    "boire",
    "boiser",
    "bolide",
    "bonbon",
    "bondir",
    "bonheur",
    "bonifier",
    "bonus",
    "bordure",
    "borne",
    "botte",
    "boucle",
    "boueux",
    "bougie",
    "boulon",
    "bouquin",
    "bourse",
    "boussole",
    "boutique",
    "boxeur",
    "branche",
    "brasier",
    "brave",
    "brebis",
    "breche",
    "breuvage",
    "bricoler",
    "brigade",
    "brillant",
    "brioche",
    "brique",
    "brochure",
    "broder",
    "bronzer",
    "brousse",
    "broyeur",
    "brume",
    "brusque",
    "brutal",
    "bruyant",
    "buffle",
    "buisson",
    "bulletin",
    "bureau",
    "burin",
    "bustier",
    "butiner",
    "butoir",
    "buvable",
    "buvette",
    "cabanon",
    "cabine",
    "cachette",
    "cadeau",
    "cadre",
    "cafeine",
    "caillou",
    "caisson",
    "calculer",
    "calepin",
    "calibre",
    "calmer",
    "calomnie",
    "calvaire",
    "camarade",
    "camera",
    "camion",
    "campagne",
    "canal",
    "caneton",
    "canon",
    "cantine",
    "canular",
    "capable",
    "caporal",
    "caprice",
    "capsule",
    "capter",
    "capuche",
    "carabine",
    "carbone",
    "caresser",
    "caribou",
    "carnage",
    "carotte",
    "carreau",
    "carton",
    "cascade",
    "casier",
    "casque",
    "cassure",
    "causer",
    "caution",
    "cavalier",
    "caverne",
    "caviar",
    "cedille",
    "ceinture",
    "celeste",
    "cellule",
    "cendrier",
    "censurer",
    "central",
    "cercle",
    "cerebral",
    "cerise",
    "cerner",
    "cerveau",
    "cesser",
    "chagrin",
    "chaise",
    "chaleur",
    "chambre",
    "chance",
    "chapitre",
    "charbon",
    "chasseur",
    "chaton",
    "chausson",
    "chavirer",
    "chemise",
    "chenille",
    "chequier",
    "chercher",
    "cheval",
    "chien",
    "chiffre",
    "chignon",
    "chimere",
    "chiot",
    "chlorure",
    "chocolat",
    "choisir",
    "chose",
    "chouette",
    "chrome",
    "chute",
    "cigare",
    "cigogne",
    "cimenter",
    "cinema",
    "cintrer",
    "circuler",
    "cirer",
    "cirque",
    "citerne",
    "citoyen",
    "citron",
    "civil",
    "clairon",
    "clameur",
    "claquer",
    "classe",
    "clavier",
    "client",
    "cligner",
    "climat",
    "clivage",
    "cloche",
    "clonage",
    "cloporte",
    "cobalt",
    "cobra",
    "cocasse",
    "cocotier",
    "coder",
    "codifier",
    "coffre",
    "cogner",
    "cohesion",
    "coiffer",
    "coincer",
    "colere",
    "colibri",
    "colline",
    "colmater",
    "colonel",
    "combat",
    "comedie",
    "commande",
    "compact",
    "concert",
    "conduire",
    "confier",
    "congeler",
    "connoter",
    "consonne",
    "contact",
    "convexe",
    "copain",
    "copie",
    "corail",
    "corbeau",
    "cordage",
    "corniche",
    "corpus",
    "correct",
    "cortege",
    "cosmique",
    "costume",
    "coton",
    "coude",
    "coupure",
    "courage",
    "couteau",
    "couvrir",
    "coyote",
    "crabe",
    "crainte",
    "cravate",
    "crayon",
    "creature",
    "crediter",
    "cremeux",
    "creuser",
    "crevette",
    "cribler",
    "crier",
    "cristal",
    "critere",
    "croire",
    "croquer",
    "crotale",
    "crucial",
    "cruel",
    "crypter",
    "cubique",
    "cueillir",
    "cuillere",
    "cuisine",
    "cuivre",
    "culminer",
    "cultiver",
    "cumuler",
    "cupide",
    "curatif",
    "curseur",
    "cyanure",
    "cycle",
    "cylindre",
    "cynique",
    "daigner",
    "damier",
    "danger",
    "danseur",
    "dauphin",
    "debattre",
    "debiter",
    "deborder",
    "debrider",
    "debutant",
    "decaler",
    "decembre",
    "dechirer",
    "decider",
    "declarer",
    "decorer",
    "decrire",
    "decupler",
    "dedale",
    "deductif",
    "deesse",
    "defensif",
    "defiler",
    "defrayer",
    "degager",
    "degivrer",
    "deglutir",
    "degrafer",
    "dejeuner",
    "delice",
    "deloger",
    "demander",
    "demeurer",
    "demolir",
    "denicher",
    "denouer",
    "dentelle",
    "denuder",
    "depart",
    "depenser",
    "dephaser",
    "deplacer",
    "deposer",
    "deranger",
    "derober",
    "desastre",
    "descente",
    "desert",
    "designer",
    "desobeir",
    "dessiner",
    "destrier",
    "detacher",
    "detester",
    "detourer",
    "detresse",
    "devancer",
    "devenir",
    "deviner",
    "devoir",
    "diable",
    "dialogue",
    "diamant",
    "dicter",
    "differer",
    "digerer",
    "digital",
    "digne",
    "diluer",
    "dimanche",
    "diminuer",
    "dioxyde",
    "directif",
    "diriger",
    "discuter",
    "disposer",
    "dissiper",
    "distance",
    "divertir",
    "diviser",
    "docile",
    "docteur",
    "dogme",
    "doigt",
    "domaine",
    "domicile",
    "dompter",
    "donateur",
    "donjon",
    "donner",
    "dopamine",
    "dortoir",
    "dorure",
    "dosage",
    "doseur",
    "dossier",
    "dotation",
    "douanier",
    "double",
    "douceur",
    "douter",
    "doyen",
    "dragon",
    "draper",
    "dresser",
    "dribbler",
    "droiture",
    "duperie",
    "duplexe",
    "durable",
    "durcir",
    "dynastie",
    "eblouir",
    "ecarter",
    "echarpe",
    "echelle",
    "eclairer",
    "eclipse",
    "eclore",
    "ecluse",
    "ecole",
    "economie",
    "ecorce",
    "ecouter",
    "ecraser",
    "ecremer",
    "ecrivain",
    "ecrou",
    "ecume",
    "ecureuil",
    "edifier",
    "eduquer",
    "effacer",
    "effectif",
    "effigie",
    "effort",
    "effrayer",
    "effusion",
    "egaliser",
    "egarer",
    "ejecter",
    "elaborer",
    "elargir",
    "electron",
    "elegant",
    "elephant",
    "eleve",
    "eligible",
    "elitisme",
    "eloge",
    "elucider",
    "eluder",
    "emballer",
    "embellir",
    "embryon",
    "emeraude",
    "emission",
    "emmener",
    "emotion",
    "emouvoir",
    "empereur",
    "employer",
    "emporter",
    "emprise",
    "emulsion",
    "encadrer",
    "enchere",
    "enclave",
    "encoche",
    "endiguer",
    "endosser",
    "endroit",
    "enduire",
    "energie",
    "enfance",
    "enfermer",
    "enfouir",
    "engager",
    "engin",
    "englober",
    "enigme",
    "enjamber",
    "enjeu",
    "enlever",
    "ennemi",
    "ennuyeux",
    "enrichir",
    "enrobage",
    "enseigne",
    "entasser",
    "entendre",
    "entier",
    "entourer",
    "entraver",
    "enumerer",
    "envahir",
    "enviable",
    "envoyer",
    "enzyme",
    "eolien",
    "epaissir",
    "epargne",
    "epatant",
    "epaule",
    "epicerie",
    "epidemie",
    "epier",
    "epilogue",
    "epine",
    "episode",
    "epitaphe",
    "epoque",
    "epreuve",
    "eprouver",
    "epuisant",
    "equerre",
    "equipe",
    "eriger",
    "erosion",
    "erreur",
    "eruption",
    "escalier",
    "espadon",
    "espece",
    "espiegle",
    "espoir",
    "esprit",
    "esquiver",
    "essayer",
    "essence",
    "essieu",
    "essorer",
    "estime",
    "estomac",
    "estrade",
    "etagere",
    "etaler",
    "etanche",
    "etatique",
    "eteindre",
    "etendoir",
    "eternel",
    "ethanol",
    "ethique",
    "ethnie",
    "etirer",
    "etoffer",
    "etoile",
    "etonnant",
    "etourdir",
    "etrange",
    "etroit",
    "etude",
    "euphorie",
    "evaluer",
    "evasion",
    "eventail",
    "evidence",
    "eviter",
    "evolutif",
    "evoquer",
    "exact",
    "exagerer",
    "exaucer",
    "exceller",
    "excitant",
    "exclusif",
    "excuse",
    "executer",
    "exemple",
    "exercer",
    "exhaler",
    "exhorter",
    "exigence",
    "exiler",
    "exister",
    "exotique",
    "expedier",
    "explorer",
    "exposer",
    "exprimer",
    "exquis",
    "extensif",
    "extraire",
    "exulter",
    "fable",
    "fabuleux",
    "facette",
    "facile",
    "facture",
    "faiblir",
    "falaise",
    "fameux",
    "famille",
    "farceur",
    "farfelu",
    "farine",
    "farouche",
    "fasciner",
    "fatal",
    "fatigue",
    "faucon",
    "fautif",
    "faveur",
    "favori",
    "febrile",
    "feconder",
    "federer",
    "felin",
    "femme",
    "femur",
    "fendoir",
    "feodal",
    "fermer",
    "feroce",
    "ferveur",
    "festival",
    "feuille",
    "feutre",
    "fevrier",
    "fiasco",
    "ficeler",
    "fictif",
    "fidele",
    "figure",
    "filature",
    "filetage",
    "filiere",
    "filleul",
    "filmer",
    "filou",
    "filtrer",
    "financer",
    "finir",
    "fiole",
    "firme",
    "fissure",
    "fixer",
    "flairer",
    "flamme",
    "flasque",
    "flatteur",
    "fleau",
    "fleche",
    "fleur",
    "flexion",
    "flocon",
    "flore",
    "fluctuer",
    "fluide",
    "fluvial",
    "folie",
    "fonderie",
    "fongible",
    "fontaine",
    "forcer",
    "forgeron",
    "formuler",
    "fortune",
    "fossile",
    "foudre",
    "fougere",
    "fouiller",
    "foulure",
    "fourmi",
    "fragile",
    "fraise",
    "franchir",
    "frapper",
    "frayeur",
    "fregate",
    "freiner",
    "frelon",
    "fremir",
    "frenesie",
    "frere",
    "friable",
    "friction",
    "frisson",
    "frivole",
    "froid",
    "fromage",
    "frontal",
    "frotter",
    "fruit",
    "fugitif",
    "fuite",
    "fureur",
    "furieux",
    "furtif",
    "fusion",
    "futur",
    "gagner",
    "galaxie",
    "galerie",
    "gambader",
    "garantir",
    "gardien",
    "garnir",
    "garrigue",
    "gazelle",
    "gazon",
    "geant",
    "gelatine",
    "gelule",
    "gendarme",
    "general",
    "genie",
    "genou",
    "gentil",
    "geologie",
    "geometre",
    "geranium",
    "germe",
    "gestuel",
    "geyser",
    "gibier",
    "gicler",
    "girafe",
    "givre",
    "glace",
    "glaive",
    "glisser",
    "globe",
    "gloire",
    "glorieux",
    "golfeur",
    "gomme",
    "gonfler",
    "gorge",
    "gorille",
    "goudron",
    "gouffre",
    "goulot",
    "goupille",
    "gourmand",
    "goutte",
    "graduel",
    "graffiti",
    "graine",
    "grand",
    "grappin",
    "gratuit",
    "gravir",
    "grenat",
    "griffure",
    "griller",
    "grimper",
    "grogner",
    "gronder",
    "grotte",
    "groupe",
    "gruger",
    "grutier",
    "gruyere",
    "guepard",
    "guerrier",
    "guide",
    "guimauve",
    "guitare",
    "gustatif",
    "gymnaste",
    "gyrostat",
    "habitude",
    "hachoir",
    "halte",
    "hameau",
    "hangar",
    "hanneton",
    "haricot",
    "harmonie",
    "harpon",
    "hasard",
    "helium",
    "hematome",
    "herbe",
    "herisson",
    "hermine",
    "heron",
    "hesiter",
    "heureux",
    "hiberner",
    "hibou",
    "hilarant",
    "histoire",
    "hiver",
    "homard",
    "hommage",
    "homogene",
    "honneur",
    "honorer",
    "honteux",
    "horde",
    "horizon",
    "horloge",
    "hormone",
    "horrible",
    "houleux",
    "housse",
    "hublot",
    "huileux",
    "humain",
    "humble",
    "humide",
    "humour",
    "hurler",
    "hydromel",
    "hygiene",
    "hymne",
    "hypnose",
    "idylle",
    "ignorer",
    "iguane",
    "illicite",
    "illusion",
    "image",
    "imbiber",
    "imiter",
    "immense",
    "immobile",
    "immuable",
    "impact",
    "imperial",
    "implorer",
    "imposer",
    "imprimer",
    "imputer",
    "incarner",
    "incendie",
    "incident",
    "incliner",
    "incolore",
    "indexer",
    "indice",
    "inductif",
    "inedit",
    "ineptie",
    "inexact",
    "infini",
    "infliger",
    "informer",
    "infusion",
    "ingerer",
    "inhaler",
    "inhiber",
    "injecter",
    "injure",
    "innocent",
    "inoculer",
    "inonder",
    "inscrire",
    "insecte",
    "insigne",
    "insolite",
    "inspirer",
    "instinct",
    "insulter",
    "intact",
    "intense",
    "intime",
    "intrigue",
    "intuitif",
    "inutile",
    "invasion",
    "inventer",
    "inviter",
    "invoquer",
    "ironique",
    "irradier",
    "irreel",
    "irriter",
    "isoler",
    "ivoire",
    "ivresse",
    "jaguar",
    "jaillir",
    "jambe",
    "janvier",
    "jardin",
    "jauger",
    "jaune",
    "javelot",
    "jetable",
    "jeton",
    "jeudi",
    "jeunesse",
    "joindre",
    "joncher",
    "jongler",
    "joueur",
    "jouissif",
    "journal",
    "jovial",
    "joyau",
    "joyeux",
    "jubiler",
    "jugement",
    "junior",
    "jupon",
    "juriste",
    "justice",
    "juteux",
    "juvenile",
    "kayak",
    "kimono",
    "kiosque",
    "label",
    "labial",
    "labourer",
    "lacerer",
    "lactose",
    "lagune",
    "laine",
    "laisser",
    "laitier",
    "lambeau",
    "lamelle",
    "lampe",
    "lanceur",
    "langage",
    "lanterne",
    "lapin",
    "largeur",
    "larme",
    "laurier",
    "lavabo",
    "lavoir",
    "lecture",
    "legal",
    "leger",
    "legume",
    "lessive",
    "lettre",
    "levier",
    "lexique",
    "lezard",
    "liasse",
    "liberer",
    "libre",
    "licence",
    "licorne",
    "liege",
    "lievre",
    "ligature",
    "ligoter",
    "ligue",
    "limer",
    "limite",
    "limonade",
    "limpide",
    "lineaire",
    "lingot",
    "lionceau",
    "liquide",
    "lisiere",
    "lister",
    "lithium",
    "litige",
    "littoral",
    "livreur",
    "logique",
    "lointain",
    "loisir",
    "lombric",
    "loterie",
    "louer",
    "lourd",
    "loutre",
    "louve",
    "loyal",
    "lubie",
    "lucide",
    "lucratif",
    "lueur",
    "lugubre",
    "luisant",
    "lumiere",
    "lunaire",
    "lundi",
    "luron",
    "lutter",
    "luxueux",
    "machine",
    "magasin",
    "magenta",
    "magique",
    "maigre",
    "maillon",
    "maintien",
    "mairie",
    "maison",
    "majorer",
    "malaxer",
    "malefice",
    "malheur",
    "malice",
    "mallette",
    "mammouth",
    "mandater",
    "maniable",
    "manquant",
    "manteau",
    "manuel",
    "marathon",
    "marbre",
    "marchand",
    "mardi",
    "maritime",
    "marqueur",
    "marron",
    "marteler",
    "mascotte",
    "massif",
    "materiel",
    "matiere",
    "matraque",
    "maudire",
    "maussade",
    "mauve",
    "maximal",
    "mechant",
    "meconnu",
    "medaille",
    "medecin",
    "mediter",
    "meduse",
    "meilleur",
    "melange",
    "melodie",
    "membre",
    "memoire",
    "menacer",
    "mener",
    "menhir",
    "mensonge",
    "mentor",
    "mercredi",
    "merite",
    "merle",
    "messager",
    "mesure",
    "metal",
    "meteore",
    "methode",
    "metier",
    "meuble",
    "miauler",
    "microbe",
    "miette",
    "mignon",
    "migrer",
    "milieu",
    "million",
    "mimique",
    "mince",
    "mineral",
    "minimal",
    "minorer",
    "minute",
    "miracle",
    "miroiter",
    "missile",
    "mixte",
    "mobile",
    "moderne",
    "moelleux",
    "mondial",
    "moniteur",
    "monnaie",
    "monotone",
    "monstre",
    "montagne",
    "monument",
    "moqueur",
    "morceau",
    "morsure",
    "mortier",
    "moteur",
    "motif",
    "mouche",
    "moufle",
    "moulin",
    "mousson",
    "mouton",
    "mouvant",
    "multiple",
    "munition",
    "muraille",
    "murene",
    "murmure",
    "muscle",
    "museum",
    "musicien",
    "mutation",
    "muter",
    "mutuel",
    "myriade",
    "myrtille",
    "mystere",
    "mythique",
    "nageur",
    "nappe",
    "narquois",
    "narrer",
    "natation",
    "nation",
    "nature",
    "naufrage",
    "nautique",
    "navire",
    "nebuleux",
    "nectar",
    "nefaste",
    "negation",
    "negliger",
    "negocier",
    "neige",
    "nerveux",
    "nettoyer",
    "neurone",
    "neutron",
    "neveu",
    "niche",
    "nickel",
    "nitrate",
    "niveau",
    "noble",
    "nocif",
    "nocturne",
    "noirceur",
    "noisette",
    "nomade",
    "nombreux",
    "nommer",
    "normatif",
    "notable",
    "notifier",
    "notoire",
    "nourrir",
    "nouveau",
    "novateur",
    "novembre",
    "novice",
    "nuage",
    "nuancer",
    "nuire",
    "nuisible",
    "numero",
    "nuptial",
    "nuque",
    "nutritif",
    "obeir",
    "objectif",
    "obliger",
    "obscur",
    "observer",
    "obstacle",
    "obtenir",
    "obturer",
    "occasion",
    "occuper",
    "ocean",
    "octobre",
    "octroyer",
    "octupler",
    "oculaire",
    "odeur",
    "odorant",
    "offenser",
    "officier",
    "offrir",
    "ogive",
    "oiseau",
    "oisillon",
    "olfactif",
    "olivier",
    "ombrage",
    "omettre",
    "onctueux",
    "onduler",
    "onereux",
    "onirique",
    "opale",
    "opaque",
    "operer",
    "opinion",
    "opportun",
    "opprimer",
    "opter",
    "optique",
    "orageux",
    "orange",
    "orbite",
    "ordonner",
    "oreille",
    "organe",
    "orgueil",
    "orifice",
    "ornement",
    "orque",
    "ortie",
    "osciller",
    "osmose",
    "ossature",
    "otarie",
    "ouragan",
    "ourson",
    "outil",
    "outrager",
    "ouvrage",
    "ovation",
    "oxyde",
    "oxygene",
    "ozone",
    "paisible",
    "palace",
    "palmares",
    "palourde",
    "palper",
    "panache",
    "panda",
    "pangolin",
    "paniquer",
    "panneau",
    "panorama",
    "pantalon",
    "papaye",
    "papier",
    "papoter",
    "papyrus",
    "paradoxe",
    "parcelle",
    "paresse",
    "parfumer",
    "parler",
    "parole",
    "parrain",
    "parsemer",
    "partager",
    "parure",
    "parvenir",
    "passion",
    "pasteque",
    "paternel",
    "patience",
    "patron",
    "pavillon",
    "pavoiser",
    "payer",
    "paysage",
    "peigne",
    "peintre",
    "pelage",
    "pelican",
    "pelle",
    "pelouse",
    "peluche",
    "pendule",
    "penetrer",
    "penible",
    "pensif",
    "penurie",
    "pepite",
    "peplum",
    "perdrix",
    "perforer",
    "periode",
    "permuter",
    "perplexe",
    "persil",
    "perte",
    "peser",
    "petale",
    "petit",
    "petrir",
    "peuple",
    "pharaon",
    "phobie",
    "phoque",
    "photon",
    "phrase",
    "physique",
    "piano",
    "pictural",
    "piece",
    "pierre",
    "pieuvre",
    "pilote",
    "pinceau",
    "pipette",
    "piquer",
    "pirogue",
    "piscine",
    "piston",
    "pivoter",
    "pixel",
    "pizza",
    "placard",
    "plafond",
    "plaisir",
    "planer",
    "plaque",
    "plastron",
    "plateau",
    "pleurer",
    "plexus",
    "pliage",
    "plomb",
    "plonger",
    "pluie",
    "plumage",
    "pochette",
    "poesie",
    "poete",
    "pointe",
    "poirier",
    "poisson",
    "poivre",
    "polaire",
    "policier",
    "pollen",
    "polygone",
    "pommade",
    "pompier",
    "ponctuel",
    "ponderer",
    "poney",
    "portique",
    "position",
    "posseder",
    "posture",
    "potager",
    "poteau",
    "potion",
    "pouce",
    "poulain",
    "poumon",
    "pourpre",
    "poussin",
    "pouvoir",
    "prairie",
    "pratique",
    "precieux",
    "predire",
    "prefixe",
    "prelude",
    "prenom",
    "presence",
    "pretexte",
    "prevoir",
    "primitif",
    "prince",
    "prison",
    "priver",
    "probleme",
    "proceder",
    "prodige",
    "profond",
    "progres",
    "proie",
    "projeter",
    "prologue",
    "promener",
    "propre",
    "prospere",
    "proteger",
    "prouesse",
    "proverbe",
    "prudence",
    "pruneau",
    "psychose",
    "public",
    "puceron",
    "puiser",
    "pulpe",
    "pulsar",
    "punaise",
    "punitif",
    "pupitre",
    "purifier",
    "puzzle",
    "pyramide",
    "quasar",
    "querelle",
    "question",
    "quietude",
    "quitter",
    "quotient",
    "racine",
    "raconter",
    "radieux",
    "ragondin",
    "raideur",
    "raisin",
    "ralentir",
    "rallonge",
    "ramasser",
    "rapide",
    "rasage",
    "ratisser",
    "ravager",
    "ravin",
    "rayonner",
    "reactif",
    "reagir",
    "realiser",
    "reanimer",
    "recevoir",
    "reciter",
    "reclamer",
    "recolter",
    "recruter",
    "reculer",
    "recycler",
    "rediger",
    "redouter",
    "refaire",
    "reflexe",
    "reformer",
    "refrain",
    "refuge",
    "regalien",
    "region",
    "reglage",
    "regulier",
    "reiterer",
    "rejeter",
    "rejouer",
    "relatif",
    "relever",
    "relief",
    "remarque",
    "remede",
    "remise",
    "remonter",
    "remplir",
    "remuer",
    "renard",
    "renfort",
    "renifler",
    "renoncer",
    "rentrer",
    "renvoi",
    "replier",
    "reporter",
    "reprise",
    "reptile",
    "requin",
    "reserve",
    "resineux",
    "resoudre",
    "respect",
    "rester",
    "resultat",
    "retablir",
    "retenir",
    "reticule",
    "retomber",
    "retracer",
    "reunion",
    "reussir",
    "revanche",
    "revivre",
    "revolte",
    "revulsif",
    "richesse",
    "rideau",
    "rieur",
    "rigide",
    "rigoler",
    "rincer",
    "riposter",
    "risible",
    "risque",
    "rituel",
    "rival",
    "riviere",
    "rocheux",
    "romance",
    "rompre",
    "ronce",
    "rondin",
    "roseau",
    "rosier",
    "rotatif",
    "rotor",
    "rotule",
    "rouge",
    "rouille",
    "rouleau",
    "routine",
    "royaume",
    "ruban",
    "rubis",
    "ruche",
    "ruelle",
    "rugueux",
    "ruiner",
    "ruisseau",
    "ruser",
    "rustique",
    "rythme",
    "sabler",
    "saboter",
    "sabre",
    "sacoche",
    "safari",
    "sagesse",
    "saisir",
    "salade",
    "salive",
    "salon",
    "saluer",
    "samedi",
    "sanction",
    "sanglier",
    "sarcasme",
    "sardine",
    "saturer",
    "saugrenu",
    "saumon",
    "sauter",
    "sauvage",
    "savant",
    "savonner",
    "scalpel",
    "scandale",
    "scelerat",
    "scenario",
    "sceptre",
    "schema",
    "science",
    "scinder",
    "score",
    "scrutin",
    "sculpter",
    "seance",
    "secable",
    "secher",
    "secouer",
    "secreter",
    "sedatif",
    "seduire",
    "seigneur",
    "sejour",
    "selectif",
    "semaine",
    "sembler",
    "semence",
    "seminal",
    "senateur",
    "sensible",
    "sentence",
    "separer",
    "sequence",
    "serein",
    "sergent",
    "serieux",
    "serrure",
    "serum",
    "service",
    "sesame",
    "sevir",
    "sevrage",
    "sextuple",
    "sideral",
    "siecle",
    "sieger",
    "siffler",
    "sigle",
    "signal",
    "silence",
    "silicium",
    "simple",
    "sincere",
    "sinistre",
    "siphon",
    "sirop",
    "sismique",
    "situer",
    "skier",
    "social",
    "socle",
    "sodium",
    "soigneux",
    "soldat",
    "soleil",
    "solitude",
    "soluble",
    "sombre",
    "sommeil",
    "somnoler",
    "sonde",
    "songeur",
    "sonnette",
    "sonore",
    "sorcier",
    "sortir",
    "sosie",
    "sottise",
    "soucieux",
    "soudure",
    "souffle",
    "soulever",
    "soupape",
    "source",
    "soutirer",
    "souvenir",
    "spacieux",
    "spatial",
    "special",
    "sphere",
    "spiral",
    "stable",
    "station",
    "sternum",
    "stimulus",
    "stipuler",
    "strict",
    "studieux",
    "stupeur",
    "styliste",
    "sublime",
    "substrat",
    "subtil",
    "subvenir",
    "succes",
    "sucre",
    "suffixe",
    "suggerer",
    "suiveur",
    "sulfate",
    "superbe",
    "supplier",
    "surface",
    "suricate",
    "surmener",
    "surprise",
    "sursaut",
    "survie",
    "suspect",
    "syllabe",
    "symbole",
    "symetrie",
    "synapse",
    "syntaxe",
    "systeme",
    "tabac",
    "tablier",
    "tactile",
    "tailler",
    "talent",
    "talisman",
    "talonner",
    "tambour",
    "tamiser",
    "tangible",
    "tapis",
    "taquiner",
    "tarder",
    "tarif",
    "tartine",
    "tasse",
    "tatami",
    "tatouage",
    "taupe",
    "taureau",
    "taxer",
    "temoin",
    "temporel",
    "tenaille",
    "tendre",
    "teneur",
    "tenir",
    "tension",
    "terminer",
    "terne",
    "terrible",
    "tetine",
    "texte",
    "theme",
    "theorie",
    "therapie",
    "thorax",
    "tibia",
    "tiede",
    "timide",
    "tirelire",
    "tiroir",
    "tissu",
    "titane",
    "titre",
    "tituber",
    "toboggan",
    "tolerant",
    "tomate",
    "tonique",
    "tonneau",
    "toponyme",
    "torche",
    "tordre",
    "tornade",
    "torpille",
    "torrent",
    "torse",
    "tortue",
    "totem",
    "toucher",
    "tournage",
    "tousser",
    "toxine",
    "traction",
    "trafic",
    "tragique",
    "trahir",
    "train",
    "trancher",
    "travail",
    "trefle",
    "tremper",
    "tresor",
    "treuil",
    "triage",
    "tribunal",
    "tricoter",
    "trilogie",
    "triomphe",
    "tripler",
    "triturer",
    "trivial",
    "trombone",
    "tronc",
    "tropical",
    "troupeau",
    "tuile",
    "tulipe",
    "tumulte",
    "tunnel",
    "turbine",
    "tuteur",
    "tutoyer",
    "tuyau",
    "tympan",
    "typhon",
    "typique",
    "tyran",
    "ubuesque",
    "ultime",
    "ultrason",
    "unanime",
    "unifier",
    "union",
    "unique",
    "unitaire",
    "univers",
    "uranium",
    "urbain",
    "urticant",
    "usage",
    "usine",
    "usuel",
    "usure",
    "utile",
    "utopie",
    "vacarme",
    "vaccin",
    "vagabond",
    "vague",
    "vaillant",
    "vaincre",
    "vaisseau",
    "valable",
    "valise",
    "vallon",
    "valve",
    "vampire",
    "vanille",
    "vapeur",
    "varier",
    "vaseux",
    "vassal",
    "vaste",
    "vecteur",
    "vedette",
    "vegetal",
    "vehicule",
    "veinard",
    "veloce",
    "vendredi",
    "venerer",
    "venger",
    "venimeux",
    "ventouse",
    "verdure",
    "verin",
    "vernir",
    "verrou",
    "verser",
    "vertu",
    "veston",
    "veteran",
    "vetuste",
    "vexant",
    "vexer",
    "viaduc",
    "viande",
    "victoire",
    "vidange",
    "video",
    "vignette",
    "vigueur",
    "vilain",
    "village",
    "vinaigre",
    "violon",
    "vipere",
    "virement",
    "virtuose",
    "virus",
    "visage",
    "viseur",
    "vision",
    "visqueux",
    "visuel",
    "vital",
    "vitesse",
    "viticole",
    "vitrine",
    "vivace",
    "vivipare",
    "vocation",
    "voguer",
    "voile",
    "voisin",
    "voiture",
    "volaille",
    "volcan",
    "voltiger",
    "volume",
    "vorace",
    "vortex",
    "voter",
    "vouloir",
    "voyage",
    "voyelle",
    "wagon",
    "xenon",
    "yacht",
    "zebre",
    "zenith",
    "zeste",
    "zoologie"
]

},{}],60:[function(require,module,exports){
module.exports=[
    "abaco",
    "abbaglio",
    "abbinato",
    "abete",
    "abisso",
    "abolire",
    "abrasivo",
    "abrogato",
    "accadere",
    "accenno",
    "accusato",
    "acetone",
    "achille",
    "acido",
    "acqua",
    "acre",
    "acrilico",
    "acrobata",
    "acuto",
    "adagio",
    "addebito",
    "addome",
    "adeguato",
    "aderire",
    "adipe",
    "adottare",
    "adulare",
    "affabile",
    "affetto",
    "affisso",
    "affranto",
    "aforisma",
    "afoso",
    "africano",
    "agave",
    "agente",
    "agevole",
    "aggancio",
    "agire",
    "agitare",
    "agonismo",
    "agricolo",
    "agrumeto",
    "aguzzo",
    "alabarda",
    "alato",
    "albatro",
    "alberato",
    "albo",
    "albume",
    "alce",
    "alcolico",
    "alettone",
    "alfa",
    "algebra",
    "aliante",
    "alibi",
    "alimento",
    "allagato",
    "allegro",
    "allievo",
    "allodola",
    "allusivo",
    "almeno",
    "alogeno",
    "alpaca",
    "alpestre",
    "altalena",
    "alterno",
    "alticcio",
    "altrove",
    "alunno",
    "alveolo",
    "alzare",
    "amalgama",
    "amanita",
    "amarena",
    "ambito",
    "ambrato",
    "ameba",
    "america",
    "ametista",
    "amico",
    "ammasso",
    "ammenda",
    "ammirare",
    "ammonito",
    "amore",
    "ampio",
    "ampliare",
    "amuleto",
    "anacardo",
    "anagrafe",
    "analista",
    "anarchia",
    "anatra",
    "anca",
    "ancella",
    "ancora",
    "andare",
    "andrea",
    "anello",
    "angelo",
    "angolare",
    "angusto",
    "anima",
    "annegare",
    "annidato",
    "anno",
    "annuncio",
    "anonimo",
    "anticipo",
    "anzi",
    "apatico",
    "apertura",
    "apode",
    "apparire",
    "appetito",
    "appoggio",
    "approdo",
    "appunto",
    "aprile",
    "arabica",
    "arachide",
    "aragosta",
    "araldica",
    "arancio",
    "aratura",
    "arazzo",
    "arbitro",
    "archivio",
    "ardito",
    "arenile",
    "argento",
    "argine",
    "arguto",
    "aria",
    "armonia",
    "arnese",
    "arredato",
    "arringa",
    "arrosto",
    "arsenico",
    "arso",
    "artefice",
    "arzillo",
    "asciutto",
    "ascolto",
    "asepsi",
    "asettico",
    "asfalto",
    "asino",
    "asola",
    "aspirato",
    "aspro",
    "assaggio",
    "asse",
    "assoluto",
    "assurdo",
    "asta",
    "astenuto",
    "astice",
    "astratto",
    "atavico",
    "ateismo",
    "atomico",
    "atono",
    "attesa",
    "attivare",
    "attorno",
    "attrito",
    "attuale",
    "ausilio",
    "austria",
    "autista",
    "autonomo",
    "autunno",
    "avanzato",
    "avere",
    "avvenire",
    "avviso",
    "avvolgere",
    "azione",
    "azoto",
    "azzimo",
    "azzurro",
    "babele",
    "baccano",
    "bacino",
    "baco",
    "badessa",
    "badilata",
    "bagnato",
    "baita",
    "balcone",
    "baldo",
    "balena",
    "ballata",
    "balzano",
    "bambino",
    "bandire",
    "baraonda",
    "barbaro",
    "barca",
    "baritono",
    "barlume",
    "barocco",
    "basilico",
    "basso",
    "batosta",
    "battuto",
    "baule",
    "bava",
    "bavosa",
    "becco",
    "beffa",
    "belgio",
    "belva",
    "benda",
    "benevole",
    "benigno",
    "benzina",
    "bere",
    "berlina",
    "beta",
    "bibita",
    "bici",
    "bidone",
    "bifido",
    "biga",
    "bilancia",
    "bimbo",
    "binocolo",
    "biologo",
    "bipede",
    "bipolare",
    "birbante",
    "birra",
    "biscotto",
    "bisesto",
    "bisnonno",
    "bisonte",
    "bisturi",
    "bizzarro",
    "blando",
    "blatta",
    "bollito",
    "bonifico",
    "bordo",
    "bosco",
    "botanico",
    "bottino",
    "bozzolo",
    "braccio",
    "bradipo",
    "brama",
    "branca",
    "bravura",
    "bretella",
    "brevetto",
    "brezza",
    "briglia",
    "brillante",
    "brindare",
    "broccolo",
    "brodo",
    "bronzina",
    "brullo",
    "bruno",
    "bubbone",
    "buca",
    "budino",
    "buffone",
    "buio",
    "bulbo",
    "buono",
    "burlone",
    "burrasca",
    "bussola",
    "busta",
    "cadetto",
    "caduco",
    "calamaro",
    "calcolo",
    "calesse",
    "calibro",
    "calmo",
    "caloria",
    "cambusa",
    "camerata",
    "camicia",
    "cammino",
    "camola",
    "campale",
    "canapa",
    "candela",
    "cane",
    "canino",
    "canotto",
    "cantina",
    "capace",
    "capello",
    "capitolo",
    "capogiro",
    "cappero",
    "capra",
    "capsula",
    "carapace",
    "carcassa",
    "cardo",
    "carisma",
    "carovana",
    "carretto",
    "cartolina",
    "casaccio",
    "cascata",
    "caserma",
    "caso",
    "cassone",
    "castello",
    "casuale",
    "catasta",
    "catena",
    "catrame",
    "cauto",
    "cavillo",
    "cedibile",
    "cedrata",
    "cefalo",
    "celebre",
    "cellulare",
    "cena",
    "cenone",
    "centesimo",
    "ceramica",
    "cercare",
    "certo",
    "cerume",
    "cervello",
    "cesoia",
    "cespo",
    "ceto",
    "chela",
    "chiaro",
    "chicca",
    "chiedere",
    "chimera",
    "china",
    "chirurgo",
    "chitarra",
    "ciao",
    "ciclismo",
    "cifrare",
    "cigno",
    "cilindro",
    "ciottolo",
    "circa",
    "cirrosi",
    "citrico",
    "cittadino",
    "ciuffo",
    "civetta",
    "civile",
    "classico",
    "clinica",
    "cloro",
    "cocco",
    "codardo",
    "codice",
    "coerente",
    "cognome",
    "collare",
    "colmato",
    "colore",
    "colposo",
    "coltivato",
    "colza",
    "coma",
    "cometa",
    "commando",
    "comodo",
    "computer",
    "comune",
    "conciso",
    "condurre",
    "conferma",
    "congelare",
    "coniuge",
    "connesso",
    "conoscere",
    "consumo",
    "continuo",
    "convegno",
    "coperto",
    "copione",
    "coppia",
    "copricapo",
    "corazza",
    "cordata",
    "coricato",
    "cornice",
    "corolla",
    "corpo",
    "corredo",
    "corsia",
    "cortese",
    "cosmico",
    "costante",
    "cottura",
    "covato",
    "cratere",
    "cravatta",
    "creato",
    "credere",
    "cremoso",
    "crescita",
    "creta",
    "criceto",
    "crinale",
    "crisi",
    "critico",
    "croce",
    "cronaca",
    "crostata",
    "cruciale",
    "crusca",
    "cucire",
    "cuculo",
    "cugino",
    "cullato",
    "cupola",
    "curatore",
    "cursore",
    "curvo",
    "cuscino",
    "custode",
    "dado",
    "daino",
    "dalmata",
    "damerino",
    "daniela",
    "dannoso",
    "danzare",
    "datato",
    "davanti",
    "davvero",
    "debutto",
    "decennio",
    "deciso",
    "declino",
    "decollo",
    "decreto",
    "dedicato",
    "definito",
    "deforme",
    "degno",
    "delegare",
    "delfino",
    "delirio",
    "delta",
    "demenza",
    "denotato",
    "dentro",
    "deposito",
    "derapata",
    "derivare",
    "deroga",
    "descritto",
    "deserto",
    "desiderio",
    "desumere",
    "detersivo",
    "devoto",
    "diametro",
    "dicembre",
    "diedro",
    "difeso",
    "diffuso",
    "digerire",
    "digitale",
    "diluvio",
    "dinamico",
    "dinnanzi",
    "dipinto",
    "diploma",
    "dipolo",
    "diradare",
    "dire",
    "dirotto",
    "dirupo",
    "disagio",
    "discreto",
    "disfare",
    "disgelo",
    "disposto",
    "distanza",
    "disumano",
    "dito",
    "divano",
    "divelto",
    "dividere",
    "divorato",
    "doblone",
    "docente",
    "doganale",
    "dogma",
    "dolce",
    "domato",
    "domenica",
    "dominare",
    "dondolo",
    "dono",
    "dormire",
    "dote",
    "dottore",
    "dovuto",
    "dozzina",
    "drago",
    "druido",
    "dubbio",
    "dubitare",
    "ducale",
    "duna",
    "duomo",
    "duplice",
    "duraturo",
    "ebano",
    "eccesso",
    "ecco",
    "eclissi",
    "economia",
    "edera",
    "edicola",
    "edile",
    "editoria",
    "educare",
    "egemonia",
    "egli",
    "egoismo",
    "egregio",
    "elaborato",
    "elargire",
    "elegante",
    "elencato",
    "eletto",
    "elevare",
    "elfico",
    "elica",
    "elmo",
    "elsa",
    "eluso",
    "emanato",
    "emblema",
    "emesso",
    "emiro",
    "emotivo",
    "emozione",
    "empirico",
    "emulo",
    "endemico",
    "enduro",
    "energia",
    "enfasi",
    "enoteca",
    "entrare",
    "enzima",
    "epatite",
    "epilogo",
    "episodio",
    "epocale",
    "eppure",
    "equatore",
    "erario",
    "erba",
    "erboso",
    "erede",
    "eremita",
    "erigere",
    "ermetico",
    "eroe",
    "erosivo",
    "errante",
    "esagono",
    "esame",
    "esanime",
    "esaudire",
    "esca",
    "esempio",
    "esercito",
    "esibito",
    "esigente",
    "esistere",
    "esito",
    "esofago",
    "esortato",
    "esoso",
    "espanso",
    "espresso",
    "essenza",
    "esso",
    "esteso",
    "estimare",
    "estonia",
    "estroso",
    "esultare",
    "etilico",
    "etnico",
    "etrusco",
    "etto",
    "euclideo",
    "europa",
    "evaso",
    "evidenza",
    "evitato",
    "evoluto",
    "evviva",
    "fabbrica",
    "faccenda",
    "fachiro",
    "falco",
    "famiglia",
    "fanale",
    "fanfara",
    "fango",
    "fantasma",
    "fare",
    "farfalla",
    "farinoso",
    "farmaco",
    "fascia",
    "fastoso",
    "fasullo",
    "faticare",
    "fato",
    "favoloso",
    "febbre",
    "fecola",
    "fede",
    "fegato",
    "felpa",
    "feltro",
    "femmina",
    "fendere",
    "fenomeno",
    "fermento",
    "ferro",
    "fertile",
    "fessura",
    "festivo",
    "fetta",
    "feudo",
    "fiaba",
    "fiducia",
    "fifa",
    "figurato",
    "filo",
    "finanza",
    "finestra",
    "finire",
    "fiore",
    "fiscale",
    "fisico",
    "fiume",
    "flacone",
    "flamenco",
    "flebo",
    "flemma",
    "florido",
    "fluente",
    "fluoro",
    "fobico",
    "focaccia",
    "focoso",
    "foderato",
    "foglio",
    "folata",
    "folclore",
    "folgore",
    "fondente",
    "fonetico",
    "fonia",
    "fontana",
    "forbito",
    "forchetta",
    "foresta",
    "formica",
    "fornaio",
    "foro",
    "fortezza",
    "forzare",
    "fosfato",
    "fosso",
    "fracasso",
    "frana",
    "frassino",
    "fratello",
    "freccetta",
    "frenata",
    "fresco",
    "frigo",
    "frollino",
    "fronde",
    "frugale",
    "frutta",
    "fucilata",
    "fucsia",
    "fuggente",
    "fulmine",
    "fulvo",
    "fumante",
    "fumetto",
    "fumoso",
    "fune",
    "funzione",
    "fuoco",
    "furbo",
    "furgone",
    "furore",
    "fuso",
    "futile",
    "gabbiano",
    "gaffe",
    "galateo",
    "gallina",
    "galoppo",
    "gambero",
    "gamma",
    "garanzia",
    "garbo",
    "garofano",
    "garzone",
    "gasdotto",
    "gasolio",
    "gastrico",
    "gatto",
    "gaudio",
    "gazebo",
    "gazzella",
    "geco",
    "gelatina",
    "gelso",
    "gemello",
    "gemmato",
    "gene",
    "genitore",
    "gennaio",
    "genotipo",
    "gergo",
    "ghepardo",
    "ghiaccio",
    "ghisa",
    "giallo",
    "gilda",
    "ginepro",
    "giocare",
    "gioiello",
    "giorno",
    "giove",
    "girato",
    "girone",
    "gittata",
    "giudizio",
    "giurato",
    "giusto",
    "globulo",
    "glutine",
    "gnomo",
    "gobba",
    "golf",
    "gomito",
    "gommone",
    "gonfio",
    "gonna",
    "governo",
    "gracile",
    "grado",
    "grafico",
    "grammo",
    "grande",
    "grattare",
    "gravoso",
    "grazia",
    "greca",
    "gregge",
    "grifone",
    "grigio",
    "grinza",
    "grotta",
    "gruppo",
    "guadagno",
    "guaio",
    "guanto",
    "guardare",
    "gufo",
    "guidare",
    "ibernato",
    "icona",
    "identico",
    "idillio",
    "idolo",
    "idra",
    "idrico",
    "idrogeno",
    "igiene",
    "ignaro",
    "ignorato",
    "ilare",
    "illeso",
    "illogico",
    "illudere",
    "imballo",
    "imbevuto",
    "imbocco",
    "imbuto",
    "immane",
    "immerso",
    "immolato",
    "impacco",
    "impeto",
    "impiego",
    "importo",
    "impronta",
    "inalare",
    "inarcare",
    "inattivo",
    "incanto",
    "incendio",
    "inchino",
    "incisivo",
    "incluso",
    "incontro",
    "incrocio",
    "incubo",
    "indagine",
    "india",
    "indole",
    "inedito",
    "infatti",
    "infilare",
    "inflitto",
    "ingaggio",
    "ingegno",
    "inglese",
    "ingordo",
    "ingrosso",
    "innesco",
    "inodore",
    "inoltrare",
    "inondato",
    "insano",
    "insetto",
    "insieme",
    "insonnia",
    "insulina",
    "intasato",
    "intero",
    "intonaco",
    "intuito",
    "inumidire",
    "invalido",
    "invece",
    "invito",
    "iperbole",
    "ipnotico",
    "ipotesi",
    "ippica",
    "iride",
    "irlanda",
    "ironico",
    "irrigato",
    "irrorare",
    "isolato",
    "isotopo",
    "isterico",
    "istituto",
    "istrice",
    "italia",
    "iterare",
    "labbro",
    "labirinto",
    "lacca",
    "lacerato",
    "lacrima",
    "lacuna",
    "laddove",
    "lago",
    "lampo",
    "lancetta",
    "lanterna",
    "lardoso",
    "larga",
    "laringe",
    "lastra",
    "latenza",
    "latino",
    "lattuga",
    "lavagna",
    "lavoro",
    "legale",
    "leggero",
    "lembo",
    "lentezza",
    "lenza",
    "leone",
    "lepre",
    "lesivo",
    "lessato",
    "lesto",
    "letterale",
    "leva",
    "levigato",
    "libero",
    "lido",
    "lievito",
    "lilla",
    "limatura",
    "limitare",
    "limpido",
    "lineare",
    "lingua",
    "liquido",
    "lira",
    "lirica",
    "lisca",
    "lite",
    "litigio",
    "livrea",
    "locanda",
    "lode",
    "logica",
    "lombare",
    "londra",
    "longevo",
    "loquace",
    "lorenzo",
    "loto",
    "lotteria",
    "luce",
    "lucidato",
    "lumaca",
    "luminoso",
    "lungo",
    "lupo",
    "luppolo",
    "lusinga",
    "lusso",
    "lutto",
    "macabro",
    "macchina",
    "macero",
    "macinato",
    "madama",
    "magico",
    "maglia",
    "magnete",
    "magro",
    "maiolica",
    "malafede",
    "malgrado",
    "malinteso",
    "malsano",
    "malto",
    "malumore",
    "mana",
    "mancia",
    "mandorla",
    "mangiare",
    "manifesto",
    "mannaro",
    "manovra",
    "mansarda",
    "mantide",
    "manubrio",
    "mappa",
    "maratona",
    "marcire",
    "maretta",
    "marmo",
    "marsupio",
    "maschera",
    "massaia",
    "mastino",
    "materasso",
    "matricola",
    "mattone",
    "maturo",
    "mazurca",
    "meandro",
    "meccanico",
    "mecenate",
    "medesimo",
    "meditare",
    "mega",
    "melassa",
    "melis",
    "melodia",
    "meninge",
    "meno",
    "mensola",
    "mercurio",
    "merenda",
    "merlo",
    "meschino",
    "mese",
    "messere",
    "mestolo",
    "metallo",
    "metodo",
    "mettere",
    "miagolare",
    "mica",
    "micelio",
    "michele",
    "microbo",
    "midollo",
    "miele",
    "migliore",
    "milano",
    "milite",
    "mimosa",
    "minerale",
    "mini",
    "minore",
    "mirino",
    "mirtillo",
    "miscela",
    "missiva",
    "misto",
    "misurare",
    "mitezza",
    "mitigare",
    "mitra",
    "mittente",
    "mnemonico",
    "modello",
    "modifica",
    "modulo",
    "mogano",
    "mogio",
    "mole",
    "molosso",
    "monastero",
    "monco",
    "mondina",
    "monetario",
    "monile",
    "monotono",
    "monsone",
    "montato",
    "monviso",
    "mora",
    "mordere",
    "morsicato",
    "mostro",
    "motivato",
    "motosega",
    "motto",
    "movenza",
    "movimento",
    "mozzo",
    "mucca",
    "mucosa",
    "muffa",
    "mughetto",
    "mugnaio",
    "mulatto",
    "mulinello",
    "multiplo",
    "mummia",
    "munto",
    "muovere",
    "murale",
    "musa",
    "muscolo",
    "musica",
    "mutevole",
    "muto",
    "nababbo",
    "nafta",
    "nanometro",
    "narciso",
    "narice",
    "narrato",
    "nascere",
    "nastrare",
    "naturale",
    "nautica",
    "naviglio",
    "nebulosa",
    "necrosi",
    "negativo",
    "negozio",
    "nemmeno",
    "neofita",
    "neretto",
    "nervo",
    "nessuno",
    "nettuno",
    "neutrale",
    "neve",
    "nevrotico",
    "nicchia",
    "ninfa",
    "nitido",
    "nobile",
    "nocivo",
    "nodo",
    "nome",
    "nomina",
    "nordico",
    "normale",
    "norvegese",
    "nostrano",
    "notare",
    "notizia",
    "notturno",
    "novella",
    "nucleo",
    "nulla",
    "numero",
    "nuovo",
    "nutrire",
    "nuvola",
    "nuziale",
    "oasi",
    "obbedire",
    "obbligo",
    "obelisco",
    "oblio",
    "obolo",
    "obsoleto",
    "occasione",
    "occhio",
    "occidente",
    "occorrere",
    "occultare",
    "ocra",
    "oculato",
    "odierno",
    "odorare",
    "offerta",
    "offrire",
    "offuscato",
    "oggetto",
    "oggi",
    "ognuno",
    "olandese",
    "olfatto",
    "oliato",
    "oliva",
    "ologramma",
    "oltre",
    "omaggio",
    "ombelico",
    "ombra",
    "omega",
    "omissione",
    "ondoso",
    "onere",
    "onice",
    "onnivoro",
    "onorevole",
    "onta",
    "operato",
    "opinione",
    "opposto",
    "oracolo",
    "orafo",
    "ordine",
    "orecchino",
    "orefice",
    "orfano",
    "organico",
    "origine",
    "orizzonte",
    "orma",
    "ormeggio",
    "ornativo",
    "orologio",
    "orrendo",
    "orribile",
    "ortensia",
    "ortica",
    "orzata",
    "orzo",
    "osare",
    "oscurare",
    "osmosi",
    "ospedale",
    "ospite",
    "ossa",
    "ossidare",
    "ostacolo",
    "oste",
    "otite",
    "otre",
    "ottagono",
    "ottimo",
    "ottobre",
    "ovale",
    "ovest",
    "ovino",
    "oviparo",
    "ovocito",
    "ovunque",
    "ovviare",
    "ozio",
    "pacchetto",
    "pace",
    "pacifico",
    "padella",
    "padrone",
    "paese",
    "paga",
    "pagina",
    "palazzina",
    "palesare",
    "pallido",
    "palo",
    "palude",
    "pandoro",
    "pannello",
    "paolo",
    "paonazzo",
    "paprica",
    "parabola",
    "parcella",
    "parere",
    "pargolo",
    "pari",
    "parlato",
    "parola",
    "partire",
    "parvenza",
    "parziale",
    "passivo",
    "pasticca",
    "patacca",
    "patologia",
    "pattume",
    "pavone",
    "peccato",
    "pedalare",
    "pedonale",
    "peggio",
    "peloso",
    "penare",
    "pendice",
    "penisola",
    "pennuto",
    "penombra",
    "pensare",
    "pentola",
    "pepe",
    "pepita",
    "perbene",
    "percorso",
    "perdonato",
    "perforare",
    "pergamena",
    "periodo",
    "permesso",
    "perno",
    "perplesso",
    "persuaso",
    "pertugio",
    "pervaso",
    "pesatore",
    "pesista",
    "peso",
    "pestifero",
    "petalo",
    "pettine",
    "petulante",
    "pezzo",
    "piacere",
    "pianta",
    "piattino",
    "piccino",
    "picozza",
    "piega",
    "pietra",
    "piffero",
    "pigiama",
    "pigolio",
    "pigro",
    "pila",
    "pilifero",
    "pillola",
    "pilota",
    "pimpante",
    "pineta",
    "pinna",
    "pinolo",
    "pioggia",
    "piombo",
    "piramide",
    "piretico",
    "pirite",
    "pirolisi",
    "pitone",
    "pizzico",
    "placebo",
    "planare",
    "plasma",
    "platano",
    "plenario",
    "pochezza",
    "poderoso",
    "podismo",
    "poesia",
    "poggiare",
    "polenta",
    "poligono",
    "pollice",
    "polmonite",
    "polpetta",
    "polso",
    "poltrona",
    "polvere",
    "pomice",
    "pomodoro",
    "ponte",
    "popoloso",
    "porfido",
    "poroso",
    "porpora",
    "porre",
    "portata",
    "posa",
    "positivo",
    "possesso",
    "postulato",
    "potassio",
    "potere",
    "pranzo",
    "prassi",
    "pratica",
    "precluso",
    "predica",
    "prefisso",
    "pregiato",
    "prelievo",
    "premere",
    "prenotare",
    "preparato",
    "presenza",
    "pretesto",
    "prevalso",
    "prima",
    "principe",
    "privato",
    "problema",
    "procura",
    "produrre",
    "profumo",
    "progetto",
    "prolunga",
    "promessa",
    "pronome",
    "proposta",
    "proroga",
    "proteso",
    "prova",
    "prudente",
    "prugna",
    "prurito",
    "psiche",
    "pubblico",
    "pudica",
    "pugilato",
    "pugno",
    "pulce",
    "pulito",
    "pulsante",
    "puntare",
    "pupazzo",
    "pupilla",
    "puro",
    "quadro",
    "qualcosa",
    "quasi",
    "querela",
    "quota",
    "raccolto",
    "raddoppio",
    "radicale",
    "radunato",
    "raffica",
    "ragazzo",
    "ragione",
    "ragno",
    "ramarro",
    "ramingo",
    "ramo",
    "randagio",
    "rantolare",
    "rapato",
    "rapina",
    "rappreso",
    "rasatura",
    "raschiato",
    "rasente",
    "rassegna",
    "rastrello",
    "rata",
    "ravveduto",
    "reale",
    "recepire",
    "recinto",
    "recluta",
    "recondito",
    "recupero",
    "reddito",
    "redimere",
    "regalato",
    "registro",
    "regola",
    "regresso",
    "relazione",
    "remare",
    "remoto",
    "renna",
    "replica",
    "reprimere",
    "reputare",
    "resa",
    "residente",
    "responso",
    "restauro",
    "rete",
    "retina",
    "retorica",
    "rettifica",
    "revocato",
    "riassunto",
    "ribadire",
    "ribelle",
    "ribrezzo",
    "ricarica",
    "ricco",
    "ricevere",
    "riciclato",
    "ricordo",
    "ricreduto",
    "ridicolo",
    "ridurre",
    "rifasare",
    "riflesso",
    "riforma",
    "rifugio",
    "rigare",
    "rigettato",
    "righello",
    "rilassato",
    "rilevato",
    "rimanere",
    "rimbalzo",
    "rimedio",
    "rimorchio",
    "rinascita",
    "rincaro",
    "rinforzo",
    "rinnovo",
    "rinomato",
    "rinsavito",
    "rintocco",
    "rinuncia",
    "rinvenire",
    "riparato",
    "ripetuto",
    "ripieno",
    "riportare",
    "ripresa",
    "ripulire",
    "risata",
    "rischio",
    "riserva",
    "risibile",
    "riso",
    "rispetto",
    "ristoro",
    "risultato",
    "risvolto",
    "ritardo",
    "ritegno",
    "ritmico",
    "ritrovo",
    "riunione",
    "riva",
    "riverso",
    "rivincita",
    "rivolto",
    "rizoma",
    "roba",
    "robotico",
    "robusto",
    "roccia",
    "roco",
    "rodaggio",
    "rodere",
    "roditore",
    "rogito",
    "rollio",
    "romantico",
    "rompere",
    "ronzio",
    "rosolare",
    "rospo",
    "rotante",
    "rotondo",
    "rotula",
    "rovescio",
    "rubizzo",
    "rubrica",
    "ruga",
    "rullino",
    "rumine",
    "rumoroso",
    "ruolo",
    "rupe",
    "russare",
    "rustico",
    "sabato",
    "sabbiare",
    "sabotato",
    "sagoma",
    "salasso",
    "saldatura",
    "salgemma",
    "salivare",
    "salmone",
    "salone",
    "saltare",
    "saluto",
    "salvo",
    "sapere",
    "sapido",
    "saporito",
    "saraceno",
    "sarcasmo",
    "sarto",
    "sassoso",
    "satellite",
    "satira",
    "satollo",
    "saturno",
    "savana",
    "savio",
    "saziato",
    "sbadiglio",
    "sbalzo",
    "sbancato",
    "sbarra",
    "sbattere",
    "sbavare",
    "sbendare",
    "sbirciare",
    "sbloccato",
    "sbocciato",
    "sbrinare",
    "sbruffone",
    "sbuffare",
    "scabroso",
    "scadenza",
    "scala",
    "scambiare",
    "scandalo",
    "scapola",
    "scarso",
    "scatenare",
    "scavato",
    "scelto",
    "scenico",
    "scettro",
    "scheda",
    "schiena",
    "sciarpa",
    "scienza",
    "scindere",
    "scippo",
    "sciroppo",
    "scivolo",
    "sclerare",
    "scodella",
    "scolpito",
    "scomparto",
    "sconforto",
    "scoprire",
    "scorta",
    "scossone",
    "scozzese",
    "scriba",
    "scrollare",
    "scrutinio",
    "scuderia",
    "scultore",
    "scuola",
    "scuro",
    "scusare",
    "sdebitare",
    "sdoganare",
    "seccatura",
    "secondo",
    "sedano",
    "seggiola",
    "segnalato",
    "segregato",
    "seguito",
    "selciato",
    "selettivo",
    "sella",
    "selvaggio",
    "semaforo",
    "sembrare",
    "seme",
    "seminato",
    "sempre",
    "senso",
    "sentire",
    "sepolto",
    "sequenza",
    "serata",
    "serbato",
    "sereno",
    "serio",
    "serpente",
    "serraglio",
    "servire",
    "sestina",
    "setola",
    "settimana",
    "sfacelo",
    "sfaldare",
    "sfamato",
    "sfarzoso",
    "sfaticato",
    "sfera",
    "sfida",
    "sfilato",
    "sfinge",
    "sfocato",
    "sfoderare",
    "sfogo",
    "sfoltire",
    "sforzato",
    "sfratto",
    "sfruttato",
    "sfuggito",
    "sfumare",
    "sfuso",
    "sgabello",
    "sgarbato",
    "sgonfiare",
    "sgorbio",
    "sgrassato",
    "sguardo",
    "sibilo",
    "siccome",
    "sierra",
    "sigla",
    "signore",
    "silenzio",
    "sillaba",
    "simbolo",
    "simpatico",
    "simulato",
    "sinfonia",
    "singolo",
    "sinistro",
    "sino",
    "sintesi",
    "sinusoide",
    "sipario",
    "sisma",
    "sistole",
    "situato",
    "slitta",
    "slogatura",
    "sloveno",
    "smarrito",
    "smemorato",
    "smentito",
    "smeraldo",
    "smilzo",
    "smontare",
    "smottato",
    "smussato",
    "snellire",
    "snervato",
    "snodo",
    "sobbalzo",
    "sobrio",
    "soccorso",
    "sociale",
    "sodale",
    "soffitto",
    "sogno",
    "soldato",
    "solenne",
    "solido",
    "sollazzo",
    "solo",
    "solubile",
    "solvente",
    "somatico",
    "somma",
    "sonda",
    "sonetto",
    "sonnifero",
    "sopire",
    "soppeso",
    "sopra",
    "sorgere",
    "sorpasso",
    "sorriso",
    "sorso",
    "sorteggio",
    "sorvolato",
    "sospiro",
    "sosta",
    "sottile",
    "spada",
    "spalla",
    "spargere",
    "spatola",
    "spavento",
    "spazzola",
    "specie",
    "spedire",
    "spegnere",
    "spelatura",
    "speranza",
    "spessore",
    "spettrale",
    "spezzato",
    "spia",
    "spigoloso",
    "spillato",
    "spinoso",
    "spirale",
    "splendido",
    "sportivo",
    "sposo",
    "spranga",
    "sprecare",
    "spronato",
    "spruzzo",
    "spuntino",
    "squillo",
    "sradicare",
    "srotolato",
    "stabile",
    "stacco",
    "staffa",
    "stagnare",
    "stampato",
    "stantio",
    "starnuto",
    "stasera",
    "statuto",
    "stelo",
    "steppa",
    "sterzo",
    "stiletto",
    "stima",
    "stirpe",
    "stivale",
    "stizzoso",
    "stonato",
    "storico",
    "strappo",
    "stregato",
    "stridulo",
    "strozzare",
    "strutto",
    "stuccare",
    "stufo",
    "stupendo",
    "subentro",
    "succoso",
    "sudore",
    "suggerito",
    "sugo",
    "sultano",
    "suonare",
    "superbo",
    "supporto",
    "surgelato",
    "surrogato",
    "sussurro",
    "sutura",
    "svagare",
    "svedese",
    "sveglio",
    "svelare",
    "svenuto",
    "svezia",
    "sviluppo",
    "svista",
    "svizzera",
    "svolta",
    "svuotare",
    "tabacco",
    "tabulato",
    "tacciare",
    "taciturno",
    "tale",
    "talismano",
    "tampone",
    "tannino",
    "tara",
    "tardivo",
    "targato",
    "tariffa",
    "tarpare",
    "tartaruga",
    "tasto",
    "tattico",
    "taverna",
    "tavolata",
    "tazza",
    "teca",
    "tecnico",
    "telefono",
    "temerario",
    "tempo",
    "temuto",
    "tendone",
    "tenero",
    "tensione",
    "tentacolo",
    "teorema",
    "terme",
    "terrazzo",
    "terzetto",
    "tesi",
    "tesserato",
    "testato",
    "tetro",
    "tettoia",
    "tifare",
    "tigella",
    "timbro",
    "tinto",
    "tipico",
    "tipografo",
    "tiraggio",
    "tiro",
    "titanio",
    "titolo",
    "titubante",
    "tizio",
    "tizzone",
    "toccare",
    "tollerare",
    "tolto",
    "tombola",
    "tomo",
    "tonfo",
    "tonsilla",
    "topazio",
    "topologia",
    "toppa",
    "torba",
    "tornare",
    "torrone",
    "tortora",
    "toscano",
    "tossire",
    "tostatura",
    "totano",
    "trabocco",
    "trachea",
    "trafila",
    "tragedia",
    "tralcio",
    "tramonto",
    "transito",
    "trapano",
    "trarre",
    "trasloco",
    "trattato",
    "trave",
    "treccia",
    "tremolio",
    "trespolo",
    "tributo",
    "tricheco",
    "trifoglio",
    "trillo",
    "trincea",
    "trio",
    "tristezza",
    "triturato",
    "trivella",
    "tromba",
    "trono",
    "troppo",
    "trottola",
    "trovare",
    "truccato",
    "tubatura",
    "tuffato",
    "tulipano",
    "tumulto",
    "tunisia",
    "turbare",
    "turchino",
    "tuta",
    "tutela",
    "ubicato",
    "uccello",
    "uccisore",
    "udire",
    "uditivo",
    "uffa",
    "ufficio",
    "uguale",
    "ulisse",
    "ultimato",
    "umano",
    "umile",
    "umorismo",
    "uncinetto",
    "ungere",
    "ungherese",
    "unicorno",
    "unificato",
    "unisono",
    "unitario",
    "unte",
    "uovo",
    "upupa",
    "uragano",
    "urgenza",
    "urlo",
    "usanza",
    "usato",
    "uscito",
    "usignolo",
    "usuraio",
    "utensile",
    "utilizzo",
    "utopia",
    "vacante",
    "vaccinato",
    "vagabondo",
    "vagliato",
    "valanga",
    "valgo",
    "valico",
    "valletta",
    "valoroso",
    "valutare",
    "valvola",
    "vampata",
    "vangare",
    "vanitoso",
    "vano",
    "vantaggio",
    "vanvera",
    "vapore",
    "varano",
    "varcato",
    "variante",
    "vasca",
    "vedetta",
    "vedova",
    "veduto",
    "vegetale",
    "veicolo",
    "velcro",
    "velina",
    "velluto",
    "veloce",
    "venato",
    "vendemmia",
    "vento",
    "verace",
    "verbale",
    "vergogna",
    "verifica",
    "vero",
    "verruca",
    "verticale",
    "vescica",
    "vessillo",
    "vestale",
    "veterano",
    "vetrina",
    "vetusto",
    "viandante",
    "vibrante",
    "vicenda",
    "vichingo",
    "vicinanza",
    "vidimare",
    "vigilia",
    "vigneto",
    "vigore",
    "vile",
    "villano",
    "vimini",
    "vincitore",
    "viola",
    "vipera",
    "virgola",
    "virologo",
    "virulento",
    "viscoso",
    "visione",
    "vispo",
    "vissuto",
    "visura",
    "vita",
    "vitello",
    "vittima",
    "vivanda",
    "vivido",
    "viziare",
    "voce",
    "voga",
    "volatile",
    "volere",
    "volpe",
    "voragine",
    "vulcano",
    "zampogna",
    "zanna",
    "zappato",
    "zattera",
    "zavorra",
    "zefiro",
    "zelante",
    "zelo",
    "zenzero",
    "zerbino",
    "zibetto",
    "zinco",
    "zircone",
    "zitto",
    "zolla",
    "zotico",
    "zucchero",
    "zufolo",
    "zulu",
    "zuppa"
]

},{}],61:[function(require,module,exports){
module.exports=[
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    ""
]

},{}],62:[function(require,module,exports){
module.exports=[
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    ""
]

},{}],63:[function(require,module,exports){
module.exports=[
    "abacate",
    "abaixo",
    "abalar",
    "abater",
    "abduzir",
    "abelha",
    "aberto",
    "abismo",
    "abotoar",
    "abranger",
    "abreviar",
    "abrigar",
    "abrupto",
    "absinto",
    "absoluto",
    "absurdo",
    "abutre",
    "acabado",
    "acalmar",
    "acampar",
    "acanhar",
    "acaso",
    "aceitar",
    "acelerar",
    "acenar",
    "acervo",
    "acessar",
    "acetona",
    "achatar",
    "acidez",
    "acima",
    "acionado",
    "acirrar",
    "aclamar",
    "aclive",
    "acolhida",
    "acomodar",
    "acoplar",
    "acordar",
    "acumular",
    "acusador",
    "adaptar",
    "adega",
    "adentro",
    "adepto",
    "adequar",
    "aderente",
    "adesivo",
    "adeus",
    "adiante",
    "aditivo",
    "adjetivo",
    "adjunto",
    "admirar",
    "adorar",
    "adquirir",
    "adubo",
    "adverso",
    "advogado",
    "aeronave",
    "afastar",
    "aferir",
    "afetivo",
    "afinador",
    "afivelar",
    "aflito",
    "afluente",
    "afrontar",
    "agachar",
    "agarrar",
    "agasalho",
    "agenciar",
    "agilizar",
    "agiota",
    "agitado",
    "agora",
    "agradar",
    "agreste",
    "agrupar",
    "aguardar",
    "agulha",
    "ajoelhar",
    "ajudar",
    "ajustar",
    "alameda",
    "alarme",
    "alastrar",
    "alavanca",
    "albergue",
    "albino",
    "alcatra",
    "aldeia",
    "alecrim",
    "alegria",
    "alertar",
    "alface",
    "alfinete",
    "algum",
    "alheio",
    "aliar",
    "alicate",
    "alienar",
    "alinhar",
    "aliviar",
    "almofada",
    "alocar",
    "alpiste",
    "alterar",
    "altitude",
    "alucinar",
    "alugar",
    "aluno",
    "alusivo",
    "alvo",
    "amaciar",
    "amador",
    "amarelo",
    "amassar",
    "ambas",
    "ambiente",
    "ameixa",
    "amenizar",
    "amido",
    "amistoso",
    "amizade",
    "amolador",
    "amontoar",
    "amoroso",
    "amostra",
    "amparar",
    "ampliar",
    "ampola",
    "anagrama",
    "analisar",
    "anarquia",
    "anatomia",
    "andaime",
    "anel",
    "anexo",
    "angular",
    "animar",
    "anjo",
    "anomalia",
    "anotado",
    "ansioso",
    "anterior",
    "anuidade",
    "anunciar",
    "anzol",
    "apagador",
    "apalpar",
    "apanhado",
    "apego",
    "apelido",
    "apertada",
    "apesar",
    "apetite",
    "apito",
    "aplauso",
    "aplicada",
    "apoio",
    "apontar",
    "aposta",
    "aprendiz",
    "aprovar",
    "aquecer",
    "arame",
    "aranha",
    "arara",
    "arcada",
    "ardente",
    "areia",
    "arejar",
    "arenito",
    "aresta",
    "argiloso",
    "argola",
    "arma",
    "arquivo",
    "arraial",
    "arrebate",
    "arriscar",
    "arroba",
    "arrumar",
    "arsenal",
    "arterial",
    "artigo",
    "arvoredo",
    "asfaltar",
    "asilado",
    "aspirar",
    "assador",
    "assinar",
    "assoalho",
    "assunto",
    "astral",
    "atacado",
    "atadura",
    "atalho",
    "atarefar",
    "atear",
    "atender",
    "aterro",
    "ateu",
    "atingir",
    "atirador",
    "ativo",
    "atoleiro",
    "atracar",
    "atrevido",
    "atriz",
    "atual",
    "atum",
    "auditor",
    "aumentar",
    "aura",
    "aurora",
    "autismo",
    "autoria",
    "autuar",
    "avaliar",
    "avante",
    "avaria",
    "avental",
    "avesso",
    "aviador",
    "avisar",
    "avulso",
    "axila",
    "azarar",
    "azedo",
    "azeite",
    "azulejo",
    "babar",
    "babosa",
    "bacalhau",
    "bacharel",
    "bacia",
    "bagagem",
    "baiano",
    "bailar",
    "baioneta",
    "bairro",
    "baixista",
    "bajular",
    "baleia",
    "baliza",
    "balsa",
    "banal",
    "bandeira",
    "banho",
    "banir",
    "banquete",
    "barato",
    "barbado",
    "baronesa",
    "barraca",
    "barulho",
    "baseado",
    "bastante",
    "batata",
    "batedor",
    "batida",
    "batom",
    "batucar",
    "baunilha",
    "beber",
    "beijo",
    "beirada",
    "beisebol",
    "beldade",
    "beleza",
    "belga",
    "beliscar",
    "bendito",
    "bengala",
    "benzer",
    "berimbau",
    "berlinda",
    "berro",
    "besouro",
    "bexiga",
    "bezerro",
    "bico",
    "bicudo",
    "bienal",
    "bifocal",
    "bifurcar",
    "bigorna",
    "bilhete",
    "bimestre",
    "bimotor",
    "biologia",
    "biombo",
    "biosfera",
    "bipolar",
    "birrento",
    "biscoito",
    "bisneto",
    "bispo",
    "bissexto",
    "bitola",
    "bizarro",
    "blindado",
    "bloco",
    "bloquear",
    "boato",
    "bobagem",
    "bocado",
    "bocejo",
    "bochecha",
    "boicotar",
    "bolada",
    "boletim",
    "bolha",
    "bolo",
    "bombeiro",
    "bonde",
    "boneco",
    "bonita",
    "borbulha",
    "borda",
    "boreal",
    "borracha",
    "bovino",
    "boxeador",
    "branco",
    "brasa",
    "braveza",
    "breu",
    "briga",
    "brilho",
    "brincar",
    "broa",
    "brochura",
    "bronzear",
    "broto",
    "bruxo",
    "bucha",
    "budismo",
    "bufar",
    "bule",
    "buraco",
    "busca",
    "busto",
    "buzina",
    "cabana",
    "cabelo",
    "cabide",
    "cabo",
    "cabrito",
    "cacau",
    "cacetada",
    "cachorro",
    "cacique",
    "cadastro",
    "cadeado",
    "cafezal",
    "caiaque",
    "caipira",
    "caixote",
    "cajado",
    "caju",
    "calafrio",
    "calcular",
    "caldeira",
    "calibrar",
    "calmante",
    "calota",
    "camada",
    "cambista",
    "camisa",
    "camomila",
    "campanha",
    "camuflar",
    "canavial",
    "cancelar",
    "caneta",
    "canguru",
    "canhoto",
    "canivete",
    "canoa",
    "cansado",
    "cantar",
    "canudo",
    "capacho",
    "capela",
    "capinar",
    "capotar",
    "capricho",
    "captador",
    "capuz",
    "caracol",
    "carbono",
    "cardeal",
    "careca",
    "carimbar",
    "carneiro",
    "carpete",
    "carreira",
    "cartaz",
    "carvalho",
    "casaco",
    "casca",
    "casebre",
    "castelo",
    "casulo",
    "catarata",
    "cativar",
    "caule",
    "causador",
    "cautelar",
    "cavalo",
    "caverna",
    "cebola",
    "cedilha",
    "cegonha",
    "celebrar",
    "celular",
    "cenoura",
    "censo",
    "centeio",
    "cercar",
    "cerrado",
    "certeiro",
    "cerveja",
    "cetim",
    "cevada",
    "chacota",
    "chaleira",
    "chamado",
    "chapada",
    "charme",
    "chatice",
    "chave",
    "chefe",
    "chegada",
    "cheiro",
    "cheque",
    "chicote",
    "chifre",
    "chinelo",
    "chocalho",
    "chover",
    "chumbo",
    "chutar",
    "chuva",
    "cicatriz",
    "ciclone",
    "cidade",
    "cidreira",
    "ciente",
    "cigana",
    "cimento",
    "cinto",
    "cinza",
    "ciranda",
    "circuito",
    "cirurgia",
    "citar",
    "clareza",
    "clero",
    "clicar",
    "clone",
    "clube",
    "coado",
    "coagir",
    "cobaia",
    "cobertor",
    "cobrar",
    "cocada",
    "coelho",
    "coentro",
    "coeso",
    "cogumelo",
    "coibir",
    "coifa",
    "coiote",
    "colar",
    "coleira",
    "colher",
    "colidir",
    "colmeia",
    "colono",
    "coluna",
    "comando",
    "combinar",
    "comentar",
    "comitiva",
    "comover",
    "complexo",
    "comum",
    "concha",
    "condor",
    "conectar",
    "confuso",
    "congelar",
    "conhecer",
    "conjugar",
    "consumir",
    "contrato",
    "convite",
    "cooperar",
    "copeiro",
    "copiador",
    "copo",
    "coquetel",
    "coragem",
    "cordial",
    "corneta",
    "coronha",
    "corporal",
    "correio",
    "cortejo",
    "coruja",
    "corvo",
    "cosseno",
    "costela",
    "cotonete",
    "couro",
    "couve",
    "covil",
    "cozinha",
    "cratera",
    "cravo",
    "creche",
    "credor",
    "creme",
    "crer",
    "crespo",
    "criada",
    "criminal",
    "crioulo",
    "crise",
    "criticar",
    "crosta",
    "crua",
    "cruzeiro",
    "cubano",
    "cueca",
    "cuidado",
    "cujo",
    "culatra",
    "culminar",
    "culpar",
    "cultura",
    "cumprir",
    "cunhado",
    "cupido",
    "curativo",
    "curral",
    "cursar",
    "curto",
    "cuspir",
    "custear",
    "cutelo",
    "damasco",
    "datar",
    "debater",
    "debitar",
    "deboche",
    "debulhar",
    "decalque",
    "decimal",
    "declive",
    "decote",
    "decretar",
    "dedal",
    "dedicado",
    "deduzir",
    "defesa",
    "defumar",
    "degelo",
    "degrau",
    "degustar",
    "deitado",
    "deixar",
    "delator",
    "delegado",
    "delinear",
    "delonga",
    "demanda",
    "demitir",
    "demolido",
    "dentista",
    "depenado",
    "depilar",
    "depois",
    "depressa",
    "depurar",
    "deriva",
    "derramar",
    "desafio",
    "desbotar",
    "descanso",
    "desenho",
    "desfiado",
    "desgaste",
    "desigual",
    "deslize",
    "desmamar",
    "desova",
    "despesa",
    "destaque",
    "desviar",
    "detalhar",
    "detentor",
    "detonar",
    "detrito",
    "deusa",
    "dever",
    "devido",
    "devotado",
    "dezena",
    "diagrama",
    "dialeto",
    "didata",
    "difuso",
    "digitar",
    "dilatado",
    "diluente",
    "diminuir",
    "dinastia",
    "dinheiro",
    "diocese",
    "direto",
    "discreta",
    "disfarce",
    "disparo",
    "disquete",
    "dissipar",
    "distante",
    "ditador",
    "diurno",
    "diverso",
    "divisor",
    "divulgar",
    "dizer",
    "dobrador",
    "dolorido",
    "domador",
    "dominado",
    "donativo",
    "donzela",
    "dormente",
    "dorsal",
    "dosagem",
    "dourado",
    "doutor",
    "drenagem",
    "drible",
    "drogaria",
    "duelar",
    "duende",
    "dueto",
    "duplo",
    "duquesa",
    "durante",
    "duvidoso",
    "eclodir",
    "ecoar",
    "ecologia",
    "edificar",
    "edital",
    "educado",
    "efeito",
    "efetivar",
    "ejetar",
    "elaborar",
    "eleger",
    "eleitor",
    "elenco",
    "elevador",
    "eliminar",
    "elogiar",
    "embargo",
    "embolado",
    "embrulho",
    "embutido",
    "emenda",
    "emergir",
    "emissor",
    "empatia",
    "empenho",
    "empinado",
    "empolgar",
    "emprego",
    "empurrar",
    "emulador",
    "encaixe",
    "encenado",
    "enchente",
    "encontro",
    "endeusar",
    "endossar",
    "enfaixar",
    "enfeite",
    "enfim",
    "engajado",
    "engenho",
    "englobar",
    "engomado",
    "engraxar",
    "enguia",
    "enjoar",
    "enlatar",
    "enquanto",
    "enraizar",
    "enrolado",
    "enrugar",
    "ensaio",
    "enseada",
    "ensino",
    "ensopado",
    "entanto",
    "enteado",
    "entidade",
    "entortar",
    "entrada",
    "entulho",
    "envergar",
    "enviado",
    "envolver",
    "enxame",
    "enxerto",
    "enxofre",
    "enxuto",
    "epiderme",
    "equipar",
    "ereto",
    "erguido",
    "errata",
    "erva",
    "ervilha",
    "esbanjar",
    "esbelto",
    "escama",
    "escola",
    "escrita",
    "escuta",
    "esfinge",
    "esfolar",
    "esfregar",
    "esfumado",
    "esgrima",
    "esmalte",
    "espanto",
    "espelho",
    "espiga",
    "esponja",
    "espreita",
    "espumar",
    "esquerda",
    "estaca",
    "esteira",
    "esticar",
    "estofado",
    "estrela",
    "estudo",
    "esvaziar",
    "etanol",
    "etiqueta",
    "euforia",
    "europeu",
    "evacuar",
    "evaporar",
    "evasivo",
    "eventual",
    "evidente",
    "evoluir",
    "exagero",
    "exalar",
    "examinar",
    "exato",
    "exausto",
    "excesso",
    "excitar",
    "exclamar",
    "executar",
    "exemplo",
    "exibir",
    "exigente",
    "exonerar",
    "expandir",
    "expelir",
    "expirar",
    "explanar",
    "exposto",
    "expresso",
    "expulsar",
    "externo",
    "extinto",
    "extrato",
    "fabricar",
    "fabuloso",
    "faceta",
    "facial",
    "fada",
    "fadiga",
    "faixa",
    "falar",
    "falta",
    "familiar",
    "fandango",
    "fanfarra",
    "fantoche",
    "fardado",
    "farelo",
    "farinha",
    "farofa",
    "farpa",
    "fartura",
    "fatia",
    "fator",
    "favorita",
    "faxina",
    "fazenda",
    "fechado",
    "feijoada",
    "feirante",
    "felino",
    "feminino",
    "fenda",
    "feno",
    "fera",
    "feriado",
    "ferrugem",
    "ferver",
    "festejar",
    "fetal",
    "feudal",
    "fiapo",
    "fibrose",
    "ficar",
    "ficheiro",
    "figurado",
    "fileira",
    "filho",
    "filme",
    "filtrar",
    "firmeza",
    "fisgada",
    "fissura",
    "fita",
    "fivela",
    "fixador",
    "fixo",
    "flacidez",
    "flamingo",
    "flanela",
    "flechada",
    "flora",
    "flutuar",
    "fluxo",
    "focal",
    "focinho",
    "fofocar",
    "fogo",
    "foguete",
    "foice",
    "folgado",
    "folheto",
    "forjar",
    "formiga",
    "forno",
    "forte",
    "fosco",
    "fossa",
    "fragata",
    "fralda",
    "frango",
    "frasco",
    "fraterno",
    "freira",
    "frente",
    "fretar",
    "frieza",
    "friso",
    "fritura",
    "fronha",
    "frustrar",
    "fruteira",
    "fugir",
    "fulano",
    "fuligem",
    "fundar",
    "fungo",
    "funil",
    "furador",
    "furioso",
    "futebol",
    "gabarito",
    "gabinete",
    "gado",
    "gaiato",
    "gaiola",
    "gaivota",
    "galega",
    "galho",
    "galinha",
    "galocha",
    "ganhar",
    "garagem",
    "garfo",
    "gargalo",
    "garimpo",
    "garoupa",
    "garrafa",
    "gasoduto",
    "gasto",
    "gata",
    "gatilho",
    "gaveta",
    "gazela",
    "gelado",
    "geleia",
    "gelo",
    "gemada",
    "gemer",
    "gemido",
    "generoso",
    "gengiva",
    "genial",
    "genoma",
    "genro",
    "geologia",
    "gerador",
    "germinar",
    "gesso",
    "gestor",
    "ginasta",
    "gincana",
    "gingado",
    "girafa",
    "girino",
    "glacial",
    "glicose",
    "global",
    "glorioso",
    "goela",
    "goiaba",
    "golfe",
    "golpear",
    "gordura",
    "gorjeta",
    "gorro",
    "gostoso",
    "goteira",
    "governar",
    "gracejo",
    "gradual",
    "grafite",
    "gralha",
    "grampo",
    "granada",
    "gratuito",
    "graveto",
    "graxa",
    "grego",
    "grelhar",
    "greve",
    "grilo",
    "grisalho",
    "gritaria",
    "grosso",
    "grotesco",
    "grudado",
    "grunhido",
    "gruta",
    "guache",
    "guarani",
    "guaxinim",
    "guerrear",
    "guiar",
    "guincho",
    "guisado",
    "gula",
    "guloso",
    "guru",
    "habitar",
    "harmonia",
    "haste",
    "haver",
    "hectare",
    "herdar",
    "heresia",
    "hesitar",
    "hiato",
    "hibernar",
    "hidratar",
    "hiena",
    "hino",
    "hipismo",
    "hipnose",
    "hipoteca",
    "hoje",
    "holofote",
    "homem",
    "honesto",
    "honrado",
    "hormonal",
    "hospedar",
    "humorado",
    "iate",
    "ideia",
    "idoso",
    "ignorado",
    "igreja",
    "iguana",
    "ileso",
    "ilha",
    "iludido",
    "iluminar",
    "ilustrar",
    "imagem",
    "imediato",
    "imenso",
    "imersivo",
    "iminente",
    "imitador",
    "imortal",
    "impacto",
    "impedir",
    "implante",
    "impor",
    "imprensa",
    "impune",
    "imunizar",
    "inalador",
    "inapto",
    "inativo",
    "incenso",
    "inchar",
    "incidir",
    "incluir",
    "incolor",
    "indeciso",
    "indireto",
    "indutor",
    "ineficaz",
    "inerente",
    "infantil",
    "infestar",
    "infinito",
    "inflamar",
    "informal",
    "infrator",
    "ingerir",
    "inibido",
    "inicial",
    "inimigo",
    "injetar",
    "inocente",
    "inodoro",
    "inovador",
    "inox",
    "inquieto",
    "inscrito",
    "inseto",
    "insistir",
    "inspetor",
    "instalar",
    "insulto",
    "intacto",
    "integral",
    "intimar",
    "intocado",
    "intriga",
    "invasor",
    "inverno",
    "invicto",
    "invocar",
    "iogurte",
    "iraniano",
    "ironizar",
    "irreal",
    "irritado",
    "isca",
    "isento",
    "isolado",
    "isqueiro",
    "italiano",
    "janeiro",
    "jangada",
    "janta",
    "jararaca",
    "jardim",
    "jarro",
    "jasmim",
    "jato",
    "javali",
    "jazida",
    "jejum",
    "joaninha",
    "joelhada",
    "jogador",
    "joia",
    "jornal",
    "jorrar",
    "jovem",
    "juba",
    "judeu",
    "judoca",
    "juiz",
    "julgador",
    "julho",
    "jurado",
    "jurista",
    "juro",
    "justa",
    "labareda",
    "laboral",
    "lacre",
    "lactante",
    "ladrilho",
    "lagarta",
    "lagoa",
    "laje",
    "lamber",
    "lamentar",
    "laminar",
    "lampejo",
    "lanche",
    "lapidar",
    "lapso",
    "laranja",
    "lareira",
    "largura",
    "lasanha",
    "lastro",
    "lateral",
    "latido",
    "lavanda",
    "lavoura",
    "lavrador",
    "laxante",
    "lazer",
    "lealdade",
    "lebre",
    "legado",
    "legendar",
    "legista",
    "leigo",
    "leiloar",
    "leitura",
    "lembrete",
    "leme",
    "lenhador",
    "lentilha",
    "leoa",
    "lesma",
    "leste",
    "letivo",
    "letreiro",
    "levar",
    "leveza",
    "levitar",
    "liberal",
    "libido",
    "liderar",
    "ligar",
    "ligeiro",
    "limitar",
    "limoeiro",
    "limpador",
    "linda",
    "linear",
    "linhagem",
    "liquidez",
    "listagem",
    "lisura",
    "litoral",
    "livro",
    "lixa",
    "lixeira",
    "locador",
    "locutor",
    "lojista",
    "lombo",
    "lona",
    "longe",
    "lontra",
    "lorde",
    "lotado",
    "loteria",
    "loucura",
    "lousa",
    "louvar",
    "luar",
    "lucidez",
    "lucro",
    "luneta",
    "lustre",
    "lutador",
    "luva",
    "macaco",
    "macete",
    "machado",
    "macio",
    "madeira",
    "madrinha",
    "magnata",
    "magreza",
    "maior",
    "mais",
    "malandro",
    "malha",
    "malote",
    "maluco",
    "mamilo",
    "mamoeiro",
    "mamute",
    "manada",
    "mancha",
    "mandato",
    "manequim",
    "manhoso",
    "manivela",
    "manobrar",
    "mansa",
    "manter",
    "manusear",
    "mapeado",
    "maquinar",
    "marcador",
    "maresia",
    "marfim",
    "margem",
    "marinho",
    "marmita",
    "maroto",
    "marquise",
    "marreco",
    "martelo",
    "marujo",
    "mascote",
    "masmorra",
    "massagem",
    "mastigar",
    "matagal",
    "materno",
    "matinal",
    "matutar",
    "maxilar",
    "medalha",
    "medida",
    "medusa",
    "megafone",
    "meiga",
    "melancia",
    "melhor",
    "membro",
    "memorial",
    "menino",
    "menos",
    "mensagem",
    "mental",
    "merecer",
    "mergulho",
    "mesada",
    "mesclar",
    "mesmo",
    "mesquita",
    "mestre",
    "metade",
    "meteoro",
    "metragem",
    "mexer",
    "mexicano",
    "micro",
    "migalha",
    "migrar",
    "milagre",
    "milenar",
    "milhar",
    "mimado",
    "minerar",
    "minhoca",
    "ministro",
    "minoria",
    "miolo",
    "mirante",
    "mirtilo",
    "misturar",
    "mocidade",
    "moderno",
    "modular",
    "moeda",
    "moer",
    "moinho",
    "moita",
    "moldura",
    "moleza",
    "molho",
    "molinete",
    "molusco",
    "montanha",
    "moqueca",
    "morango",
    "morcego",
    "mordomo",
    "morena",
    "mosaico",
    "mosquete",
    "mostarda",
    "motel",
    "motim",
    "moto",
    "motriz",
    "muda",
    "muito",
    "mulata",
    "mulher",
    "multar",
    "mundial",
    "munido",
    "muralha",
    "murcho",
    "muscular",
    "museu",
    "musical",
    "nacional",
    "nadador",
    "naja",
    "namoro",
    "narina",
    "narrado",
    "nascer",
    "nativa",
    "natureza",
    "navalha",
    "navegar",
    "navio",
    "neblina",
    "nebuloso",
    "negativa",
    "negociar",
    "negrito",
    "nervoso",
    "neta",
    "neural",
    "nevasca",
    "nevoeiro",
    "ninar",
    "ninho",
    "nitidez",
    "nivelar",
    "nobreza",
    "noite",
    "noiva",
    "nomear",
    "nominal",
    "nordeste",
    "nortear",
    "notar",
    "noticiar",
    "noturno",
    "novelo",
    "novilho",
    "novo",
    "nublado",
    "nudez",
    "numeral",
    "nupcial",
    "nutrir",
    "nuvem",
    "obcecado",
    "obedecer",
    "objetivo",
    "obrigado",
    "obscuro",
    "obstetra",
    "obter",
    "obturar",
    "ocidente",
    "ocioso",
    "ocorrer",
    "oculista",
    "ocupado",
    "ofegante",
    "ofensiva",
    "oferenda",
    "oficina",
    "ofuscado",
    "ogiva",
    "olaria",
    "oleoso",
    "olhar",
    "oliveira",
    "ombro",
    "omelete",
    "omisso",
    "omitir",
    "ondulado",
    "oneroso",
    "ontem",
    "opcional",
    "operador",
    "oponente",
    "oportuno",
    "oposto",
    "orar",
    "orbitar",
    "ordem",
    "ordinal",
    "orfanato",
    "orgasmo",
    "orgulho",
    "oriental",
    "origem",
    "oriundo",
    "orla",
    "ortodoxo",
    "orvalho",
    "oscilar",
    "ossada",
    "osso",
    "ostentar",
    "otimismo",
    "ousadia",
    "outono",
    "outubro",
    "ouvido",
    "ovelha",
    "ovular",
    "oxidar",
    "oxigenar",
    "pacato",
    "paciente",
    "pacote",
    "pactuar",
    "padaria",
    "padrinho",
    "pagar",
    "pagode",
    "painel",
    "pairar",
    "paisagem",
    "palavra",
    "palestra",
    "palheta",
    "palito",
    "palmada",
    "palpitar",
    "pancada",
    "panela",
    "panfleto",
    "panqueca",
    "pantanal",
    "papagaio",
    "papelada",
    "papiro",
    "parafina",
    "parcial",
    "pardal",
    "parede",
    "partida",
    "pasmo",
    "passado",
    "pastel",
    "patamar",
    "patente",
    "patinar",
    "patrono",
    "paulada",
    "pausar",
    "peculiar",
    "pedalar",
    "pedestre",
    "pediatra",
    "pedra",
    "pegada",
    "peitoral",
    "peixe",
    "pele",
    "pelicano",
    "penca",
    "pendurar",
    "peneira",
    "penhasco",
    "pensador",
    "pente",
    "perceber",
    "perfeito",
    "pergunta",
    "perito",
    "permitir",
    "perna",
    "perplexo",
    "persiana",
    "pertence",
    "peruca",
    "pescado",
    "pesquisa",
    "pessoa",
    "petiscar",
    "piada",
    "picado",
    "piedade",
    "pigmento",
    "pilastra",
    "pilhado",
    "pilotar",
    "pimenta",
    "pincel",
    "pinguim",
    "pinha",
    "pinote",
    "pintar",
    "pioneiro",
    "pipoca",
    "piquete",
    "piranha",
    "pires",
    "pirueta",
    "piscar",
    "pistola",
    "pitanga",
    "pivete",
    "planta",
    "plaqueta",
    "platina",
    "plebeu",
    "plumagem",
    "pluvial",
    "pneu",
    "poda",
    "poeira",
    "poetisa",
    "polegada",
    "policiar",
    "poluente",
    "polvilho",
    "pomar",
    "pomba",
    "ponderar",
    "pontaria",
    "populoso",
    "porta",
    "possuir",
    "postal",
    "pote",
    "poupar",
    "pouso",
    "povoar",
    "praia",
    "prancha",
    "prato",
    "praxe",
    "prece",
    "predador",
    "prefeito",
    "premiar",
    "prensar",
    "preparar",
    "presilha",
    "pretexto",
    "prevenir",
    "prezar",
    "primata",
    "princesa",
    "prisma",
    "privado",
    "processo",
    "produto",
    "profeta",
    "proibido",
    "projeto",
    "prometer",
    "propagar",
    "prosa",
    "protetor",
    "provador",
    "publicar",
    "pudim",
    "pular",
    "pulmonar",
    "pulseira",
    "punhal",
    "punir",
    "pupilo",
    "pureza",
    "puxador",
    "quadra",
    "quantia",
    "quarto",
    "quase",
    "quebrar",
    "queda",
    "queijo",
    "quente",
    "querido",
    "quimono",
    "quina",
    "quiosque",
    "rabanada",
    "rabisco",
    "rachar",
    "racionar",
    "radial",
    "raiar",
    "rainha",
    "raio",
    "raiva",
    "rajada",
    "ralado",
    "ramal",
    "ranger",
    "ranhura",
    "rapadura",
    "rapel",
    "rapidez",
    "raposa",
    "raquete",
    "raridade",
    "rasante",
    "rascunho",
    "rasgar",
    "raspador",
    "rasteira",
    "rasurar",
    "ratazana",
    "ratoeira",
    "realeza",
    "reanimar",
    "reaver",
    "rebaixar",
    "rebelde",
    "rebolar",
    "recado",
    "recente",
    "recheio",
    "recibo",
    "recordar",
    "recrutar",
    "recuar",
    "rede",
    "redimir",
    "redonda",
    "reduzida",
    "reenvio",
    "refinar",
    "refletir",
    "refogar",
    "refresco",
    "refugiar",
    "regalia",
    "regime",
    "regra",
    "reinado",
    "reitor",
    "rejeitar",
    "relativo",
    "remador",
    "remendo",
    "remorso",
    "renovado",
    "reparo",
    "repelir",
    "repleto",
    "repolho",
    "represa",
    "repudiar",
    "requerer",
    "resenha",
    "resfriar",
    "resgatar",
    "residir",
    "resolver",
    "respeito",
    "ressaca",
    "restante",
    "resumir",
    "retalho",
    "reter",
    "retirar",
    "retomada",
    "retratar",
    "revelar",
    "revisor",
    "revolta",
    "riacho",
    "rica",
    "rigidez",
    "rigoroso",
    "rimar",
    "ringue",
    "risada",
    "risco",
    "risonho",
    "robalo",
    "rochedo",
    "rodada",
    "rodeio",
    "rodovia",
    "roedor",
    "roleta",
    "romano",
    "roncar",
    "rosado",
    "roseira",
    "rosto",
    "rota",
    "roteiro",
    "rotina",
    "rotular",
    "rouco",
    "roupa",
    "roxo",
    "rubro",
    "rugido",
    "rugoso",
    "ruivo",
    "rumo",
    "rupestre",
    "russo",
    "sabor",
    "saciar",
    "sacola",
    "sacudir",
    "sadio",
    "safira",
    "saga",
    "sagrada",
    "saibro",
    "salada",
    "saleiro",
    "salgado",
    "saliva",
    "salpicar",
    "salsicha",
    "saltar",
    "salvador",
    "sambar",
    "samurai",
    "sanar",
    "sanfona",
    "sangue",
    "sanidade",
    "sapato",
    "sarda",
    "sargento",
    "sarjeta",
    "saturar",
    "saudade",
    "saxofone",
    "sazonal",
    "secar",
    "secular",
    "seda",
    "sedento",
    "sediado",
    "sedoso",
    "sedutor",
    "segmento",
    "segredo",
    "segundo",
    "seiva",
    "seleto",
    "selvagem",
    "semanal",
    "semente",
    "senador",
    "senhor",
    "sensual",
    "sentado",
    "separado",
    "sereia",
    "seringa",
    "serra",
    "servo",
    "setembro",
    "setor",
    "sigilo",
    "silhueta",
    "silicone",
    "simetria",
    "simpatia",
    "simular",
    "sinal",
    "sincero",
    "singular",
    "sinopse",
    "sintonia",
    "sirene",
    "siri",
    "situado",
    "soberano",
    "sobra",
    "socorro",
    "sogro",
    "soja",
    "solda",
    "soletrar",
    "solteiro",
    "sombrio",
    "sonata",
    "sondar",
    "sonegar",
    "sonhador",
    "sono",
    "soprano",
    "soquete",
    "sorrir",
    "sorteio",
    "sossego",
    "sotaque",
    "soterrar",
    "sovado",
    "sozinho",
    "suavizar",
    "subida",
    "submerso",
    "subsolo",
    "subtrair",
    "sucata",
    "sucesso",
    "suco",
    "sudeste",
    "sufixo",
    "sugador",
    "sugerir",
    "sujeito",
    "sulfato",
    "sumir",
    "suor",
    "superior",
    "suplicar",
    "suposto",
    "suprimir",
    "surdina",
    "surfista",
    "surpresa",
    "surreal",
    "surtir",
    "suspiro",
    "sustento",
    "tabela",
    "tablete",
    "tabuada",
    "tacho",
    "tagarela",
    "talher",
    "talo",
    "talvez",
    "tamanho",
    "tamborim",
    "tampa",
    "tangente",
    "tanto",
    "tapar",
    "tapioca",
    "tardio",
    "tarefa",
    "tarja",
    "tarraxa",
    "tatuagem",
    "taurino",
    "taxativo",
    "taxista",
    "teatral",
    "tecer",
    "tecido",
    "teclado",
    "tedioso",
    "teia",
    "teimar",
    "telefone",
    "telhado",
    "tempero",
    "tenente",
    "tensor",
    "tentar",
    "termal",
    "terno",
    "terreno",
    "tese",
    "tesoura",
    "testado",
    "teto",
    "textura",
    "texugo",
    "tiara",
    "tigela",
    "tijolo",
    "timbrar",
    "timidez",
    "tingido",
    "tinteiro",
    "tiragem",
    "titular",
    "toalha",
    "tocha",
    "tolerar",
    "tolice",
    "tomada",
    "tomilho",
    "tonel",
    "tontura",
    "topete",
    "tora",
    "torcido",
    "torneio",
    "torque",
    "torrada",
    "torto",
    "tostar",
    "touca",
    "toupeira",
    "toxina",
    "trabalho",
    "tracejar",
    "tradutor",
    "trafegar",
    "trajeto",
    "trama",
    "trancar",
    "trapo",
    "traseiro",
    "tratador",
    "travar",
    "treino",
    "tremer",
    "trepidar",
    "trevo",
    "triagem",
    "tribo",
    "triciclo",
    "tridente",
    "trilogia",
    "trindade",
    "triplo",
    "triturar",
    "triunfal",
    "trocar",
    "trombeta",
    "trova",
    "trunfo",
    "truque",
    "tubular",
    "tucano",
    "tudo",
    "tulipa",
    "tupi",
    "turbo",
    "turma",
    "turquesa",
    "tutelar",
    "tutorial",
    "uivar",
    "umbigo",
    "unha",
    "unidade",
    "uniforme",
    "urologia",
    "urso",
    "urtiga",
    "urubu",
    "usado",
    "usina",
    "usufruir",
    "vacina",
    "vadiar",
    "vagaroso",
    "vaidoso",
    "vala",
    "valente",
    "validade",
    "valores",
    "vantagem",
    "vaqueiro",
    "varanda",
    "vareta",
    "varrer",
    "vascular",
    "vasilha",
    "vassoura",
    "vazar",
    "vazio",
    "veado",
    "vedar",
    "vegetar",
    "veicular",
    "veleiro",
    "velhice",
    "veludo",
    "vencedor",
    "vendaval",
    "venerar",
    "ventre",
    "verbal",
    "verdade",
    "vereador",
    "vergonha",
    "vermelho",
    "verniz",
    "versar",
    "vertente",
    "vespa",
    "vestido",
    "vetorial",
    "viaduto",
    "viagem",
    "viajar",
    "viatura",
    "vibrador",
    "videira",
    "vidraria",
    "viela",
    "viga",
    "vigente",
    "vigiar",
    "vigorar",
    "vilarejo",
    "vinco",
    "vinheta",
    "vinil",
    "violeta",
    "virada",
    "virtude",
    "visitar",
    "visto",
    "vitral",
    "viveiro",
    "vizinho",
    "voador",
    "voar",
    "vogal",
    "volante",
    "voleibol",
    "voltagem",
    "volumoso",
    "vontade",
    "vulto",
    "vuvuzela",
    "xadrez",
    "xarope",
    "xeque",
    "xeretar",
    "xerife",
    "xingar",
    "zangado",
    "zarpar",
    "zebu",
    "zelador",
    "zombar",
    "zoologia",
    "zumbido"
]

},{}],64:[function(require,module,exports){
module.exports=[
    "abaco",
    "abdomen",
    "abeja",
    "abierto",
    "abogado",
    "abono",
    "aborto",
    "abrazo",
    "abrir",
    "abuelo",
    "abuso",
    "acabar",
    "academia",
    "acceso",
    "accion",
    "aceite",
    "acelga",
    "acento",
    "aceptar",
    "acido",
    "aclarar",
    "acne",
    "acoger",
    "acoso",
    "activo",
    "acto",
    "actriz",
    "actuar",
    "acudir",
    "acuerdo",
    "acusar",
    "adicto",
    "admitir",
    "adoptar",
    "adorno",
    "aduana",
    "adulto",
    "aereo",
    "afectar",
    "aficion",
    "afinar",
    "afirmar",
    "agil",
    "agitar",
    "agonia",
    "agosto",
    "agotar",
    "agregar",
    "agrio",
    "agua",
    "agudo",
    "aguila",
    "aguja",
    "ahogo",
    "ahorro",
    "aire",
    "aislar",
    "ajedrez",
    "ajeno",
    "ajuste",
    "alacran",
    "alambre",
    "alarma",
    "alba",
    "album",
    "alcalde",
    "aldea",
    "alegre",
    "alejar",
    "alerta",
    "aleta",
    "alfiler",
    "alga",
    "algodon",
    "aliado",
    "aliento",
    "alivio",
    "alma",
    "almeja",
    "almibar",
    "altar",
    "alteza",
    "altivo",
    "alto",
    "altura",
    "alumno",
    "alzar",
    "amable",
    "amante",
    "amapola",
    "amargo",
    "amasar",
    "ambar",
    "ambito",
    "ameno",
    "amigo",
    "amistad",
    "amor",
    "amparo",
    "amplio",
    "ancho",
    "anciano",
    "ancla",
    "andar",
    "anden",
    "anemia",
    "angulo",
    "anillo",
    "animo",
    "anis",
    "anotar",
    "antena",
    "antiguo",
    "antojo",
    "anual",
    "anular",
    "anuncio",
    "anadir",
    "anejo",
    "ano",
    "apagar",
    "aparato",
    "apetito",
    "apio",
    "aplicar",
    "apodo",
    "aporte",
    "apoyo",
    "aprender",
    "aprobar",
    "apuesta",
    "apuro",
    "arado",
    "arana",
    "arar",
    "arbitro",
    "arbol",
    "arbusto",
    "archivo",
    "arco",
    "arder",
    "ardilla",
    "arduo",
    "area",
    "arido",
    "aries",
    "armonia",
    "arnes",
    "aroma",
    "arpa",
    "arpon",
    "arreglo",
    "arroz",
    "arruga",
    "arte",
    "artista",
    "asa",
    "asado",
    "asalto",
    "ascenso",
    "asegurar",
    "aseo",
    "asesor",
    "asiento",
    "asilo",
    "asistir",
    "asno",
    "asombro",
    "aspero",
    "astilla",
    "astro",
    "astuto",
    "asumir",
    "asunto",
    "atajo",
    "ataque",
    "atar",
    "atento",
    "ateo",
    "atico",
    "atleta",
    "atomo",
    "atraer",
    "atroz",
    "atun",
    "audaz",
    "audio",
    "auge",
    "aula",
    "aumento",
    "ausente",
    "autor",
    "aval",
    "avance",
    "avaro",
    "ave",
    "avellana",
    "avena",
    "avestruz",
    "avion",
    "aviso",
    "ayer",
    "ayuda",
    "ayuno",
    "azafran",
    "azar",
    "azote",
    "azucar",
    "azufre",
    "azul",
    "baba",
    "babor",
    "bache",
    "bahia",
    "baile",
    "bajar",
    "balanza",
    "balcon",
    "balde",
    "bambu",
    "banco",
    "banda",
    "bano",
    "barba",
    "barco",
    "barniz",
    "barro",
    "bascula",
    "baston",
    "basura",
    "batalla",
    "bateria",
    "batir",
    "batuta",
    "baul",
    "bazar",
    "bebe",
    "bebida",
    "bello",
    "besar",
    "beso",
    "bestia",
    "bicho",
    "bien",
    "bingo",
    "blanco",
    "bloque",
    "blusa",
    "boa",
    "bobina",
    "bobo",
    "boca",
    "bocina",
    "boda",
    "bodega",
    "boina",
    "bola",
    "bolero",
    "bolsa",
    "bomba",
    "bondad",
    "bonito",
    "bono",
    "bonsai",
    "borde",
    "borrar",
    "bosque",
    "bote",
    "botin",
    "boveda",
    "bozal",
    "bravo",
    "brazo",
    "brecha",
    "breve",
    "brillo",
    "brinco",
    "brisa",
    "broca",
    "broma",
    "bronce",
    "brote",
    "bruja",
    "brusco",
    "bruto",
    "buceo",
    "bucle",
    "bueno",
    "buey",
    "bufanda",
    "bufon",
    "buho",
    "buitre",
    "bulto",
    "burbuja",
    "burla",
    "burro",
    "buscar",
    "butaca",
    "buzon",
    "caballo",
    "cabeza",
    "cabina",
    "cabra",
    "cacao",
    "cadaver",
    "cadena",
    "caer",
    "cafe",
    "caida",
    "caiman",
    "caja",
    "cajon",
    "cal",
    "calamar",
    "calcio",
    "caldo",
    "calidad",
    "calle",
    "calma",
    "calor",
    "calvo",
    "cama",
    "cambio",
    "camello",
    "camino",
    "campo",
    "cancer",
    "candil",
    "canela",
    "canguro",
    "canica",
    "canto",
    "cana",
    "canon",
    "caoba",
    "caos",
    "capaz",
    "capitan",
    "capote",
    "captar",
    "capucha",
    "cara",
    "carbon",
    "carcel",
    "careta",
    "carga",
    "carino",
    "carne",
    "carpeta",
    "carro",
    "carta",
    "casa",
    "casco",
    "casero",
    "caspa",
    "castor",
    "catorce",
    "catre",
    "caudal",
    "causa",
    "cazo",
    "cebolla",
    "ceder",
    "cedro",
    "celda",
    "celebre",
    "celoso",
    "celula",
    "cemento",
    "ceniza",
    "centro",
    "cerca",
    "cerdo",
    "cereza",
    "cero",
    "cerrar",
    "certeza",
    "cesped",
    "cetro",
    "chacal",
    "chaleco",
    "champu",
    "chancla",
    "chapa",
    "charla",
    "chico",
    "chiste",
    "chivo",
    "choque",
    "choza",
    "chuleta",
    "chupar",
    "ciclon",
    "ciego",
    "cielo",
    "cien",
    "cierto",
    "cifra",
    "cigarro",
    "cima",
    "cinco",
    "cine",
    "cinta",
    "cipres",
    "circo",
    "ciruela",
    "cisne",
    "cita",
    "ciudad",
    "clamor",
    "clan",
    "claro",
    "clase",
    "clave",
    "cliente",
    "clima",
    "clinica",
    "cobre",
    "coccion",
    "cochino",
    "cocina",
    "coco",
    "codigo",
    "codo",
    "cofre",
    "coger",
    "cohete",
    "cojin",
    "cojo",
    "cola",
    "colcha",
    "colegio",
    "colgar",
    "colina",
    "collar",
    "colmo",
    "columna",
    "combate",
    "comer",
    "comida",
    "comodo",
    "compra",
    "conde",
    "conejo",
    "conga",
    "conocer",
    "consejo",
    "contar",
    "copa",
    "copia",
    "corazon",
    "corbata",
    "corcho",
    "cordon",
    "corona",
    "correr",
    "coser",
    "cosmos",
    "costa",
    "craneo",
    "crater",
    "crear",
    "crecer",
    "creido",
    "crema",
    "cria",
    "crimen",
    "cripta",
    "crisis",
    "cromo",
    "cronica",
    "croqueta",
    "crudo",
    "cruz",
    "cuadro",
    "cuarto",
    "cuatro",
    "cubo",
    "cubrir",
    "cuchara",
    "cuello",
    "cuento",
    "cuerda",
    "cuesta",
    "cueva",
    "cuidar",
    "culebra",
    "culpa",
    "culto",
    "cumbre",
    "cumplir",
    "cuna",
    "cuneta",
    "cuota",
    "cupon",
    "cupula",
    "curar",
    "curioso",
    "curso",
    "curva",
    "cutis",
    "dama",
    "danza",
    "dar",
    "dardo",
    "datil",
    "deber",
    "debil",
    "decada",
    "decir",
    "dedo",
    "defensa",
    "definir",
    "dejar",
    "delfin",
    "delgado",
    "delito",
    "demora",
    "denso",
    "dental",
    "deporte",
    "derecho",
    "derrota",
    "desayuno",
    "deseo",
    "desfile",
    "desnudo",
    "destino",
    "desvio",
    "detalle",
    "detener",
    "deuda",
    "dia",
    "diablo",
    "diadema",
    "diamante",
    "diana",
    "diario",
    "dibujo",
    "dictar",
    "diente",
    "dieta",
    "diez",
    "dificil",
    "digno",
    "dilema",
    "diluir",
    "dinero",
    "directo",
    "dirigir",
    "disco",
    "diseno",
    "disfraz",
    "diva",
    "divino",
    "doble",
    "doce",
    "dolor",
    "domingo",
    "don",
    "donar",
    "dorado",
    "dormir",
    "dorso",
    "dos",
    "dosis",
    "dragon",
    "droga",
    "ducha",
    "duda",
    "duelo",
    "dueno",
    "dulce",
    "duo",
    "duque",
    "durar",
    "dureza",
    "duro",
    "ebano",
    "ebrio",
    "echar",
    "eco",
    "ecuador",
    "edad",
    "edicion",
    "edificio",
    "editor",
    "educar",
    "efecto",
    "eficaz",
    "eje",
    "ejemplo",
    "elefante",
    "elegir",
    "elemento",
    "elevar",
    "elipse",
    "elite",
    "elixir",
    "elogio",
    "eludir",
    "embudo",
    "emitir",
    "emocion",
    "empate",
    "empeno",
    "empleo",
    "empresa",
    "enano",
    "encargo",
    "enchufe",
    "encia",
    "enemigo",
    "enero",
    "enfado",
    "enfermo",
    "engano",
    "enigma",
    "enlace",
    "enorme",
    "enredo",
    "ensayo",
    "ensenar",
    "entero",
    "entrar",
    "envase",
    "envio",
    "epoca",
    "equipo",
    "erizo",
    "escala",
    "escena",
    "escolar",
    "escribir",
    "escudo",
    "esencia",
    "esfera",
    "esfuerzo",
    "espada",
    "espejo",
    "espia",
    "esposa",
    "espuma",
    "esqui",
    "estar",
    "este",
    "estilo",
    "estufa",
    "etapa",
    "eterno",
    "etica",
    "etnia",
    "evadir",
    "evaluar",
    "evento",
    "evitar",
    "exacto",
    "examen",
    "exceso",
    "excusa",
    "exento",
    "exigir",
    "exilio",
    "existir",
    "exito",
    "experto",
    "explicar",
    "exponer",
    "extremo",
    "fabrica",
    "fabula",
    "fachada",
    "facil",
    "factor",
    "faena",
    "faja",
    "falda",
    "fallo",
    "falso",
    "faltar",
    "fama",
    "familia",
    "famoso",
    "faraon",
    "farmacia",
    "farol",
    "farsa",
    "fase",
    "fatiga",
    "fauna",
    "favor",
    "fax",
    "febrero",
    "fecha",
    "feliz",
    "feo",
    "feria",
    "feroz",
    "fertil",
    "fervor",
    "festin",
    "fiable",
    "fianza",
    "fiar",
    "fibra",
    "ficcion",
    "ficha",
    "fideo",
    "fiebre",
    "fiel",
    "fiera",
    "fiesta",
    "figura",
    "fijar",
    "fijo",
    "fila",
    "filete",
    "filial",
    "filtro",
    "fin",
    "finca",
    "fingir",
    "finito",
    "firma",
    "flaco",
    "flauta",
    "flecha",
    "flor",
    "flota",
    "fluir",
    "flujo",
    "fluor",
    "fobia",
    "foca",
    "fogata",
    "fogon",
    "folio",
    "folleto",
    "fondo",
    "forma",
    "forro",
    "fortuna",
    "forzar",
    "fosa",
    "foto",
    "fracaso",
    "fragil",
    "franja",
    "frase",
    "fraude",
    "freir",
    "freno",
    "fresa",
    "frio",
    "frito",
    "fruta",
    "fuego",
    "fuente",
    "fuerza",
    "fuga",
    "fumar",
    "funcion",
    "funda",
    "furgon",
    "furia",
    "fusil",
    "futbol",
    "futuro",
    "gacela",
    "gafas",
    "gaita",
    "gajo",
    "gala",
    "galeria",
    "gallo",
    "gamba",
    "ganar",
    "gancho",
    "ganga",
    "ganso",
    "garaje",
    "garza",
    "gasolina",
    "gastar",
    "gato",
    "gavilan",
    "gemelo",
    "gemir",
    "gen",
    "genero",
    "genio",
    "gente",
    "geranio",
    "gerente",
    "germen",
    "gesto",
    "gigante",
    "gimnasio",
    "girar",
    "giro",
    "glaciar",
    "globo",
    "gloria",
    "gol",
    "golfo",
    "goloso",
    "golpe",
    "goma",
    "gordo",
    "gorila",
    "gorra",
    "gota",
    "goteo",
    "gozar",
    "grada",
    "grafico",
    "grano",
    "grasa",
    "gratis",
    "grave",
    "grieta",
    "grillo",
    "gripe",
    "gris",
    "grito",
    "grosor",
    "grua",
    "grueso",
    "grumo",
    "grupo",
    "guante",
    "guapo",
    "guardia",
    "guerra",
    "guia",
    "guino",
    "guion",
    "guiso",
    "guitarra",
    "gusano",
    "gustar",
    "haber",
    "habil",
    "hablar",
    "hacer",
    "hacha",
    "hada",
    "hallar",
    "hamaca",
    "harina",
    "haz",
    "hazana",
    "hebilla",
    "hebra",
    "hecho",
    "helado",
    "helio",
    "hembra",
    "herir",
    "hermano",
    "heroe",
    "hervir",
    "hielo",
    "hierro",
    "higado",
    "higiene",
    "hijo",
    "himno",
    "historia",
    "hocico",
    "hogar",
    "hoguera",
    "hoja",
    "hombre",
    "hongo",
    "honor",
    "honra",
    "hora",
    "hormiga",
    "horno",
    "hostil",
    "hoyo",
    "hueco",
    "huelga",
    "huerta",
    "hueso",
    "huevo",
    "huida",
    "huir",
    "humano",
    "humedo",
    "humilde",
    "humo",
    "hundir",
    "huracan",
    "hurto",
    "icono",
    "ideal",
    "idioma",
    "idolo",
    "iglesia",
    "iglu",
    "igual",
    "ilegal",
    "ilusion",
    "imagen",
    "iman",
    "imitar",
    "impar",
    "imperio",
    "imponer",
    "impulso",
    "incapaz",
    "indice",
    "inerte",
    "infiel",
    "informe",
    "ingenio",
    "inicio",
    "inmenso",
    "inmune",
    "innato",
    "insecto",
    "instante",
    "interes",
    "intimo",
    "intuir",
    "inutil",
    "invierno",
    "ira",
    "iris",
    "ironia",
    "isla",
    "islote",
    "jabali",
    "jabon",
    "jamon",
    "jarabe",
    "jardin",
    "jarra",
    "jaula",
    "jazmin",
    "jefe",
    "jeringa",
    "jinete",
    "jornada",
    "joroba",
    "joven",
    "joya",
    "juerga",
    "jueves",
    "juez",
    "jugador",
    "jugo",
    "juguete",
    "juicio",
    "junco",
    "jungla",
    "junio",
    "juntar",
    "jupiter",
    "jurar",
    "justo",
    "juvenil",
    "juzgar",
    "kilo",
    "koala",
    "labio",
    "lacio",
    "lacra",
    "lado",
    "ladron",
    "lagarto",
    "lagrima",
    "laguna",
    "laico",
    "lamer",
    "lamina",
    "lampara",
    "lana",
    "lancha",
    "langosta",
    "lanza",
    "lapiz",
    "largo",
    "larva",
    "lastima",
    "lata",
    "latex",
    "latir",
    "laurel",
    "lavar",
    "lazo",
    "leal",
    "leccion",
    "leche",
    "lector",
    "leer",
    "legion",
    "legumbre",
    "lejano",
    "lengua",
    "lento",
    "lena",
    "leon",
    "leopardo",
    "lesion",
    "letal",
    "letra",
    "leve",
    "leyenda",
    "libertad",
    "libro",
    "licor",
    "lider",
    "lidiar",
    "lienzo",
    "liga",
    "ligero",
    "lima",
    "limite",
    "limon",
    "limpio",
    "lince",
    "lindo",
    "linea",
    "lingote",
    "lino",
    "linterna",
    "liquido",
    "liso",
    "lista",
    "litera",
    "litio",
    "litro",
    "llaga",
    "llama",
    "llanto",
    "llave",
    "llegar",
    "llenar",
    "llevar",
    "llorar",
    "llover",
    "lluvia",
    "lobo",
    "locion",
    "loco",
    "locura",
    "logica",
    "logro",
    "lombriz",
    "lomo",
    "lonja",
    "lote",
    "lucha",
    "lucir",
    "lugar",
    "lujo",
    "luna",
    "lunes",
    "lupa",
    "lustro",
    "luto",
    "luz",
    "maceta",
    "macho",
    "madera",
    "madre",
    "maduro",
    "maestro",
    "mafia",
    "magia",
    "mago",
    "maiz",
    "maldad",
    "maleta",
    "malla",
    "malo",
    "mama",
    "mambo",
    "mamut",
    "manco",
    "mando",
    "manejar",
    "manga",
    "maniqui",
    "manjar",
    "mano",
    "manso",
    "manta",
    "manana",
    "mapa",
    "maquina",
    "mar",
    "marco",
    "marea",
    "marfil",
    "margen",
    "marido",
    "marmol",
    "marron",
    "martes",
    "marzo",
    "masa",
    "mascara",
    "masivo",
    "matar",
    "materia",
    "matiz",
    "matriz",
    "maximo",
    "mayor",
    "mazorca",
    "mecha",
    "medalla",
    "medio",
    "medula",
    "mejilla",
    "mejor",
    "melena",
    "melon",
    "memoria",
    "menor",
    "mensaje",
    "mente",
    "menu",
    "mercado",
    "merengue",
    "merito",
    "mes",
    "meson",
    "meta",
    "meter",
    "metodo",
    "metro",
    "mezcla",
    "miedo",
    "miel",
    "miembro",
    "miga",
    "mil",
    "milagro",
    "militar",
    "millon",
    "mimo",
    "mina",
    "minero",
    "minimo",
    "minuto",
    "miope",
    "mirar",
    "misa",
    "miseria",
    "misil",
    "mismo",
    "mitad",
    "mito",
    "mochila",
    "mocion",
    "moda",
    "modelo",
    "moho",
    "mojar",
    "molde",
    "moler",
    "molino",
    "momento",
    "momia",
    "monarca",
    "moneda",
    "monja",
    "monto",
    "mono",
    "morada",
    "morder",
    "moreno",
    "morir",
    "morro",
    "morsa",
    "mortal",
    "mosca",
    "mostrar",
    "motivo",
    "mover",
    "movil",
    "mozo",
    "mucho",
    "mudar",
    "mueble",
    "muela",
    "muerte",
    "muestra",
    "mugre",
    "mujer",
    "mula",
    "muleta",
    "multa",
    "mundo",
    "muneca",
    "mural",
    "muro",
    "musculo",
    "museo",
    "musgo",
    "musica",
    "muslo",
    "nacar",
    "nacion",
    "nadar",
    "naipe",
    "naranja",
    "nariz",
    "narrar",
    "nasal",
    "natal",
    "nativo",
    "natural",
    "nausea",
    "naval",
    "nave",
    "navidad",
    "necio",
    "nectar",
    "negar",
    "negocio",
    "negro",
    "neon",
    "nervio",
    "neto",
    "neutro",
    "nevar",
    "nevera",
    "nicho",
    "nido",
    "niebla",
    "nieto",
    "ninez",
    "nino",
    "nitido",
    "nivel",
    "nobleza",
    "noche",
    "nomina",
    "noria",
    "norma",
    "norte",
    "nota",
    "noticia",
    "novato",
    "novela",
    "novio",
    "nube",
    "nuca",
    "nucleo",
    "nudillo",
    "nudo",
    "nuera",
    "nueve",
    "nuez",
    "nulo",
    "numero",
    "nutria",
    "oasis",
    "obeso",
    "obispo",
    "objeto",
    "obra",
    "obrero",
    "observar",
    "obtener",
    "obvio",
    "oca",
    "ocaso",
    "oceano",
    "ochenta",
    "ocho",
    "ocio",
    "ocre",
    "octavo",
    "octubre",
    "oculto",
    "ocupar",
    "ocurrir",
    "odiar",
    "odio",
    "odisea",
    "oeste",
    "ofensa",
    "oferta",
    "oficio",
    "ofrecer",
    "ogro",
    "oido",
    "oir",
    "ojo",
    "ola",
    "oleada",
    "olfato",
    "olivo",
    "olla",
    "olmo",
    "olor",
    "olvido",
    "ombligo",
    "onda",
    "onza",
    "opaco",
    "opcion",
    "opera",
    "opinar",
    "oponer",
    "optar",
    "optica",
    "opuesto",
    "oracion",
    "orador",
    "oral",
    "orbita",
    "orca",
    "orden",
    "oreja",
    "organo",
    "orgia",
    "orgullo",
    "oriente",
    "origen",
    "orilla",
    "oro",
    "orquesta",
    "oruga",
    "osadia",
    "oscuro",
    "osezno",
    "oso",
    "ostra",
    "otono",
    "otro",
    "oveja",
    "ovulo",
    "oxido",
    "oxigeno",
    "oyente",
    "ozono",
    "pacto",
    "padre",
    "paella",
    "pagina",
    "pago",
    "pais",
    "pajaro",
    "palabra",
    "palco",
    "paleta",
    "palido",
    "palma",
    "paloma",
    "palpar",
    "pan",
    "panal",
    "panico",
    "pantera",
    "panuelo",
    "papa",
    "papel",
    "papilla",
    "paquete",
    "parar",
    "parcela",
    "pared",
    "parir",
    "paro",
    "parpado",
    "parque",
    "parrafo",
    "parte",
    "pasar",
    "paseo",
    "pasion",
    "paso",
    "pasta",
    "pata",
    "patio",
    "patria",
    "pausa",
    "pauta",
    "pavo",
    "payaso",
    "peaton",
    "pecado",
    "pecera",
    "pecho",
    "pedal",
    "pedir",
    "pegar",
    "peine",
    "pelar",
    "peldano",
    "pelea",
    "peligro",
    "pellejo",
    "pelo",
    "peluca",
    "pena",
    "pensar",
    "penon",
    "peon",
    "peor",
    "pepino",
    "pequeno",
    "pera",
    "percha",
    "perder",
    "pereza",
    "perfil",
    "perico",
    "perla",
    "permiso",
    "perro",
    "persona",
    "pesa",
    "pesca",
    "pesimo",
    "pestana",
    "petalo",
    "petroleo",
    "pez",
    "pezuna",
    "picar",
    "pichon",
    "pie",
    "piedra",
    "pierna",
    "pieza",
    "pijama",
    "pilar",
    "piloto",
    "pimienta",
    "pino",
    "pintor",
    "pinza",
    "pina",
    "piojo",
    "pipa",
    "pirata",
    "pisar",
    "piscina",
    "piso",
    "pista",
    "piton",
    "pizca",
    "placa",
    "plan",
    "plata",
    "playa",
    "plaza",
    "pleito",
    "pleno",
    "plomo",
    "pluma",
    "plural",
    "pobre",
    "poco",
    "poder",
    "podio",
    "poema",
    "poesia",
    "poeta",
    "polen",
    "policia",
    "pollo",
    "polvo",
    "pomada",
    "pomelo",
    "pomo",
    "pompa",
    "poner",
    "porcion",
    "portal",
    "posada",
    "poseer",
    "posible",
    "poste",
    "potencia",
    "potro",
    "pozo",
    "prado",
    "precoz",
    "pregunta",
    "premio",
    "prensa",
    "preso",
    "previo",
    "primo",
    "principe",
    "prision",
    "privar",
    "proa",
    "probar",
    "proceso",
    "producto",
    "proeza",
    "profesor",
    "programa",
    "prole",
    "promesa",
    "pronto",
    "propio",
    "proximo",
    "prueba",
    "publico",
    "puchero",
    "pudor",
    "pueblo",
    "puerta",
    "puesto",
    "pulga",
    "pulir",
    "pulmon",
    "pulpo",
    "pulso",
    "puma",
    "punto",
    "punal",
    "puno",
    "pupa",
    "pupila",
    "pure",
    "quedar",
    "queja",
    "quemar",
    "querer",
    "queso",
    "quieto",
    "quimica",
    "quince",
    "quitar",
    "rabano",
    "rabia",
    "rabo",
    "racion",
    "radical",
    "raiz",
    "rama",
    "rampa",
    "rancho",
    "rango",
    "rapaz",
    "rapido",
    "rapto",
    "rasgo",
    "raspa",
    "rato",
    "rayo",
    "raza",
    "razon",
    "reaccion",
    "realidad",
    "rebano",
    "rebote",
    "recaer",
    "receta",
    "rechazo",
    "recoger",
    "recreo",
    "recto",
    "recurso",
    "red",
    "redondo",
    "reducir",
    "reflejo",
    "reforma",
    "refran",
    "refugio",
    "regalo",
    "regir",
    "regla",
    "regreso",
    "rehen",
    "reino",
    "reir",
    "reja",
    "relato",
    "relevo",
    "relieve",
    "relleno",
    "reloj",
    "remar",
    "remedio",
    "remo",
    "rencor",
    "rendir",
    "renta",
    "reparto",
    "repetir",
    "reposo",
    "reptil",
    "res",
    "rescate",
    "resina",
    "respeto",
    "resto",
    "resumen",
    "retiro",
    "retorno",
    "retrato",
    "reunir",
    "reves",
    "revista",
    "rey",
    "rezar",
    "rico",
    "riego",
    "rienda",
    "riesgo",
    "rifa",
    "rigido",
    "rigor",
    "rincon",
    "rinon",
    "rio",
    "riqueza",
    "risa",
    "ritmo",
    "rito",
    "rizo",
    "roble",
    "roce",
    "rociar",
    "rodar",
    "rodeo",
    "rodilla",
    "roer",
    "rojizo",
    "rojo",
    "romero",
    "romper",
    "ron",
    "ronco",
    "ronda",
    "ropa",
    "ropero",
    "rosa",
    "rosca",
    "rostro",
    "rotar",
    "rubi",
    "rubor",
    "rudo",
    "rueda",
    "rugir",
    "ruido",
    "ruina",
    "ruleta",
    "rulo",
    "rumbo",
    "rumor",
    "ruptura",
    "ruta",
    "rutina",
    "sabado",
    "saber",
    "sabio",
    "sable",
    "sacar",
    "sagaz",
    "sagrado",
    "sala",
    "saldo",
    "salero",
    "salir",
    "salmon",
    "salon",
    "salsa",
    "salto",
    "salud",
    "salvar",
    "samba",
    "sancion",
    "sandia",
    "sanear",
    "sangre",
    "sanidad",
    "sano",
    "santo",
    "sapo",
    "saque",
    "sardina",
    "sarten",
    "sastre",
    "satan",
    "sauna",
    "saxofon",
    "seccion",
    "seco",
    "secreto",
    "secta",
    "sed",
    "seguir",
    "seis",
    "sello",
    "selva",
    "semana",
    "semilla",
    "senda",
    "sensor",
    "senal",
    "senor",
    "separar",
    "sepia",
    "sequia",
    "ser",
    "serie",
    "sermon",
    "servir",
    "sesenta",
    "sesion",
    "seta",
    "setenta",
    "severo",
    "sexo",
    "sexto",
    "sidra",
    "siesta",
    "siete",
    "siglo",
    "signo",
    "silaba",
    "silbar",
    "silencio",
    "silla",
    "simbolo",
    "simio",
    "sirena",
    "sistema",
    "sitio",
    "situar",
    "sobre",
    "socio",
    "sodio",
    "sol",
    "solapa",
    "soldado",
    "soledad",
    "solido",
    "soltar",
    "solucion",
    "sombra",
    "sondeo",
    "sonido",
    "sonoro",
    "sonrisa",
    "sopa",
    "soplar",
    "soporte",
    "sordo",
    "sorpresa",
    "sorteo",
    "sosten",
    "sotano",
    "suave",
    "subir",
    "suceso",
    "sudor",
    "suegra",
    "suelo",
    "sueno",
    "suerte",
    "sufrir",
    "sujeto",
    "sultan",
    "sumar",
    "superar",
    "suplir",
    "suponer",
    "supremo",
    "sur",
    "surco",
    "sureno",
    "surgir",
    "susto",
    "sutil",
    "tabaco",
    "tabique",
    "tabla",
    "tabu",
    "taco",
    "tacto",
    "tajo",
    "talar",
    "talco",
    "talento",
    "talla",
    "talon",
    "tamano",
    "tambor",
    "tango",
    "tanque",
    "tapa",
    "tapete",
    "tapia",
    "tapon",
    "taquilla",
    "tarde",
    "tarea",
    "tarifa",
    "tarjeta",
    "tarot",
    "tarro",
    "tarta",
    "tatuaje",
    "tauro",
    "taza",
    "tazon",
    "teatro",
    "techo",
    "tecla",
    "tecnica",
    "tejado",
    "tejer",
    "tejido",
    "tela",
    "telefono",
    "tema",
    "temor",
    "templo",
    "tenaz",
    "tender",
    "tener",
    "tenis",
    "tenso",
    "teoria",
    "terapia",
    "terco",
    "termino",
    "ternura",
    "terror",
    "tesis",
    "tesoro",
    "testigo",
    "tetera",
    "texto",
    "tez",
    "tibio",
    "tiburon",
    "tiempo",
    "tienda",
    "tierra",
    "tieso",
    "tigre",
    "tijera",
    "tilde",
    "timbre",
    "timido",
    "timo",
    "tinta",
    "tio",
    "tipico",
    "tipo",
    "tira",
    "tiron",
    "titan",
    "titere",
    "titulo",
    "tiza",
    "toalla",
    "tobillo",
    "tocar",
    "tocino",
    "todo",
    "toga",
    "toldo",
    "tomar",
    "tono",
    "tonto",
    "topar",
    "tope",
    "toque",
    "torax",
    "torero",
    "tormenta",
    "torneo",
    "toro",
    "torpedo",
    "torre",
    "torso",
    "tortuga",
    "tos",
    "tosco",
    "toser",
    "toxico",
    "trabajo",
    "tractor",
    "traer",
    "trafico",
    "trago",
    "traje",
    "tramo",
    "trance",
    "trato",
    "trauma",
    "trazar",
    "trebol",
    "tregua",
    "treinta",
    "tren",
    "trepar",
    "tres",
    "tribu",
    "trigo",
    "tripa",
    "triste",
    "triunfo",
    "trofeo",
    "trompa",
    "tronco",
    "tropa",
    "trote",
    "trozo",
    "truco",
    "trueno",
    "trufa",
    "tuberia",
    "tubo",
    "tuerto",
    "tumba",
    "tumor",
    "tunel",
    "tunica",
    "turbina",
    "turismo",
    "turno",
    "tutor",
    "ubicar",
    "ulcera",
    "umbral",
    "unidad",
    "unir",
    "universo",
    "uno",
    "untar",
    "una",
    "urbano",
    "urbe",
    "urgente",
    "urna",
    "usar",
    "usuario",
    "util",
    "utopia",
    "uva",
    "vaca",
    "vacio",
    "vacuna",
    "vagar",
    "vago",
    "vaina",
    "vajilla",
    "vale",
    "valido",
    "valle",
    "valor",
    "valvula",
    "vampiro",
    "vara",
    "variar",
    "varon",
    "vaso",
    "vecino",
    "vector",
    "vehiculo",
    "veinte",
    "vejez",
    "vela",
    "velero",
    "veloz",
    "vena",
    "vencer",
    "venda",
    "veneno",
    "vengar",
    "venir",
    "venta",
    "venus",
    "ver",
    "verano",
    "verbo",
    "verde",
    "vereda",
    "verja",
    "verso",
    "verter",
    "via",
    "viaje",
    "vibrar",
    "vicio",
    "victima",
    "vida",
    "video",
    "vidrio",
    "viejo",
    "viernes",
    "vigor",
    "vil",
    "villa",
    "vinagre",
    "vino",
    "vinedo",
    "violin",
    "viral",
    "virgo",
    "virtud",
    "visor",
    "vispera",
    "vista",
    "vitamina",
    "viudo",
    "vivaz",
    "vivero",
    "vivir",
    "vivo",
    "volcan",
    "volumen",
    "volver",
    "voraz",
    "votar",
    "voto",
    "voz",
    "vuelo",
    "vulgar",
    "yacer",
    "yate",
    "yegua",
    "yema",
    "yerno",
    "yeso",
    "yodo",
    "yoga",
    "yogur",
    "zafiro",
    "zanja",
    "zapato",
    "zarza",
    "zona",
    "zorro",
    "zumo",
    "zurdo"
]

},{}],65:[function(require,module,exports){
arguments[4][18][0].apply(exports,arguments)
},{"buffer":"buffer","dup":18}],66:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ValiError = exports.UUID_REGEX = exports.ULID_REGEX = exports.OCTAL_REGEX = exports.MAC_REGEX = exports.MAC64_REGEX = exports.MAC48_REGEX = exports.ISO_WEEK_REGEX = exports.ISO_TIME_SECOND_REGEX = exports.ISO_TIME_REGEX = exports.ISO_TIMESTAMP_REGEX = exports.ISO_DATE_TIME_REGEX = exports.ISO_DATE_REGEX = exports.IP_REGEX = exports.IPV6_REGEX = exports.IPV4_REGEX = exports.IMEI_REGEX = exports.HEX_COLOR_REGEX = exports.HEXADECIMAL_REGEX = exports.EMOJI_REGEX = exports.EMAIL_REGEX = exports.DECIMAL_REGEX = exports.CUID2_REGEX = exports.BIC_REGEX = exports.BASE64_REGEX = void 0;
exports._addIssue = _addIssue;
exports._isLuhnAlgo = _isLuhnAlgo;
exports._isValidObjectKey = _isValidObjectKey;
exports._joinExpects = _joinExpects;
exports._stringify = _stringify;
exports.any = any;
exports.array = array;
exports.arrayAsync = arrayAsync;
exports.awaitAsync = awaitAsync;
exports.base64 = base64;
exports.bic = bic;
exports.bigint = bigint;
exports.blob = blob;
exports["boolean"] = _boolean;
exports.brand = brand;
exports.bytes = bytes;
exports.check = check;
exports.checkAsync = checkAsync;
exports.checkItems = checkItems;
exports.config = config;
exports.creditCard = creditCard;
exports.cuid2 = cuid2;
exports.custom = custom;
exports.customAsync = customAsync;
exports.date = date;
exports.decimal = decimal;
exports.deleteGlobalConfig = deleteGlobalConfig;
exports.deleteGlobalMessage = deleteGlobalMessage;
exports.deleteSchemaMessage = deleteSchemaMessage;
exports.deleteSpecificMessage = deleteSpecificMessage;
exports.description = description;
exports.email = email;
exports.emoji = emoji;
exports.empty = empty;
exports.endsWith = endsWith;
exports.entriesFromList = entriesFromList;
exports.enum_ = exports["enum"] = enum_;
exports.everyItem = everyItem;
exports.excludes = excludes;
exports.fallback = fallback;
exports.fallbackAsync = fallbackAsync;
exports.file = file;
exports.filterItems = filterItems;
exports.findItem = findItem;
exports.finite = finite;
exports.flatten = flatten;
exports.forward = forward;
exports.forwardAsync = forwardAsync;
exports.function_ = exports["function"] = function_;
exports.getDefault = getDefault;
exports.getDefaults = getDefaults;
exports.getDefaultsAsync = getDefaultsAsync;
exports.getDotPath = getDotPath;
exports.getFallback = getFallback;
exports.getFallbacks = getFallbacks;
exports.getFallbacksAsync = getFallbacksAsync;
exports.getGlobalConfig = getGlobalConfig;
exports.getGlobalMessage = getGlobalMessage;
exports.getSchemaMessage = getSchemaMessage;
exports.getSpecificMessage = getSpecificMessage;
exports.hash = hash;
exports.hexColor = hexColor;
exports.hexadecimal = hexadecimal;
exports.imei = imei;
exports.includes = includes;
exports.instance = instance;
exports.integer = integer;
exports.intersect = intersect;
exports.intersectAsync = intersectAsync;
exports.ip = ip;
exports.ipv4 = ipv4;
exports.ipv6 = ipv6;
exports.is = is;
exports.isOfKind = isOfKind;
exports.isOfType = isOfType;
exports.isValiError = isValiError;
exports.isoDate = isoDate;
exports.isoDateTime = isoDateTime;
exports.isoTime = isoTime;
exports.isoTimeSecond = isoTimeSecond;
exports.isoTimestamp = isoTimestamp;
exports.isoWeek = isoWeek;
exports.keyof = keyof;
exports.lazy = lazy;
exports.lazyAsync = lazyAsync;
exports.length = length;
exports.literal = literal;
exports.looseObject = looseObject;
exports.looseObjectAsync = looseObjectAsync;
exports.looseTuple = looseTuple;
exports.looseTupleAsync = looseTupleAsync;
exports.mac = mac;
exports.mac48 = mac48;
exports.mac64 = mac64;
exports.map = map;
exports.mapAsync = mapAsync;
exports.mapItems = mapItems;
exports.maxBytes = maxBytes;
exports.maxLength = maxLength;
exports.maxSize = maxSize;
exports.maxValue = maxValue;
exports.mimeType = mimeType;
exports.minBytes = minBytes;
exports.minLength = minLength;
exports.minSize = minSize;
exports.minValue = minValue;
exports.multipleOf = multipleOf;
exports.nan = nan;
exports.never = never;
exports.nonEmpty = nonEmpty;
exports.nonNullable = nonNullable;
exports.nonNullableAsync = nonNullableAsync;
exports.nonNullish = nonNullish;
exports.nonNullishAsync = nonNullishAsync;
exports.nonOptional = nonOptional;
exports.nonOptionalAsync = nonOptionalAsync;
exports.normalize = normalize;
exports.notBytes = notBytes;
exports.notLength = notLength;
exports.notSize = notSize;
exports.notValue = notValue;
exports.null_ = exports["null"] = null_;
exports.nullable = nullable;
exports.nullableAsync = nullableAsync;
exports.nullish = nullish;
exports.nullishAsync = nullishAsync;
exports.number = number;
exports.object = object;
exports.objectAsync = objectAsync;
exports.objectWithRest = objectWithRest;
exports.objectWithRestAsync = objectWithRestAsync;
exports.octal = octal;
exports.omit = omit;
exports.optional = optional;
exports.optionalAsync = optionalAsync;
exports.parse = parse;
exports.parseAsync = parseAsync;
exports.parser = parser;
exports.parserAsync = parserAsync;
exports.partial = partial;
exports.partialAsync = partialAsync;
exports.partialCheck = partialCheck;
exports.partialCheckAsync = partialCheckAsync;
exports.pick = pick;
exports.picklist = picklist;
exports.pipe = pipe;
exports.pipeAsync = pipeAsync;
exports.promise = promise;
exports.rawCheck = rawCheck;
exports.rawCheckAsync = rawCheckAsync;
exports.rawTransform = rawTransform;
exports.rawTransformAsync = rawTransformAsync;
exports.readonly = readonly;
exports.record = record;
exports.recordAsync = recordAsync;
exports.reduceItems = reduceItems;
exports.regex = regex;
exports.required = required;
exports.requiredAsync = requiredAsync;
exports.safeInteger = safeInteger;
exports.safeParse = safeParse;
exports.safeParseAsync = safeParseAsync;
exports.safeParser = safeParser;
exports.safeParserAsync = safeParserAsync;
exports.set = set;
exports.setAsync = setAsync;
exports.setGlobalConfig = setGlobalConfig;
exports.setGlobalMessage = setGlobalMessage;
exports.setSchemaMessage = setSchemaMessage;
exports.setSpecificMessage = setSpecificMessage;
exports.size = size;
exports.someItem = someItem;
exports.sortItems = sortItems;
exports.startsWith = startsWith;
exports.strictObject = strictObject;
exports.strictObjectAsync = strictObjectAsync;
exports.strictTuple = strictTuple;
exports.strictTupleAsync = strictTupleAsync;
exports.string = string;
exports.symbol = symbol;
exports.toLowerCase = toLowerCase;
exports.toMaxValue = toMaxValue;
exports.toMinValue = toMinValue;
exports.toUpperCase = toUpperCase;
exports.transform = transform;
exports.transformAsync = transformAsync;
exports.trim = trim;
exports.trimEnd = trimEnd;
exports.trimStart = trimStart;
exports.tuple = tuple;
exports.tupleAsync = tupleAsync;
exports.tupleWithRest = tupleWithRest;
exports.tupleWithRestAsync = tupleWithRestAsync;
exports.ulid = ulid;
exports.undefined_ = exports.undefined = undefined_;
exports.union = union;
exports.unionAsync = unionAsync;
exports.unknown = unknown;
exports.unwrap = unwrap;
exports.url = url;
exports.uuid = uuid;
exports.value = value;
exports.variant = variant;
exports.variantAsync = variantAsync;
exports.void_ = exports["void"] = void_;
function _slicedToArray(r, e) { return _arrayWithHoles(r) || _iterableToArrayLimit(r, e) || _unsupportedIterableToArray(r, e) || _nonIterableRest(); }
function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _iterableToArrayLimit(r, l) { var t = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (null != t) { var e, n, i, u, a = [], f = !0, o = !1; try { if (i = (t = t.call(r)).next, 0 === l) { if (Object(t) !== t) return; f = !1; } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0); } catch (r) { o = !0, n = r; } finally { try { if (!f && null != t["return"] && (u = t["return"](), Object(u) !== u)) return; } finally { if (o) throw n; } } return a; } }
function _arrayWithHoles(r) { if (Array.isArray(r)) return r; }
function _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }
function _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: !1 }), e; }
function _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function"); }
function _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }
function _possibleConstructorReturn(t, e) { if (e && ("object" == _typeof(e) || "function" == typeof e)) return e; if (void 0 !== e) throw new TypeError("Derived constructors may only return object or undefined"); return _assertThisInitialized(t); }
function _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); return e; }
function _inherits(t, e) { if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, "prototype", { writable: !1 }), e && _setPrototypeOf(t, e); }
function _wrapNativeSuper(t) { var r = "function" == typeof Map ? new Map() : void 0; return _wrapNativeSuper = function _wrapNativeSuper(t) { if (null === t || !_isNativeFunction(t)) return t; if ("function" != typeof t) throw new TypeError("Super expression must either be null or a function"); if (void 0 !== r) { if (r.has(t)) return r.get(t); r.set(t, Wrapper); } function Wrapper() { return _construct(t, arguments, _getPrototypeOf(this).constructor); } return Wrapper.prototype = Object.create(t.prototype, { constructor: { value: Wrapper, enumerable: !1, writable: !0, configurable: !0 } }), _setPrototypeOf(Wrapper, t); }, _wrapNativeSuper(t); }
function _construct(t, e, r) { if (_isNativeReflectConstruct()) return Reflect.construct.apply(null, arguments); var o = [null]; o.push.apply(o, e); var p = new (t.bind.apply(t, o))(); return r && _setPrototypeOf(p, r.prototype), p; }
function _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }
function _isNativeFunction(t) { try { return -1 !== Function.toString.call(t).indexOf("[native code]"); } catch (n) { return "function" == typeof t; } }
function _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }
function _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }
function _createForOfIteratorHelper(r, e) { var t = "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (!t) { if (Array.isArray(r) || (t = _unsupportedIterableToArray(r)) || e && r && "number" == typeof r.length) { t && (r = t); var _n = 0, F = function F() {}; return { s: F, n: function n() { return _n >= r.length ? { done: !0 } : { done: !1, value: r[_n++] }; }, e: function e(r) { throw r; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var o, a = !0, u = !1; return { s: function s() { t = t.call(r); }, n: function n() { var r = t.next(); return a = r.done, r; }, e: function e(r) { u = !0, o = r; }, f: function f() { try { a || null == t["return"] || t["return"](); } finally { if (u) throw o; } } }; }
function _toConsumableArray(r) { return _arrayWithoutHoles(r) || _iterableToArray(r) || _unsupportedIterableToArray(r) || _nonIterableSpread(); }
function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _unsupportedIterableToArray(r, a) { if (r) { if ("string" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }
function _iterableToArray(r) { if ("undefined" != typeof Symbol && null != r[Symbol.iterator] || null != r["@@iterator"]) return Array.from(r); }
function _arrayWithoutHoles(r) { if (Array.isArray(r)) return _arrayLikeToArray(r); }
function _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
function _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
function _regeneratorRuntime() { "use strict"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return e; }; var t, e = {}, r = Object.prototype, n = r.hasOwnProperty, o = Object.defineProperty || function (t, e, r) { t[e] = r.value; }, i = "function" == typeof Symbol ? Symbol : {}, a = i.iterator || "@@iterator", c = i.asyncIterator || "@@asyncIterator", u = i.toStringTag || "@@toStringTag"; function define(t, e, r) { return Object.defineProperty(t, e, { value: r, enumerable: !0, configurable: !0, writable: !0 }), t[e]; } try { define({}, ""); } catch (t) { define = function define(t, e, r) { return t[e] = r; }; } function wrap(t, e, r, n) { var i = e && e.prototype instanceof Generator ? e : Generator, a = Object.create(i.prototype), c = new Context(n || []); return o(a, "_invoke", { value: makeInvokeMethod(t, r, c) }), a; } function tryCatch(t, e, r) { try { return { type: "normal", arg: t.call(e, r) }; } catch (t) { return { type: "throw", arg: t }; } } e.wrap = wrap; var h = "suspendedStart", l = "suspendedYield", f = "executing", s = "completed", y = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var p = {}; define(p, a, function () { return this; }); var d = Object.getPrototypeOf, v = d && d(d(values([]))); v && v !== r && n.call(v, a) && (p = v); var g = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(p); function defineIteratorMethods(t) { ["next", "throw", "return"].forEach(function (e) { define(t, e, function (t) { return this._invoke(e, t); }); }); } function AsyncIterator(t, e) { function invoke(r, o, i, a) { var c = tryCatch(t[r], t, o); if ("throw" !== c.type) { var u = c.arg, h = u.value; return h && "object" == _typeof(h) && n.call(h, "__await") ? e.resolve(h.__await).then(function (t) { invoke("next", t, i, a); }, function (t) { invoke("throw", t, i, a); }) : e.resolve(h).then(function (t) { u.value = t, i(u); }, function (t) { return invoke("throw", t, i, a); }); } a(c.arg); } var r; o(this, "_invoke", { value: function value(t, n) { function callInvokeWithMethodAndArg() { return new e(function (e, r) { invoke(t, n, e, r); }); } return r = r ? r.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); } }); } function makeInvokeMethod(e, r, n) { var o = h; return function (i, a) { if (o === f) throw Error("Generator is already running"); if (o === s) { if ("throw" === i) throw a; return { value: t, done: !0 }; } for (n.method = i, n.arg = a;;) { var c = n.delegate; if (c) { var u = maybeInvokeDelegate(c, n); if (u) { if (u === y) continue; return u; } } if ("next" === n.method) n.sent = n._sent = n.arg;else if ("throw" === n.method) { if (o === h) throw o = s, n.arg; n.dispatchException(n.arg); } else "return" === n.method && n.abrupt("return", n.arg); o = f; var p = tryCatch(e, r, n); if ("normal" === p.type) { if (o = n.done ? s : l, p.arg === y) continue; return { value: p.arg, done: n.done }; } "throw" === p.type && (o = s, n.method = "throw", n.arg = p.arg); } }; } function maybeInvokeDelegate(e, r) { var n = r.method, o = e.iterator[n]; if (o === t) return r.delegate = null, "throw" === n && e.iterator["return"] && (r.method = "return", r.arg = t, maybeInvokeDelegate(e, r), "throw" === r.method) || "return" !== n && (r.method = "throw", r.arg = new TypeError("The iterator does not provide a '" + n + "' method")), y; var i = tryCatch(o, e.iterator, r.arg); if ("throw" === i.type) return r.method = "throw", r.arg = i.arg, r.delegate = null, y; var a = i.arg; return a ? a.done ? (r[e.resultName] = a.value, r.next = e.nextLoc, "return" !== r.method && (r.method = "next", r.arg = t), r.delegate = null, y) : a : (r.method = "throw", r.arg = new TypeError("iterator result is not an object"), r.delegate = null, y); } function pushTryEntry(t) { var e = { tryLoc: t[0] }; 1 in t && (e.catchLoc = t[1]), 2 in t && (e.finallyLoc = t[2], e.afterLoc = t[3]), this.tryEntries.push(e); } function resetTryEntry(t) { var e = t.completion || {}; e.type = "normal", delete e.arg, t.completion = e; } function Context(t) { this.tryEntries = [{ tryLoc: "root" }], t.forEach(pushTryEntry, this), this.reset(!0); } function values(e) { if (e || "" === e) { var r = e[a]; if (r) return r.call(e); if ("function" == typeof e.next) return e; if (!isNaN(e.length)) { var o = -1, i = function next() { for (; ++o < e.length;) if (n.call(e, o)) return next.value = e[o], next.done = !1, next; return next.value = t, next.done = !0, next; }; return i.next = i; } } throw new TypeError(_typeof(e) + " is not iterable"); } return GeneratorFunction.prototype = GeneratorFunctionPrototype, o(g, "constructor", { value: GeneratorFunctionPrototype, configurable: !0 }), o(GeneratorFunctionPrototype, "constructor", { value: GeneratorFunction, configurable: !0 }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, u, "GeneratorFunction"), e.isGeneratorFunction = function (t) { var e = "function" == typeof t && t.constructor; return !!e && (e === GeneratorFunction || "GeneratorFunction" === (e.displayName || e.name)); }, e.mark = function (t) { return Object.setPrototypeOf ? Object.setPrototypeOf(t, GeneratorFunctionPrototype) : (t.__proto__ = GeneratorFunctionPrototype, define(t, u, "GeneratorFunction")), t.prototype = Object.create(g), t; }, e.awrap = function (t) { return { __await: t }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, c, function () { return this; }), e.AsyncIterator = AsyncIterator, e.async = function (t, r, n, o, i) { void 0 === i && (i = Promise); var a = new AsyncIterator(wrap(t, r, n, o), i); return e.isGeneratorFunction(r) ? a : a.next().then(function (t) { return t.done ? t.value : a.next(); }); }, defineIteratorMethods(g), define(g, u, "Generator"), define(g, a, function () { return this; }), define(g, "toString", function () { return "[object Generator]"; }), e.keys = function (t) { var e = Object(t), r = []; for (var n in e) r.push(n); return r.reverse(), function next() { for (; r.length;) { var t = r.pop(); if (t in e) return next.value = t, next.done = !1, next; } return next.done = !0, next; }; }, e.values = values, Context.prototype = { constructor: Context, reset: function reset(e) { if (this.prev = 0, this.next = 0, this.sent = this._sent = t, this.done = !1, this.delegate = null, this.method = "next", this.arg = t, this.tryEntries.forEach(resetTryEntry), !e) for (var r in this) "t" === r.charAt(0) && n.call(this, r) && !isNaN(+r.slice(1)) && (this[r] = t); }, stop: function stop() { this.done = !0; var t = this.tryEntries[0].completion; if ("throw" === t.type) throw t.arg; return this.rval; }, dispatchException: function dispatchException(e) { if (this.done) throw e; var r = this; function handle(n, o) { return a.type = "throw", a.arg = e, r.next = n, o && (r.method = "next", r.arg = t), !!o; } for (var o = this.tryEntries.length - 1; o >= 0; --o) { var i = this.tryEntries[o], a = i.completion; if ("root" === i.tryLoc) return handle("end"); if (i.tryLoc <= this.prev) { var c = n.call(i, "catchLoc"), u = n.call(i, "finallyLoc"); if (c && u) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } else if (c) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); } else { if (!u) throw Error("try statement without catch or finally"); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } } } }, abrupt: function abrupt(t, e) { for (var r = this.tryEntries.length - 1; r >= 0; --r) { var o = this.tryEntries[r]; if (o.tryLoc <= this.prev && n.call(o, "finallyLoc") && this.prev < o.finallyLoc) { var i = o; break; } } i && ("break" === t || "continue" === t) && i.tryLoc <= e && e <= i.finallyLoc && (i = null); var a = i ? i.completion : {}; return a.type = t, a.arg = e, i ? (this.method = "next", this.next = i.finallyLoc, y) : this.complete(a); }, complete: function complete(t, e) { if ("throw" === t.type) throw t.arg; return "break" === t.type || "continue" === t.type ? this.next = t.arg : "return" === t.type ? (this.rval = this.arg = t.arg, this.method = "return", this.next = "end") : "normal" === t.type && e && (this.next = e), y; }, finish: function finish(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.finallyLoc === t) return this.complete(r.completion, r.afterLoc), resetTryEntry(r), y; } }, "catch": function _catch(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.tryLoc === t) { var n = r.completion; if ("throw" === n.type) { var o = n.arg; resetTryEntry(r); } return o; } } throw Error("illegal catch attempt"); }, delegateYield: function delegateYield(e, r, n) { return this.delegate = { iterator: values(e), resultName: r, nextLoc: n }, "next" === this.method && (this.arg = t), y; } }, e; }
function asyncGeneratorStep(n, t, e, r, o, a, c) { try { var i = n[a](c), u = i.value; } catch (n) { return void e(n); } i.done ? t(u) : Promise.resolve(u).then(r, o); }
function _asyncToGenerator(n) { return function () { var t = this, e = arguments; return new Promise(function (r, o) { var a = n.apply(t, e); function _next(n) { asyncGeneratorStep(a, r, o, _next, _throw, "next", n); } function _throw(n) { asyncGeneratorStep(a, r, o, _next, _throw, "throw", n); } _next(void 0); }); }; }
// src/actions/await/awaitAsync.ts
function awaitAsync() {
  return {
    kind: "transformation",
    type: "await",
    reference: awaitAsync,
    async: true,
    _run: function _run(dataset) {
      return _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee() {
        return _regeneratorRuntime().wrap(function _callee$(_context) {
          while (1) switch (_context.prev = _context.next) {
            case 0:
              _context.next = 2;
              return dataset.value;
            case 2:
              dataset.value = _context.sent;
              return _context.abrupt("return", dataset);
            case 4:
            case "end":
              return _context.stop();
          }
        }, _callee);
      }))();
    }
  };
}

// src/regex.ts
var BASE64_REGEX = exports.BASE64_REGEX = /^(?:[\+\/-9a-z\u017F\u212A]{4})*(?:[\+\/-9a-z\u017F\u212A]{2}==|[\+\/-9a-z\u017F\u212A]{3}=)?$/i;
var BIC_REGEX = exports.BIC_REGEX = /^[A-Z]{6}(?!00)[0-9A-Z]{2}(?:[0-9A-Z]{3})?$/;
var CUID2_REGEX = exports.CUID2_REGEX = /^[a-z][0-9a-z]*$/;
var DECIMAL_REGEX = exports.DECIMAL_REGEX = /^[0-9]+$/;
var EMAIL_REGEX = exports.EMAIL_REGEX = /^[\+\x2D0-9A-Z_a-z\u017F\u212A]+(?:\.[\+\x2D0-9A-Z_a-z\u017F\u212A]+)*@[0-9a-z\u017F\u212A]+(?:[\x2D\.][0-9a-z\u017F\u212A]+)*\.[a-z\u017F\u212A]{2,}$/i;
var EMOJI_REGEX = exports.EMOJI_REGEX =
// eslint-disable-next-line redos-detector/no-unsafe-regex, regexp/no-dupe-disjunctions -- false positives
/^(?:(?:\uD83C[\uDDE6-\uDDFF]){2}|(?:\uD83C\uDFF4)(?:\uDB40[\uDC61-\uDC7A]){2}(?:\uDB40[\uDC30-\uDC39\uDC61-\uDC7A]){1,3}(?:\uDB40\uDC7F)|(?:(?:[#\*0-9\xA9\xAE\u203C\u2049\u2122\u2139\u2194-\u2199\u21A9\u21AA\u231A\u231B\u2328\u23CF\u23E9-\u23F3\u23F8-\u23FA\u24C2\u25AA\u25AB\u25B6\u25C0\u25FB-\u25FE\u2600-\u2604\u260E\u2611\u2614\u2615\u2618\u261D\u2620\u2622\u2623\u2626\u262A\u262E\u262F\u2638-\u263A\u2640\u2642\u2648-\u2653\u265F\u2660\u2663\u2665\u2666\u2668\u267B\u267E\u267F\u2692-\u2697\u2699\u269B\u269C\u26A0\u26A1\u26A7\u26AA\u26AB\u26B0\u26B1\u26BD\u26BE\u26C4\u26C5\u26C8\u26CE\u26CF\u26D1\u26D3\u26D4\u26E9\u26EA\u26F0-\u26F5\u26F7-\u26FA\u26FD\u2702\u2705\u2708-\u270D\u270F\u2712\u2714\u2716\u271D\u2721\u2728\u2733\u2734\u2744\u2747\u274C\u274E\u2753-\u2755\u2757\u2763\u2764\u2795-\u2797\u27A1\u27B0\u27BF\u2934\u2935\u2B05-\u2B07\u2B1B\u2B1C\u2B50\u2B55\u3030\u303D\u3297\u3299]|\uD83C[\uDC04\uDCCF\uDD70\uDD71\uDD7E\uDD7F\uDD8E\uDD91-\uDD9A\uDDE6-\uDDFF\uDE01\uDE02\uDE1A\uDE2F\uDE32-\uDE3A\uDE50\uDE51\uDF00-\uDF21\uDF24-\uDF93\uDF96\uDF97\uDF99-\uDF9B\uDF9E-\uDFF0\uDFF3-\uDFF5\uDFF7-\uDFFF]|\uD83D[\uDC00-\uDCFD\uDCFF-\uDD3D\uDD49-\uDD4E\uDD50-\uDD67\uDD6F\uDD70\uDD73-\uDD7A\uDD87\uDD8A-\uDD8D\uDD90\uDD95\uDD96\uDDA4\uDDA5\uDDA8\uDDB1\uDDB2\uDDBC\uDDC2-\uDDC4\uDDD1-\uDDD3\uDDDC-\uDDDE\uDDE1\uDDE3\uDDE8\uDDEF\uDDF3\uDDFA-\uDE4F\uDE80-\uDEC5\uDECB-\uDED2\uDED5-\uDED7\uDEDC-\uDEE5\uDEE9\uDEEB\uDEEC\uDEF0\uDEF3-\uDEFC\uDFE0-\uDFEB\uDFF0]|\uD83E[\uDD0C-\uDD3A\uDD3C-\uDD45\uDD47-\uDDFF\uDE70-\uDE7C\uDE80-\uDE89\uDE8F-\uDEC6\uDECE-\uDEDC\uDEDF-\uDEE9\uDEF0-\uDEF8])\uFE0F\u20E3?|(?:[\u261D\u26F9\u270A-\u270D]|\uD83C[\uDF85\uDFC2-\uDFC4\uDFC7\uDFCA-\uDFCC]|\uD83D[\uDC42\uDC43\uDC46-\uDC50\uDC66-\uDC78\uDC7C\uDC81-\uDC83\uDC85-\uDC87\uDC8F\uDC91\uDCAA\uDD74\uDD75\uDD7A\uDD90\uDD95\uDD96\uDE45-\uDE47\uDE4B-\uDE4F\uDEA3\uDEB4-\uDEB6\uDEC0\uDECC]|\uD83E[\uDD0C\uDD0F\uDD18-\uDD1F\uDD26\uDD30-\uDD39\uDD3C-\uDD3E\uDD77\uDDB5\uDDB6\uDDB8\uDDB9\uDDBB\uDDCD-\uDDCF\uDDD1-\uDDDD\uDEC3-\uDEC5\uDEF0-\uDEF8])(?:\uD83C[\uDFFB-\uDFFF])?|(?:[\u231A\u231B\u23E9-\u23EC\u23F0\u23F3\u25FD\u25FE\u2614\u2615\u2648-\u2653\u267F\u2693\u26A1\u26AA\u26AB\u26BD\u26BE\u26C4\u26C5\u26CE\u26D4\u26EA\u26F2\u26F3\u26F5\u26FA\u26FD\u2705\u270A\u270B\u2728\u274C\u274E\u2753-\u2755\u2757\u2795-\u2797\u27B0\u27BF\u2B1B\u2B1C\u2B50\u2B55]|\uD83C[\uDC04\uDCCF\uDD8E\uDD91-\uDD9A\uDDE6-\uDDFF\uDE01\uDE1A\uDE2F\uDE32-\uDE36\uDE38-\uDE3A\uDE50\uDE51\uDF00-\uDF20\uDF2D-\uDF35\uDF37-\uDF7C\uDF7E-\uDF93\uDFA0-\uDFCA\uDFCF-\uDFD3\uDFE0-\uDFF0\uDFF4\uDFF8-\uDFFF]|\uD83D[\uDC00-\uDC3E\uDC40\uDC42-\uDCFC\uDCFF-\uDD3D\uDD4B-\uDD4E\uDD50-\uDD67\uDD7A\uDD95\uDD96\uDDA4\uDDFB-\uDE4F\uDE80-\uDEC5\uDECC\uDED0-\uDED2\uDED5-\uDED7\uDEDC-\uDEDF\uDEEB\uDEEC\uDEF4-\uDEFC\uDFE0-\uDFEB\uDFF0]|\uD83E[\uDD0C-\uDD3A\uDD3C-\uDD45\uDD47-\uDDFF\uDE70-\uDE7C\uDE80-\uDE89\uDE8F-\uDEC6\uDECE-\uDEDC\uDEDF-\uDEE9\uDEF0-\uDEF8]))(?:\u200D(?:(?:[#\*0-9\xA9\xAE\u203C\u2049\u2122\u2139\u2194-\u2199\u21A9\u21AA\u231A\u231B\u2328\u23CF\u23E9-\u23F3\u23F8-\u23FA\u24C2\u25AA\u25AB\u25B6\u25C0\u25FB-\u25FE\u2600-\u2604\u260E\u2611\u2614\u2615\u2618\u261D\u2620\u2622\u2623\u2626\u262A\u262E\u262F\u2638-\u263A\u2640\u2642\u2648-\u2653\u265F\u2660\u2663\u2665\u2666\u2668\u267B\u267E\u267F\u2692-\u2697\u2699\u269B\u269C\u26A0\u26A1\u26A7\u26AA\u26AB\u26B0\u26B1\u26BD\u26BE\u26C4\u26C5\u26C8\u26CE\u26CF\u26D1\u26D3\u26D4\u26E9\u26EA\u26F0-\u26F5\u26F7-\u26FA\u26FD\u2702\u2705\u2708-\u270D\u270F\u2712\u2714\u2716\u271D\u2721\u2728\u2733\u2734\u2744\u2747\u274C\u274E\u2753-\u2755\u2757\u2763\u2764\u2795-\u2797\u27A1\u27B0\u27BF\u2934\u2935\u2B05-\u2B07\u2B1B\u2B1C\u2B50\u2B55\u3030\u303D\u3297\u3299]|\uD83C[\uDC04\uDCCF\uDD70\uDD71\uDD7E\uDD7F\uDD8E\uDD91-\uDD9A\uDDE6-\uDDFF\uDE01\uDE02\uDE1A\uDE2F\uDE32-\uDE3A\uDE50\uDE51\uDF00-\uDF21\uDF24-\uDF93\uDF96\uDF97\uDF99-\uDF9B\uDF9E-\uDFF0\uDFF3-\uDFF5\uDFF7-\uDFFF]|\uD83D[\uDC00-\uDCFD\uDCFF-\uDD3D\uDD49-\uDD4E\uDD50-\uDD67\uDD6F\uDD70\uDD73-\uDD7A\uDD87\uDD8A-\uDD8D\uDD90\uDD95\uDD96\uDDA4\uDDA5\uDDA8\uDDB1\uDDB2\uDDBC\uDDC2-\uDDC4\uDDD1-\uDDD3\uDDDC-\uDDDE\uDDE1\uDDE3\uDDE8\uDDEF\uDDF3\uDDFA-\uDE4F\uDE80-\uDEC5\uDECB-\uDED2\uDED5-\uDED7\uDEDC-\uDEE5\uDEE9\uDEEB\uDEEC\uDEF0\uDEF3-\uDEFC\uDFE0-\uDFEB\uDFF0]|\uD83E[\uDD0C-\uDD3A\uDD3C-\uDD45\uDD47-\uDDFF\uDE70-\uDE7C\uDE80-\uDE89\uDE8F-\uDEC6\uDECE-\uDEDC\uDEDF-\uDEE9\uDEF0-\uDEF8])\uFE0F\u20E3?|(?:[\u261D\u26F9\u270A-\u270D]|\uD83C[\uDF85\uDFC2-\uDFC4\uDFC7\uDFCA-\uDFCC]|\uD83D[\uDC42\uDC43\uDC46-\uDC50\uDC66-\uDC78\uDC7C\uDC81-\uDC83\uDC85-\uDC87\uDC8F\uDC91\uDCAA\uDD74\uDD75\uDD7A\uDD90\uDD95\uDD96\uDE45-\uDE47\uDE4B-\uDE4F\uDEA3\uDEB4-\uDEB6\uDEC0\uDECC]|\uD83E[\uDD0C\uDD0F\uDD18-\uDD1F\uDD26\uDD30-\uDD39\uDD3C-\uDD3E\uDD77\uDDB5\uDDB6\uDDB8\uDDB9\uDDBB\uDDCD-\uDDCF\uDDD1-\uDDDD\uDEC3-\uDEC5\uDEF0-\uDEF8])(?:\uD83C[\uDFFB-\uDFFF])?|(?:[\u231A\u231B\u23E9-\u23EC\u23F0\u23F3\u25FD\u25FE\u2614\u2615\u2648-\u2653\u267F\u2693\u26A1\u26AA\u26AB\u26BD\u26BE\u26C4\u26C5\u26CE\u26D4\u26EA\u26F2\u26F3\u26F5\u26FA\u26FD\u2705\u270A\u270B\u2728\u274C\u274E\u2753-\u2755\u2757\u2795-\u2797\u27B0\u27BF\u2B1B\u2B1C\u2B50\u2B55]|\uD83C[\uDC04\uDCCF\uDD8E\uDD91-\uDD9A\uDDE6-\uDDFF\uDE01\uDE1A\uDE2F\uDE32-\uDE36\uDE38-\uDE3A\uDE50\uDE51\uDF00-\uDF20\uDF2D-\uDF35\uDF37-\uDF7C\uDF7E-\uDF93\uDFA0-\uDFCA\uDFCF-\uDFD3\uDFE0-\uDFF0\uDFF4\uDFF8-\uDFFF]|\uD83D[\uDC00-\uDC3E\uDC40\uDC42-\uDCFC\uDCFF-\uDD3D\uDD4B-\uDD4E\uDD50-\uDD67\uDD7A\uDD95\uDD96\uDDA4\uDDFB-\uDE4F\uDE80-\uDEC5\uDECC\uDED0-\uDED2\uDED5-\uDED7\uDEDC-\uDEDF\uDEEB\uDEEC\uDEF4-\uDEFC\uDFE0-\uDFEB\uDFF0]|\uD83E[\uDD0C-\uDD3A\uDD3C-\uDD45\uDD47-\uDDFF\uDE70-\uDE7C\uDE80-\uDE89\uDE8F-\uDEC6\uDECE-\uDEDC\uDEDF-\uDEE9\uDEF0-\uDEF8])))*)+$/;
var HEXADECIMAL_REGEX = exports.HEXADECIMAL_REGEX = /^(?:0[hx])?[0-9a-f]+$/i;
var HEX_COLOR_REGEX = exports.HEX_COLOR_REGEX = /^#(?:[0-9a-f]{3,4}|[0-9a-f]{6}|[0-9a-f]{8})$/i;
var IMEI_REGEX = exports.IMEI_REGEX = /^[0-9]{15}$|^[0-9]{2}-[0-9]{6}-[0-9]{6}-[0-9]$/;
var IPV4_REGEX = exports.IPV4_REGEX =
// eslint-disable-next-line redos-detector/no-unsafe-regex -- false positive
/^(?:(?:[1-9]|1[0-9]|2[0-4])?[0-9]|25[0-5])(?:\.(?:(?:[1-9]|1[0-9]|2[0-4])?[0-9]|25[0-5])){3}$/;
var IPV6_REGEX = exports.IPV6_REGEX = /^(?:(?:[0-9a-f]{1,4}:){7}[0-9a-f]{1,4}|(?:[0-9a-f]{1,4}:){1,7}:|(?:[0-9a-f]{1,4}:){1,6}:[0-9a-f]{1,4}|(?:[0-9a-f]{1,4}:){1,5}(?::[0-9a-f]{1,4}){1,2}|(?:[0-9a-f]{1,4}:){1,4}(?::[0-9a-f]{1,4}){1,3}|(?:[0-9a-f]{1,4}:){1,3}(?::[0-9a-f]{1,4}){1,4}|(?:[0-9a-f]{1,4}:){1,2}(?::[0-9a-f]{1,4}){1,5}|[0-9a-f]{1,4}:(?::[0-9a-f]{1,4}){1,6}|:(?:(?::[0-9a-f]{1,4}){1,7}|:)|fe80:(?::[0-9a-f]{0,4}){0,4}%[0-9a-z\u017F\u212A]+|::(?:f{4}(?::0{1,4})?:)?(?:(?:25[0-5]|(?:2[0-4]|1?[0-9])?[0-9])\.){3}(?:25[0-5]|(?:2[0-4]|1?[0-9])?[0-9])|(?:[0-9a-f]{1,4}:){1,4}:(?:(?:25[0-5]|(?:2[0-4]|1?[0-9])?[0-9])\.){3}(?:25[0-5]|(?:2[0-4]|1?[0-9])?[0-9]))$/i;
var IP_REGEX = exports.IP_REGEX = /^(?:(?:[1-9]|1[0-9]|2[0-4])?[0-9]|25[0-5])(?:\.(?:(?:[1-9]|1[0-9]|2[0-4])?[0-9]|25[0-5])){3}$|^(?:(?:[0-9a-f]{1,4}:){7}[0-9a-f]{1,4}|(?:[0-9a-f]{1,4}:){1,7}:|(?:[0-9a-f]{1,4}:){1,6}:[0-9a-f]{1,4}|(?:[0-9a-f]{1,4}:){1,5}(?::[0-9a-f]{1,4}){1,2}|(?:[0-9a-f]{1,4}:){1,4}(?::[0-9a-f]{1,4}){1,3}|(?:[0-9a-f]{1,4}:){1,3}(?::[0-9a-f]{1,4}){1,4}|(?:[0-9a-f]{1,4}:){1,2}(?::[0-9a-f]{1,4}){1,5}|[0-9a-f]{1,4}:(?::[0-9a-f]{1,4}){1,6}|:(?:(?::[0-9a-f]{1,4}){1,7}|:)|fe80:(?::[0-9a-f]{0,4}){0,4}%[0-9a-z\u017F\u212A]+|::(?:f{4}(?::0{1,4})?:)?(?:(?:25[0-5]|(?:2[0-4]|1?[0-9])?[0-9])\.){3}(?:25[0-5]|(?:2[0-4]|1?[0-9])?[0-9])|(?:[0-9a-f]{1,4}:){1,4}:(?:(?:25[0-5]|(?:2[0-4]|1?[0-9])?[0-9])\.){3}(?:25[0-5]|(?:2[0-4]|1?[0-9])?[0-9]))$/i;
var ISO_DATE_REGEX = exports.ISO_DATE_REGEX = /^[0-9]{4}-(?:0[1-9]|1[0-2])-(?:[12][0-9]|0[1-9]|3[01])$/;
var ISO_DATE_TIME_REGEX = exports.ISO_DATE_TIME_REGEX = /^[0-9]{4}-(?:0[1-9]|1[0-2])-(?:[12][0-9]|0[1-9]|3[01])T(?:0[0-9]|1[0-9]|2[0-3]):[0-5][0-9]$/;
var ISO_TIME_REGEX = exports.ISO_TIME_REGEX = /^(?:0[0-9]|1[0-9]|2[0-3]):[0-5][0-9]$/;
var ISO_TIME_SECOND_REGEX = exports.ISO_TIME_SECOND_REGEX = /^(?:0[0-9]|1[0-9]|2[0-3])(?::[0-5][0-9]){2}$/;
var ISO_TIMESTAMP_REGEX = exports.ISO_TIMESTAMP_REGEX = /^[0-9]{4}-(?:0[1-9]|1[0-2])-(?:[12][0-9]|0[1-9]|3[01])T(?:0[0-9]|1[0-9]|2[0-3])(?::[0-5][0-9]){2}(?:\.[0-9]{1,9})?(?:Z|[\+\x2D](?:0[0-9]|1[0-9]|2[0-3])(?::?[0-5][0-9])?)$/;
var ISO_WEEK_REGEX = exports.ISO_WEEK_REGEX = /^[0-9]{4}-W(?:0[1-9]|[1-4][0-9]|5[0-3])$/;
var MAC48_REGEX = exports.MAC48_REGEX = /^(?:[0-9a-f]{2}:){5}[0-9a-f]{2}$|^(?:[0-9a-f]{2}-){5}[0-9a-f]{2}$|^(?:[0-9a-f]{4}\.){2}[0-9a-f]{4}$/i;
var MAC64_REGEX = exports.MAC64_REGEX = /^(?:[0-9a-f]{2}:){7}[0-9a-f]{2}$|^(?:[0-9a-f]{2}-){7}[0-9a-f]{2}$|^(?:[0-9a-f]{4}\.){3}[0-9a-f]{4}$|^(?:[0-9a-f]{4}:){3}[0-9a-f]{4}$/i;
var MAC_REGEX = exports.MAC_REGEX = /^(?:[0-9a-f]{2}:){5}[0-9a-f]{2}$|^(?:[0-9a-f]{2}-){5}[0-9a-f]{2}$|^(?:[0-9a-f]{4}\.){2}[0-9a-f]{4}$|^(?:[0-9a-f]{2}:){7}[0-9a-f]{2}$|^(?:[0-9a-f]{2}-){7}[0-9a-f]{2}$|^(?:[0-9a-f]{4}\.){3}[0-9a-f]{4}$|^(?:[0-9a-f]{4}:){3}[0-9a-f]{4}$/i;
var OCTAL_REGEX = exports.OCTAL_REGEX = /^(?:0o)?[0-7]+$/i;
var ULID_REGEX = exports.ULID_REGEX = /^[0-9a-hjkmnp-tv-z\u017F\u212A]{26}$/i;
var UUID_REGEX = exports.UUID_REGEX = /^[0-9a-f]{8}(?:-[0-9a-f]{4}){3}-[0-9a-f]{12}$/i;

// src/storages/globalConfig/globalConfig.ts
var store;
function setGlobalConfig(config2) {
  store = _objectSpread(_objectSpread({}, store), config2);
}
function getGlobalConfig(config2) {
  var _config2$lang, _store, _config2$abortEarly, _store2, _config2$abortPipeEar, _store3;
  return {
    lang: (_config2$lang = config2 === null || config2 === void 0 ? void 0 : config2.lang) !== null && _config2$lang !== void 0 ? _config2$lang : (_store = store) === null || _store === void 0 ? void 0 : _store.lang,
    message: config2 === null || config2 === void 0 ? void 0 : config2.message,
    abortEarly: (_config2$abortEarly = config2 === null || config2 === void 0 ? void 0 : config2.abortEarly) !== null && _config2$abortEarly !== void 0 ? _config2$abortEarly : (_store2 = store) === null || _store2 === void 0 ? void 0 : _store2.abortEarly,
    abortPipeEarly: (_config2$abortPipeEar = config2 === null || config2 === void 0 ? void 0 : config2.abortPipeEarly) !== null && _config2$abortPipeEar !== void 0 ? _config2$abortPipeEar : (_store3 = store) === null || _store3 === void 0 ? void 0 : _store3.abortPipeEarly
  };
}
function deleteGlobalConfig() {
  store = void 0;
}

// src/storages/globalMessage/globalMessage.ts
var store2;
function setGlobalMessage(message, lang) {
  if (!store2) store2 = /* @__PURE__ */new Map();
  store2.set(lang, message);
}
function getGlobalMessage(lang) {
  var _store4;
  return (_store4 = store2) === null || _store4 === void 0 ? void 0 : _store4.get(lang);
}
function deleteGlobalMessage(lang) {
  var _store5;
  (_store5 = store2) === null || _store5 === void 0 || _store5["delete"](lang);
}

// src/storages/schemaMessage/schemaMessage.ts
var store3;
function setSchemaMessage(message, lang) {
  if (!store3) store3 = /* @__PURE__ */new Map();
  store3.set(lang, message);
}
function getSchemaMessage(lang) {
  var _store6;
  return (_store6 = store3) === null || _store6 === void 0 ? void 0 : _store6.get(lang);
}
function deleteSchemaMessage(lang) {
  var _store7;
  (_store7 = store3) === null || _store7 === void 0 || _store7["delete"](lang);
}

// src/storages/specificMessage/specificMessage.ts
var store4;
function setSpecificMessage(reference, message, lang) {
  if (!store4) store4 = /* @__PURE__ */new Map();
  if (!store4.get(reference)) store4.set(reference, /* @__PURE__ */new Map());
  store4.get(reference).set(lang, message);
}
function getSpecificMessage(reference, lang) {
  var _store8;
  return (_store8 = store4) === null || _store8 === void 0 || (_store8 = _store8.get(reference)) === null || _store8 === void 0 ? void 0 : _store8.get(lang);
}
function deleteSpecificMessage(reference, lang) {
  var _store9;
  (_store9 = store4) === null || _store9 === void 0 || (_store9 = _store9.get(reference)) === null || _store9 === void 0 || _store9["delete"](lang);
}

// src/utils/_stringify/_stringify.ts
function _stringify(input) {
  var type = _typeof(input);
  if (type === "string") {
    return "\"".concat(input, "\"");
  }
  if (type === "number" || type === "bigint" || type === "boolean") {
    return "".concat(input);
  }
  if (type === "object" || type === "function") {
    var _ref, _Object$getPrototypeO;
    return (_ref = input && ((_Object$getPrototypeO = Object.getPrototypeOf(input)) === null || _Object$getPrototypeO === void 0 || (_Object$getPrototypeO = _Object$getPrototypeO.constructor) === null || _Object$getPrototypeO === void 0 ? void 0 : _Object$getPrototypeO.name)) !== null && _ref !== void 0 ? _ref : "null";
  }
  return type;
}

// src/utils/_addIssue/_addIssue.ts
function _addIssue(context, label, dataset, config2, other) {
  var _ref2, _other$expected, _other$received, _ref3, _ref4, _ref5, _ref6, _other$message;
  var input = other && "input" in other ? other.input : dataset.value;
  var expected = (_ref2 = (_other$expected = other === null || other === void 0 ? void 0 : other.expected) !== null && _other$expected !== void 0 ? _other$expected : context.expects) !== null && _ref2 !== void 0 ? _ref2 : null;
  var received = (_other$received = other === null || other === void 0 ? void 0 : other.received) !== null && _other$received !== void 0 ? _other$received : _stringify(input);
  var issue = {
    kind: context.kind,
    type: context.type,
    input: input,
    expected: expected,
    received: received,
    message: "Invalid ".concat(label, ": ").concat(expected ? "Expected ".concat(expected, " but r") : "R", "eceived ").concat(received),
    // @ts-expect-error
    requirement: context.requirement,
    path: other === null || other === void 0 ? void 0 : other.path,
    issues: other === null || other === void 0 ? void 0 : other.issues,
    lang: config2.lang,
    abortEarly: config2.abortEarly,
    abortPipeEarly: config2.abortPipeEarly
  };
  var isSchema = context.kind === "schema";
  var message = (_ref3 = (_ref4 = (_ref5 = (_ref6 = (_other$message = other === null || other === void 0 ? void 0 : other.message) !== null && _other$message !== void 0 ? _other$message :
  // @ts-expect-error
  context.message) !== null && _ref6 !== void 0 ? _ref6 : getSpecificMessage(context.reference, issue.lang)) !== null && _ref5 !== void 0 ? _ref5 : isSchema ? getSchemaMessage(issue.lang) : null) !== null && _ref4 !== void 0 ? _ref4 : config2.message) !== null && _ref3 !== void 0 ? _ref3 : getGlobalMessage(issue.lang);
  if (message) {
    issue.message = typeof message === "function" ? message(issue) : message;
  }
  if (isSchema) {
    dataset.typed = false;
  }
  if (dataset.issues) {
    dataset.issues.push(issue);
  } else {
    dataset.issues = [issue];
  }
}

// src/utils/_isLuhnAlgo/_isLuhnAlgo.ts
var NON_DIGIT_REGEX = /(?:[\0-\/:-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF][\uDC00-\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])/g;
function _isLuhnAlgo(input) {
  var number2 = input.replace(NON_DIGIT_REGEX, "");
  var length2 = number2.length;
  var bit = 1;
  var sum = 0;
  while (length2) {
    var value2 = +number2[--length2];
    bit ^= 1;
    sum += bit ? [0, 2, 4, 6, 8, 1, 3, 5, 7, 9][value2] : value2;
  }
  return sum % 10 === 0;
}

// src/utils/_isValidObjectKey/_isValidObjectKey.ts
function _isValidObjectKey(object2, key) {
  return Object.hasOwn(object2, key) && key !== "__proto__" && key !== "prototype" && key !== "constructor";
}

// src/utils/_joinExpects/_joinExpects.ts
function _joinExpects(values, separator) {
  var _list$;
  var list = _toConsumableArray(new Set(values));
  if (list.length > 1) {
    return "(".concat(list.join(" ".concat(separator, " ")), ")");
  }
  return (_list$ = list[0]) !== null && _list$ !== void 0 ? _list$ : "never";
}

// src/utils/entriesFromList/entriesFromList.ts
function entriesFromList(list, schema) {
  var entries = {};
  var _iterator = _createForOfIteratorHelper(list),
    _step;
  try {
    for (_iterator.s(); !(_step = _iterator.n()).done;) {
      var key = _step.value;
      entries[key] = schema;
    }
  } catch (err) {
    _iterator.e(err);
  } finally {
    _iterator.f();
  }
  return entries;
}

// src/utils/getDotPath/getDotPath.ts
function getDotPath(issue) {
  if (issue.path) {
    var key = "";
    var _iterator2 = _createForOfIteratorHelper(issue.path),
      _step2;
    try {
      for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
        var item = _step2.value;
        if (typeof item.key === "string" || typeof item.key === "number") {
          if (key) {
            key += ".".concat(item.key);
          } else {
            key += item.key;
          }
        } else {
          return null;
        }
      }
    } catch (err) {
      _iterator2.e(err);
    } finally {
      _iterator2.f();
    }
    return key;
  }
  return null;
}

// src/utils/isOfKind/isOfKind.ts
function isOfKind(kind, object2) {
  return object2.kind === kind;
}

// src/utils/isOfType/isOfType.ts
function isOfType(type, object2) {
  return object2.type === type;
}

// src/utils/isValiError/isValiError.ts
function isValiError(error) {
  return error instanceof ValiError;
}

// src/utils/ValiError/ValiError.ts
var ValiError = exports.ValiError = /*#__PURE__*/function (_Error) {
  /**
   * Creates a Valibot error with useful information.
   *
   * @param issues The error issues.
   */
  function ValiError(issues) {
    var _this;
    _classCallCheck(this, ValiError);
    _this = _callSuper(this, ValiError, [issues[0].message]);
    /**
     * The error issues.
     */
    _defineProperty(_this, "issues", void 0);
    _this.name = "ValiError";
    _this.issues = issues;
    return _this;
  }
  _inherits(ValiError, _Error);
  return _createClass(ValiError);
}(/*#__PURE__*/_wrapNativeSuper(Error));

// src/actions/base64/base64.ts
function base64(message) {
  return {
    kind: "validation",
    type: "base64",
    reference: base64,
    async: false,
    expects: null,
    requirement: BASE64_REGEX,
    message: message,
    _run: function _run(dataset, config2) {
      if (dataset.typed && !this.requirement.test(dataset.value)) {
        _addIssue(this, "Base64", dataset, config2);
      }
      return dataset;
    }
  };
}

// src/actions/bic/bic.ts
function bic(message) {
  return {
    kind: "validation",
    type: "bic",
    reference: bic,
    async: false,
    expects: null,
    requirement: BIC_REGEX,
    message: message,
    _run: function _run(dataset, config2) {
      if (dataset.typed && !this.requirement.test(dataset.value)) {
        _addIssue(this, "BIC", dataset, config2);
      }
      return dataset;
    }
  };
}

// src/actions/brand/brand.ts
function brand(name) {
  return {
    kind: "transformation",
    type: "brand",
    reference: brand,
    async: false,
    name: name,
    _run: function _run(dataset) {
      return dataset;
    }
  };
}

// src/actions/bytes/bytes.ts
function bytes(requirement, message) {
  return {
    kind: "validation",
    type: "bytes",
    reference: bytes,
    async: false,
    expects: "".concat(requirement),
    requirement: requirement,
    message: message,
    _run: function _run(dataset, config2) {
      if (dataset.typed) {
        var length2 = new TextEncoder().encode(dataset.value).length;
        if (length2 !== this.requirement) {
          _addIssue(this, "bytes", dataset, config2, {
            received: "".concat(length2)
          });
        }
      }
      return dataset;
    }
  };
}

// src/actions/check/check.ts
function check(requirement, message) {
  return {
    kind: "validation",
    type: "check",
    reference: check,
    async: false,
    expects: null,
    requirement: requirement,
    message: message,
    _run: function _run(dataset, config2) {
      if (dataset.typed && !this.requirement(dataset.value)) {
        _addIssue(this, "input", dataset, config2);
      }
      return dataset;
    }
  };
}

// src/actions/check/checkAsync.ts
function checkAsync(requirement, message) {
  return {
    kind: "validation",
    type: "check",
    reference: checkAsync,
    async: true,
    expects: null,
    requirement: requirement,
    message: message,
    _run: function _run(dataset, config2) {
      var _this2 = this;
      return _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee2() {
        return _regeneratorRuntime().wrap(function _callee2$(_context2) {
          while (1) switch (_context2.prev = _context2.next) {
            case 0:
              _context2.t0 = dataset.typed;
              if (!_context2.t0) {
                _context2.next = 5;
                break;
              }
              _context2.next = 4;
              return _this2.requirement(dataset.value);
            case 4:
              _context2.t0 = !_context2.sent;
            case 5:
              if (!_context2.t0) {
                _context2.next = 7;
                break;
              }
              _addIssue(_this2, "input", dataset, config2);
            case 7:
              return _context2.abrupt("return", dataset);
            case 8:
            case "end":
              return _context2.stop();
          }
        }, _callee2);
      }))();
    }
  };
}

// src/actions/checkItems/checkItems.ts
function checkItems(requirement, message) {
  return {
    kind: "validation",
    type: "check_items",
    reference: checkItems,
    async: false,
    expects: null,
    requirement: requirement,
    message: message,
    _run: function _run(dataset, config2) {
      if (dataset.typed) {
        for (var index = 0; index < dataset.value.length; index++) {
          var item = dataset.value[index];
          if (!this.requirement(item, index, dataset.value)) {
            _addIssue(this, "item", dataset, config2, {
              input: item,
              path: [{
                type: "array",
                origin: "value",
                input: dataset.value,
                key: index,
                value: item
              }]
            });
          }
        }
      }
      return dataset;
    }
  };
}

// src/actions/creditCard/creditCard.ts
var CREDIT_CARD_REGEX = /^(?:[0-9]{14,19}|[0-9]{4}(?: [0-9]{3,6}){2,4}|[0-9]{4}(?:-[0-9]{3,6}){2,4})$/;
var SANITIZE_REGEX = /[ \x2D]/g;
var PROVIDER_REGEX_LIST = [
// American Express
/^3[47][0-9]{13}$/,
// Diners Club
/^3(?:0[0-5]|[68][0-9])[0-9]{11,13}$/,
// Discover
/^6(?:011|5[0-9]{2})[0-9]{12,15}$/,
// JCB
/^(?:2131|1800|35[0-9]{3})[0-9]{11}$/,
// Mastercard
/^5[1-5][0-9]{2}|(?:222[0-9]|22[3-9][0-9]|2[3-6][0-9]{2}|27[01][0-9]|2720)[0-9]{12}$/,
// UnionPay
/^(?:6[27][0-9]{14,17}|81[0-9]{14,17})$/,
// Visa
/^4[0-9]{12}(?:[0-9]{3,6})?$/];
function creditCard(message) {
  return {
    kind: "validation",
    type: "credit_card",
    reference: creditCard,
    async: false,
    expects: null,
    requirement: function requirement(input) {
      var sanitized;
      return CREDIT_CARD_REGEX.test(input) && (
      // Remove any hyphens and blanks
      sanitized = input.replace(SANITIZE_REGEX, "")) &&
      // Check if it matches a provider
      PROVIDER_REGEX_LIST.some(function (regex2) {
        return regex2.test(sanitized);
      }) &&
      // Check if passes luhn algorithm
      _isLuhnAlgo(sanitized);
    },
    message: message,
    _run: function _run(dataset, config2) {
      if (dataset.typed && !this.requirement(dataset.value)) {
        _addIssue(this, "credit card", dataset, config2);
      }
      return dataset;
    }
  };
}

// src/actions/cuid2/cuid2.ts
function cuid2(message) {
  return {
    kind: "validation",
    type: "cuid2",
    reference: cuid2,
    async: false,
    expects: null,
    requirement: CUID2_REGEX,
    message: message,
    _run: function _run(dataset, config2) {
      if (dataset.typed && !this.requirement.test(dataset.value)) {
        _addIssue(this, "Cuid2", dataset, config2);
      }
      return dataset;
    }
  };
}

// src/actions/decimal/decimal.ts
function decimal(message) {
  return {
    kind: "validation",
    type: "decimal",
    reference: decimal,
    async: false,
    expects: null,
    requirement: DECIMAL_REGEX,
    message: message,
    _run: function _run(dataset, config2) {
      if (dataset.typed && !this.requirement.test(dataset.value)) {
        _addIssue(this, "decimal", dataset, config2);
      }
      return dataset;
    }
  };
}

// src/actions/description/description.ts
function description(description_) {
  return {
    kind: "metadata",
    type: "description",
    reference: description,
    description: description_
  };
}

// src/actions/email/email.ts
function email(message) {
  return {
    kind: "validation",
    type: "email",
    reference: email,
    expects: null,
    async: false,
    requirement: EMAIL_REGEX,
    message: message,
    _run: function _run(dataset, config2) {
      if (dataset.typed && !this.requirement.test(dataset.value)) {
        _addIssue(this, "email", dataset, config2);
      }
      return dataset;
    }
  };
}

// src/actions/emoji/emoji.ts
function emoji(message) {
  return {
    kind: "validation",
    type: "emoji",
    reference: emoji,
    async: false,
    expects: null,
    requirement: EMOJI_REGEX,
    message: message,
    _run: function _run(dataset, config2) {
      if (dataset.typed && !this.requirement.test(dataset.value)) {
        _addIssue(this, "emoji", dataset, config2);
      }
      return dataset;
    }
  };
}

// src/actions/empty/empty.ts
function empty(message) {
  return {
    kind: "validation",
    type: "empty",
    reference: empty,
    async: false,
    expects: "0",
    message: message,
    _run: function _run(dataset, config2) {
      if (dataset.typed && dataset.value.length > 0) {
        _addIssue(this, "length", dataset, config2, {
          received: "".concat(dataset.value.length)
        });
      }
      return dataset;
    }
  };
}

// src/actions/endsWith/endsWith.ts
function endsWith(requirement, message) {
  return {
    kind: "validation",
    type: "ends_with",
    reference: endsWith,
    async: false,
    expects: "\"".concat(requirement, "\""),
    requirement: requirement,
    message: message,
    _run: function _run(dataset, config2) {
      if (dataset.typed && !dataset.value.endsWith(this.requirement)) {
        _addIssue(this, "end", dataset, config2, {
          received: "\"".concat(dataset.value.slice(-this.requirement.length), "\"")
        });
      }
      return dataset;
    }
  };
}

// src/actions/everyItem/everyItem.ts
function everyItem(requirement, message) {
  return {
    kind: "validation",
    type: "every_item",
    reference: everyItem,
    async: false,
    expects: null,
    requirement: requirement,
    message: message,
    _run: function _run(dataset, config2) {
      if (dataset.typed && !dataset.value.every(this.requirement)) {
        _addIssue(this, "item", dataset, config2);
      }
      return dataset;
    }
  };
}

// src/actions/excludes/excludes.ts
function excludes(requirement, message) {
  var received = _stringify(requirement);
  return {
    kind: "validation",
    type: "excludes",
    reference: excludes,
    async: false,
    expects: "!".concat(received),
    requirement: requirement,
    message: message,
    _run: function _run(dataset, config2) {
      if (dataset.typed && dataset.value.includes(this.requirement)) {
        _addIssue(this, "content", dataset, config2, {
          received: received
        });
      }
      return dataset;
    }
  };
}

// src/actions/filterItems/filterItems.ts
function filterItems(operation) {
  return {
    kind: "transformation",
    type: "filter_items",
    reference: filterItems,
    async: false,
    operation: operation,
    _run: function _run(dataset) {
      dataset.value = dataset.value.filter(this.operation);
      return dataset;
    }
  };
}

// src/actions/findItem/findItem.ts
function findItem(operation) {
  return {
    kind: "transformation",
    type: "find_item",
    reference: findItem,
    async: false,
    operation: operation,
    _run: function _run(dataset) {
      dataset.value = dataset.value.find(this.operation);
      return dataset;
    }
  };
}

// src/actions/finite/finite.ts
function finite(message) {
  return {
    kind: "validation",
    type: "finite",
    reference: finite,
    async: false,
    expects: null,
    requirement: Number.isFinite,
    message: message,
    _run: function _run(dataset, config2) {
      if (dataset.typed && !this.requirement(dataset.value)) {
        _addIssue(this, "finite", dataset, config2);
      }
      return dataset;
    }
  };
}

// src/actions/hash/hash.ts
var HASH_LENGTHS = {
  md4: 32,
  md5: 32,
  sha1: 40,
  sha256: 64,
  sha384: 96,
  sha512: 128,
  ripemd128: 32,
  ripemd160: 40,
  tiger128: 32,
  tiger160: 40,
  tiger192: 48,
  crc32: 8,
  crc32b: 8,
  adler32: 8
};
function hash(types, message) {
  return {
    kind: "validation",
    type: "hash",
    reference: hash,
    expects: null,
    async: false,
    requirement: RegExp(types.map(function (type) {
      return "^[a-f0-9]{".concat(HASH_LENGTHS[type], "}$");
    }).join("|"), "iu"),
    message: message,
    _run: function _run(dataset, config2) {
      if (dataset.typed && !this.requirement.test(dataset.value)) {
        _addIssue(this, "hash", dataset, config2);
      }
      return dataset;
    }
  };
}

// src/actions/hexadecimal/hexadecimal.ts
function hexadecimal(message) {
  return {
    kind: "validation",
    type: "hexadecimal",
    reference: hexadecimal,
    async: false,
    expects: null,
    requirement: HEXADECIMAL_REGEX,
    message: message,
    _run: function _run(dataset, config2) {
      if (dataset.typed && !this.requirement.test(dataset.value)) {
        _addIssue(this, "hexadecimal", dataset, config2);
      }
      return dataset;
    }
  };
}

// src/actions/hexColor/hexColor.ts
function hexColor(message) {
  return {
    kind: "validation",
    type: "hex_color",
    reference: hexColor,
    async: false,
    expects: null,
    requirement: HEX_COLOR_REGEX,
    message: message,
    _run: function _run(dataset, config2) {
      if (dataset.typed && !this.requirement.test(dataset.value)) {
        _addIssue(this, "hex color", dataset, config2);
      }
      return dataset;
    }
  };
}

// src/actions/imei/imei.ts
function imei(message) {
  return {
    kind: "validation",
    type: "imei",
    reference: imei,
    async: false,
    expects: null,
    requirement: function requirement(input) {
      return IMEI_REGEX.test(input) && _isLuhnAlgo(input);
    },
    message: message,
    _run: function _run(dataset, config2) {
      if (dataset.typed && !this.requirement(dataset.value)) {
        _addIssue(this, "IMEI", dataset, config2);
      }
      return dataset;
    }
  };
}

// src/actions/includes/includes.ts
function includes(requirement, message) {
  var expects = _stringify(requirement);
  return {
    kind: "validation",
    type: "includes",
    reference: includes,
    async: false,
    expects: expects,
    requirement: requirement,
    message: message,
    _run: function _run(dataset, config2) {
      if (dataset.typed && !dataset.value.includes(this.requirement)) {
        _addIssue(this, "content", dataset, config2, {
          received: "!".concat(expects)
        });
      }
      return dataset;
    }
  };
}

// src/actions/integer/integer.ts
function integer(message) {
  return {
    kind: "validation",
    type: "integer",
    reference: integer,
    async: false,
    expects: null,
    requirement: Number.isInteger,
    message: message,
    _run: function _run(dataset, config2) {
      if (dataset.typed && !this.requirement(dataset.value)) {
        _addIssue(this, "integer", dataset, config2);
      }
      return dataset;
    }
  };
}

// src/actions/ip/ip.ts
function ip(message) {
  return {
    kind: "validation",
    type: "ip",
    reference: ip,
    async: false,
    expects: null,
    requirement: IP_REGEX,
    message: message,
    _run: function _run(dataset, config2) {
      if (dataset.typed && !this.requirement.test(dataset.value)) {
        _addIssue(this, "IP", dataset, config2);
      }
      return dataset;
    }
  };
}

// src/actions/ipv4/ipv4.ts
function ipv4(message) {
  return {
    kind: "validation",
    type: "ipv4",
    reference: ipv4,
    async: false,
    expects: null,
    requirement: IPV4_REGEX,
    message: message,
    _run: function _run(dataset, config2) {
      if (dataset.typed && !this.requirement.test(dataset.value)) {
        _addIssue(this, "IPv4", dataset, config2);
      }
      return dataset;
    }
  };
}

// src/actions/ipv6/ipv6.ts
function ipv6(message) {
  return {
    kind: "validation",
    type: "ipv6",
    reference: ipv6,
    async: false,
    expects: null,
    requirement: IPV6_REGEX,
    message: message,
    _run: function _run(dataset, config2) {
      if (dataset.typed && !this.requirement.test(dataset.value)) {
        _addIssue(this, "IPv6", dataset, config2);
      }
      return dataset;
    }
  };
}

// src/actions/isoDate/isoDate.ts
function isoDate(message) {
  return {
    kind: "validation",
    type: "iso_date",
    reference: isoDate,
    async: false,
    expects: null,
    requirement: ISO_DATE_REGEX,
    message: message,
    _run: function _run(dataset, config2) {
      if (dataset.typed && !this.requirement.test(dataset.value)) {
        _addIssue(this, "date", dataset, config2);
      }
      return dataset;
    }
  };
}

// src/actions/isoDateTime/isoDateTime.ts
function isoDateTime(message) {
  return {
    kind: "validation",
    type: "iso_date_time",
    reference: isoDateTime,
    async: false,
    expects: null,
    requirement: ISO_DATE_TIME_REGEX,
    message: message,
    _run: function _run(dataset, config2) {
      if (dataset.typed && !this.requirement.test(dataset.value)) {
        _addIssue(this, "date-time", dataset, config2);
      }
      return dataset;
    }
  };
}

// src/actions/isoTime/isoTime.ts
function isoTime(message) {
  return {
    kind: "validation",
    type: "iso_time",
    reference: isoTime,
    async: false,
    expects: null,
    requirement: ISO_TIME_REGEX,
    message: message,
    _run: function _run(dataset, config2) {
      if (dataset.typed && !this.requirement.test(dataset.value)) {
        _addIssue(this, "time", dataset, config2);
      }
      return dataset;
    }
  };
}

// src/actions/isoTimeSecond/isoTimeSecond.ts
function isoTimeSecond(message) {
  return {
    kind: "validation",
    type: "iso_time_second",
    reference: isoTimeSecond,
    async: false,
    expects: null,
    requirement: ISO_TIME_SECOND_REGEX,
    message: message,
    _run: function _run(dataset, config2) {
      if (dataset.typed && !this.requirement.test(dataset.value)) {
        _addIssue(this, "time-second", dataset, config2);
      }
      return dataset;
    }
  };
}

// src/actions/isoTimestamp/isoTimestamp.ts
function isoTimestamp(message) {
  return {
    kind: "validation",
    type: "iso_timestamp",
    reference: isoTimestamp,
    async: false,
    expects: null,
    requirement: ISO_TIMESTAMP_REGEX,
    message: message,
    _run: function _run(dataset, config2) {
      if (dataset.typed && !this.requirement.test(dataset.value)) {
        _addIssue(this, "timestamp", dataset, config2);
      }
      return dataset;
    }
  };
}

// src/actions/isoWeek/isoWeek.ts
function isoWeek(message) {
  return {
    kind: "validation",
    type: "iso_week",
    reference: isoWeek,
    async: false,
    expects: null,
    requirement: ISO_WEEK_REGEX,
    message: message,
    _run: function _run(dataset, config2) {
      if (dataset.typed && !this.requirement.test(dataset.value)) {
        _addIssue(this, "week", dataset, config2);
      }
      return dataset;
    }
  };
}

// src/actions/length/length.ts
function length(requirement, message) {
  return {
    kind: "validation",
    type: "length",
    reference: length,
    async: false,
    expects: "".concat(requirement),
    requirement: requirement,
    message: message,
    _run: function _run(dataset, config2) {
      if (dataset.typed && dataset.value.length !== this.requirement) {
        _addIssue(this, "length", dataset, config2, {
          received: "".concat(dataset.value.length)
        });
      }
      return dataset;
    }
  };
}

// src/actions/mac/mac.ts
function mac(message) {
  return {
    kind: "validation",
    type: "mac",
    reference: mac,
    async: false,
    expects: null,
    requirement: MAC_REGEX,
    message: message,
    _run: function _run(dataset, config2) {
      if (dataset.typed && !this.requirement.test(dataset.value)) {
        _addIssue(this, "MAC", dataset, config2);
      }
      return dataset;
    }
  };
}

// src/actions/mac48/mac48.ts
function mac48(message) {
  return {
    kind: "validation",
    type: "mac48",
    reference: mac48,
    async: false,
    expects: null,
    requirement: MAC48_REGEX,
    message: message,
    _run: function _run(dataset, config2) {
      if (dataset.typed && !this.requirement.test(dataset.value)) {
        _addIssue(this, "48-bit MAC", dataset, config2);
      }
      return dataset;
    }
  };
}

// src/actions/mac64/mac64.ts
function mac64(message) {
  return {
    kind: "validation",
    type: "mac64",
    reference: mac64,
    async: false,
    expects: null,
    requirement: MAC64_REGEX,
    message: message,
    _run: function _run(dataset, config2) {
      if (dataset.typed && !this.requirement.test(dataset.value)) {
        _addIssue(this, "64-bit MAC", dataset, config2);
      }
      return dataset;
    }
  };
}

// src/actions/mapItems/mapItems.ts
function mapItems(operation) {
  return {
    kind: "transformation",
    type: "map_items",
    reference: mapItems,
    async: false,
    operation: operation,
    _run: function _run(dataset) {
      dataset.value = dataset.value.map(this.operation);
      return dataset;
    }
  };
}

// src/actions/maxBytes/maxBytes.ts
function maxBytes(requirement, message) {
  return {
    kind: "validation",
    type: "max_bytes",
    reference: maxBytes,
    async: false,
    expects: "<=".concat(requirement),
    requirement: requirement,
    message: message,
    _run: function _run(dataset, config2) {
      if (dataset.typed) {
        var length2 = new TextEncoder().encode(dataset.value).length;
        if (length2 > this.requirement) {
          _addIssue(this, "bytes", dataset, config2, {
            received: "".concat(length2)
          });
        }
      }
      return dataset;
    }
  };
}

// src/actions/maxLength/maxLength.ts
function maxLength(requirement, message) {
  return {
    kind: "validation",
    type: "max_length",
    reference: maxLength,
    async: false,
    expects: "<=".concat(requirement),
    requirement: requirement,
    message: message,
    _run: function _run(dataset, config2) {
      if (dataset.typed && dataset.value.length > this.requirement) {
        _addIssue(this, "length", dataset, config2, {
          received: "".concat(dataset.value.length)
        });
      }
      return dataset;
    }
  };
}

// src/actions/maxSize/maxSize.ts
function maxSize(requirement, message) {
  return {
    kind: "validation",
    type: "max_size",
    reference: maxSize,
    async: false,
    expects: "<=".concat(requirement),
    requirement: requirement,
    message: message,
    _run: function _run(dataset, config2) {
      if (dataset.typed && dataset.value.size > this.requirement) {
        _addIssue(this, "size", dataset, config2, {
          received: "".concat(dataset.value.size)
        });
      }
      return dataset;
    }
  };
}

// src/actions/maxValue/maxValue.ts
function maxValue(requirement, message) {
  return {
    kind: "validation",
    type: "max_value",
    reference: maxValue,
    async: false,
    expects: "<=".concat(requirement instanceof Date ? requirement.toJSON() : _stringify(requirement)),
    requirement: requirement,
    message: message,
    _run: function _run(dataset, config2) {
      if (dataset.typed && dataset.value > this.requirement) {
        _addIssue(this, "value", dataset, config2, {
          received: dataset.value instanceof Date ? dataset.value.toJSON() : _stringify(dataset.value)
        });
      }
      return dataset;
    }
  };
}

// src/actions/mimeType/mimeType.ts
function mimeType(requirement, message) {
  return {
    kind: "validation",
    type: "mime_type",
    reference: mimeType,
    async: false,
    expects: _joinExpects(requirement.map(function (option) {
      return "\"".concat(option, "\"");
    }), "|"),
    requirement: requirement,
    message: message,
    _run: function _run(dataset, config2) {
      if (dataset.typed && !this.requirement.includes(dataset.value.type)) {
        _addIssue(this, "MIME type", dataset, config2, {
          received: "\"".concat(dataset.value.type, "\"")
        });
      }
      return dataset;
    }
  };
}

// src/actions/minBytes/minBytes.ts
function minBytes(requirement, message) {
  return {
    kind: "validation",
    type: "min_bytes",
    reference: minBytes,
    async: false,
    expects: ">=".concat(requirement),
    requirement: requirement,
    message: message,
    _run: function _run(dataset, config2) {
      if (dataset.typed) {
        var length2 = new TextEncoder().encode(dataset.value).length;
        if (length2 < this.requirement) {
          _addIssue(this, "bytes", dataset, config2, {
            received: "".concat(length2)
          });
        }
      }
      return dataset;
    }
  };
}

// src/actions/minLength/minLength.ts
function minLength(requirement, message) {
  return {
    kind: "validation",
    type: "min_length",
    reference: minLength,
    async: false,
    expects: ">=".concat(requirement),
    requirement: requirement,
    message: message,
    _run: function _run(dataset, config2) {
      if (dataset.typed && dataset.value.length < this.requirement) {
        _addIssue(this, "length", dataset, config2, {
          received: "".concat(dataset.value.length)
        });
      }
      return dataset;
    }
  };
}

// src/actions/minSize/minSize.ts
function minSize(requirement, message) {
  return {
    kind: "validation",
    type: "min_size",
    reference: minSize,
    async: false,
    expects: ">=".concat(requirement),
    requirement: requirement,
    message: message,
    _run: function _run(dataset, config2) {
      if (dataset.typed && dataset.value.size < this.requirement) {
        _addIssue(this, "size", dataset, config2, {
          received: "".concat(dataset.value.size)
        });
      }
      return dataset;
    }
  };
}

// src/actions/minValue/minValue.ts
function minValue(requirement, message) {
  return {
    kind: "validation",
    type: "min_value",
    reference: minValue,
    async: false,
    expects: ">=".concat(requirement instanceof Date ? requirement.toJSON() : _stringify(requirement)),
    requirement: requirement,
    message: message,
    _run: function _run(dataset, config2) {
      if (dataset.typed && dataset.value < this.requirement) {
        _addIssue(this, "value", dataset, config2, {
          received: dataset.value instanceof Date ? dataset.value.toJSON() : _stringify(dataset.value)
        });
      }
      return dataset;
    }
  };
}

// src/actions/multipleOf/multipleOf.ts
function multipleOf(requirement, message) {
  return {
    kind: "validation",
    type: "multiple_of",
    reference: multipleOf,
    async: false,
    expects: "%".concat(requirement),
    requirement: requirement,
    message: message,
    _run: function _run(dataset, config2) {
      if (dataset.typed && dataset.value % this.requirement !== 0) {
        _addIssue(this, "multiple", dataset, config2);
      }
      return dataset;
    }
  };
}

// src/actions/nonEmpty/nonEmpty.ts
function nonEmpty(message) {
  return {
    kind: "validation",
    type: "non_empty",
    reference: nonEmpty,
    async: false,
    expects: "!0",
    message: message,
    _run: function _run(dataset, config2) {
      if (dataset.typed && dataset.value.length === 0) {
        _addIssue(this, "length", dataset, config2, {
          received: "0"
        });
      }
      return dataset;
    }
  };
}

// src/actions/normalize/normalize.ts
function normalize(form) {
  return {
    kind: "transformation",
    type: "normalize",
    reference: normalize,
    async: false,
    form: form,
    _run: function _run(dataset) {
      dataset.value = dataset.value.normalize(this.form);
      return dataset;
    }
  };
}

// src/actions/notBytes/notBytes.ts
function notBytes(requirement, message) {
  return {
    kind: "validation",
    type: "not_bytes",
    reference: notBytes,
    async: false,
    expects: "!".concat(requirement),
    requirement: requirement,
    message: message,
    _run: function _run(dataset, config2) {
      if (dataset.typed) {
        var length2 = new TextEncoder().encode(dataset.value).length;
        if (length2 === this.requirement) {
          _addIssue(this, "bytes", dataset, config2, {
            received: "".concat(length2)
          });
        }
      }
      return dataset;
    }
  };
}

// src/actions/notLength/notLength.ts
function notLength(requirement, message) {
  return {
    kind: "validation",
    type: "not_length",
    reference: notLength,
    async: false,
    expects: "!".concat(requirement),
    requirement: requirement,
    message: message,
    _run: function _run(dataset, config2) {
      if (dataset.typed && dataset.value.length === this.requirement) {
        _addIssue(this, "length", dataset, config2, {
          received: "".concat(dataset.value.length)
        });
      }
      return dataset;
    }
  };
}

// src/actions/notSize/notSize.ts
function notSize(requirement, message) {
  return {
    kind: "validation",
    type: "not_size",
    reference: notSize,
    async: false,
    expects: "!".concat(requirement),
    requirement: requirement,
    message: message,
    _run: function _run(dataset, config2) {
      if (dataset.typed && dataset.value.size === this.requirement) {
        _addIssue(this, "size", dataset, config2, {
          received: "".concat(dataset.value.size)
        });
      }
      return dataset;
    }
  };
}

// src/actions/notValue/notValue.ts
function notValue(requirement, message) {
  return {
    kind: "validation",
    type: "not_value",
    reference: notValue,
    async: false,
    expects: requirement instanceof Date ? "!".concat(requirement.toJSON()) : "!".concat(_stringify(requirement)),
    requirement: requirement,
    message: message,
    _run: function _run(dataset, config2) {
      if (dataset.typed && this.requirement <= dataset.value && this.requirement >= dataset.value) {
        _addIssue(this, "value", dataset, config2, {
          received: dataset.value instanceof Date ? dataset.value.toJSON() : _stringify(dataset.value)
        });
      }
      return dataset;
    }
  };
}

// src/actions/octal/octal.ts
function octal(message) {
  return {
    kind: "validation",
    type: "octal",
    reference: octal,
    async: false,
    expects: null,
    requirement: OCTAL_REGEX,
    message: message,
    _run: function _run(dataset, config2) {
      if (dataset.typed && !this.requirement.test(dataset.value)) {
        _addIssue(this, "octal", dataset, config2);
      }
      return dataset;
    }
  };
}

// src/actions/partialCheck/utils/_isPartiallyTyped/_isPartiallyTyped.ts
function _isPartiallyTyped(dataset, pathList) {
  if (dataset.issues) {
    var _iterator3 = _createForOfIteratorHelper(pathList),
      _step3;
    try {
      for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
        var path = _step3.value;
        var _iterator4 = _createForOfIteratorHelper(dataset.issues),
          _step4;
        try {
          for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {
            var _issue$path$length, _issue$path;
            var issue = _step4.value;
            var typed = false;
            var bound = Math.min(path.length, (_issue$path$length = (_issue$path = issue.path) === null || _issue$path === void 0 ? void 0 : _issue$path.length) !== null && _issue$path$length !== void 0 ? _issue$path$length : 0);
            for (var index = 0; index < bound; index++) {
              if (path[index] !== issue.path[index].key) {
                typed = true;
                break;
              }
            }
            if (!typed) {
              return false;
            }
          }
        } catch (err) {
          _iterator4.e(err);
        } finally {
          _iterator4.f();
        }
      }
    } catch (err) {
      _iterator3.e(err);
    } finally {
      _iterator3.f();
    }
  }
  return true;
}

// src/actions/partialCheck/partialCheck.ts
function partialCheck(pathList, requirement, message) {
  return {
    kind: "validation",
    type: "partial_check",
    reference: partialCheck,
    async: false,
    expects: null,
    requirement: requirement,
    message: message,
    _run: function _run(dataset, config2) {
      if (_isPartiallyTyped(dataset, pathList) &&
      // @ts-expect-error
      !this.requirement(dataset.value)) {
        _addIssue(this, "input", dataset, config2);
      }
      return dataset;
    }
  };
}

// src/actions/partialCheck/partialCheckAsync.ts
function partialCheckAsync(pathList, requirement, message) {
  return {
    kind: "validation",
    type: "partial_check",
    reference: partialCheckAsync,
    async: true,
    expects: null,
    requirement: requirement,
    message: message,
    _run: function _run(dataset, config2) {
      var _this3 = this;
      return _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee3() {
        return _regeneratorRuntime().wrap(function _callee3$(_context3) {
          while (1) switch (_context3.prev = _context3.next) {
            case 0:
              _context3.t0 = _isPartiallyTyped(dataset, pathList);
              if (!_context3.t0) {
                _context3.next = 5;
                break;
              }
              _context3.next = 4;
              return _this3.requirement(dataset.value);
            case 4:
              _context3.t0 = !_context3.sent;
            case 5:
              if (!_context3.t0) {
                _context3.next = 7;
                break;
              }
              _addIssue(_this3, "input", dataset, config2);
            case 7:
              return _context3.abrupt("return", dataset);
            case 8:
            case "end":
              return _context3.stop();
          }
        }, _callee3);
      }))();
    }
  };
}

// src/actions/rawCheck/rawCheck.ts
function rawCheck(action) {
  return {
    kind: "validation",
    type: "raw_check",
    reference: rawCheck,
    async: false,
    expects: null,
    _run: function _run(dataset, config2) {
      var _this4 = this;
      action({
        dataset: dataset,
        config: config2,
        addIssue: function addIssue(info) {
          var _info$label;
          return _addIssue(_this4, (_info$label = info === null || info === void 0 ? void 0 : info.label) !== null && _info$label !== void 0 ? _info$label : "input", dataset, config2, info);
        }
      });
      return dataset;
    }
  };
}

// src/actions/rawCheck/rawCheckAsync.ts
function rawCheckAsync(action) {
  return {
    kind: "validation",
    type: "raw_check",
    reference: rawCheckAsync,
    async: true,
    expects: null,
    _run: function _run(dataset, config2) {
      var _this5 = this;
      return _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee4() {
        return _regeneratorRuntime().wrap(function _callee4$(_context4) {
          while (1) switch (_context4.prev = _context4.next) {
            case 0:
              _context4.next = 2;
              return action({
                dataset: dataset,
                config: config2,
                addIssue: function addIssue(info) {
                  var _info$label2;
                  return _addIssue(_this5, (_info$label2 = info === null || info === void 0 ? void 0 : info.label) !== null && _info$label2 !== void 0 ? _info$label2 : "input", dataset, config2, info);
                }
              });
            case 2:
              return _context4.abrupt("return", dataset);
            case 3:
            case "end":
              return _context4.stop();
          }
        }, _callee4);
      }))();
    }
  };
}

// src/actions/rawTransform/rawTransform.ts
function rawTransform(action) {
  return {
    kind: "transformation",
    type: "raw_transform",
    reference: rawTransform,
    async: false,
    _run: function _run(dataset, config2) {
      var _this6 = this;
      var output = action({
        dataset: dataset,
        config: config2,
        addIssue: function addIssue(info) {
          var _info$label3;
          return _addIssue(_this6, (_info$label3 = info === null || info === void 0 ? void 0 : info.label) !== null && _info$label3 !== void 0 ? _info$label3 : "input", dataset, config2, info);
        },
        NEVER: null
      });
      if (dataset.issues) {
        dataset.typed = false;
      } else {
        dataset.value = output;
      }
      return dataset;
    }
  };
}

// src/actions/rawTransform/rawTransformAsync.ts
function rawTransformAsync(action) {
  return {
    kind: "transformation",
    type: "raw_transform",
    reference: rawTransformAsync,
    async: true,
    _run: function _run(dataset, config2) {
      var _this7 = this;
      return _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee5() {
        var output;
        return _regeneratorRuntime().wrap(function _callee5$(_context5) {
          while (1) switch (_context5.prev = _context5.next) {
            case 0:
              _context5.next = 2;
              return action({
                dataset: dataset,
                config: config2,
                addIssue: function addIssue(info) {
                  var _info$label4;
                  return _addIssue(_this7, (_info$label4 = info === null || info === void 0 ? void 0 : info.label) !== null && _info$label4 !== void 0 ? _info$label4 : "input", dataset, config2, info);
                },
                NEVER: null
              });
            case 2:
              output = _context5.sent;
              if (dataset.issues) {
                dataset.typed = false;
              } else {
                dataset.value = output;
              }
              return _context5.abrupt("return", dataset);
            case 5:
            case "end":
              return _context5.stop();
          }
        }, _callee5);
      }))();
    }
  };
}

// src/actions/readonly/readonly.ts
function readonly() {
  return {
    kind: "transformation",
    type: "readonly",
    reference: readonly,
    async: false,
    _run: function _run(dataset) {
      return dataset;
    }
  };
}

// src/actions/reduceItems/reduceItems.ts
function reduceItems(operation, initial) {
  return {
    kind: "transformation",
    type: "reduce_items",
    reference: reduceItems,
    async: false,
    operation: operation,
    initial: initial,
    _run: function _run(dataset) {
      dataset.value = dataset.value.reduce(this.operation, this.initial);
      return dataset;
    }
  };
}

// src/actions/regex/regex.ts
function regex(requirement, message) {
  return {
    kind: "validation",
    type: "regex",
    reference: regex,
    async: false,
    expects: "".concat(requirement),
    requirement: requirement,
    message: message,
    _run: function _run(dataset, config2) {
      if (dataset.typed && !this.requirement.test(dataset.value)) {
        _addIssue(this, "format", dataset, config2);
      }
      return dataset;
    }
  };
}

// src/actions/safeInteger/safeInteger.ts
function safeInteger(message) {
  return {
    kind: "validation",
    type: "safe_integer",
    reference: safeInteger,
    async: false,
    expects: null,
    requirement: Number.isSafeInteger,
    message: message,
    _run: function _run(dataset, config2) {
      if (dataset.typed && !this.requirement(dataset.value)) {
        _addIssue(this, "safe integer", dataset, config2);
      }
      return dataset;
    }
  };
}

// src/actions/size/size.ts
function size(requirement, message) {
  return {
    kind: "validation",
    type: "size",
    reference: size,
    async: false,
    expects: "".concat(requirement),
    requirement: requirement,
    message: message,
    _run: function _run(dataset, config2) {
      if (dataset.typed && dataset.value.size !== this.requirement) {
        _addIssue(this, "size", dataset, config2, {
          received: "".concat(dataset.value.size)
        });
      }
      return dataset;
    }
  };
}

// src/actions/someItem/someItem.ts
function someItem(requirement, message) {
  return {
    kind: "validation",
    type: "some_item",
    reference: someItem,
    async: false,
    expects: null,
    requirement: requirement,
    message: message,
    _run: function _run(dataset, config2) {
      if (dataset.typed && !dataset.value.some(this.requirement)) {
        _addIssue(this, "item", dataset, config2);
      }
      return dataset;
    }
  };
}

// src/actions/sortItems/sortItems.ts
function sortItems(operation) {
  return {
    kind: "transformation",
    type: "sort_items",
    reference: sortItems,
    async: false,
    operation: operation,
    _run: function _run(dataset) {
      dataset.value = dataset.value.sort(this.operation);
      return dataset;
    }
  };
}

// src/actions/startsWith/startsWith.ts
function startsWith(requirement, message) {
  return {
    kind: "validation",
    type: "starts_with",
    reference: startsWith,
    async: false,
    expects: "\"".concat(requirement, "\""),
    requirement: requirement,
    message: message,
    _run: function _run(dataset, config2) {
      if (dataset.typed && !dataset.value.startsWith(this.requirement)) {
        _addIssue(this, "start", dataset, config2, {
          received: "\"".concat(dataset.value.slice(0, this.requirement.length), "\"")
        });
      }
      return dataset;
    }
  };
}

// src/actions/toLowerCase/toLowerCase.ts
function toLowerCase() {
  return {
    kind: "transformation",
    type: "to_lower_case",
    reference: toLowerCase,
    async: false,
    _run: function _run(dataset) {
      dataset.value = dataset.value.toLowerCase();
      return dataset;
    }
  };
}

// src/actions/toMaxValue/toMaxValue.ts
function toMaxValue(requirement) {
  return {
    kind: "transformation",
    type: "to_max_value",
    reference: toMaxValue,
    async: false,
    requirement: requirement,
    _run: function _run(dataset) {
      dataset.value = dataset.value > this.requirement ? this.requirement : dataset.value;
      return dataset;
    }
  };
}

// src/actions/toMinValue/toMinValue.ts
function toMinValue(requirement) {
  return {
    kind: "transformation",
    type: "to_min_value",
    reference: toMinValue,
    async: false,
    requirement: requirement,
    _run: function _run(dataset) {
      dataset.value = dataset.value < this.requirement ? this.requirement : dataset.value;
      return dataset;
    }
  };
}

// src/actions/toUpperCase/toUpperCase.ts
function toUpperCase() {
  return {
    kind: "transformation",
    type: "to_upper_case",
    reference: toUpperCase,
    async: false,
    _run: function _run(dataset) {
      dataset.value = dataset.value.toUpperCase();
      return dataset;
    }
  };
}

// src/actions/transform/transform.ts
function transform(operation) {
  return {
    kind: "transformation",
    type: "transform",
    reference: transform,
    async: false,
    operation: operation,
    _run: function _run(dataset) {
      dataset.value = this.operation(dataset.value);
      return dataset;
    }
  };
}

// src/actions/transform/transformAsync.ts
function transformAsync(operation) {
  return {
    kind: "transformation",
    type: "transform",
    reference: transformAsync,
    async: true,
    operation: operation,
    _run: function _run(dataset) {
      var _this8 = this;
      return _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee6() {
        return _regeneratorRuntime().wrap(function _callee6$(_context6) {
          while (1) switch (_context6.prev = _context6.next) {
            case 0:
              _context6.next = 2;
              return _this8.operation(dataset.value);
            case 2:
              dataset.value = _context6.sent;
              return _context6.abrupt("return", dataset);
            case 4:
            case "end":
              return _context6.stop();
          }
        }, _callee6);
      }))();
    }
  };
}

// src/actions/trim/trim.ts
function trim() {
  return {
    kind: "transformation",
    type: "trim",
    reference: trim,
    async: false,
    _run: function _run(dataset) {
      dataset.value = dataset.value.trim();
      return dataset;
    }
  };
}

// src/actions/trimEnd/trimEnd.ts
function trimEnd() {
  return {
    kind: "transformation",
    type: "trim_end",
    reference: trimEnd,
    async: false,
    _run: function _run(dataset) {
      dataset.value = dataset.value.trimEnd();
      return dataset;
    }
  };
}

// src/actions/trimStart/trimStart.ts
function trimStart() {
  return {
    kind: "transformation",
    type: "trim_start",
    reference: trimStart,
    async: false,
    _run: function _run(dataset) {
      dataset.value = dataset.value.trimStart();
      return dataset;
    }
  };
}

// src/actions/ulid/ulid.ts
function ulid(message) {
  return {
    kind: "validation",
    type: "ulid",
    reference: ulid,
    async: false,
    expects: null,
    requirement: ULID_REGEX,
    message: message,
    _run: function _run(dataset, config2) {
      if (dataset.typed && !this.requirement.test(dataset.value)) {
        _addIssue(this, "ULID", dataset, config2);
      }
      return dataset;
    }
  };
}

// src/actions/url/url.ts
function url(message) {
  return {
    kind: "validation",
    type: "url",
    reference: url,
    async: false,
    expects: null,
    requirement: function requirement(input) {
      try {
        new URL(input);
        return true;
      } catch (_unused) {
        return false;
      }
    },
    message: message,
    _run: function _run(dataset, config2) {
      if (dataset.typed && !this.requirement(dataset.value)) {
        _addIssue(this, "URL", dataset, config2);
      }
      return dataset;
    }
  };
}

// src/actions/uuid/uuid.ts
function uuid(message) {
  return {
    kind: "validation",
    type: "uuid",
    reference: uuid,
    async: false,
    expects: null,
    requirement: UUID_REGEX,
    message: message,
    _run: function _run(dataset, config2) {
      if (dataset.typed && !this.requirement.test(dataset.value)) {
        _addIssue(this, "UUID", dataset, config2);
      }
      return dataset;
    }
  };
}

// src/actions/value/value.ts
function value(requirement, message) {
  return {
    kind: "validation",
    type: "value",
    reference: value,
    async: false,
    expects: requirement instanceof Date ? requirement.toJSON() : _stringify(requirement),
    requirement: requirement,
    message: message,
    _run: function _run(dataset, config2) {
      if (dataset.typed && !(this.requirement <= dataset.value && this.requirement >= dataset.value)) {
        _addIssue(this, "value", dataset, config2, {
          received: dataset.value instanceof Date ? dataset.value.toJSON() : _stringify(dataset.value)
        });
      }
      return dataset;
    }
  };
}

// src/methods/config/config.ts
function config(schema, config2) {
  return _objectSpread(_objectSpread({}, schema), {}, {
    _run: function _run(dataset, config_) {
      return schema._run(dataset, _objectSpread(_objectSpread({}, config_), config2));
    }
  });
}

// src/methods/getFallback/getFallback.ts
function getFallback(schema, dataset, config2) {
  return typeof schema.fallback === "function" ?
  // @ts-expect-error
  schema.fallback(dataset, config2) :
  // @ts-expect-error
  schema.fallback;
}

// src/methods/fallback/fallback.ts
function fallback(schema, fallback2) {
  return _objectSpread(_objectSpread({}, schema), {}, {
    fallback: fallback2,
    _run: function _run(dataset, config2) {
      var outputDataset = schema._run(dataset, config2);
      return outputDataset.issues ? {
        typed: true,
        value: getFallback(this, outputDataset, config2)
      } : outputDataset;
    }
  });
}

// src/methods/fallback/fallbackAsync.ts
function fallbackAsync(schema, fallback2) {
  return _objectSpread(_objectSpread({}, schema), {}, {
    fallback: fallback2,
    async: true,
    _run: function _run(dataset, config2) {
      var _this9 = this;
      return _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee7() {
        var outputDataset;
        return _regeneratorRuntime().wrap(function _callee7$(_context7) {
          while (1) switch (_context7.prev = _context7.next) {
            case 0:
              _context7.next = 2;
              return schema._run(dataset, config2);
            case 2:
              outputDataset = _context7.sent;
              if (!outputDataset.issues) {
                _context7.next = 10;
                break;
              }
              _context7.next = 6;
              return getFallback(_this9, outputDataset, config2);
            case 6:
              _context7.t1 = _context7.sent;
              _context7.t0 = {
                typed: true,
                value: _context7.t1
              };
              _context7.next = 11;
              break;
            case 10:
              _context7.t0 = outputDataset;
            case 11:
              return _context7.abrupt("return", _context7.t0);
            case 12:
            case "end":
              return _context7.stop();
          }
        }, _callee7);
      }))();
    }
  });
}

// src/methods/flatten/flatten.ts
function flatten(issues) {
  var flatErrors = {};
  var _iterator5 = _createForOfIteratorHelper(issues),
    _step5;
  try {
    for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {
      var issue = _step5.value;
      if (issue.path) {
        var dotPath = getDotPath(issue);
        if (dotPath) {
          if (!flatErrors.nested) {
            flatErrors.nested = {};
          }
          if (flatErrors.nested[dotPath]) {
            flatErrors.nested[dotPath].push(issue.message);
          } else {
            flatErrors.nested[dotPath] = [issue.message];
          }
        } else {
          if (flatErrors.other) {
            flatErrors.other.push(issue.message);
          } else {
            flatErrors.other = [issue.message];
          }
        }
      } else {
        if (flatErrors.root) {
          flatErrors.root.push(issue.message);
        } else {
          flatErrors.root = [issue.message];
        }
      }
    }
  } catch (err) {
    _iterator5.e(err);
  } finally {
    _iterator5.f();
  }
  return flatErrors;
}

// src/methods/forward/forward.ts
function forward(action, pathKeys) {
  return _objectSpread(_objectSpread({}, action), {}, {
    _run: function _run(dataset, config2) {
      var prevIssues = dataset.issues && _toConsumableArray(dataset.issues);
      action._run(dataset, config2);
      if (dataset.issues) {
        var _iterator6 = _createForOfIteratorHelper(dataset.issues),
          _step6;
        try {
          for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {
            var issue = _step6.value;
            if (!(prevIssues !== null && prevIssues !== void 0 && prevIssues.includes(issue))) {
              var pathInput = dataset.value;
              var _iterator7 = _createForOfIteratorHelper(pathKeys),
                _step7;
              try {
                for (_iterator7.s(); !(_step7 = _iterator7.n()).done;) {
                  var key = _step7.value;
                  var pathValue = pathInput[key];
                  var pathItem = {
                    type: "unknown",
                    origin: "value",
                    input: pathInput,
                    key: key,
                    value: pathValue
                  };
                  if (issue.path) {
                    issue.path.push(pathItem);
                  } else {
                    issue.path = [pathItem];
                  }
                  if (!pathValue) {
                    break;
                  }
                  pathInput = pathValue;
                }
              } catch (err) {
                _iterator7.e(err);
              } finally {
                _iterator7.f();
              }
            }
          }
        } catch (err) {
          _iterator6.e(err);
        } finally {
          _iterator6.f();
        }
      }
      return dataset;
    }
  });
}

// src/methods/forward/forwardAsync.ts
function forwardAsync(action, pathKeys) {
  return _objectSpread(_objectSpread({}, action), {}, {
    async: true,
    _run: function _run(dataset, config2) {
      return _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee8() {
        var prevIssues, _iterator8, _step8, issue, pathInput, _iterator9, _step9, key, pathValue, pathItem;
        return _regeneratorRuntime().wrap(function _callee8$(_context8) {
          while (1) switch (_context8.prev = _context8.next) {
            case 0:
              prevIssues = dataset.issues && _toConsumableArray(dataset.issues);
              _context8.next = 3;
              return action._run(dataset, config2);
            case 3:
              if (!dataset.issues) {
                _context8.next = 42;
                break;
              }
              _iterator8 = _createForOfIteratorHelper(dataset.issues);
              _context8.prev = 5;
              _iterator8.s();
            case 7:
              if ((_step8 = _iterator8.n()).done) {
                _context8.next = 34;
                break;
              }
              issue = _step8.value;
              if (prevIssues !== null && prevIssues !== void 0 && prevIssues.includes(issue)) {
                _context8.next = 32;
                break;
              }
              pathInput = dataset.value;
              _iterator9 = _createForOfIteratorHelper(pathKeys);
              _context8.prev = 12;
              _iterator9.s();
            case 14:
              if ((_step9 = _iterator9.n()).done) {
                _context8.next = 24;
                break;
              }
              key = _step9.value;
              pathValue = pathInput[key];
              pathItem = {
                type: "unknown",
                origin: "value",
                input: pathInput,
                key: key,
                value: pathValue
              };
              if (issue.path) {
                issue.path.push(pathItem);
              } else {
                issue.path = [pathItem];
              }
              if (pathValue) {
                _context8.next = 21;
                break;
              }
              return _context8.abrupt("break", 24);
            case 21:
              pathInput = pathValue;
            case 22:
              _context8.next = 14;
              break;
            case 24:
              _context8.next = 29;
              break;
            case 26:
              _context8.prev = 26;
              _context8.t0 = _context8["catch"](12);
              _iterator9.e(_context8.t0);
            case 29:
              _context8.prev = 29;
              _iterator9.f();
              return _context8.finish(29);
            case 32:
              _context8.next = 7;
              break;
            case 34:
              _context8.next = 39;
              break;
            case 36:
              _context8.prev = 36;
              _context8.t1 = _context8["catch"](5);
              _iterator8.e(_context8.t1);
            case 39:
              _context8.prev = 39;
              _iterator8.f();
              return _context8.finish(39);
            case 42:
              return _context8.abrupt("return", dataset);
            case 43:
            case "end":
              return _context8.stop();
          }
        }, _callee8, null, [[5, 36, 39, 42], [12, 26, 29, 32]]);
      }))();
    }
  });
}

// src/methods/getDefault/getDefault.ts
function getDefault(schema, dataset, config2) {
  return typeof schema["default"] === "function" ?
  // @ts-expect-error
  schema["default"](dataset, config2) :
  // @ts-expect-error
  schema["default"];
}

// src/methods/getDefaults/getDefaults.ts
function getDefaults(schema) {
  if ("entries" in schema) {
    var object2 = {};
    for (var key in schema.entries) {
      object2[key] = getDefaults(schema.entries[key]);
    }
    return object2;
  }
  if ("items" in schema) {
    return schema.items.map(getDefaults);
  }
  return getDefault(schema);
}

// src/methods/getDefaults/getDefaultsAsync.ts
function getDefaultsAsync(_x) {
  return _getDefaultsAsync.apply(this, arguments);
} // src/methods/getFallbacks/getFallbacks.ts
function _getDefaultsAsync() {
  _getDefaultsAsync = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee45(schema) {
    return _regeneratorRuntime().wrap(function _callee45$(_context45) {
      while (1) switch (_context45.prev = _context45.next) {
        case 0:
          if (!("entries" in schema)) {
            _context45.next = 6;
            break;
          }
          _context45.t0 = Object;
          _context45.next = 4;
          return Promise.all(Object.entries(schema.entries).map(/*#__PURE__*/function () {
            var _ref41 = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee44(_ref40) {
              var _ref42, key, value2;
              return _regeneratorRuntime().wrap(function _callee44$(_context44) {
                while (1) switch (_context44.prev = _context44.next) {
                  case 0:
                    _ref42 = _slicedToArray(_ref40, 2), key = _ref42[0], value2 = _ref42[1];
                    _context44.t0 = key;
                    _context44.next = 4;
                    return getDefaultsAsync(value2);
                  case 4:
                    _context44.t1 = _context44.sent;
                    return _context44.abrupt("return", [_context44.t0, _context44.t1]);
                  case 6:
                  case "end":
                    return _context44.stop();
                }
              }, _callee44);
            }));
            return function (_x25) {
              return _ref41.apply(this, arguments);
            };
          }()));
        case 4:
          _context45.t1 = _context45.sent;
          return _context45.abrupt("return", _context45.t0.fromEntries.call(_context45.t0, _context45.t1));
        case 6:
          if (!("items" in schema)) {
            _context45.next = 8;
            break;
          }
          return _context45.abrupt("return", Promise.all(schema.items.map(getDefaultsAsync)));
        case 8:
          return _context45.abrupt("return", getDefault(schema));
        case 9:
        case "end":
          return _context45.stop();
      }
    }, _callee45);
  }));
  return _getDefaultsAsync.apply(this, arguments);
}
function getFallbacks(schema) {
  if ("entries" in schema) {
    var object2 = {};
    for (var key in schema.entries) {
      object2[key] = getFallbacks(schema.entries[key]);
    }
    return object2;
  }
  if ("items" in schema) {
    return schema.items.map(getFallbacks);
  }
  return getFallback(schema);
}

// src/methods/getFallbacks/getFallbacksAsync.ts
function getFallbacksAsync(_x2) {
  return _getFallbacksAsync.apply(this, arguments);
} // src/methods/is/is.ts
function _getFallbacksAsync() {
  _getFallbacksAsync = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee47(schema) {
    return _regeneratorRuntime().wrap(function _callee47$(_context47) {
      while (1) switch (_context47.prev = _context47.next) {
        case 0:
          if (!("entries" in schema)) {
            _context47.next = 6;
            break;
          }
          _context47.t0 = Object;
          _context47.next = 4;
          return Promise.all(Object.entries(schema.entries).map(/*#__PURE__*/function () {
            var _ref44 = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee46(_ref43) {
              var _ref45, key, value2;
              return _regeneratorRuntime().wrap(function _callee46$(_context46) {
                while (1) switch (_context46.prev = _context46.next) {
                  case 0:
                    _ref45 = _slicedToArray(_ref43, 2), key = _ref45[0], value2 = _ref45[1];
                    _context46.t0 = key;
                    _context46.next = 4;
                    return getFallbacksAsync(value2);
                  case 4:
                    _context46.t1 = _context46.sent;
                    return _context46.abrupt("return", [_context46.t0, _context46.t1]);
                  case 6:
                  case "end":
                    return _context46.stop();
                }
              }, _callee46);
            }));
            return function (_x26) {
              return _ref44.apply(this, arguments);
            };
          }()));
        case 4:
          _context47.t1 = _context47.sent;
          return _context47.abrupt("return", _context47.t0.fromEntries.call(_context47.t0, _context47.t1));
        case 6:
          if (!("items" in schema)) {
            _context47.next = 8;
            break;
          }
          return _context47.abrupt("return", Promise.all(schema.items.map(getFallbacksAsync)));
        case 8:
          return _context47.abrupt("return", getFallback(schema));
        case 9:
        case "end":
          return _context47.stop();
      }
    }, _callee47);
  }));
  return _getFallbacksAsync.apply(this, arguments);
}
function is(schema, input) {
  return !schema._run({
    typed: false,
    value: input
  }, {
    abortEarly: true
  }).issues;
}

// src/schemas/any/any.ts
function any() {
  return {
    kind: "schema",
    type: "any",
    reference: any,
    expects: "any",
    async: false,
    _run: function _run(dataset) {
      dataset.typed = true;
      return dataset;
    }
  };
}

// src/schemas/array/array.ts
function array(item, message) {
  return {
    kind: "schema",
    type: "array",
    reference: array,
    expects: "Array",
    async: false,
    item: item,
    message: message,
    _run: function _run(dataset, config2) {
      var input = dataset.value;
      if (Array.isArray(input)) {
        dataset.typed = true;
        dataset.value = [];
        for (var key = 0; key < input.length; key++) {
          var value2 = input[key];
          var itemDataset = this.item._run({
            typed: false,
            value: value2
          }, config2);
          if (itemDataset.issues) {
            var pathItem = {
              type: "array",
              origin: "value",
              input: input,
              key: key,
              value: value2
            };
            var _iterator10 = _createForOfIteratorHelper(itemDataset.issues),
              _step10;
            try {
              for (_iterator10.s(); !(_step10 = _iterator10.n()).done;) {
                var _dataset$issues;
                var issue = _step10.value;
                if (issue.path) {
                  issue.path.unshift(pathItem);
                } else {
                  issue.path = [pathItem];
                }
                (_dataset$issues = dataset.issues) === null || _dataset$issues === void 0 || _dataset$issues.push(issue);
              }
            } catch (err) {
              _iterator10.e(err);
            } finally {
              _iterator10.f();
            }
            if (!dataset.issues) {
              dataset.issues = itemDataset.issues;
            }
            if (config2.abortEarly) {
              dataset.typed = false;
              break;
            }
          }
          if (!itemDataset.typed) {
            dataset.typed = false;
          }
          dataset.value.push(itemDataset.value);
        }
      } else {
        _addIssue(this, "type", dataset, config2);
      }
      return dataset;
    }
  };
}

// src/schemas/array/arrayAsync.ts
function arrayAsync(item, message) {
  return {
    kind: "schema",
    type: "array",
    reference: arrayAsync,
    expects: "Array",
    async: true,
    item: item,
    message: message,
    _run: function _run(dataset, config2) {
      var _this10 = this;
      return _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee9() {
        var input, itemDatasets, key, itemDataset, pathItem, _iterator11, _step11, _dataset$issues2, issue;
        return _regeneratorRuntime().wrap(function _callee9$(_context9) {
          while (1) switch (_context9.prev = _context9.next) {
            case 0:
              input = dataset.value;
              if (!Array.isArray(input)) {
                _context9.next = 25;
                break;
              }
              dataset.typed = true;
              dataset.value = [];
              _context9.next = 6;
              return Promise.all(input.map(function (value2) {
                return _this10.item._run({
                  typed: false,
                  value: value2
                }, config2);
              }));
            case 6:
              itemDatasets = _context9.sent;
              key = 0;
            case 8:
              if (!(key < itemDatasets.length)) {
                _context9.next = 23;
                break;
              }
              itemDataset = itemDatasets[key];
              if (!itemDataset.issues) {
                _context9.next = 18;
                break;
              }
              pathItem = {
                type: "array",
                origin: "value",
                input: input,
                key: key,
                value: input[key]
              };
              _iterator11 = _createForOfIteratorHelper(itemDataset.issues);
              try {
                for (_iterator11.s(); !(_step11 = _iterator11.n()).done;) {
                  issue = _step11.value;
                  if (issue.path) {
                    issue.path.unshift(pathItem);
                  } else {
                    issue.path = [pathItem];
                  }
                  (_dataset$issues2 = dataset.issues) === null || _dataset$issues2 === void 0 || _dataset$issues2.push(issue);
                }
              } catch (err) {
                _iterator11.e(err);
              } finally {
                _iterator11.f();
              }
              if (!dataset.issues) {
                dataset.issues = itemDataset.issues;
              }
              if (!config2.abortEarly) {
                _context9.next = 18;
                break;
              }
              dataset.typed = false;
              return _context9.abrupt("break", 23);
            case 18:
              if (!itemDataset.typed) {
                dataset.typed = false;
              }
              dataset.value.push(itemDataset.value);
            case 20:
              key++;
              _context9.next = 8;
              break;
            case 23:
              _context9.next = 26;
              break;
            case 25:
              _addIssue(_this10, "type", dataset, config2);
            case 26:
              return _context9.abrupt("return", dataset);
            case 27:
            case "end":
              return _context9.stop();
          }
        }, _callee9);
      }))();
    }
  };
}

// src/schemas/bigint/bigint.ts
function bigint(message) {
  return {
    kind: "schema",
    type: "bigint",
    reference: bigint,
    expects: "bigint",
    async: false,
    message: message,
    _run: function _run(dataset, config2) {
      if (typeof dataset.value === "bigint") {
        dataset.typed = true;
      } else {
        _addIssue(this, "type", dataset, config2);
      }
      return dataset;
    }
  };
}

// src/schemas/blob/blob.ts
function blob(message) {
  return {
    kind: "schema",
    type: "blob",
    reference: blob,
    expects: "Blob",
    async: false,
    message: message,
    _run: function _run(dataset, config2) {
      if (dataset.value instanceof Blob) {
        dataset.typed = true;
      } else {
        _addIssue(this, "type", dataset, config2);
      }
      return dataset;
    }
  };
}

// src/schemas/boolean/boolean.ts
function _boolean(message) {
  return {
    kind: "schema",
    type: "boolean",
    reference: _boolean,
    expects: "boolean",
    async: false,
    message: message,
    _run: function _run(dataset, config2) {
      if (typeof dataset.value === "boolean") {
        dataset.typed = true;
      } else {
        _addIssue(this, "type", dataset, config2);
      }
      return dataset;
    }
  };
}

// src/schemas/custom/custom.ts
function custom(check2, message) {
  return {
    kind: "schema",
    type: "custom",
    reference: custom,
    expects: "unknown",
    async: false,
    check: check2,
    message: message,
    _run: function _run(dataset, config2) {
      if (this.check(dataset.value)) {
        dataset.typed = true;
      } else {
        _addIssue(this, "type", dataset, config2);
      }
      return dataset;
    }
  };
}

// src/schemas/custom/customAsync.ts
function customAsync(check2, message) {
  return {
    kind: "schema",
    type: "custom",
    reference: customAsync,
    expects: "unknown",
    async: true,
    check: check2,
    message: message,
    _run: function _run(dataset, config2) {
      var _this11 = this;
      return _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee10() {
        return _regeneratorRuntime().wrap(function _callee10$(_context10) {
          while (1) switch (_context10.prev = _context10.next) {
            case 0:
              _context10.next = 2;
              return _this11.check(dataset.value);
            case 2:
              if (!_context10.sent) {
                _context10.next = 6;
                break;
              }
              dataset.typed = true;
              _context10.next = 7;
              break;
            case 6:
              _addIssue(_this11, "type", dataset, config2);
            case 7:
              return _context10.abrupt("return", dataset);
            case 8:
            case "end":
              return _context10.stop();
          }
        }, _callee10);
      }))();
    }
  };
}

// src/schemas/date/date.ts
function date(message) {
  return {
    kind: "schema",
    type: "date",
    reference: date,
    expects: "Date",
    async: false,
    message: message,
    _run: function _run(dataset, config2) {
      if (dataset.value instanceof Date) {
        if (!isNaN(dataset.value)) {
          dataset.typed = true;
        } else {
          _addIssue(this, "type", dataset, config2, {
            received: '"Invalid Date"'
          });
        }
      } else {
        _addIssue(this, "type", dataset, config2);
      }
      return dataset;
    }
  };
}

// src/schemas/enum/enum.ts
function enum_(enum__, message) {
  var options = Object.entries(enum__).filter(function (_ref7) {
    var _ref8 = _slicedToArray(_ref7, 1),
      key = _ref8[0];
    return isNaN(+key);
  }).map(function (_ref9) {
    var _ref10 = _slicedToArray(_ref9, 2),
      value2 = _ref10[1];
    return value2;
  });
  return {
    kind: "schema",
    type: "enum",
    reference: enum_,
    expects: _joinExpects(options.map(_stringify), "|"),
    async: false,
    "enum": enum__,
    options: options,
    message: message,
    _run: function _run(dataset, config2) {
      if (this.options.includes(dataset.value)) {
        dataset.typed = true;
      } else {
        _addIssue(this, "type", dataset, config2);
      }
      return dataset;
    }
  };
}

// src/schemas/file/file.ts
function file(message) {
  return {
    kind: "schema",
    type: "file",
    reference: file,
    expects: "File",
    async: false,
    message: message,
    _run: function _run(dataset, config2) {
      if (dataset.value instanceof File) {
        dataset.typed = true;
      } else {
        _addIssue(this, "type", dataset, config2);
      }
      return dataset;
    }
  };
}

// src/schemas/function/function.ts
function function_(message) {
  return {
    kind: "schema",
    type: "function",
    reference: function_,
    expects: "Function",
    async: false,
    message: message,
    _run: function _run(dataset, config2) {
      if (typeof dataset.value === "function") {
        dataset.typed = true;
      } else {
        _addIssue(this, "type", dataset, config2);
      }
      return dataset;
    }
  };
}

// src/schemas/instance/instance.ts
function instance(class_, message) {
  return {
    kind: "schema",
    type: "instance",
    reference: instance,
    expects: class_.name,
    async: false,
    "class": class_,
    message: message,
    _run: function _run(dataset, config2) {
      if (dataset.value instanceof this["class"]) {
        dataset.typed = true;
      } else {
        _addIssue(this, "type", dataset, config2);
      }
      return dataset;
    }
  };
}

// src/schemas/intersect/utils/_merge/_merge.ts
function _merge(value1, value2) {
  if (_typeof(value1) === _typeof(value2)) {
    if (value1 === value2 || value1 instanceof Date && value2 instanceof Date && +value1 === +value2) {
      return {
        value: value1
      };
    }
    if (value1 && value2 && value1.constructor === Object && value2.constructor === Object) {
      for (var key in value2) {
        if (key in value1) {
          var dataset = _merge(value1[key], value2[key]);
          if (dataset.issue) {
            return dataset;
          }
          value1[key] = dataset.value;
        } else {
          value1[key] = value2[key];
        }
      }
      return {
        value: value1
      };
    }
    if (Array.isArray(value1) && Array.isArray(value2)) {
      if (value1.length === value2.length) {
        for (var index = 0; index < value1.length; index++) {
          var _dataset = _merge(value1[index], value2[index]);
          if (_dataset.issue) {
            return _dataset;
          }
          value1[index] = _dataset.value;
        }
        return {
          value: value1
        };
      }
    }
  }
  return {
    issue: true
  };
}

// src/schemas/intersect/intersect.ts
function intersect(options, message) {
  return {
    kind: "schema",
    type: "intersect",
    reference: intersect,
    expects: _joinExpects(options.map(function (option) {
      return option.expects;
    }), "&"),
    async: false,
    options: options,
    message: message,
    _run: function _run(dataset, config2) {
      if (this.options.length) {
        var input = dataset.value;
        var outputs;
        dataset.typed = true;
        var _iterator12 = _createForOfIteratorHelper(this.options),
          _step12;
        try {
          for (_iterator12.s(); !(_step12 = _iterator12.n()).done;) {
            var schema = _step12.value;
            var optionDataset = schema._run({
              typed: false,
              value: input
            }, config2);
            if (optionDataset.issues) {
              if (dataset.issues) {
                var _dataset$issues3;
                (_dataset$issues3 = dataset.issues).push.apply(_dataset$issues3, _toConsumableArray(optionDataset.issues));
              } else {
                dataset.issues = optionDataset.issues;
              }
              if (config2.abortEarly) {
                dataset.typed = false;
                break;
              }
            }
            if (!optionDataset.typed) {
              dataset.typed = false;
            }
            if (dataset.typed) {
              if (outputs) {
                outputs.push(optionDataset.value);
              } else {
                outputs = [optionDataset.value];
              }
            }
          }
        } catch (err) {
          _iterator12.e(err);
        } finally {
          _iterator12.f();
        }
        if (dataset.typed) {
          dataset.value = outputs[0];
          for (var index = 1; index < outputs.length; index++) {
            var mergeDataset = _merge(dataset.value, outputs[index]);
            if (mergeDataset.issue) {
              _addIssue(this, "type", dataset, config2, {
                received: "unknown"
              });
              break;
            }
            dataset.value = mergeDataset.value;
          }
        }
      } else {
        _addIssue(this, "type", dataset, config2);
      }
      return dataset;
    }
  };
}

// src/schemas/intersect/intersectAsync.ts
function intersectAsync(options, message) {
  return {
    kind: "schema",
    type: "intersect",
    reference: intersectAsync,
    expects: _joinExpects(options.map(function (option) {
      return option.expects;
    }), "&"),
    async: true,
    options: options,
    message: message,
    _run: function _run(dataset, config2) {
      var _this12 = this;
      return _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee11() {
        var input, outputs, optionDatasets, _iterator13, _step13, optionDataset, _dataset$issues4, index, mergeDataset;
        return _regeneratorRuntime().wrap(function _callee11$(_context11) {
          while (1) switch (_context11.prev = _context11.next) {
            case 0:
              if (!_this12.options.length) {
                _context11.next = 42;
                break;
              }
              input = dataset.value;
              dataset.typed = true;
              _context11.next = 5;
              return Promise.all(_this12.options.map(function (schema) {
                return schema._run({
                  typed: false,
                  value: input
                }, config2);
              }));
            case 5:
              optionDatasets = _context11.sent;
              _iterator13 = _createForOfIteratorHelper(optionDatasets);
              _context11.prev = 7;
              _iterator13.s();
            case 9:
              if ((_step13 = _iterator13.n()).done) {
                _context11.next = 20;
                break;
              }
              optionDataset = _step13.value;
              if (!optionDataset.issues) {
                _context11.next = 16;
                break;
              }
              if (dataset.issues) {
                (_dataset$issues4 = dataset.issues).push.apply(_dataset$issues4, _toConsumableArray(optionDataset.issues));
              } else {
                dataset.issues = optionDataset.issues;
              }
              if (!config2.abortEarly) {
                _context11.next = 16;
                break;
              }
              dataset.typed = false;
              return _context11.abrupt("break", 20);
            case 16:
              if (!optionDataset.typed) {
                dataset.typed = false;
              }
              if (dataset.typed) {
                if (outputs) {
                  outputs.push(optionDataset.value);
                } else {
                  outputs = [optionDataset.value];
                }
              }
            case 18:
              _context11.next = 9;
              break;
            case 20:
              _context11.next = 25;
              break;
            case 22:
              _context11.prev = 22;
              _context11.t0 = _context11["catch"](7);
              _iterator13.e(_context11.t0);
            case 25:
              _context11.prev = 25;
              _iterator13.f();
              return _context11.finish(25);
            case 28:
              if (!dataset.typed) {
                _context11.next = 40;
                break;
              }
              dataset.value = outputs[0];
              index = 1;
            case 31:
              if (!(index < outputs.length)) {
                _context11.next = 40;
                break;
              }
              mergeDataset = _merge(dataset.value, outputs[index]);
              if (!mergeDataset.issue) {
                _context11.next = 36;
                break;
              }
              _addIssue(_this12, "type", dataset, config2, {
                received: "unknown"
              });
              return _context11.abrupt("break", 40);
            case 36:
              dataset.value = mergeDataset.value;
            case 37:
              index++;
              _context11.next = 31;
              break;
            case 40:
              _context11.next = 43;
              break;
            case 42:
              _addIssue(_this12, "type", dataset, config2);
            case 43:
              return _context11.abrupt("return", dataset);
            case 44:
            case "end":
              return _context11.stop();
          }
        }, _callee11, null, [[7, 22, 25, 28]]);
      }))();
    }
  };
}

// src/schemas/lazy/lazy.ts
function lazy(getter) {
  return {
    kind: "schema",
    type: "lazy",
    reference: lazy,
    expects: "unknown",
    async: false,
    getter: getter,
    _run: function _run(dataset, config2) {
      return this.getter(dataset.value)._run(dataset, config2);
    }
  };
}

// src/schemas/lazy/lazyAsync.ts
function lazyAsync(getter) {
  return {
    kind: "schema",
    type: "lazy",
    reference: lazyAsync,
    expects: "unknown",
    async: true,
    getter: getter,
    _run: function _run(dataset, config2) {
      var _this13 = this;
      return _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee12() {
        return _regeneratorRuntime().wrap(function _callee12$(_context12) {
          while (1) switch (_context12.prev = _context12.next) {
            case 0:
              _context12.next = 2;
              return _this13.getter(dataset.value);
            case 2:
              return _context12.abrupt("return", _context12.sent._run(dataset, config2));
            case 3:
            case "end":
              return _context12.stop();
          }
        }, _callee12);
      }))();
    }
  };
}

// src/schemas/literal/literal.ts
function literal(literal_, message) {
  return {
    kind: "schema",
    type: "literal",
    reference: literal,
    expects: _stringify(literal_),
    async: false,
    literal: literal_,
    message: message,
    _run: function _run(dataset, config2) {
      if (dataset.value === this.literal) {
        dataset.typed = true;
      } else {
        _addIssue(this, "type", dataset, config2);
      }
      return dataset;
    }
  };
}

// src/schemas/looseObject/looseObject.ts
function looseObject(entries, message) {
  return {
    kind: "schema",
    type: "loose_object",
    reference: looseObject,
    expects: "Object",
    async: false,
    entries: entries,
    message: message,
    _run: function _run(dataset, config2) {
      var input = dataset.value;
      if (input && _typeof(input) === "object") {
        dataset.typed = true;
        dataset.value = {};
        for (var key in this.entries) {
          var value2 = input[key];
          var valueDataset = this.entries[key]._run({
            typed: false,
            value: value2
          }, config2);
          if (valueDataset.issues) {
            var pathItem = {
              type: "object",
              origin: "value",
              input: input,
              key: key,
              value: value2
            };
            var _iterator14 = _createForOfIteratorHelper(valueDataset.issues),
              _step14;
            try {
              for (_iterator14.s(); !(_step14 = _iterator14.n()).done;) {
                var _dataset$issues5;
                var issue = _step14.value;
                if (issue.path) {
                  issue.path.unshift(pathItem);
                } else {
                  issue.path = [pathItem];
                }
                (_dataset$issues5 = dataset.issues) === null || _dataset$issues5 === void 0 || _dataset$issues5.push(issue);
              }
            } catch (err) {
              _iterator14.e(err);
            } finally {
              _iterator14.f();
            }
            if (!dataset.issues) {
              dataset.issues = valueDataset.issues;
            }
            if (config2.abortEarly) {
              dataset.typed = false;
              break;
            }
          }
          if (!valueDataset.typed) {
            dataset.typed = false;
          }
          if (valueDataset.value !== void 0 || key in input) {
            dataset.value[key] = valueDataset.value;
          }
        }
        if (!dataset.issues || !config2.abortEarly) {
          for (var _key in input) {
            if (_isValidObjectKey(input, _key) && !(_key in this.entries)) {
              dataset.value[_key] = input[_key];
            }
          }
        }
      } else {
        _addIssue(this, "type", dataset, config2);
      }
      return dataset;
    }
  };
}

// src/schemas/looseObject/looseObjectAsync.ts
function looseObjectAsync(entries, message) {
  return {
    kind: "schema",
    type: "loose_object",
    reference: looseObjectAsync,
    expects: "Object",
    async: true,
    entries: entries,
    message: message,
    _run: function _run(dataset, config2) {
      var _this14 = this;
      return _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee14() {
        var input, valueDatasets, _iterator15, _step15, _step15$value, _key2, value2, valueDataset, pathItem, _iterator16, _step16, _dataset$issues6, issue, key;
        return _regeneratorRuntime().wrap(function _callee14$(_context14) {
          while (1) switch (_context14.prev = _context14.next) {
            case 0:
              input = dataset.value;
              if (!(input && _typeof(input) === "object")) {
                _context14.next = 35;
                break;
              }
              dataset.typed = true;
              dataset.value = {};
              _context14.next = 6;
              return Promise.all(Object.entries(_this14.entries).map(/*#__PURE__*/function () {
                var _ref12 = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee13(_ref11) {
                  var _ref13, key, schema, value2;
                  return _regeneratorRuntime().wrap(function _callee13$(_context13) {
                    while (1) switch (_context13.prev = _context13.next) {
                      case 0:
                        _ref13 = _slicedToArray(_ref11, 2), key = _ref13[0], schema = _ref13[1];
                        value2 = input[key];
                        _context13.t0 = key;
                        _context13.t1 = value2;
                        _context13.next = 6;
                        return schema._run({
                          typed: false,
                          value: value2
                        }, config2);
                      case 6:
                        _context13.t2 = _context13.sent;
                        return _context13.abrupt("return", [_context13.t0, _context13.t1, _context13.t2]);
                      case 8:
                      case "end":
                        return _context13.stop();
                    }
                  }, _callee13);
                }));
                return function (_x3) {
                  return _ref12.apply(this, arguments);
                };
              }()));
            case 6:
              valueDatasets = _context14.sent;
              _iterator15 = _createForOfIteratorHelper(valueDatasets);
              _context14.prev = 8;
              _iterator15.s();
            case 10:
              if ((_step15 = _iterator15.n()).done) {
                _context14.next = 24;
                break;
              }
              _step15$value = _slicedToArray(_step15.value, 3), _key2 = _step15$value[0], value2 = _step15$value[1], valueDataset = _step15$value[2];
              if (!valueDataset.issues) {
                _context14.next = 20;
                break;
              }
              pathItem = {
                type: "object",
                origin: "value",
                input: input,
                key: _key2,
                value: value2
              };
              _iterator16 = _createForOfIteratorHelper(valueDataset.issues);
              try {
                for (_iterator16.s(); !(_step16 = _iterator16.n()).done;) {
                  issue = _step16.value;
                  if (issue.path) {
                    issue.path.unshift(pathItem);
                  } else {
                    issue.path = [pathItem];
                  }
                  (_dataset$issues6 = dataset.issues) === null || _dataset$issues6 === void 0 || _dataset$issues6.push(issue);
                }
              } catch (err) {
                _iterator16.e(err);
              } finally {
                _iterator16.f();
              }
              if (!dataset.issues) {
                dataset.issues = valueDataset.issues;
              }
              if (!config2.abortEarly) {
                _context14.next = 20;
                break;
              }
              dataset.typed = false;
              return _context14.abrupt("break", 24);
            case 20:
              if (!valueDataset.typed) {
                dataset.typed = false;
              }
              if (valueDataset.value !== void 0 || _key2 in input) {
                dataset.value[_key2] = valueDataset.value;
              }
            case 22:
              _context14.next = 10;
              break;
            case 24:
              _context14.next = 29;
              break;
            case 26:
              _context14.prev = 26;
              _context14.t0 = _context14["catch"](8);
              _iterator15.e(_context14.t0);
            case 29:
              _context14.prev = 29;
              _iterator15.f();
              return _context14.finish(29);
            case 32:
              if (!dataset.issues || !config2.abortEarly) {
                for (key in input) {
                  if (_isValidObjectKey(input, key) && !(key in _this14.entries)) {
                    dataset.value[key] = input[key];
                  }
                }
              }
              _context14.next = 36;
              break;
            case 35:
              _addIssue(_this14, "type", dataset, config2);
            case 36:
              return _context14.abrupt("return", dataset);
            case 37:
            case "end":
              return _context14.stop();
          }
        }, _callee14, null, [[8, 26, 29, 32]]);
      }))();
    }
  };
}

// src/schemas/looseTuple/looseTuple.ts
function looseTuple(items, message) {
  return {
    kind: "schema",
    type: "loose_tuple",
    reference: looseTuple,
    expects: "Array",
    async: false,
    items: items,
    message: message,
    _run: function _run(dataset, config2) {
      var input = dataset.value;
      if (Array.isArray(input)) {
        dataset.typed = true;
        dataset.value = [];
        for (var key = 0; key < this.items.length; key++) {
          var value2 = input[key];
          var itemDataset = this.items[key]._run({
            typed: false,
            value: value2
          }, config2);
          if (itemDataset.issues) {
            var pathItem = {
              type: "array",
              origin: "value",
              input: input,
              key: key,
              value: value2
            };
            var _iterator17 = _createForOfIteratorHelper(itemDataset.issues),
              _step17;
            try {
              for (_iterator17.s(); !(_step17 = _iterator17.n()).done;) {
                var _dataset$issues7;
                var issue = _step17.value;
                if (issue.path) {
                  issue.path.unshift(pathItem);
                } else {
                  issue.path = [pathItem];
                }
                (_dataset$issues7 = dataset.issues) === null || _dataset$issues7 === void 0 || _dataset$issues7.push(issue);
              }
            } catch (err) {
              _iterator17.e(err);
            } finally {
              _iterator17.f();
            }
            if (!dataset.issues) {
              dataset.issues = itemDataset.issues;
            }
            if (config2.abortEarly) {
              dataset.typed = false;
              break;
            }
          }
          if (!itemDataset.typed) {
            dataset.typed = false;
          }
          dataset.value.push(itemDataset.value);
        }
        if (!dataset.issues || !config2.abortEarly) {
          for (var _key3 = this.items.length; _key3 < input.length; _key3++) {
            dataset.value.push(input[_key3]);
          }
        }
      } else {
        _addIssue(this, "type", dataset, config2);
      }
      return dataset;
    }
  };
}

// src/schemas/looseTuple/looseTupleAsync.ts
function looseTupleAsync(items, message) {
  return {
    kind: "schema",
    type: "loose_tuple",
    reference: looseTupleAsync,
    expects: "Array",
    async: true,
    items: items,
    message: message,
    _run: function _run(dataset, config2) {
      var _this15 = this;
      return _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee16() {
        var input, itemDatasets, _iterator18, _step18, _step18$value, _key4, value2, itemDataset, pathItem, _iterator19, _step19, _dataset$issues8, issue, key;
        return _regeneratorRuntime().wrap(function _callee16$(_context16) {
          while (1) switch (_context16.prev = _context16.next) {
            case 0:
              input = dataset.value;
              if (!Array.isArray(input)) {
                _context16.next = 35;
                break;
              }
              dataset.typed = true;
              dataset.value = [];
              _context16.next = 6;
              return Promise.all(_this15.items.map(/*#__PURE__*/function () {
                var _ref14 = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee15(item, key) {
                  var value2;
                  return _regeneratorRuntime().wrap(function _callee15$(_context15) {
                    while (1) switch (_context15.prev = _context15.next) {
                      case 0:
                        value2 = input[key];
                        _context15.t0 = key;
                        _context15.t1 = value2;
                        _context15.next = 5;
                        return item._run({
                          typed: false,
                          value: value2
                        }, config2);
                      case 5:
                        _context15.t2 = _context15.sent;
                        return _context15.abrupt("return", [_context15.t0, _context15.t1, _context15.t2]);
                      case 7:
                      case "end":
                        return _context15.stop();
                    }
                  }, _callee15);
                }));
                return function (_x4, _x5) {
                  return _ref14.apply(this, arguments);
                };
              }()));
            case 6:
              itemDatasets = _context16.sent;
              _iterator18 = _createForOfIteratorHelper(itemDatasets);
              _context16.prev = 8;
              _iterator18.s();
            case 10:
              if ((_step18 = _iterator18.n()).done) {
                _context16.next = 24;
                break;
              }
              _step18$value = _slicedToArray(_step18.value, 3), _key4 = _step18$value[0], value2 = _step18$value[1], itemDataset = _step18$value[2];
              if (!itemDataset.issues) {
                _context16.next = 20;
                break;
              }
              pathItem = {
                type: "array",
                origin: "value",
                input: input,
                key: _key4,
                value: value2
              };
              _iterator19 = _createForOfIteratorHelper(itemDataset.issues);
              try {
                for (_iterator19.s(); !(_step19 = _iterator19.n()).done;) {
                  issue = _step19.value;
                  if (issue.path) {
                    issue.path.unshift(pathItem);
                  } else {
                    issue.path = [pathItem];
                  }
                  (_dataset$issues8 = dataset.issues) === null || _dataset$issues8 === void 0 || _dataset$issues8.push(issue);
                }
              } catch (err) {
                _iterator19.e(err);
              } finally {
                _iterator19.f();
              }
              if (!dataset.issues) {
                dataset.issues = itemDataset.issues;
              }
              if (!config2.abortEarly) {
                _context16.next = 20;
                break;
              }
              dataset.typed = false;
              return _context16.abrupt("break", 24);
            case 20:
              if (!itemDataset.typed) {
                dataset.typed = false;
              }
              dataset.value.push(itemDataset.value);
            case 22:
              _context16.next = 10;
              break;
            case 24:
              _context16.next = 29;
              break;
            case 26:
              _context16.prev = 26;
              _context16.t0 = _context16["catch"](8);
              _iterator18.e(_context16.t0);
            case 29:
              _context16.prev = 29;
              _iterator18.f();
              return _context16.finish(29);
            case 32:
              if (!dataset.issues || !config2.abortEarly) {
                for (key = _this15.items.length; key < input.length; key++) {
                  dataset.value.push(input[key]);
                }
              }
              _context16.next = 36;
              break;
            case 35:
              _addIssue(_this15, "type", dataset, config2);
            case 36:
              return _context16.abrupt("return", dataset);
            case 37:
            case "end":
              return _context16.stop();
          }
        }, _callee16, null, [[8, 26, 29, 32]]);
      }))();
    }
  };
}

// src/schemas/map/map.ts
function map(key, value2, message) {
  return {
    kind: "schema",
    type: "map",
    reference: map,
    expects: "Map",
    async: false,
    key: key,
    value: value2,
    message: message,
    _run: function _run(dataset, config2) {
      var input = dataset.value;
      if (input instanceof Map) {
        dataset.typed = true;
        dataset.value = /* @__PURE__ */new Map();
        var _iterator20 = _createForOfIteratorHelper(input),
          _step20;
        try {
          for (_iterator20.s(); !(_step20 = _iterator20.n()).done;) {
            var _step20$value = _slicedToArray(_step20.value, 2),
              inputKey = _step20$value[0],
              inputValue = _step20$value[1];
            var keyDataset = this.key._run({
              typed: false,
              value: inputKey
            }, config2);
            if (keyDataset.issues) {
              var pathItem = {
                type: "map",
                origin: "key",
                input: input,
                key: inputKey,
                value: inputValue
              };
              var _iterator21 = _createForOfIteratorHelper(keyDataset.issues),
                _step21;
              try {
                for (_iterator21.s(); !(_step21 = _iterator21.n()).done;) {
                  var _dataset$issues9;
                  var issue = _step21.value;
                  if (issue.path) {
                    issue.path.unshift(pathItem);
                  } else {
                    issue.path = [pathItem];
                  }
                  (_dataset$issues9 = dataset.issues) === null || _dataset$issues9 === void 0 || _dataset$issues9.push(issue);
                }
              } catch (err) {
                _iterator21.e(err);
              } finally {
                _iterator21.f();
              }
              if (!dataset.issues) {
                dataset.issues = keyDataset.issues;
              }
              if (config2.abortEarly) {
                dataset.typed = false;
                break;
              }
            }
            var valueDataset = this.value._run({
              typed: false,
              value: inputValue
            }, config2);
            if (valueDataset.issues) {
              var _pathItem = {
                type: "map",
                origin: "value",
                input: input,
                key: inputKey,
                value: inputValue
              };
              var _iterator22 = _createForOfIteratorHelper(valueDataset.issues),
                _step22;
              try {
                for (_iterator22.s(); !(_step22 = _iterator22.n()).done;) {
                  var _dataset$issues10;
                  var _issue = _step22.value;
                  if (_issue.path) {
                    _issue.path.unshift(_pathItem);
                  } else {
                    _issue.path = [_pathItem];
                  }
                  (_dataset$issues10 = dataset.issues) === null || _dataset$issues10 === void 0 || _dataset$issues10.push(_issue);
                }
              } catch (err) {
                _iterator22.e(err);
              } finally {
                _iterator22.f();
              }
              if (!dataset.issues) {
                dataset.issues = valueDataset.issues;
              }
              if (config2.abortEarly) {
                dataset.typed = false;
                break;
              }
            }
            if (!keyDataset.typed || !valueDataset.typed) {
              dataset.typed = false;
            }
            dataset.value.set(keyDataset.value, valueDataset.value);
          }
        } catch (err) {
          _iterator20.e(err);
        } finally {
          _iterator20.f();
        }
      } else {
        _addIssue(this, "type", dataset, config2);
      }
      return dataset;
    }
  };
}

// src/schemas/map/mapAsync.ts
function mapAsync(key, value2, message) {
  return {
    kind: "schema",
    type: "map",
    reference: mapAsync,
    expects: "Map",
    async: true,
    key: key,
    value: value2,
    message: message,
    _run: function _run(dataset, config2) {
      var _this16 = this;
      return _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee17() {
        var input, datasets, _iterator23, _step23, _step23$value, inputKey, inputValue, keyDataset, valueDataset, pathItem, _iterator24, _step24, _dataset$issues11, issue, _pathItem2, _iterator25, _step25, _dataset$issues12, _issue2;
        return _regeneratorRuntime().wrap(function _callee17$(_context17) {
          while (1) switch (_context17.prev = _context17.next) {
            case 0:
              input = dataset.value;
              if (!(input instanceof Map)) {
                _context17.next = 42;
                break;
              }
              dataset.typed = true;
              dataset.value = /* @__PURE__ */new Map();
              _context17.next = 6;
              return Promise.all(_toConsumableArray(input).map(function (_ref15) {
                var _ref16 = _slicedToArray(_ref15, 2),
                  inputKey = _ref16[0],
                  inputValue = _ref16[1];
                return Promise.all([inputKey, inputValue, _this16.key._run({
                  typed: false,
                  value: inputKey
                }, config2), _this16.value._run({
                  typed: false,
                  value: inputValue
                }, config2)]);
              }));
            case 6:
              datasets = _context17.sent;
              _iterator23 = _createForOfIteratorHelper(datasets);
              _context17.prev = 8;
              _iterator23.s();
            case 10:
              if ((_step23 = _iterator23.n()).done) {
                _context17.next = 32;
                break;
              }
              _step23$value = _slicedToArray(_step23.value, 4), inputKey = _step23$value[0], inputValue = _step23$value[1], keyDataset = _step23$value[2], valueDataset = _step23$value[3];
              if (!keyDataset.issues) {
                _context17.next = 20;
                break;
              }
              pathItem = {
                type: "map",
                origin: "key",
                input: input,
                key: inputKey,
                value: inputValue
              };
              _iterator24 = _createForOfIteratorHelper(keyDataset.issues);
              try {
                for (_iterator24.s(); !(_step24 = _iterator24.n()).done;) {
                  issue = _step24.value;
                  if (issue.path) {
                    issue.path.unshift(pathItem);
                  } else {
                    issue.path = [pathItem];
                  }
                  (_dataset$issues11 = dataset.issues) === null || _dataset$issues11 === void 0 || _dataset$issues11.push(issue);
                }
              } catch (err) {
                _iterator24.e(err);
              } finally {
                _iterator24.f();
              }
              if (!dataset.issues) {
                dataset.issues = keyDataset.issues;
              }
              if (!config2.abortEarly) {
                _context17.next = 20;
                break;
              }
              dataset.typed = false;
              return _context17.abrupt("break", 32);
            case 20:
              if (!valueDataset.issues) {
                _context17.next = 28;
                break;
              }
              _pathItem2 = {
                type: "map",
                origin: "value",
                input: input,
                key: inputKey,
                value: inputValue
              };
              _iterator25 = _createForOfIteratorHelper(valueDataset.issues);
              try {
                for (_iterator25.s(); !(_step25 = _iterator25.n()).done;) {
                  _issue2 = _step25.value;
                  if (_issue2.path) {
                    _issue2.path.unshift(_pathItem2);
                  } else {
                    _issue2.path = [_pathItem2];
                  }
                  (_dataset$issues12 = dataset.issues) === null || _dataset$issues12 === void 0 || _dataset$issues12.push(_issue2);
                }
              } catch (err) {
                _iterator25.e(err);
              } finally {
                _iterator25.f();
              }
              if (!dataset.issues) {
                dataset.issues = valueDataset.issues;
              }
              if (!config2.abortEarly) {
                _context17.next = 28;
                break;
              }
              dataset.typed = false;
              return _context17.abrupt("break", 32);
            case 28:
              if (!keyDataset.typed || !valueDataset.typed) {
                dataset.typed = false;
              }
              dataset.value.set(keyDataset.value, valueDataset.value);
            case 30:
              _context17.next = 10;
              break;
            case 32:
              _context17.next = 37;
              break;
            case 34:
              _context17.prev = 34;
              _context17.t0 = _context17["catch"](8);
              _iterator23.e(_context17.t0);
            case 37:
              _context17.prev = 37;
              _iterator23.f();
              return _context17.finish(37);
            case 40:
              _context17.next = 43;
              break;
            case 42:
              _addIssue(_this16, "type", dataset, config2);
            case 43:
              return _context17.abrupt("return", dataset);
            case 44:
            case "end":
              return _context17.stop();
          }
        }, _callee17, null, [[8, 34, 37, 40]]);
      }))();
    }
  };
}

// src/schemas/nan/nan.ts
function nan(message) {
  return {
    kind: "schema",
    type: "nan",
    reference: nan,
    expects: "NaN",
    async: false,
    message: message,
    _run: function _run(dataset, config2) {
      if (Number.isNaN(dataset.value)) {
        dataset.typed = true;
      } else {
        _addIssue(this, "type", dataset, config2);
      }
      return dataset;
    }
  };
}

// src/schemas/never/never.ts
function never(message) {
  return {
    kind: "schema",
    type: "never",
    reference: never,
    expects: "never",
    async: false,
    message: message,
    _run: function _run(dataset, config2) {
      _addIssue(this, "type", dataset, config2);
      return dataset;
    }
  };
}

// src/schemas/nonNullable/nonNullable.ts
function nonNullable(wrapped, message) {
  return {
    kind: "schema",
    type: "non_nullable",
    reference: nonNullable,
    expects: "!null",
    async: false,
    wrapped: wrapped,
    message: message,
    _run: function _run(dataset, config2) {
      if (dataset.value === null) {
        _addIssue(this, "type", dataset, config2);
        return dataset;
      }
      return this.wrapped._run(dataset, config2);
    }
  };
}

// src/schemas/nonNullable/nonNullableAsync.ts
function nonNullableAsync(wrapped, message) {
  return {
    kind: "schema",
    type: "non_nullable",
    reference: nonNullableAsync,
    expects: "!null",
    async: true,
    wrapped: wrapped,
    message: message,
    _run: function _run(dataset, config2) {
      var _this17 = this;
      return _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee18() {
        return _regeneratorRuntime().wrap(function _callee18$(_context18) {
          while (1) switch (_context18.prev = _context18.next) {
            case 0:
              if (!(dataset.value === null)) {
                _context18.next = 3;
                break;
              }
              _addIssue(_this17, "type", dataset, config2);
              return _context18.abrupt("return", dataset);
            case 3:
              return _context18.abrupt("return", _this17.wrapped._run(dataset, config2));
            case 4:
            case "end":
              return _context18.stop();
          }
        }, _callee18);
      }))();
    }
  };
}

// src/schemas/nonNullish/nonNullish.ts
function nonNullish(wrapped, message) {
  return {
    kind: "schema",
    type: "non_nullish",
    reference: nonNullish,
    expects: "(!null & !undefined)",
    async: false,
    wrapped: wrapped,
    message: message,
    _run: function _run(dataset, config2) {
      if (dataset.value === null || dataset.value === void 0) {
        _addIssue(this, "type", dataset, config2);
        return dataset;
      }
      return this.wrapped._run(dataset, config2);
    }
  };
}

// src/schemas/nonNullish/nonNullishAsync.ts
function nonNullishAsync(wrapped, message) {
  return {
    kind: "schema",
    type: "non_nullish",
    reference: nonNullishAsync,
    expects: "(!null & !undefined)",
    async: true,
    wrapped: wrapped,
    message: message,
    _run: function _run(dataset, config2) {
      var _this18 = this;
      return _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee19() {
        return _regeneratorRuntime().wrap(function _callee19$(_context19) {
          while (1) switch (_context19.prev = _context19.next) {
            case 0:
              if (!(dataset.value === null || dataset.value === void 0)) {
                _context19.next = 3;
                break;
              }
              _addIssue(_this18, "type", dataset, config2);
              return _context19.abrupt("return", dataset);
            case 3:
              return _context19.abrupt("return", _this18.wrapped._run(dataset, config2));
            case 4:
            case "end":
              return _context19.stop();
          }
        }, _callee19);
      }))();
    }
  };
}

// src/schemas/nonOptional/nonOptional.ts
function nonOptional(wrapped, message) {
  return {
    kind: "schema",
    type: "non_optional",
    reference: nonOptional,
    expects: "!undefined",
    async: false,
    wrapped: wrapped,
    message: message,
    _run: function _run(dataset, config2) {
      if (dataset.value === void 0) {
        _addIssue(this, "type", dataset, config2);
        return dataset;
      }
      return this.wrapped._run(dataset, config2);
    }
  };
}

// src/schemas/nonOptional/nonOptionalAsync.ts
function nonOptionalAsync(wrapped, message) {
  return {
    kind: "schema",
    type: "non_optional",
    reference: nonOptionalAsync,
    expects: "!undefined",
    async: true,
    wrapped: wrapped,
    message: message,
    _run: function _run(dataset, config2) {
      var _this19 = this;
      return _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee20() {
        return _regeneratorRuntime().wrap(function _callee20$(_context20) {
          while (1) switch (_context20.prev = _context20.next) {
            case 0:
              if (!(dataset.value === void 0)) {
                _context20.next = 3;
                break;
              }
              _addIssue(_this19, "type", dataset, config2);
              return _context20.abrupt("return", dataset);
            case 3:
              return _context20.abrupt("return", _this19.wrapped._run(dataset, config2));
            case 4:
            case "end":
              return _context20.stop();
          }
        }, _callee20);
      }))();
    }
  };
}

// src/schemas/null/null.ts
function null_(message) {
  return {
    kind: "schema",
    type: "null",
    reference: null_,
    expects: "null",
    async: false,
    message: message,
    _run: function _run(dataset, config2) {
      if (dataset.value === null) {
        dataset.typed = true;
      } else {
        _addIssue(this, "type", dataset, config2);
      }
      return dataset;
    }
  };
}

// src/schemas/nullable/nullable.ts
function nullable(wrapped) {
  var schema = {
    kind: "schema",
    type: "nullable",
    reference: nullable,
    expects: "(".concat(wrapped.expects, " | null)"),
    async: false,
    wrapped: wrapped,
    _run: function _run(dataset, config2) {
      if (dataset.value === null) {
        if ("default" in this) {
          dataset.value = getDefault(this, dataset, config2);
        }
        if (dataset.value === null) {
          dataset.typed = true;
          return dataset;
        }
      }
      return this.wrapped._run(dataset, config2);
    }
  };
  for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key5 = 1; _key5 < _len; _key5++) {
    args[_key5 - 1] = arguments[_key5];
  }
  if (0 in args) {
    schema["default"] = args[0];
  }
  return schema;
}

// src/schemas/nullable/nullableAsync.ts
function nullableAsync(wrapped) {
  var schema = {
    kind: "schema",
    type: "nullable",
    reference: nullableAsync,
    expects: "(".concat(wrapped.expects, " | null)"),
    async: true,
    wrapped: wrapped,
    _run: function _run(dataset, config2) {
      var _this20 = this;
      return _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee21() {
        return _regeneratorRuntime().wrap(function _callee21$(_context21) {
          while (1) switch (_context21.prev = _context21.next) {
            case 0:
              if (!(dataset.value === null)) {
                _context21.next = 8;
                break;
              }
              if (!("default" in _this20)) {
                _context21.next = 5;
                break;
              }
              _context21.next = 4;
              return getDefault(_this20, dataset, config2);
            case 4:
              dataset.value = _context21.sent;
            case 5:
              if (!(dataset.value === null)) {
                _context21.next = 8;
                break;
              }
              dataset.typed = true;
              return _context21.abrupt("return", dataset);
            case 8:
              return _context21.abrupt("return", _this20.wrapped._run(dataset, config2));
            case 9:
            case "end":
              return _context21.stop();
          }
        }, _callee21);
      }))();
    }
  };
  for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key6 = 1; _key6 < _len2; _key6++) {
    args[_key6 - 1] = arguments[_key6];
  }
  if (0 in args) {
    schema["default"] = args[0];
  }
  return schema;
}

// src/schemas/nullish/nullish.ts
function nullish(wrapped) {
  var schema = {
    kind: "schema",
    type: "nullish",
    reference: nullish,
    expects: "(".concat(wrapped.expects, " | null | undefined)"),
    async: false,
    wrapped: wrapped,
    _run: function _run(dataset, config2) {
      if (dataset.value === null || dataset.value === void 0) {
        if ("default" in this) {
          dataset.value = getDefault(this, dataset, config2);
        }
        if (dataset.value === null || dataset.value === void 0) {
          dataset.typed = true;
          return dataset;
        }
      }
      return this.wrapped._run(dataset, config2);
    }
  };
  for (var _len3 = arguments.length, args = new Array(_len3 > 1 ? _len3 - 1 : 0), _key7 = 1; _key7 < _len3; _key7++) {
    args[_key7 - 1] = arguments[_key7];
  }
  if (0 in args) {
    schema["default"] = args[0];
  }
  return schema;
}

// src/schemas/nullish/nullishAsync.ts
function nullishAsync(wrapped) {
  var schema = {
    kind: "schema",
    type: "nullish",
    reference: nullishAsync,
    expects: "(".concat(wrapped.expects, " | null | undefined)"),
    async: true,
    wrapped: wrapped,
    _run: function _run(dataset, config2) {
      var _this21 = this;
      return _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee22() {
        return _regeneratorRuntime().wrap(function _callee22$(_context22) {
          while (1) switch (_context22.prev = _context22.next) {
            case 0:
              if (!(dataset.value === null || dataset.value === void 0)) {
                _context22.next = 8;
                break;
              }
              if (!("default" in _this21)) {
                _context22.next = 5;
                break;
              }
              _context22.next = 4;
              return getDefault(_this21, dataset, config2);
            case 4:
              dataset.value = _context22.sent;
            case 5:
              if (!(dataset.value === null || dataset.value === void 0)) {
                _context22.next = 8;
                break;
              }
              dataset.typed = true;
              return _context22.abrupt("return", dataset);
            case 8:
              return _context22.abrupt("return", _this21.wrapped._run(dataset, config2));
            case 9:
            case "end":
              return _context22.stop();
          }
        }, _callee22);
      }))();
    }
  };
  for (var _len4 = arguments.length, args = new Array(_len4 > 1 ? _len4 - 1 : 0), _key8 = 1; _key8 < _len4; _key8++) {
    args[_key8 - 1] = arguments[_key8];
  }
  if (0 in args) {
    schema["default"] = args[0];
  }
  return schema;
}

// src/schemas/number/number.ts
function number(message) {
  return {
    kind: "schema",
    type: "number",
    reference: number,
    expects: "number",
    async: false,
    message: message,
    _run: function _run(dataset, config2) {
      if (typeof dataset.value === "number" && !isNaN(dataset.value)) {
        dataset.typed = true;
      } else {
        _addIssue(this, "type", dataset, config2);
      }
      return dataset;
    }
  };
}

// src/schemas/object/object.ts
function object(entries, message) {
  return {
    kind: "schema",
    type: "object",
    reference: object,
    expects: "Object",
    async: false,
    entries: entries,
    message: message,
    _run: function _run(dataset, config2) {
      var input = dataset.value;
      if (input && _typeof(input) === "object") {
        dataset.typed = true;
        dataset.value = {};
        for (var key in this.entries) {
          var value2 = input[key];
          var valueDataset = this.entries[key]._run({
            typed: false,
            value: value2
          }, config2);
          if (valueDataset.issues) {
            var pathItem = {
              type: "object",
              origin: "value",
              input: input,
              key: key,
              value: value2
            };
            var _iterator26 = _createForOfIteratorHelper(valueDataset.issues),
              _step26;
            try {
              for (_iterator26.s(); !(_step26 = _iterator26.n()).done;) {
                var _dataset$issues13;
                var issue = _step26.value;
                if (issue.path) {
                  issue.path.unshift(pathItem);
                } else {
                  issue.path = [pathItem];
                }
                (_dataset$issues13 = dataset.issues) === null || _dataset$issues13 === void 0 || _dataset$issues13.push(issue);
              }
            } catch (err) {
              _iterator26.e(err);
            } finally {
              _iterator26.f();
            }
            if (!dataset.issues) {
              dataset.issues = valueDataset.issues;
            }
            if (config2.abortEarly) {
              dataset.typed = false;
              break;
            }
          }
          if (!valueDataset.typed) {
            dataset.typed = false;
          }
          if (valueDataset.value !== void 0 || key in input) {
            dataset.value[key] = valueDataset.value;
          }
        }
      } else {
        _addIssue(this, "type", dataset, config2);
      }
      return dataset;
    }
  };
}

// src/schemas/object/objectAsync.ts
function objectAsync(entries, message) {
  return {
    kind: "schema",
    type: "object",
    reference: objectAsync,
    expects: "Object",
    async: true,
    entries: entries,
    message: message,
    _run: function _run(dataset, config2) {
      var _this22 = this;
      return _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee24() {
        var input, valueDatasets, _iterator27, _step27, _step27$value, key, value2, valueDataset, pathItem, _iterator28, _step28, _dataset$issues14, issue;
        return _regeneratorRuntime().wrap(function _callee24$(_context24) {
          while (1) switch (_context24.prev = _context24.next) {
            case 0:
              input = dataset.value;
              if (!(input && _typeof(input) === "object")) {
                _context24.next = 34;
                break;
              }
              dataset.typed = true;
              dataset.value = {};
              _context24.next = 6;
              return Promise.all(Object.entries(_this22.entries).map(/*#__PURE__*/function () {
                var _ref18 = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee23(_ref17) {
                  var _ref19, key, schema, value2;
                  return _regeneratorRuntime().wrap(function _callee23$(_context23) {
                    while (1) switch (_context23.prev = _context23.next) {
                      case 0:
                        _ref19 = _slicedToArray(_ref17, 2), key = _ref19[0], schema = _ref19[1];
                        value2 = input[key];
                        _context23.t0 = key;
                        _context23.t1 = value2;
                        _context23.next = 6;
                        return schema._run({
                          typed: false,
                          value: value2
                        }, config2);
                      case 6:
                        _context23.t2 = _context23.sent;
                        return _context23.abrupt("return", [_context23.t0, _context23.t1, _context23.t2]);
                      case 8:
                      case "end":
                        return _context23.stop();
                    }
                  }, _callee23);
                }));
                return function (_x6) {
                  return _ref18.apply(this, arguments);
                };
              }()));
            case 6:
              valueDatasets = _context24.sent;
              _iterator27 = _createForOfIteratorHelper(valueDatasets);
              _context24.prev = 8;
              _iterator27.s();
            case 10:
              if ((_step27 = _iterator27.n()).done) {
                _context24.next = 24;
                break;
              }
              _step27$value = _slicedToArray(_step27.value, 3), key = _step27$value[0], value2 = _step27$value[1], valueDataset = _step27$value[2];
              if (!valueDataset.issues) {
                _context24.next = 20;
                break;
              }
              pathItem = {
                type: "object",
                origin: "value",
                input: input,
                key: key,
                value: value2
              };
              _iterator28 = _createForOfIteratorHelper(valueDataset.issues);
              try {
                for (_iterator28.s(); !(_step28 = _iterator28.n()).done;) {
                  issue = _step28.value;
                  if (issue.path) {
                    issue.path.unshift(pathItem);
                  } else {
                    issue.path = [pathItem];
                  }
                  (_dataset$issues14 = dataset.issues) === null || _dataset$issues14 === void 0 || _dataset$issues14.push(issue);
                }
              } catch (err) {
                _iterator28.e(err);
              } finally {
                _iterator28.f();
              }
              if (!dataset.issues) {
                dataset.issues = valueDataset.issues;
              }
              if (!config2.abortEarly) {
                _context24.next = 20;
                break;
              }
              dataset.typed = false;
              return _context24.abrupt("break", 24);
            case 20:
              if (!valueDataset.typed) {
                dataset.typed = false;
              }
              if (valueDataset.value !== void 0 || key in input) {
                dataset.value[key] = valueDataset.value;
              }
            case 22:
              _context24.next = 10;
              break;
            case 24:
              _context24.next = 29;
              break;
            case 26:
              _context24.prev = 26;
              _context24.t0 = _context24["catch"](8);
              _iterator27.e(_context24.t0);
            case 29:
              _context24.prev = 29;
              _iterator27.f();
              return _context24.finish(29);
            case 32:
              _context24.next = 35;
              break;
            case 34:
              _addIssue(_this22, "type", dataset, config2);
            case 35:
              return _context24.abrupt("return", dataset);
            case 36:
            case "end":
              return _context24.stop();
          }
        }, _callee24, null, [[8, 26, 29, 32]]);
      }))();
    }
  };
}

// src/schemas/objectWithRest/objectWithRest.ts
function objectWithRest(entries, rest, message) {
  return {
    kind: "schema",
    type: "object_with_rest",
    reference: objectWithRest,
    expects: "Object",
    async: false,
    entries: entries,
    rest: rest,
    message: message,
    _run: function _run(dataset, config2) {
      var input = dataset.value;
      if (input && _typeof(input) === "object") {
        dataset.typed = true;
        dataset.value = {};
        for (var key in this.entries) {
          var value2 = input[key];
          var valueDataset = this.entries[key]._run({
            typed: false,
            value: value2
          }, config2);
          if (valueDataset.issues) {
            var pathItem = {
              type: "object",
              origin: "value",
              input: input,
              key: key,
              value: value2
            };
            var _iterator29 = _createForOfIteratorHelper(valueDataset.issues),
              _step29;
            try {
              for (_iterator29.s(); !(_step29 = _iterator29.n()).done;) {
                var _dataset$issues15;
                var issue = _step29.value;
                if (issue.path) {
                  issue.path.unshift(pathItem);
                } else {
                  issue.path = [pathItem];
                }
                (_dataset$issues15 = dataset.issues) === null || _dataset$issues15 === void 0 || _dataset$issues15.push(issue);
              }
            } catch (err) {
              _iterator29.e(err);
            } finally {
              _iterator29.f();
            }
            if (!dataset.issues) {
              dataset.issues = valueDataset.issues;
            }
            if (config2.abortEarly) {
              dataset.typed = false;
              break;
            }
          }
          if (!valueDataset.typed) {
            dataset.typed = false;
          }
          if (valueDataset.value !== void 0 || key in input) {
            dataset.value[key] = valueDataset.value;
          }
        }
        if (!dataset.issues || !config2.abortEarly) {
          for (var _key9 in input) {
            if (_isValidObjectKey(input, _key9) && !(_key9 in this.entries)) {
              var _value = input[_key9];
              var _valueDataset = this.rest._run({
                typed: false,
                value: _value
              }, config2);
              if (_valueDataset.issues) {
                var _pathItem3 = {
                  type: "object",
                  origin: "value",
                  input: input,
                  key: _key9,
                  value: _value
                };
                var _iterator30 = _createForOfIteratorHelper(_valueDataset.issues),
                  _step30;
                try {
                  for (_iterator30.s(); !(_step30 = _iterator30.n()).done;) {
                    var _dataset$issues16;
                    var _issue3 = _step30.value;
                    if (_issue3.path) {
                      _issue3.path.unshift(_pathItem3);
                    } else {
                      _issue3.path = [_pathItem3];
                    }
                    (_dataset$issues16 = dataset.issues) === null || _dataset$issues16 === void 0 || _dataset$issues16.push(_issue3);
                  }
                } catch (err) {
                  _iterator30.e(err);
                } finally {
                  _iterator30.f();
                }
                if (!dataset.issues) {
                  dataset.issues = _valueDataset.issues;
                }
                if (config2.abortEarly) {
                  dataset.typed = false;
                  break;
                }
              }
              if (!_valueDataset.typed) {
                dataset.typed = false;
              }
              dataset.value[_key9] = _valueDataset.value;
            }
          }
        }
      } else {
        _addIssue(this, "type", dataset, config2);
      }
      return dataset;
    }
  };
}

// src/schemas/objectWithRest/objectWithRestAsync.ts
function objectWithRestAsync(entries, rest, message) {
  return {
    kind: "schema",
    type: "object_with_rest",
    reference: objectWithRestAsync,
    expects: "Object",
    async: true,
    entries: entries,
    rest: rest,
    message: message,
    _run: function _run(dataset, config2) {
      var _this23 = this;
      return _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee27() {
        var input, _yield$Promise$all, _yield$Promise$all2, normalDatasets, restDatasets, _iterator31, _step31, _step31$value, _key10, _value2, _valueDataset2, _pathItem4, _iterator34, _step34, _dataset$issues18, _issue4, _iterator32, _step32, _step32$value, key, value2, valueDataset, pathItem, _iterator33, _step33, _dataset$issues17, issue;
        return _regeneratorRuntime().wrap(function _callee27$(_context27) {
          while (1) switch (_context27.prev = _context27.next) {
            case 0:
              input = dataset.value;
              if (!(input && _typeof(input) === "object")) {
                _context27.next = 63;
                break;
              }
              dataset.typed = true;
              dataset.value = {};
              _context27.next = 6;
              return Promise.all([
              // Parse schema of each normal entry
              // Hint: We do not distinguish between missing and `undefined` entries.
              // The reason for this decision is that it reduces the bundle size, and
              // we also expect that most users will expect this behavior.
              Promise.all(Object.entries(_this23.entries).map(/*#__PURE__*/function () {
                var _ref21 = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee25(_ref20) {
                  var _ref22, key, schema, value2;
                  return _regeneratorRuntime().wrap(function _callee25$(_context25) {
                    while (1) switch (_context25.prev = _context25.next) {
                      case 0:
                        _ref22 = _slicedToArray(_ref20, 2), key = _ref22[0], schema = _ref22[1];
                        value2 = input[key];
                        _context25.t0 = key;
                        _context25.t1 = value2;
                        _context25.next = 6;
                        return schema._run({
                          typed: false,
                          value: value2
                        }, config2);
                      case 6:
                        _context25.t2 = _context25.sent;
                        return _context25.abrupt("return", [_context25.t0, _context25.t1, _context25.t2]);
                      case 8:
                      case "end":
                        return _context25.stop();
                    }
                  }, _callee25);
                }));
                return function (_x7) {
                  return _ref21.apply(this, arguments);
                };
              }())),
              // Parse other entries with rest schema
              // Hint: We exclude specific keys for security reasons
              Promise.all(Object.entries(input).filter(function (_ref23) {
                var _ref24 = _slicedToArray(_ref23, 1),
                  key = _ref24[0];
                return _isValidObjectKey(input, key) && !(key in _this23.entries);
              }).map(/*#__PURE__*/function () {
                var _ref26 = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee26(_ref25) {
                  var _ref27, key, value2;
                  return _regeneratorRuntime().wrap(function _callee26$(_context26) {
                    while (1) switch (_context26.prev = _context26.next) {
                      case 0:
                        _ref27 = _slicedToArray(_ref25, 2), key = _ref27[0], value2 = _ref27[1];
                        _context26.t0 = key;
                        _context26.t1 = value2;
                        _context26.next = 5;
                        return _this23.rest._run({
                          typed: false,
                          value: value2
                        }, config2);
                      case 5:
                        _context26.t2 = _context26.sent;
                        return _context26.abrupt("return", [_context26.t0, _context26.t1, _context26.t2]);
                      case 7:
                      case "end":
                        return _context26.stop();
                    }
                  }, _callee26);
                }));
                return function (_x8) {
                  return _ref26.apply(this, arguments);
                };
              }()))]);
            case 6:
              _yield$Promise$all = _context27.sent;
              _yield$Promise$all2 = _slicedToArray(_yield$Promise$all, 2);
              normalDatasets = _yield$Promise$all2[0];
              restDatasets = _yield$Promise$all2[1];
              _iterator31 = _createForOfIteratorHelper(normalDatasets);
              _context27.prev = 11;
              _iterator31.s();
            case 13:
              if ((_step31 = _iterator31.n()).done) {
                _context27.next = 27;
                break;
              }
              _step31$value = _slicedToArray(_step31.value, 3), _key10 = _step31$value[0], _value2 = _step31$value[1], _valueDataset2 = _step31$value[2];
              if (!_valueDataset2.issues) {
                _context27.next = 23;
                break;
              }
              _pathItem4 = {
                type: "object",
                origin: "value",
                input: input,
                key: _key10,
                value: _value2
              };
              _iterator34 = _createForOfIteratorHelper(_valueDataset2.issues);
              try {
                for (_iterator34.s(); !(_step34 = _iterator34.n()).done;) {
                  _issue4 = _step34.value;
                  if (_issue4.path) {
                    _issue4.path.unshift(_pathItem4);
                  } else {
                    _issue4.path = [_pathItem4];
                  }
                  (_dataset$issues18 = dataset.issues) === null || _dataset$issues18 === void 0 || _dataset$issues18.push(_issue4);
                }
              } catch (err) {
                _iterator34.e(err);
              } finally {
                _iterator34.f();
              }
              if (!dataset.issues) {
                dataset.issues = _valueDataset2.issues;
              }
              if (!config2.abortEarly) {
                _context27.next = 23;
                break;
              }
              dataset.typed = false;
              return _context27.abrupt("break", 27);
            case 23:
              if (!_valueDataset2.typed) {
                dataset.typed = false;
              }
              if (_valueDataset2.value !== void 0 || _key10 in input) {
                dataset.value[_key10] = _valueDataset2.value;
              }
            case 25:
              _context27.next = 13;
              break;
            case 27:
              _context27.next = 32;
              break;
            case 29:
              _context27.prev = 29;
              _context27.t0 = _context27["catch"](11);
              _iterator31.e(_context27.t0);
            case 32:
              _context27.prev = 32;
              _iterator31.f();
              return _context27.finish(32);
            case 35:
              if (!(!dataset.issues || !config2.abortEarly)) {
                _context27.next = 61;
                break;
              }
              _iterator32 = _createForOfIteratorHelper(restDatasets);
              _context27.prev = 37;
              _iterator32.s();
            case 39:
              if ((_step32 = _iterator32.n()).done) {
                _context27.next = 53;
                break;
              }
              _step32$value = _slicedToArray(_step32.value, 3), key = _step32$value[0], value2 = _step32$value[1], valueDataset = _step32$value[2];
              if (!valueDataset.issues) {
                _context27.next = 49;
                break;
              }
              pathItem = {
                type: "object",
                origin: "value",
                input: input,
                key: key,
                value: value2
              };
              _iterator33 = _createForOfIteratorHelper(valueDataset.issues);
              try {
                for (_iterator33.s(); !(_step33 = _iterator33.n()).done;) {
                  issue = _step33.value;
                  if (issue.path) {
                    issue.path.unshift(pathItem);
                  } else {
                    issue.path = [pathItem];
                  }
                  (_dataset$issues17 = dataset.issues) === null || _dataset$issues17 === void 0 || _dataset$issues17.push(issue);
                }
              } catch (err) {
                _iterator33.e(err);
              } finally {
                _iterator33.f();
              }
              if (!dataset.issues) {
                dataset.issues = valueDataset.issues;
              }
              if (!config2.abortEarly) {
                _context27.next = 49;
                break;
              }
              dataset.typed = false;
              return _context27.abrupt("break", 53);
            case 49:
              if (!valueDataset.typed) {
                dataset.typed = false;
              }
              dataset.value[key] = valueDataset.value;
            case 51:
              _context27.next = 39;
              break;
            case 53:
              _context27.next = 58;
              break;
            case 55:
              _context27.prev = 55;
              _context27.t1 = _context27["catch"](37);
              _iterator32.e(_context27.t1);
            case 58:
              _context27.prev = 58;
              _iterator32.f();
              return _context27.finish(58);
            case 61:
              _context27.next = 64;
              break;
            case 63:
              _addIssue(_this23, "type", dataset, config2);
            case 64:
              return _context27.abrupt("return", dataset);
            case 65:
            case "end":
              return _context27.stop();
          }
        }, _callee27, null, [[11, 29, 32, 35], [37, 55, 58, 61]]);
      }))();
    }
  };
}

// src/schemas/optional/optional.ts
function optional(wrapped) {
  var schema = {
    kind: "schema",
    type: "optional",
    reference: optional,
    expects: "(".concat(wrapped.expects, " | undefined)"),
    async: false,
    wrapped: wrapped,
    _run: function _run(dataset, config2) {
      if (dataset.value === void 0) {
        if ("default" in this) {
          dataset.value = getDefault(this, dataset, config2);
        }
        if (dataset.value === void 0) {
          dataset.typed = true;
          return dataset;
        }
      }
      return this.wrapped._run(dataset, config2);
    }
  };
  for (var _len5 = arguments.length, args = new Array(_len5 > 1 ? _len5 - 1 : 0), _key11 = 1; _key11 < _len5; _key11++) {
    args[_key11 - 1] = arguments[_key11];
  }
  if (0 in args) {
    schema["default"] = args[0];
  }
  return schema;
}

// src/schemas/optional/optionalAsync.ts
function optionalAsync(wrapped) {
  var schema = {
    kind: "schema",
    type: "optional",
    reference: optionalAsync,
    expects: "(".concat(wrapped.expects, " | undefined)"),
    async: true,
    wrapped: wrapped,
    _run: function _run(dataset, config2) {
      var _this24 = this;
      return _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee28() {
        return _regeneratorRuntime().wrap(function _callee28$(_context28) {
          while (1) switch (_context28.prev = _context28.next) {
            case 0:
              if (!(dataset.value === void 0)) {
                _context28.next = 8;
                break;
              }
              if (!("default" in _this24)) {
                _context28.next = 5;
                break;
              }
              _context28.next = 4;
              return getDefault(_this24, dataset, config2);
            case 4:
              dataset.value = _context28.sent;
            case 5:
              if (!(dataset.value === void 0)) {
                _context28.next = 8;
                break;
              }
              dataset.typed = true;
              return _context28.abrupt("return", dataset);
            case 8:
              return _context28.abrupt("return", _this24.wrapped._run(dataset, config2));
            case 9:
            case "end":
              return _context28.stop();
          }
        }, _callee28);
      }))();
    }
  };
  for (var _len6 = arguments.length, args = new Array(_len6 > 1 ? _len6 - 1 : 0), _key12 = 1; _key12 < _len6; _key12++) {
    args[_key12 - 1] = arguments[_key12];
  }
  if (0 in args) {
    schema["default"] = args[0];
  }
  return schema;
}

// src/schemas/picklist/picklist.ts
function picklist(options, message) {
  return {
    kind: "schema",
    type: "picklist",
    reference: picklist,
    expects: _joinExpects(options.map(_stringify), "|"),
    async: false,
    options: options,
    message: message,
    _run: function _run(dataset, config2) {
      if (this.options.includes(dataset.value)) {
        dataset.typed = true;
      } else {
        _addIssue(this, "type", dataset, config2);
      }
      return dataset;
    }
  };
}

// src/schemas/promise/promise.ts
function promise(message) {
  return {
    kind: "schema",
    type: "promise",
    reference: promise,
    expects: "Promise",
    async: false,
    message: message,
    _run: function _run(dataset, config2) {
      if (dataset.value instanceof Promise) {
        dataset.typed = true;
      } else {
        _addIssue(this, "type", dataset, config2);
      }
      return dataset;
    }
  };
}

// src/schemas/record/record.ts
function record(key, value2, message) {
  return {
    kind: "schema",
    type: "record",
    reference: record,
    expects: "Object",
    async: false,
    key: key,
    value: value2,
    message: message,
    _run: function _run(dataset, config2) {
      var input = dataset.value;
      if (input && _typeof(input) === "object") {
        dataset.typed = true;
        dataset.value = {};
        for (var entryKey in input) {
          if (_isValidObjectKey(input, entryKey)) {
            var entryValue = input[entryKey];
            var keyDataset = this.key._run({
              typed: false,
              value: entryKey
            }, config2);
            if (keyDataset.issues) {
              var pathItem = {
                type: "object",
                origin: "key",
                input: input,
                key: entryKey,
                value: entryValue
              };
              var _iterator35 = _createForOfIteratorHelper(keyDataset.issues),
                _step35;
              try {
                for (_iterator35.s(); !(_step35 = _iterator35.n()).done;) {
                  var _dataset$issues19;
                  var issue = _step35.value;
                  issue.path = [pathItem];
                  (_dataset$issues19 = dataset.issues) === null || _dataset$issues19 === void 0 || _dataset$issues19.push(issue);
                }
              } catch (err) {
                _iterator35.e(err);
              } finally {
                _iterator35.f();
              }
              if (!dataset.issues) {
                dataset.issues = keyDataset.issues;
              }
              if (config2.abortEarly) {
                dataset.typed = false;
                break;
              }
            }
            var valueDataset = this.value._run({
              typed: false,
              value: entryValue
            }, config2);
            if (valueDataset.issues) {
              var _pathItem5 = {
                type: "object",
                origin: "value",
                input: input,
                key: entryKey,
                value: entryValue
              };
              var _iterator36 = _createForOfIteratorHelper(valueDataset.issues),
                _step36;
              try {
                for (_iterator36.s(); !(_step36 = _iterator36.n()).done;) {
                  var _dataset$issues20;
                  var _issue5 = _step36.value;
                  if (_issue5.path) {
                    _issue5.path.unshift(_pathItem5);
                  } else {
                    _issue5.path = [_pathItem5];
                  }
                  (_dataset$issues20 = dataset.issues) === null || _dataset$issues20 === void 0 || _dataset$issues20.push(_issue5);
                }
              } catch (err) {
                _iterator36.e(err);
              } finally {
                _iterator36.f();
              }
              if (!dataset.issues) {
                dataset.issues = valueDataset.issues;
              }
              if (config2.abortEarly) {
                dataset.typed = false;
                break;
              }
            }
            if (!keyDataset.typed || !valueDataset.typed) {
              dataset.typed = false;
            }
            if (keyDataset.typed) {
              dataset.value[keyDataset.value] = valueDataset.value;
            }
          }
        }
      } else {
        _addIssue(this, "type", dataset, config2);
      }
      return dataset;
    }
  };
}

// src/schemas/record/recordAsync.ts
function recordAsync(key, value2, message) {
  return {
    kind: "schema",
    type: "record",
    reference: recordAsync,
    expects: "Object",
    async: true,
    key: key,
    value: value2,
    message: message,
    _run: function _run(dataset, config2) {
      var _this25 = this;
      return _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee29() {
        var input, datasets, _iterator37, _step37, _step37$value, entryKey, entryValue, keyDataset, valueDataset, pathItem, _iterator38, _step38, _dataset$issues21, issue, _pathItem6, _iterator39, _step39, _dataset$issues22, _issue6;
        return _regeneratorRuntime().wrap(function _callee29$(_context29) {
          while (1) switch (_context29.prev = _context29.next) {
            case 0:
              input = dataset.value;
              if (!(input && _typeof(input) === "object")) {
                _context29.next = 42;
                break;
              }
              dataset.typed = true;
              dataset.value = {};
              _context29.next = 6;
              return Promise.all(Object.entries(input).filter(function (_ref28) {
                var _ref29 = _slicedToArray(_ref28, 1),
                  key2 = _ref29[0];
                return _isValidObjectKey(input, key2);
              }).map(function (_ref30) {
                var _ref31 = _slicedToArray(_ref30, 2),
                  entryKey = _ref31[0],
                  entryValue = _ref31[1];
                return Promise.all([entryKey, entryValue, _this25.key._run({
                  typed: false,
                  value: entryKey
                }, config2), _this25.value._run({
                  typed: false,
                  value: entryValue
                }, config2)]);
              }));
            case 6:
              datasets = _context29.sent;
              _iterator37 = _createForOfIteratorHelper(datasets);
              _context29.prev = 8;
              _iterator37.s();
            case 10:
              if ((_step37 = _iterator37.n()).done) {
                _context29.next = 32;
                break;
              }
              _step37$value = _slicedToArray(_step37.value, 4), entryKey = _step37$value[0], entryValue = _step37$value[1], keyDataset = _step37$value[2], valueDataset = _step37$value[3];
              if (!keyDataset.issues) {
                _context29.next = 20;
                break;
              }
              pathItem = {
                type: "object",
                origin: "key",
                input: input,
                key: entryKey,
                value: entryValue
              };
              _iterator38 = _createForOfIteratorHelper(keyDataset.issues);
              try {
                for (_iterator38.s(); !(_step38 = _iterator38.n()).done;) {
                  issue = _step38.value;
                  issue.path = [pathItem];
                  (_dataset$issues21 = dataset.issues) === null || _dataset$issues21 === void 0 || _dataset$issues21.push(issue);
                }
              } catch (err) {
                _iterator38.e(err);
              } finally {
                _iterator38.f();
              }
              if (!dataset.issues) {
                dataset.issues = keyDataset.issues;
              }
              if (!config2.abortEarly) {
                _context29.next = 20;
                break;
              }
              dataset.typed = false;
              return _context29.abrupt("break", 32);
            case 20:
              if (!valueDataset.issues) {
                _context29.next = 28;
                break;
              }
              _pathItem6 = {
                type: "object",
                origin: "value",
                input: input,
                key: entryKey,
                value: entryValue
              };
              _iterator39 = _createForOfIteratorHelper(valueDataset.issues);
              try {
                for (_iterator39.s(); !(_step39 = _iterator39.n()).done;) {
                  _issue6 = _step39.value;
                  if (_issue6.path) {
                    _issue6.path.unshift(_pathItem6);
                  } else {
                    _issue6.path = [_pathItem6];
                  }
                  (_dataset$issues22 = dataset.issues) === null || _dataset$issues22 === void 0 || _dataset$issues22.push(_issue6);
                }
              } catch (err) {
                _iterator39.e(err);
              } finally {
                _iterator39.f();
              }
              if (!dataset.issues) {
                dataset.issues = valueDataset.issues;
              }
              if (!config2.abortEarly) {
                _context29.next = 28;
                break;
              }
              dataset.typed = false;
              return _context29.abrupt("break", 32);
            case 28:
              if (!keyDataset.typed || !valueDataset.typed) {
                dataset.typed = false;
              }
              if (keyDataset.typed) {
                dataset.value[keyDataset.value] = valueDataset.value;
              }
            case 30:
              _context29.next = 10;
              break;
            case 32:
              _context29.next = 37;
              break;
            case 34:
              _context29.prev = 34;
              _context29.t0 = _context29["catch"](8);
              _iterator37.e(_context29.t0);
            case 37:
              _context29.prev = 37;
              _iterator37.f();
              return _context29.finish(37);
            case 40:
              _context29.next = 43;
              break;
            case 42:
              _addIssue(_this25, "type", dataset, config2);
            case 43:
              return _context29.abrupt("return", dataset);
            case 44:
            case "end":
              return _context29.stop();
          }
        }, _callee29, null, [[8, 34, 37, 40]]);
      }))();
    }
  };
}

// src/schemas/set/set.ts
function set(value2, message) {
  return {
    kind: "schema",
    type: "set",
    reference: set,
    expects: "Set",
    async: false,
    value: value2,
    message: message,
    _run: function _run(dataset, config2) {
      var input = dataset.value;
      if (input instanceof Set) {
        dataset.typed = true;
        dataset.value = /* @__PURE__ */new Set();
        var _iterator40 = _createForOfIteratorHelper(input),
          _step40;
        try {
          for (_iterator40.s(); !(_step40 = _iterator40.n()).done;) {
            var inputValue = _step40.value;
            var valueDataset = this.value._run({
              typed: false,
              value: inputValue
            }, config2);
            if (valueDataset.issues) {
              var pathItem = {
                type: "set",
                origin: "value",
                input: input,
                key: null,
                value: inputValue
              };
              var _iterator41 = _createForOfIteratorHelper(valueDataset.issues),
                _step41;
              try {
                for (_iterator41.s(); !(_step41 = _iterator41.n()).done;) {
                  var _dataset$issues23;
                  var issue = _step41.value;
                  if (issue.path) {
                    issue.path.unshift(pathItem);
                  } else {
                    issue.path = [pathItem];
                  }
                  (_dataset$issues23 = dataset.issues) === null || _dataset$issues23 === void 0 || _dataset$issues23.push(issue);
                }
              } catch (err) {
                _iterator41.e(err);
              } finally {
                _iterator41.f();
              }
              if (!dataset.issues) {
                dataset.issues = valueDataset.issues;
              }
              if (config2.abortEarly) {
                dataset.typed = false;
                break;
              }
            }
            if (!valueDataset.typed) {
              dataset.typed = false;
            }
            dataset.value.add(valueDataset.value);
          }
        } catch (err) {
          _iterator40.e(err);
        } finally {
          _iterator40.f();
        }
      } else {
        _addIssue(this, "type", dataset, config2);
      }
      return dataset;
    }
  };
}

// src/schemas/set/setAsync.ts
function setAsync(value2, message) {
  return {
    kind: "schema",
    type: "set",
    reference: setAsync,
    expects: "Set",
    async: true,
    value: value2,
    message: message,
    _run: function _run(dataset, config2) {
      var _this26 = this;
      return _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee31() {
        var input, valueDatasets, _iterator42, _step42, _step42$value, inputValue, valueDataset, pathItem, _iterator43, _step43, _dataset$issues24, issue;
        return _regeneratorRuntime().wrap(function _callee31$(_context31) {
          while (1) switch (_context31.prev = _context31.next) {
            case 0:
              input = dataset.value;
              if (!(input instanceof Set)) {
                _context31.next = 34;
                break;
              }
              dataset.typed = true;
              dataset.value = /* @__PURE__ */new Set();
              _context31.next = 6;
              return Promise.all(_toConsumableArray(input).map(/*#__PURE__*/function () {
                var _ref32 = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee30(inputValue) {
                  return _regeneratorRuntime().wrap(function _callee30$(_context30) {
                    while (1) switch (_context30.prev = _context30.next) {
                      case 0:
                        _context30.t0 = inputValue;
                        _context30.next = 3;
                        return _this26.value._run({
                          typed: false,
                          value: inputValue
                        }, config2);
                      case 3:
                        _context30.t1 = _context30.sent;
                        return _context30.abrupt("return", [_context30.t0, _context30.t1]);
                      case 5:
                      case "end":
                        return _context30.stop();
                    }
                  }, _callee30);
                }));
                return function (_x9) {
                  return _ref32.apply(this, arguments);
                };
              }()));
            case 6:
              valueDatasets = _context31.sent;
              _iterator42 = _createForOfIteratorHelper(valueDatasets);
              _context31.prev = 8;
              _iterator42.s();
            case 10:
              if ((_step42 = _iterator42.n()).done) {
                _context31.next = 24;
                break;
              }
              _step42$value = _slicedToArray(_step42.value, 2), inputValue = _step42$value[0], valueDataset = _step42$value[1];
              if (!valueDataset.issues) {
                _context31.next = 20;
                break;
              }
              pathItem = {
                type: "set",
                origin: "value",
                input: input,
                key: null,
                value: inputValue
              };
              _iterator43 = _createForOfIteratorHelper(valueDataset.issues);
              try {
                for (_iterator43.s(); !(_step43 = _iterator43.n()).done;) {
                  issue = _step43.value;
                  if (issue.path) {
                    issue.path.unshift(pathItem);
                  } else {
                    issue.path = [pathItem];
                  }
                  (_dataset$issues24 = dataset.issues) === null || _dataset$issues24 === void 0 || _dataset$issues24.push(issue);
                }
              } catch (err) {
                _iterator43.e(err);
              } finally {
                _iterator43.f();
              }
              if (!dataset.issues) {
                dataset.issues = valueDataset.issues;
              }
              if (!config2.abortEarly) {
                _context31.next = 20;
                break;
              }
              dataset.typed = false;
              return _context31.abrupt("break", 24);
            case 20:
              if (!valueDataset.typed) {
                dataset.typed = false;
              }
              dataset.value.add(valueDataset.value);
            case 22:
              _context31.next = 10;
              break;
            case 24:
              _context31.next = 29;
              break;
            case 26:
              _context31.prev = 26;
              _context31.t0 = _context31["catch"](8);
              _iterator42.e(_context31.t0);
            case 29:
              _context31.prev = 29;
              _iterator42.f();
              return _context31.finish(29);
            case 32:
              _context31.next = 35;
              break;
            case 34:
              _addIssue(_this26, "type", dataset, config2);
            case 35:
              return _context31.abrupt("return", dataset);
            case 36:
            case "end":
              return _context31.stop();
          }
        }, _callee31, null, [[8, 26, 29, 32]]);
      }))();
    }
  };
}

// src/schemas/strictObject/strictObject.ts
function strictObject(entries, message) {
  return {
    kind: "schema",
    type: "strict_object",
    reference: strictObject,
    expects: "Object",
    async: false,
    entries: entries,
    message: message,
    _run: function _run(dataset, config2) {
      var input = dataset.value;
      if (input && _typeof(input) === "object") {
        dataset.typed = true;
        dataset.value = {};
        for (var key in this.entries) {
          var value2 = input[key];
          var valueDataset = this.entries[key]._run({
            typed: false,
            value: value2
          }, config2);
          if (valueDataset.issues) {
            var pathItem = {
              type: "object",
              origin: "value",
              input: input,
              key: key,
              value: value2
            };
            var _iterator44 = _createForOfIteratorHelper(valueDataset.issues),
              _step44;
            try {
              for (_iterator44.s(); !(_step44 = _iterator44.n()).done;) {
                var _dataset$issues25;
                var issue = _step44.value;
                if (issue.path) {
                  issue.path.unshift(pathItem);
                } else {
                  issue.path = [pathItem];
                }
                (_dataset$issues25 = dataset.issues) === null || _dataset$issues25 === void 0 || _dataset$issues25.push(issue);
              }
            } catch (err) {
              _iterator44.e(err);
            } finally {
              _iterator44.f();
            }
            if (!dataset.issues) {
              dataset.issues = valueDataset.issues;
            }
            if (config2.abortEarly) {
              dataset.typed = false;
              break;
            }
          }
          if (!valueDataset.typed) {
            dataset.typed = false;
          }
          if (valueDataset.value !== void 0 || key in input) {
            dataset.value[key] = valueDataset.value;
          }
        }
        if (!dataset.issues || !config2.abortEarly) {
          for (var _key13 in input) {
            if (!(_key13 in this.entries)) {
              var _value3 = input[_key13];
              _addIssue(this, "type", dataset, config2, {
                input: _value3,
                expected: "never",
                path: [{
                  type: "object",
                  origin: "value",
                  input: input,
                  key: _key13,
                  value: _value3
                }]
              });
              break;
            }
          }
        }
      } else {
        _addIssue(this, "type", dataset, config2);
      }
      return dataset;
    }
  };
}

// src/schemas/strictObject/strictObjectAsync.ts
function strictObjectAsync(entries, message) {
  return {
    kind: "schema",
    type: "strict_object",
    reference: strictObjectAsync,
    expects: "Object",
    async: true,
    entries: entries,
    message: message,
    _run: function _run(dataset, config2) {
      var _this27 = this;
      return _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee33() {
        var input, valueDatasets, _iterator45, _step45, _step45$value, _key14, _value4, valueDataset, pathItem, _iterator46, _step46, _dataset$issues26, issue, key, value2;
        return _regeneratorRuntime().wrap(function _callee33$(_context33) {
          while (1) switch (_context33.prev = _context33.next) {
            case 0:
              input = dataset.value;
              if (!(input && _typeof(input) === "object")) {
                _context33.next = 44;
                break;
              }
              dataset.typed = true;
              dataset.value = {};
              _context33.next = 6;
              return Promise.all(Object.entries(_this27.entries).map(/*#__PURE__*/function () {
                var _ref34 = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee32(_ref33) {
                  var _ref35, key, schema, value2;
                  return _regeneratorRuntime().wrap(function _callee32$(_context32) {
                    while (1) switch (_context32.prev = _context32.next) {
                      case 0:
                        _ref35 = _slicedToArray(_ref33, 2), key = _ref35[0], schema = _ref35[1];
                        value2 = input[key];
                        _context32.t0 = key;
                        _context32.t1 = value2;
                        _context32.next = 6;
                        return schema._run({
                          typed: false,
                          value: value2
                        }, config2);
                      case 6:
                        _context32.t2 = _context32.sent;
                        return _context32.abrupt("return", [_context32.t0, _context32.t1, _context32.t2]);
                      case 8:
                      case "end":
                        return _context32.stop();
                    }
                  }, _callee32);
                }));
                return function (_x10) {
                  return _ref34.apply(this, arguments);
                };
              }()));
            case 6:
              valueDatasets = _context33.sent;
              _iterator45 = _createForOfIteratorHelper(valueDatasets);
              _context33.prev = 8;
              _iterator45.s();
            case 10:
              if ((_step45 = _iterator45.n()).done) {
                _context33.next = 24;
                break;
              }
              _step45$value = _slicedToArray(_step45.value, 3), _key14 = _step45$value[0], _value4 = _step45$value[1], valueDataset = _step45$value[2];
              if (!valueDataset.issues) {
                _context33.next = 20;
                break;
              }
              pathItem = {
                type: "object",
                origin: "value",
                input: input,
                key: _key14,
                value: _value4
              };
              _iterator46 = _createForOfIteratorHelper(valueDataset.issues);
              try {
                for (_iterator46.s(); !(_step46 = _iterator46.n()).done;) {
                  issue = _step46.value;
                  if (issue.path) {
                    issue.path.unshift(pathItem);
                  } else {
                    issue.path = [pathItem];
                  }
                  (_dataset$issues26 = dataset.issues) === null || _dataset$issues26 === void 0 || _dataset$issues26.push(issue);
                }
              } catch (err) {
                _iterator46.e(err);
              } finally {
                _iterator46.f();
              }
              if (!dataset.issues) {
                dataset.issues = valueDataset.issues;
              }
              if (!config2.abortEarly) {
                _context33.next = 20;
                break;
              }
              dataset.typed = false;
              return _context33.abrupt("break", 24);
            case 20:
              if (!valueDataset.typed) {
                dataset.typed = false;
              }
              if (valueDataset.value !== void 0 || _key14 in input) {
                dataset.value[_key14] = valueDataset.value;
              }
            case 22:
              _context33.next = 10;
              break;
            case 24:
              _context33.next = 29;
              break;
            case 26:
              _context33.prev = 26;
              _context33.t0 = _context33["catch"](8);
              _iterator45.e(_context33.t0);
            case 29:
              _context33.prev = 29;
              _iterator45.f();
              return _context33.finish(29);
            case 32:
              if (!(!dataset.issues || !config2.abortEarly)) {
                _context33.next = 42;
                break;
              }
              _context33.t1 = _regeneratorRuntime().keys(input);
            case 34:
              if ((_context33.t2 = _context33.t1()).done) {
                _context33.next = 42;
                break;
              }
              key = _context33.t2.value;
              if (key in _this27.entries) {
                _context33.next = 40;
                break;
              }
              value2 = input[key];
              _addIssue(_this27, "type", dataset, config2, {
                input: value2,
                expected: "never",
                path: [{
                  type: "object",
                  origin: "value",
                  input: input,
                  key: key,
                  value: value2
                }]
              });
              return _context33.abrupt("break", 42);
            case 40:
              _context33.next = 34;
              break;
            case 42:
              _context33.next = 45;
              break;
            case 44:
              _addIssue(_this27, "type", dataset, config2);
            case 45:
              return _context33.abrupt("return", dataset);
            case 46:
            case "end":
              return _context33.stop();
          }
        }, _callee33, null, [[8, 26, 29, 32]]);
      }))();
    }
  };
}

// src/schemas/strictTuple/strictTuple.ts
function strictTuple(items, message) {
  return {
    kind: "schema",
    type: "strict_tuple",
    reference: strictTuple,
    expects: "Array",
    async: false,
    items: items,
    message: message,
    _run: function _run(dataset, config2) {
      var input = dataset.value;
      if (Array.isArray(input)) {
        dataset.typed = true;
        dataset.value = [];
        for (var key = 0; key < this.items.length; key++) {
          var value2 = input[key];
          var itemDataset = this.items[key]._run({
            typed: false,
            value: value2
          }, config2);
          if (itemDataset.issues) {
            var pathItem = {
              type: "array",
              origin: "value",
              input: input,
              key: key,
              value: value2
            };
            var _iterator47 = _createForOfIteratorHelper(itemDataset.issues),
              _step47;
            try {
              for (_iterator47.s(); !(_step47 = _iterator47.n()).done;) {
                var _dataset$issues27;
                var issue = _step47.value;
                if (issue.path) {
                  issue.path.unshift(pathItem);
                } else {
                  issue.path = [pathItem];
                }
                (_dataset$issues27 = dataset.issues) === null || _dataset$issues27 === void 0 || _dataset$issues27.push(issue);
              }
            } catch (err) {
              _iterator47.e(err);
            } finally {
              _iterator47.f();
            }
            if (!dataset.issues) {
              dataset.issues = itemDataset.issues;
            }
            if (config2.abortEarly) {
              dataset.typed = false;
              break;
            }
          }
          if (!itemDataset.typed) {
            dataset.typed = false;
          }
          dataset.value.push(itemDataset.value);
        }
        if (!(dataset.issues && config2.abortEarly) && this.items.length < input.length) {
          var _value5 = input[items.length];
          _addIssue(this, "type", dataset, config2, {
            input: _value5,
            expected: "never",
            path: [{
              type: "array",
              origin: "value",
              input: input,
              key: this.items.length,
              value: _value5
            }]
          });
        }
      } else {
        _addIssue(this, "type", dataset, config2);
      }
      return dataset;
    }
  };
}

// src/schemas/strictTuple/strictTupleAsync.ts
function strictTupleAsync(items, message) {
  return {
    kind: "schema",
    type: "strict_tuple",
    reference: strictTupleAsync,
    expects: "Array",
    async: true,
    items: items,
    message: message,
    _run: function _run(dataset, config2) {
      var _this28 = this;
      return _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee35() {
        var input, itemDatasets, _iterator48, _step48, _step48$value, key, _value6, itemDataset, pathItem, _iterator49, _step49, _dataset$issues28, issue, value2;
        return _regeneratorRuntime().wrap(function _callee35$(_context35) {
          while (1) switch (_context35.prev = _context35.next) {
            case 0:
              input = dataset.value;
              if (!Array.isArray(input)) {
                _context35.next = 35;
                break;
              }
              dataset.typed = true;
              dataset.value = [];
              _context35.next = 6;
              return Promise.all(_this28.items.map(/*#__PURE__*/function () {
                var _ref36 = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee34(item, key) {
                  var value2;
                  return _regeneratorRuntime().wrap(function _callee34$(_context34) {
                    while (1) switch (_context34.prev = _context34.next) {
                      case 0:
                        value2 = input[key];
                        _context34.t0 = key;
                        _context34.t1 = value2;
                        _context34.next = 5;
                        return item._run({
                          typed: false,
                          value: value2
                        }, config2);
                      case 5:
                        _context34.t2 = _context34.sent;
                        return _context34.abrupt("return", [_context34.t0, _context34.t1, _context34.t2]);
                      case 7:
                      case "end":
                        return _context34.stop();
                    }
                  }, _callee34);
                }));
                return function (_x11, _x12) {
                  return _ref36.apply(this, arguments);
                };
              }()));
            case 6:
              itemDatasets = _context35.sent;
              _iterator48 = _createForOfIteratorHelper(itemDatasets);
              _context35.prev = 8;
              _iterator48.s();
            case 10:
              if ((_step48 = _iterator48.n()).done) {
                _context35.next = 24;
                break;
              }
              _step48$value = _slicedToArray(_step48.value, 3), key = _step48$value[0], _value6 = _step48$value[1], itemDataset = _step48$value[2];
              if (!itemDataset.issues) {
                _context35.next = 20;
                break;
              }
              pathItem = {
                type: "array",
                origin: "value",
                input: input,
                key: key,
                value: _value6
              };
              _iterator49 = _createForOfIteratorHelper(itemDataset.issues);
              try {
                for (_iterator49.s(); !(_step49 = _iterator49.n()).done;) {
                  issue = _step49.value;
                  if (issue.path) {
                    issue.path.unshift(pathItem);
                  } else {
                    issue.path = [pathItem];
                  }
                  (_dataset$issues28 = dataset.issues) === null || _dataset$issues28 === void 0 || _dataset$issues28.push(issue);
                }
              } catch (err) {
                _iterator49.e(err);
              } finally {
                _iterator49.f();
              }
              if (!dataset.issues) {
                dataset.issues = itemDataset.issues;
              }
              if (!config2.abortEarly) {
                _context35.next = 20;
                break;
              }
              dataset.typed = false;
              return _context35.abrupt("break", 24);
            case 20:
              if (!itemDataset.typed) {
                dataset.typed = false;
              }
              dataset.value.push(itemDataset.value);
            case 22:
              _context35.next = 10;
              break;
            case 24:
              _context35.next = 29;
              break;
            case 26:
              _context35.prev = 26;
              _context35.t0 = _context35["catch"](8);
              _iterator48.e(_context35.t0);
            case 29:
              _context35.prev = 29;
              _iterator48.f();
              return _context35.finish(29);
            case 32:
              if (!(dataset.issues && config2.abortEarly) && _this28.items.length < input.length) {
                value2 = input[items.length];
                _addIssue(_this28, "type", dataset, config2, {
                  input: value2,
                  expected: "never",
                  path: [{
                    type: "array",
                    origin: "value",
                    input: input,
                    key: _this28.items.length,
                    value: value2
                  }]
                });
              }
              _context35.next = 36;
              break;
            case 35:
              _addIssue(_this28, "type", dataset, config2);
            case 36:
              return _context35.abrupt("return", dataset);
            case 37:
            case "end":
              return _context35.stop();
          }
        }, _callee35, null, [[8, 26, 29, 32]]);
      }))();
    }
  };
}

// src/schemas/string/string.ts
function string(message) {
  return {
    kind: "schema",
    type: "string",
    reference: string,
    expects: "string",
    async: false,
    message: message,
    _run: function _run(dataset, config2) {
      if (typeof dataset.value === "string") {
        dataset.typed = true;
      } else {
        _addIssue(this, "type", dataset, config2);
      }
      return dataset;
    }
  };
}

// src/schemas/symbol/symbol.ts
function symbol(message) {
  return {
    kind: "schema",
    type: "symbol",
    reference: symbol,
    expects: "symbol",
    async: false,
    message: message,
    _run: function _run(dataset, config2) {
      if (_typeof(dataset.value) === "symbol") {
        dataset.typed = true;
      } else {
        _addIssue(this, "type", dataset, config2);
      }
      return dataset;
    }
  };
}

// src/schemas/tuple/tuple.ts
function tuple(items, message) {
  return {
    kind: "schema",
    type: "tuple",
    reference: tuple,
    expects: "Array",
    async: false,
    items: items,
    message: message,
    _run: function _run(dataset, config2) {
      var input = dataset.value;
      if (Array.isArray(input)) {
        dataset.typed = true;
        dataset.value = [];
        for (var key = 0; key < this.items.length; key++) {
          var value2 = input[key];
          var itemDataset = this.items[key]._run({
            typed: false,
            value: value2
          }, config2);
          if (itemDataset.issues) {
            var pathItem = {
              type: "array",
              origin: "value",
              input: input,
              key: key,
              value: value2
            };
            var _iterator50 = _createForOfIteratorHelper(itemDataset.issues),
              _step50;
            try {
              for (_iterator50.s(); !(_step50 = _iterator50.n()).done;) {
                var _dataset$issues29;
                var issue = _step50.value;
                if (issue.path) {
                  issue.path.unshift(pathItem);
                } else {
                  issue.path = [pathItem];
                }
                (_dataset$issues29 = dataset.issues) === null || _dataset$issues29 === void 0 || _dataset$issues29.push(issue);
              }
            } catch (err) {
              _iterator50.e(err);
            } finally {
              _iterator50.f();
            }
            if (!dataset.issues) {
              dataset.issues = itemDataset.issues;
            }
            if (config2.abortEarly) {
              dataset.typed = false;
              break;
            }
          }
          if (!itemDataset.typed) {
            dataset.typed = false;
          }
          dataset.value.push(itemDataset.value);
        }
      } else {
        _addIssue(this, "type", dataset, config2);
      }
      return dataset;
    }
  };
}

// src/schemas/tuple/tupleAsync.ts
function tupleAsync(items, message) {
  return {
    kind: "schema",
    type: "tuple",
    reference: tupleAsync,
    expects: "Array",
    async: true,
    items: items,
    message: message,
    _run: function _run(dataset, config2) {
      var _this29 = this;
      return _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee37() {
        var input, itemDatasets, _iterator51, _step51, _step51$value, key, value2, itemDataset, pathItem, _iterator52, _step52, _dataset$issues30, issue;
        return _regeneratorRuntime().wrap(function _callee37$(_context37) {
          while (1) switch (_context37.prev = _context37.next) {
            case 0:
              input = dataset.value;
              if (!Array.isArray(input)) {
                _context37.next = 34;
                break;
              }
              dataset.typed = true;
              dataset.value = [];
              _context37.next = 6;
              return Promise.all(_this29.items.map(/*#__PURE__*/function () {
                var _ref37 = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee36(item, key) {
                  var value2;
                  return _regeneratorRuntime().wrap(function _callee36$(_context36) {
                    while (1) switch (_context36.prev = _context36.next) {
                      case 0:
                        value2 = input[key];
                        _context36.t0 = key;
                        _context36.t1 = value2;
                        _context36.next = 5;
                        return item._run({
                          typed: false,
                          value: value2
                        }, config2);
                      case 5:
                        _context36.t2 = _context36.sent;
                        return _context36.abrupt("return", [_context36.t0, _context36.t1, _context36.t2]);
                      case 7:
                      case "end":
                        return _context36.stop();
                    }
                  }, _callee36);
                }));
                return function (_x13, _x14) {
                  return _ref37.apply(this, arguments);
                };
              }()));
            case 6:
              itemDatasets = _context37.sent;
              _iterator51 = _createForOfIteratorHelper(itemDatasets);
              _context37.prev = 8;
              _iterator51.s();
            case 10:
              if ((_step51 = _iterator51.n()).done) {
                _context37.next = 24;
                break;
              }
              _step51$value = _slicedToArray(_step51.value, 3), key = _step51$value[0], value2 = _step51$value[1], itemDataset = _step51$value[2];
              if (!itemDataset.issues) {
                _context37.next = 20;
                break;
              }
              pathItem = {
                type: "array",
                origin: "value",
                input: input,
                key: key,
                value: value2
              };
              _iterator52 = _createForOfIteratorHelper(itemDataset.issues);
              try {
                for (_iterator52.s(); !(_step52 = _iterator52.n()).done;) {
                  issue = _step52.value;
                  if (issue.path) {
                    issue.path.unshift(pathItem);
                  } else {
                    issue.path = [pathItem];
                  }
                  (_dataset$issues30 = dataset.issues) === null || _dataset$issues30 === void 0 || _dataset$issues30.push(issue);
                }
              } catch (err) {
                _iterator52.e(err);
              } finally {
                _iterator52.f();
              }
              if (!dataset.issues) {
                dataset.issues = itemDataset.issues;
              }
              if (!config2.abortEarly) {
                _context37.next = 20;
                break;
              }
              dataset.typed = false;
              return _context37.abrupt("break", 24);
            case 20:
              if (!itemDataset.typed) {
                dataset.typed = false;
              }
              dataset.value.push(itemDataset.value);
            case 22:
              _context37.next = 10;
              break;
            case 24:
              _context37.next = 29;
              break;
            case 26:
              _context37.prev = 26;
              _context37.t0 = _context37["catch"](8);
              _iterator51.e(_context37.t0);
            case 29:
              _context37.prev = 29;
              _iterator51.f();
              return _context37.finish(29);
            case 32:
              _context37.next = 35;
              break;
            case 34:
              _addIssue(_this29, "type", dataset, config2);
            case 35:
              return _context37.abrupt("return", dataset);
            case 36:
            case "end":
              return _context37.stop();
          }
        }, _callee37, null, [[8, 26, 29, 32]]);
      }))();
    }
  };
}

// src/schemas/tupleWithRest/tupleWithRest.ts
function tupleWithRest(items, rest, message) {
  return {
    kind: "schema",
    type: "tuple_with_rest",
    reference: tupleWithRest,
    expects: "Array",
    async: false,
    items: items,
    rest: rest,
    message: message,
    _run: function _run(dataset, config2) {
      var input = dataset.value;
      if (Array.isArray(input)) {
        dataset.typed = true;
        dataset.value = [];
        for (var key = 0; key < this.items.length; key++) {
          var value2 = input[key];
          var itemDataset = this.items[key]._run({
            typed: false,
            value: value2
          }, config2);
          if (itemDataset.issues) {
            var pathItem = {
              type: "array",
              origin: "value",
              input: input,
              key: key,
              value: value2
            };
            var _iterator53 = _createForOfIteratorHelper(itemDataset.issues),
              _step53;
            try {
              for (_iterator53.s(); !(_step53 = _iterator53.n()).done;) {
                var _dataset$issues31;
                var issue = _step53.value;
                if (issue.path) {
                  issue.path.unshift(pathItem);
                } else {
                  issue.path = [pathItem];
                }
                (_dataset$issues31 = dataset.issues) === null || _dataset$issues31 === void 0 || _dataset$issues31.push(issue);
              }
            } catch (err) {
              _iterator53.e(err);
            } finally {
              _iterator53.f();
            }
            if (!dataset.issues) {
              dataset.issues = itemDataset.issues;
            }
            if (config2.abortEarly) {
              dataset.typed = false;
              break;
            }
          }
          if (!itemDataset.typed) {
            dataset.typed = false;
          }
          dataset.value.push(itemDataset.value);
        }
        if (!dataset.issues || !config2.abortEarly) {
          for (var _key15 = this.items.length; _key15 < input.length; _key15++) {
            var _value7 = input[_key15];
            var _itemDataset = this.rest._run({
              typed: false,
              value: _value7
            }, config2);
            if (_itemDataset.issues) {
              var _pathItem7 = {
                type: "array",
                origin: "value",
                input: input,
                key: _key15,
                value: _value7
              };
              var _iterator54 = _createForOfIteratorHelper(_itemDataset.issues),
                _step54;
              try {
                for (_iterator54.s(); !(_step54 = _iterator54.n()).done;) {
                  var _dataset$issues32;
                  var _issue7 = _step54.value;
                  if (_issue7.path) {
                    _issue7.path.unshift(_pathItem7);
                  } else {
                    _issue7.path = [_pathItem7];
                  }
                  (_dataset$issues32 = dataset.issues) === null || _dataset$issues32 === void 0 || _dataset$issues32.push(_issue7);
                }
              } catch (err) {
                _iterator54.e(err);
              } finally {
                _iterator54.f();
              }
              if (!dataset.issues) {
                dataset.issues = _itemDataset.issues;
              }
              if (config2.abortEarly) {
                dataset.typed = false;
                break;
              }
            }
            if (!_itemDataset.typed) {
              dataset.typed = false;
            }
            dataset.value.push(_itemDataset.value);
          }
        }
      } else {
        _addIssue(this, "type", dataset, config2);
      }
      return dataset;
    }
  };
}

// src/schemas/tupleWithRest/tupleWithRestAsync.ts
function tupleWithRestAsync(items, rest, message) {
  return {
    kind: "schema",
    type: "tuple_with_rest",
    reference: tupleWithRestAsync,
    expects: "Array",
    async: true,
    items: items,
    rest: rest,
    message: message,
    _run: function _run(dataset, config2) {
      var _this30 = this;
      return _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee40() {
        var input, _yield$Promise$all3, _yield$Promise$all4, normalDatasets, restDatasets, _iterator55, _step55, _step55$value, _key16, _value8, _itemDataset2, _pathItem8, _iterator58, _step58, _dataset$issues34, _issue8, _iterator56, _step56, _step56$value, key, value2, itemDataset, pathItem, _iterator57, _step57, _dataset$issues33, issue;
        return _regeneratorRuntime().wrap(function _callee40$(_context40) {
          while (1) switch (_context40.prev = _context40.next) {
            case 0:
              input = dataset.value;
              if (!Array.isArray(input)) {
                _context40.next = 63;
                break;
              }
              dataset.typed = true;
              dataset.value = [];
              _context40.next = 6;
              return Promise.all([
              // Parse schema of each normal item
              Promise.all(_this30.items.map(/*#__PURE__*/function () {
                var _ref38 = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee38(item, key) {
                  var value2;
                  return _regeneratorRuntime().wrap(function _callee38$(_context38) {
                    while (1) switch (_context38.prev = _context38.next) {
                      case 0:
                        value2 = input[key];
                        _context38.t0 = key;
                        _context38.t1 = value2;
                        _context38.next = 5;
                        return item._run({
                          typed: false,
                          value: value2
                        }, config2);
                      case 5:
                        _context38.t2 = _context38.sent;
                        return _context38.abrupt("return", [_context38.t0, _context38.t1, _context38.t2]);
                      case 7:
                      case "end":
                        return _context38.stop();
                    }
                  }, _callee38);
                }));
                return function (_x15, _x16) {
                  return _ref38.apply(this, arguments);
                };
              }())),
              // Parse other items with rest schema
              Promise.all(input.slice(_this30.items.length).map(/*#__PURE__*/function () {
                var _ref39 = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee39(value2, key) {
                  return _regeneratorRuntime().wrap(function _callee39$(_context39) {
                    while (1) switch (_context39.prev = _context39.next) {
                      case 0:
                        _context39.t0 = key + _this30.items.length;
                        _context39.t1 = value2;
                        _context39.next = 4;
                        return _this30.rest._run({
                          typed: false,
                          value: value2
                        }, config2);
                      case 4:
                        _context39.t2 = _context39.sent;
                        return _context39.abrupt("return", [_context39.t0, _context39.t1, _context39.t2]);
                      case 6:
                      case "end":
                        return _context39.stop();
                    }
                  }, _callee39);
                }));
                return function (_x17, _x18) {
                  return _ref39.apply(this, arguments);
                };
              }()))]);
            case 6:
              _yield$Promise$all3 = _context40.sent;
              _yield$Promise$all4 = _slicedToArray(_yield$Promise$all3, 2);
              normalDatasets = _yield$Promise$all4[0];
              restDatasets = _yield$Promise$all4[1];
              _iterator55 = _createForOfIteratorHelper(normalDatasets);
              _context40.prev = 11;
              _iterator55.s();
            case 13:
              if ((_step55 = _iterator55.n()).done) {
                _context40.next = 27;
                break;
              }
              _step55$value = _slicedToArray(_step55.value, 3), _key16 = _step55$value[0], _value8 = _step55$value[1], _itemDataset2 = _step55$value[2];
              if (!_itemDataset2.issues) {
                _context40.next = 23;
                break;
              }
              _pathItem8 = {
                type: "array",
                origin: "value",
                input: input,
                key: _key16,
                value: _value8
              };
              _iterator58 = _createForOfIteratorHelper(_itemDataset2.issues);
              try {
                for (_iterator58.s(); !(_step58 = _iterator58.n()).done;) {
                  _issue8 = _step58.value;
                  if (_issue8.path) {
                    _issue8.path.unshift(_pathItem8);
                  } else {
                    _issue8.path = [_pathItem8];
                  }
                  (_dataset$issues34 = dataset.issues) === null || _dataset$issues34 === void 0 || _dataset$issues34.push(_issue8);
                }
              } catch (err) {
                _iterator58.e(err);
              } finally {
                _iterator58.f();
              }
              if (!dataset.issues) {
                dataset.issues = _itemDataset2.issues;
              }
              if (!config2.abortEarly) {
                _context40.next = 23;
                break;
              }
              dataset.typed = false;
              return _context40.abrupt("break", 27);
            case 23:
              if (!_itemDataset2.typed) {
                dataset.typed = false;
              }
              dataset.value.push(_itemDataset2.value);
            case 25:
              _context40.next = 13;
              break;
            case 27:
              _context40.next = 32;
              break;
            case 29:
              _context40.prev = 29;
              _context40.t0 = _context40["catch"](11);
              _iterator55.e(_context40.t0);
            case 32:
              _context40.prev = 32;
              _iterator55.f();
              return _context40.finish(32);
            case 35:
              if (!(!dataset.issues || !config2.abortEarly)) {
                _context40.next = 61;
                break;
              }
              _iterator56 = _createForOfIteratorHelper(restDatasets);
              _context40.prev = 37;
              _iterator56.s();
            case 39:
              if ((_step56 = _iterator56.n()).done) {
                _context40.next = 53;
                break;
              }
              _step56$value = _slicedToArray(_step56.value, 3), key = _step56$value[0], value2 = _step56$value[1], itemDataset = _step56$value[2];
              if (!itemDataset.issues) {
                _context40.next = 49;
                break;
              }
              pathItem = {
                type: "array",
                origin: "value",
                input: input,
                key: key,
                value: value2
              };
              _iterator57 = _createForOfIteratorHelper(itemDataset.issues);
              try {
                for (_iterator57.s(); !(_step57 = _iterator57.n()).done;) {
                  issue = _step57.value;
                  if (issue.path) {
                    issue.path.unshift(pathItem);
                  } else {
                    issue.path = [pathItem];
                  }
                  (_dataset$issues33 = dataset.issues) === null || _dataset$issues33 === void 0 || _dataset$issues33.push(issue);
                }
              } catch (err) {
                _iterator57.e(err);
              } finally {
                _iterator57.f();
              }
              if (!dataset.issues) {
                dataset.issues = itemDataset.issues;
              }
              if (!config2.abortEarly) {
                _context40.next = 49;
                break;
              }
              dataset.typed = false;
              return _context40.abrupt("break", 53);
            case 49:
              if (!itemDataset.typed) {
                dataset.typed = false;
              }
              dataset.value.push(itemDataset.value);
            case 51:
              _context40.next = 39;
              break;
            case 53:
              _context40.next = 58;
              break;
            case 55:
              _context40.prev = 55;
              _context40.t1 = _context40["catch"](37);
              _iterator56.e(_context40.t1);
            case 58:
              _context40.prev = 58;
              _iterator56.f();
              return _context40.finish(58);
            case 61:
              _context40.next = 64;
              break;
            case 63:
              _addIssue(_this30, "type", dataset, config2);
            case 64:
              return _context40.abrupt("return", dataset);
            case 65:
            case "end":
              return _context40.stop();
          }
        }, _callee40, null, [[11, 29, 32, 35], [37, 55, 58, 61]]);
      }))();
    }
  };
}

// src/schemas/undefined/undefined.ts
function undefined_(message) {
  return {
    kind: "schema",
    type: "undefined",
    reference: undefined_,
    expects: "undefined",
    async: false,
    message: message,
    _run: function _run(dataset, config2) {
      if (dataset.value === void 0) {
        dataset.typed = true;
      } else {
        _addIssue(this, "type", dataset, config2);
      }
      return dataset;
    }
  };
}

// src/schemas/union/utils/_subIssues/_subIssues.ts
function _subIssues(datasets) {
  var issues;
  if (datasets) {
    var _iterator59 = _createForOfIteratorHelper(datasets),
      _step59;
    try {
      for (_iterator59.s(); !(_step59 = _iterator59.n()).done;) {
        var dataset = _step59.value;
        if (issues) {
          var _issues;
          (_issues = issues).push.apply(_issues, _toConsumableArray(dataset.issues));
        } else {
          issues = dataset.issues;
        }
      }
    } catch (err) {
      _iterator59.e(err);
    } finally {
      _iterator59.f();
    }
  }
  return issues;
}

// src/schemas/union/union.ts
function union(options, message) {
  return {
    kind: "schema",
    type: "union",
    reference: union,
    expects: _joinExpects(options.map(function (option) {
      return option.expects;
    }), "|"),
    async: false,
    options: options,
    message: message,
    _run: function _run(dataset, config2) {
      var _untypedDatasets;
      var validDataset;
      var typedDatasets;
      var untypedDatasets;
      var _iterator60 = _createForOfIteratorHelper(this.options),
        _step60;
      try {
        for (_iterator60.s(); !(_step60 = _iterator60.n()).done;) {
          var schema = _step60.value;
          var optionDataset = schema._run({
            typed: false,
            value: dataset.value
          }, config2);
          if (optionDataset.typed) {
            if (optionDataset.issues) {
              if (typedDatasets) {
                typedDatasets.push(optionDataset);
              } else {
                typedDatasets = [optionDataset];
              }
            } else {
              validDataset = optionDataset;
              break;
            }
          } else {
            if (untypedDatasets) {
              untypedDatasets.push(optionDataset);
            } else {
              untypedDatasets = [optionDataset];
            }
          }
        }
      } catch (err) {
        _iterator60.e(err);
      } finally {
        _iterator60.f();
      }
      if (validDataset) {
        return validDataset;
      }
      if (typedDatasets) {
        if (typedDatasets.length === 1) {
          return typedDatasets[0];
        }
        _addIssue(this, "type", dataset, config2, {
          issues: _subIssues(typedDatasets)
        });
        dataset.typed = true;
      } else if (((_untypedDatasets = untypedDatasets) === null || _untypedDatasets === void 0 ? void 0 : _untypedDatasets.length) === 1) {
        return untypedDatasets[0];
      } else {
        _addIssue(this, "type", dataset, config2, {
          issues: _subIssues(untypedDatasets)
        });
      }
      return dataset;
    }
  };
}

// src/schemas/union/unionAsync.ts
function unionAsync(options, message) {
  return {
    kind: "schema",
    type: "union",
    reference: unionAsync,
    expects: _joinExpects(options.map(function (option) {
      return option.expects;
    }), "|"),
    async: true,
    options: options,
    message: message,
    _run: function _run(dataset, config2) {
      var _this31 = this;
      return _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee41() {
        var _untypedDatasets2;
        var validDataset, typedDatasets, untypedDatasets, _iterator61, _step61, schema, optionDataset;
        return _regeneratorRuntime().wrap(function _callee41$(_context41) {
          while (1) switch (_context41.prev = _context41.next) {
            case 0:
              _iterator61 = _createForOfIteratorHelper(_this31.options);
              _context41.prev = 1;
              _iterator61.s();
            case 3:
              if ((_step61 = _iterator61.n()).done) {
                _context41.next = 20;
                break;
              }
              schema = _step61.value;
              _context41.next = 7;
              return schema._run({
                typed: false,
                value: dataset.value
              }, config2);
            case 7:
              optionDataset = _context41.sent;
              if (!optionDataset.typed) {
                _context41.next = 17;
                break;
              }
              if (!optionDataset.issues) {
                _context41.next = 13;
                break;
              }
              if (typedDatasets) {
                typedDatasets.push(optionDataset);
              } else {
                typedDatasets = [optionDataset];
              }
              _context41.next = 15;
              break;
            case 13:
              validDataset = optionDataset;
              return _context41.abrupt("break", 20);
            case 15:
              _context41.next = 18;
              break;
            case 17:
              if (untypedDatasets) {
                untypedDatasets.push(optionDataset);
              } else {
                untypedDatasets = [optionDataset];
              }
            case 18:
              _context41.next = 3;
              break;
            case 20:
              _context41.next = 25;
              break;
            case 22:
              _context41.prev = 22;
              _context41.t0 = _context41["catch"](1);
              _iterator61.e(_context41.t0);
            case 25:
              _context41.prev = 25;
              _iterator61.f();
              return _context41.finish(25);
            case 28:
              if (!validDataset) {
                _context41.next = 30;
                break;
              }
              return _context41.abrupt("return", validDataset);
            case 30:
              if (!typedDatasets) {
                _context41.next = 37;
                break;
              }
              if (!(typedDatasets.length === 1)) {
                _context41.next = 33;
                break;
              }
              return _context41.abrupt("return", typedDatasets[0]);
            case 33:
              _addIssue(_this31, "type", dataset, config2, {
                issues: _subIssues(typedDatasets)
              });
              dataset.typed = true;
              _context41.next = 42;
              break;
            case 37:
              if (!(((_untypedDatasets2 = untypedDatasets) === null || _untypedDatasets2 === void 0 ? void 0 : _untypedDatasets2.length) === 1)) {
                _context41.next = 41;
                break;
              }
              return _context41.abrupt("return", untypedDatasets[0]);
            case 41:
              _addIssue(_this31, "type", dataset, config2, {
                issues: _subIssues(untypedDatasets)
              });
            case 42:
              return _context41.abrupt("return", dataset);
            case 43:
            case "end":
              return _context41.stop();
          }
        }, _callee41, null, [[1, 22, 25, 28]]);
      }))();
    }
  };
}

// src/schemas/unknown/unknown.ts
function unknown() {
  return {
    kind: "schema",
    type: "unknown",
    reference: unknown,
    expects: "unknown",
    async: false,
    _run: function _run(dataset) {
      dataset.typed = true;
      return dataset;
    }
  };
}

// src/schemas/variant/utils/_discriminators/_discriminators.ts
function _discriminators(key, options) {
  var list = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];
  var _iterator62 = _createForOfIteratorHelper(options),
    _step62;
  try {
    for (_iterator62.s(); !(_step62 = _iterator62.n()).done;) {
      var schema = _step62.value;
      if (schema.type === "variant") {
        _discriminators(key, schema.options, list);
      } else {
        list.push(schema.entries[key].expects);
      }
    }
  } catch (err) {
    _iterator62.e(err);
  } finally {
    _iterator62.f();
  }
  return list;
}

// src/schemas/variant/variant.ts
function variant(key, options, message) {
  var expectedDiscriminators;
  return {
    kind: "schema",
    type: "variant",
    reference: variant,
    expects: "Object",
    async: false,
    key: key,
    options: options,
    message: message,
    _run: function _run(dataset, config2) {
      var input = dataset.value;
      if (input && _typeof(input) === "object") {
        var discriminator = input[this.key];
        if (this.key in input) {
          var outputDataset;
          var _iterator63 = _createForOfIteratorHelper(this.options),
            _step63;
          try {
            for (_iterator63.s(); !(_step63 = _iterator63.n()).done;) {
              var schema = _step63.value;
              if (schema.type === "variant" || !schema.entries[this.key]._run({
                typed: false,
                value: discriminator
              }, config2).issues) {
                var optionDataset = schema._run({
                  typed: false,
                  value: input
                }, config2);
                if (!optionDataset.issues) {
                  return optionDataset;
                }
                if (!outputDataset || !outputDataset.typed && optionDataset.typed) {
                  outputDataset = optionDataset;
                }
              }
            }
          } catch (err) {
            _iterator63.e(err);
          } finally {
            _iterator63.f();
          }
          if (outputDataset) {
            return outputDataset;
          }
        }
        if (!expectedDiscriminators) {
          expectedDiscriminators = _joinExpects(_discriminators(this.key, this.options), "|");
        }
        _addIssue(this, "type", dataset, config2, {
          input: discriminator,
          expected: expectedDiscriminators,
          path: [{
            type: "object",
            origin: "value",
            input: input,
            key: this.key,
            value: discriminator
          }]
        });
      } else {
        _addIssue(this, "type", dataset, config2);
      }
      return dataset;
    }
  };
}

// src/schemas/variant/variantAsync.ts
function variantAsync(key, options, message) {
  var expectedDiscriminators;
  return {
    kind: "schema",
    type: "variant",
    reference: variantAsync,
    expects: "Object",
    async: true,
    key: key,
    options: options,
    message: message,
    _run: function _run(dataset, config2) {
      var _this32 = this;
      return _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee42() {
        var input, discriminator, outputDataset, _iterator64, _step64, schema, optionDataset;
        return _regeneratorRuntime().wrap(function _callee42$(_context42) {
          while (1) switch (_context42.prev = _context42.next) {
            case 0:
              input = dataset.value;
              if (!(input && _typeof(input) === "object")) {
                _context42.next = 37;
                break;
              }
              discriminator = input[_this32.key];
              if (!(_this32.key in input)) {
                _context42.next = 33;
                break;
              }
              _iterator64 = _createForOfIteratorHelper(_this32.options);
              _context42.prev = 5;
              _iterator64.s();
            case 7:
              if ((_step64 = _iterator64.n()).done) {
                _context42.next = 23;
                break;
              }
              schema = _step64.value;
              _context42.t0 = schema.type === "variant";
              if (_context42.t0) {
                _context42.next = 14;
                break;
              }
              _context42.next = 13;
              return schema.entries[_this32.key]._run({
                typed: false,
                value: discriminator
              }, config2);
            case 13:
              _context42.t0 = !_context42.sent.issues;
            case 14:
              if (!_context42.t0) {
                _context42.next = 21;
                break;
              }
              _context42.next = 17;
              return schema._run({
                typed: false,
                value: input
              }, config2);
            case 17:
              optionDataset = _context42.sent;
              if (optionDataset.issues) {
                _context42.next = 20;
                break;
              }
              return _context42.abrupt("return", optionDataset);
            case 20:
              if (!outputDataset || !outputDataset.typed && optionDataset.typed) {
                outputDataset = optionDataset;
              }
            case 21:
              _context42.next = 7;
              break;
            case 23:
              _context42.next = 28;
              break;
            case 25:
              _context42.prev = 25;
              _context42.t1 = _context42["catch"](5);
              _iterator64.e(_context42.t1);
            case 28:
              _context42.prev = 28;
              _iterator64.f();
              return _context42.finish(28);
            case 31:
              if (!outputDataset) {
                _context42.next = 33;
                break;
              }
              return _context42.abrupt("return", outputDataset);
            case 33:
              if (!expectedDiscriminators) {
                expectedDiscriminators = _joinExpects(_discriminators(_this32.key, _this32.options), "|");
              }
              _addIssue(_this32, "type", dataset, config2, {
                input: discriminator,
                expected: expectedDiscriminators,
                path: [{
                  type: "object",
                  origin: "value",
                  input: input,
                  key: _this32.key,
                  value: discriminator
                }]
              });
              _context42.next = 38;
              break;
            case 37:
              _addIssue(_this32, "type", dataset, config2);
            case 38:
              return _context42.abrupt("return", dataset);
            case 39:
            case "end":
              return _context42.stop();
          }
        }, _callee42, null, [[5, 25, 28, 31]]);
      }))();
    }
  };
}

// src/schemas/void/void.ts
function void_(message) {
  return {
    kind: "schema",
    type: "void",
    reference: void_,
    expects: "void",
    async: false,
    message: message,
    _run: function _run(dataset, config2) {
      if (dataset.value === void 0) {
        dataset.typed = true;
      } else {
        _addIssue(this, "type", dataset, config2);
      }
      return dataset;
    }
  };
}

// src/methods/keyof/keyof.ts
function keyof(schema, message) {
  return picklist(Object.keys(schema.entries), message);
}

// src/methods/omit/omit.ts
function omit(schema, keys) {
  var entries = _objectSpread({}, schema.entries);
  var _iterator65 = _createForOfIteratorHelper(keys),
    _step65;
  try {
    for (_iterator65.s(); !(_step65 = _iterator65.n()).done;) {
      var key = _step65.value;
      delete entries[key];
    }
  } catch (err) {
    _iterator65.e(err);
  } finally {
    _iterator65.f();
  }
  return _objectSpread(_objectSpread({}, schema), {}, {
    entries: entries
  });
}

// src/methods/parse/parse.ts
function parse(schema, input, config2) {
  var dataset = schema._run({
    typed: false,
    value: input
  }, getGlobalConfig(config2));
  if (dataset.issues) {
    throw new ValiError(dataset.issues);
  }
  return dataset.value;
}

// src/methods/parse/parseAsync.ts
function parseAsync(_x19, _x20, _x21) {
  return _parseAsync.apply(this, arguments);
} // src/methods/parser/parser.ts
function _parseAsync() {
  _parseAsync = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee48(schema, input, config2) {
    var dataset;
    return _regeneratorRuntime().wrap(function _callee48$(_context48) {
      while (1) switch (_context48.prev = _context48.next) {
        case 0:
          _context48.next = 2;
          return schema._run({
            typed: false,
            value: input
          }, getGlobalConfig(config2));
        case 2:
          dataset = _context48.sent;
          if (!dataset.issues) {
            _context48.next = 5;
            break;
          }
          throw new ValiError(dataset.issues);
        case 5:
          return _context48.abrupt("return", dataset.value);
        case 6:
        case "end":
          return _context48.stop();
      }
    }, _callee48);
  }));
  return _parseAsync.apply(this, arguments);
}
function parser(schema, config2) {
  var func = function func(input) {
    return parse(schema, input, config2);
  };
  func.schema = schema;
  func.config = config2;
  return func;
}

// src/methods/parser/parserAsync.ts
function parserAsync(schema, config2) {
  var func = function func(input) {
    return parseAsync(schema, input, config2);
  };
  func.schema = schema;
  func.config = config2;
  return func;
}

// src/methods/partial/partial.ts
function partial(schema, keys) {
  var entries = {};
  for (var key in schema.entries) {
    entries[key] = !keys || keys.includes(key) ? optional(schema.entries[key]) : schema.entries[key];
  }
  return _objectSpread(_objectSpread({}, schema), {}, {
    entries: entries
  });
}

// src/methods/partial/partialAsync.ts
function partialAsync(schema, keys) {
  var entries = {};
  for (var key in schema.entries) {
    entries[key] = !keys || keys.includes(key) ? optionalAsync(schema.entries[key]) : schema.entries[key];
  }
  return _objectSpread(_objectSpread({}, schema), {}, {
    entries: entries
  });
}

// src/methods/pick/pick.ts
function pick(schema, keys) {
  var entries = {};
  var _iterator66 = _createForOfIteratorHelper(keys),
    _step66;
  try {
    for (_iterator66.s(); !(_step66 = _iterator66.n()).done;) {
      var key = _step66.value;
      entries[key] = schema.entries[key];
    }
  } catch (err) {
    _iterator66.e(err);
  } finally {
    _iterator66.f();
  }
  return _objectSpread(_objectSpread({}, schema), {}, {
    entries: entries
  });
}

// src/methods/pipe/pipe.ts
function pipe() {
  for (var _len7 = arguments.length, pipe2 = new Array(_len7), _key17 = 0; _key17 < _len7; _key17++) {
    pipe2[_key17] = arguments[_key17];
  }
  return _objectSpread(_objectSpread({}, pipe2[0]), {}, {
    pipe: pipe2,
    _run: function _run(dataset, config2) {
      for (var _i = 0, _pipe = pipe2; _i < _pipe.length; _i++) {
        var item = _pipe[_i];
        if (item.kind !== "metadata") {
          if (dataset.issues && (item.kind === "schema" || item.kind === "transformation")) {
            dataset.typed = false;
            break;
          }
          if (!dataset.issues || !config2.abortEarly && !config2.abortPipeEarly) {
            dataset = item._run(dataset, config2);
          }
        }
      }
      return dataset;
    }
  });
}

// src/methods/pipe/pipeAsync.ts
function pipeAsync() {
  for (var _len8 = arguments.length, pipe2 = new Array(_len8), _key18 = 0; _key18 < _len8; _key18++) {
    pipe2[_key18] = arguments[_key18];
  }
  return _objectSpread(_objectSpread({}, pipe2[0]), {}, {
    pipe: pipe2,
    async: true,
    _run: function _run(dataset, config2) {
      return _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee43() {
        var _i2, _pipe2, item;
        return _regeneratorRuntime().wrap(function _callee43$(_context43) {
          while (1) switch (_context43.prev = _context43.next) {
            case 0:
              _i2 = 0, _pipe2 = pipe2;
            case 1:
              if (!(_i2 < _pipe2.length)) {
                _context43.next = 14;
                break;
              }
              item = _pipe2[_i2];
              if (!(item.kind !== "metadata")) {
                _context43.next = 11;
                break;
              }
              if (!(dataset.issues && (item.kind === "schema" || item.kind === "transformation"))) {
                _context43.next = 7;
                break;
              }
              dataset.typed = false;
              return _context43.abrupt("break", 14);
            case 7:
              if (!(!dataset.issues || !config2.abortEarly && !config2.abortPipeEarly)) {
                _context43.next = 11;
                break;
              }
              _context43.next = 10;
              return item._run(dataset, config2);
            case 10:
              dataset = _context43.sent;
            case 11:
              _i2++;
              _context43.next = 1;
              break;
            case 14:
              return _context43.abrupt("return", dataset);
            case 15:
            case "end":
              return _context43.stop();
          }
        }, _callee43);
      }))();
    }
  });
}

// src/methods/required/required.ts
function required(schema, arg2, arg3) {
  var keys = Array.isArray(arg2) ? arg2 : void 0;
  var message = Array.isArray(arg2) ? arg3 : arg2;
  var entries = {};
  for (var key in schema.entries) {
    entries[key] = !keys || keys.includes(key) ? nonOptional(schema.entries[key], message) : schema.entries[key];
  }
  return _objectSpread(_objectSpread({}, schema), {}, {
    entries: entries
  });
}

// src/methods/required/requiredAsync.ts
function requiredAsync(schema, arg2, arg3) {
  var keys = Array.isArray(arg2) ? arg2 : void 0;
  var message = Array.isArray(arg2) ? arg3 : arg2;
  var entries = {};
  for (var key in schema.entries) {
    entries[key] = !keys || keys.includes(key) ? nonOptionalAsync(schema.entries[key], message) : schema.entries[key];
  }
  return _objectSpread(_objectSpread({}, schema), {}, {
    entries: entries
  });
}

// src/methods/safeParse/safeParse.ts
function safeParse(schema, input, config2) {
  var dataset = schema._run({
    typed: false,
    value: input
  }, getGlobalConfig(config2));
  return {
    typed: dataset.typed,
    success: !dataset.issues,
    output: dataset.value,
    issues: dataset.issues
  };
}

// src/methods/safeParse/safeParseAsync.ts
function safeParseAsync(_x22, _x23, _x24) {
  return _safeParseAsync.apply(this, arguments);
} // src/methods/safeParser/safeParser.ts
function _safeParseAsync() {
  _safeParseAsync = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee49(schema, input, config2) {
    var dataset;
    return _regeneratorRuntime().wrap(function _callee49$(_context49) {
      while (1) switch (_context49.prev = _context49.next) {
        case 0:
          _context49.next = 2;
          return schema._run({
            typed: false,
            value: input
          }, getGlobalConfig(config2));
        case 2:
          dataset = _context49.sent;
          return _context49.abrupt("return", {
            typed: dataset.typed,
            success: !dataset.issues,
            output: dataset.value,
            issues: dataset.issues
          });
        case 4:
        case "end":
          return _context49.stop();
      }
    }, _callee49);
  }));
  return _safeParseAsync.apply(this, arguments);
}
function safeParser(schema, config2) {
  var func = function func(input) {
    return safeParse(schema, input, config2);
  };
  func.schema = schema;
  func.config = config2;
  return func;
}

// src/methods/safeParser/safeParserAsync.ts
function safeParserAsync(schema, config2) {
  var func = function func(input) {
    return safeParseAsync(schema, input, config2);
  };
  func.schema = schema;
  func.config = config2;
  return func;
}

// src/methods/unwrap/unwrap.ts
function unwrap(schema) {
  return schema.wrapped;
}

},{}],67:[function(require,module,exports){
'use strict';

var __createBinding = void 0 && (void 0).__createBinding || (Object.create ? function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  var desc = Object.getOwnPropertyDescriptor(m, k);
  if (!desc || ('get' in desc ? !m.__esModule : desc.writable || desc.configurable)) {
    desc = {
      enumerable: true,
      get: function get() {
        return m[k];
      }
    };
  }
  Object.defineProperty(o, k2, desc);
} : function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  o[k2] = m[k];
});
var __setModuleDefault = void 0 && (void 0).__setModuleDefault || (Object.create ? function (o, v) {
  Object.defineProperty(o, 'default', {
    enumerable: true,
    value: v
  });
} : function (o, v) {
  o['default'] = v;
});
var __importStar = void 0 && (void 0).__importStar || function (mod) {
  if (mod && mod.__esModule) return mod;
  var result = {};
  if (mod != null) for (var k in mod) if (k !== 'default' && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
  __setModuleDefault(result, mod);
  return result;
};
var __importDefault = void 0 && (void 0).__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};
Object.defineProperty(exports, '__esModule', {
  value: true
});
exports.fromBase58Check = fromBase58Check;
exports.fromBech32 = fromBech32;
exports.toBase58Check = toBase58Check;
exports.toBech32 = toBech32;
exports.fromOutputScript = fromOutputScript;
exports.toOutputScript = toOutputScript;
var networks = __importStar(require('./networks.cjs'));
var payments = __importStar(require('./payments/index.cjs'));
var bscript = __importStar(require('./script.cjs'));
var types_js_1 = require('./types.cjs');
var bech32_1 = require('bech32');
var bs58check_1 = __importDefault(require('bs58check'));
var tools = __importStar(require('uint8array-tools'));
var v = __importStar(require('valibot'));
var FUTURE_SEGWIT_MAX_SIZE = 40;
var FUTURE_SEGWIT_MIN_SIZE = 2;
var FUTURE_SEGWIT_MAX_VERSION = 16;
var FUTURE_SEGWIT_MIN_VERSION = 2;
var FUTURE_SEGWIT_VERSION_DIFF = 0x50;
var FUTURE_SEGWIT_VERSION_WARNING = 'WARNING: Sending to a future segwit version address can lead to loss of funds. ' + 'End users MUST be warned carefully in the GUI and asked if they wish to proceed ' + 'with caution. Wallets should verify the segwit version from the output of fromBech32, ' + 'then decide when it is safe to use which version of segwit.';
/**
 * Converts an output buffer to a future segwit address.
 * @param output - The output buffer.
 * @param network - The network object.
 * @returns The future segwit address.
 * @throws {TypeError} If the program length or version is invalid for segwit address.
 */
function _toFutureSegwitAddress(output, network) {
  var data = output.slice(2);
  if (data.length < FUTURE_SEGWIT_MIN_SIZE || data.length > FUTURE_SEGWIT_MAX_SIZE) throw new TypeError('Invalid program length for segwit address');
  var version = output[0] - FUTURE_SEGWIT_VERSION_DIFF;
  if (version < FUTURE_SEGWIT_MIN_VERSION || version > FUTURE_SEGWIT_MAX_VERSION) throw new TypeError('Invalid version for segwit address');
  if (output[1] !== data.length) throw new TypeError('Invalid script for segwit address');
  console.warn(FUTURE_SEGWIT_VERSION_WARNING);
  return toBech32(data, version, network.bech32);
}
/**
 * Decodes a base58check encoded Bitcoin address and returns the version and hash.
 *
 * @param address - The base58check encoded Bitcoin address to decode.
 * @returns An object containing the version and hash of the decoded address.
 * @throws {TypeError} If the address is too short or too long.
 */
function fromBase58Check(address) {
  var payload = bs58check_1["default"].decode(address);
  // TODO: 4.0.0, move to "toOutputScript"
  if (payload.length < 21) throw new TypeError(address + ' is too short');
  if (payload.length > 21) throw new TypeError(address + ' is too long');
  var version = tools.readUInt8(payload, 0);
  var hash = payload.slice(1);
  return {
    version: version,
    hash: hash
  };
}
/**
 * Converts a Bech32 or Bech32m encoded address to its corresponding data representation.
 * @param address - The Bech32 or Bech32m encoded address.
 * @returns An object containing the version, prefix, and data of the address.
 * @throws {TypeError} If the address uses the wrong encoding.
 */
function fromBech32(address) {
  var result;
  var version;
  try {
    result = bech32_1.bech32.decode(address);
  } catch (e) {}
  if (result) {
    version = result.words[0];
    if (version !== 0) throw new TypeError(address + ' uses wrong encoding');
  } else {
    result = bech32_1.bech32m.decode(address);
    version = result.words[0];
    if (version === 0) throw new TypeError(address + ' uses wrong encoding');
  }
  var data = bech32_1.bech32.fromWords(result.words.slice(1));
  return {
    version: version,
    prefix: result.prefix,
    data: Uint8Array.from(data)
  };
}
/**
 * Converts a hash to a Base58Check-encoded string.
 * @param hash - The hash to be encoded.
 * @param version - The version byte to be prepended to the encoded string.
 * @returns The Base58Check-encoded string.
 */
function toBase58Check(hash, version) {
  v.parse(v.tuple([types_js_1.Hash160bitSchema, types_js_1.UInt8Schema]), [hash, version]);
  var payload = new Uint8Array(21);
  tools.writeUInt8(payload, 0, version);
  payload.set(hash, 1);
  return bs58check_1["default"].encode(payload);
}
/**
 * Converts a buffer to a Bech32 or Bech32m encoded string.
 * @param data - The buffer to be encoded.
 * @param version - The version number to be used in the encoding.
 * @param prefix - The prefix string to be used in the encoding.
 * @returns The Bech32 or Bech32m encoded string.
 */
function toBech32(data, version, prefix) {
  var words = bech32_1.bech32.toWords(data);
  words.unshift(version);
  return version === 0 ? bech32_1.bech32.encode(prefix, words) : bech32_1.bech32m.encode(prefix, words);
}
/**
 * Converts an output script to a Bitcoin address.
 * @param output - The output script as a Buffer.
 * @param network - The Bitcoin network (optional).
 * @returns The Bitcoin address corresponding to the output script.
 * @throws If the output script has no matching address.
 */
function fromOutputScript(output, network) {
  // TODO: Network
  network = network || networks.bitcoin;
  try {
    return payments.p2pkh({
      output: output,
      network: network
    }).address;
  } catch (e) {}
  try {
    return payments.p2sh({
      output: output,
      network: network
    }).address;
  } catch (e) {}
  try {
    return payments.p2wpkh({
      output: output,
      network: network
    }).address;
  } catch (e) {}
  try {
    return payments.p2wsh({
      output: output,
      network: network
    }).address;
  } catch (e) {}
  try {
    return payments.p2tr({
      output: output,
      network: network
    }).address;
  } catch (e) {}
  try {
    return _toFutureSegwitAddress(output, network);
  } catch (e) {}
  throw new Error(bscript.toASM(output) + ' has no matching Address');
}
/**
 * Converts a Bitcoin address to its corresponding output script.
 * @param address - The Bitcoin address to convert.
 * @param network - The Bitcoin network to use. Defaults to the Bitcoin network.
 * @returns The corresponding output script as a Buffer.
 * @throws If the address has an invalid prefix or no matching script.
 */
function toOutputScript(address, network) {
  network = network || networks.bitcoin;
  var decodeBase58;
  var decodeBech32;
  try {
    decodeBase58 = fromBase58Check(address);
  } catch (e) {}
  if (decodeBase58) {
    if (decodeBase58.version === network.pubKeyHash) return payments.p2pkh({
      hash: decodeBase58.hash
    }).output;
    if (decodeBase58.version === network.scriptHash) return payments.p2sh({
      hash: decodeBase58.hash
    }).output;
  } else {
    try {
      decodeBech32 = fromBech32(address);
    } catch (e) {}
    if (decodeBech32) {
      if (decodeBech32.prefix !== network.bech32) throw new Error(address + ' has an invalid prefix');
      if (decodeBech32.version === 0) {
        if (decodeBech32.data.length === 20) return payments.p2wpkh({
          hash: decodeBech32.data
        }).output;
        if (decodeBech32.data.length === 32) return payments.p2wsh({
          hash: decodeBech32.data
        }).output;
      } else if (decodeBech32.version === 1) {
        if (decodeBech32.data.length === 32) return payments.p2tr({
          pubkey: decodeBech32.data
        }).output;
      } else if (decodeBech32.version >= FUTURE_SEGWIT_MIN_VERSION && decodeBech32.version <= FUTURE_SEGWIT_MAX_VERSION && decodeBech32.data.length >= FUTURE_SEGWIT_MIN_SIZE && decodeBech32.data.length <= FUTURE_SEGWIT_MAX_SIZE) {
        console.warn(FUTURE_SEGWIT_VERSION_WARNING);
        return bscript.compile([decodeBech32.version + FUTURE_SEGWIT_VERSION_DIFF, decodeBech32.data]);
      }
    }
  }
  throw new Error(address + ' has no matching Script');
}

},{"./networks.cjs":75,"./payments/index.cjs":79,"./script.cjs":92,"./types.cjs":96,"bech32":17,"bs58check":100,"uint8array-tools":65,"valibot":66}],68:[function(require,module,exports){
'use strict';

// Reference https://github.com/bitcoin/bips/blob/master/bip-0066.mediawiki
// Format: 0x30 [total-length] 0x02 [R-length] [R] 0x02 [S-length] [S]
// NOTE: SIGHASH byte ignored AND restricted, truncate before use
Object.defineProperty(exports, '__esModule', {
  value: true
});
exports.check = check;
exports.decode = decode;
exports.encode = encode;
/**
 * Checks if the given buffer is a valid BIP66-encoded signature.
 *
 * @param buffer - The buffer to check.
 * @returns A boolean indicating whether the buffer is a valid BIP66-encoded signature.
 */
function check(buffer) {
  if (buffer.length < 8) return false;
  if (buffer.length > 72) return false;
  if (buffer[0] !== 0x30) return false;
  if (buffer[1] !== buffer.length - 2) return false;
  if (buffer[2] !== 0x02) return false;
  var lenR = buffer[3];
  if (lenR === 0) return false;
  if (5 + lenR >= buffer.length) return false;
  if (buffer[4 + lenR] !== 0x02) return false;
  var lenS = buffer[5 + lenR];
  if (lenS === 0) return false;
  if (6 + lenR + lenS !== buffer.length) return false;
  if (buffer[4] & 0x80) return false;
  if (lenR > 1 && buffer[4] === 0x00 && !(buffer[5] & 0x80)) return false;
  if (buffer[lenR + 6] & 0x80) return false;
  if (lenS > 1 && buffer[lenR + 6] === 0x00 && !(buffer[lenR + 7] & 0x80)) return false;
  return true;
}
/**
 * Decodes a DER-encoded signature buffer and returns the R and S values.
 * @param buffer - The DER-encoded signature buffer.
 * @returns An object containing the R and S values.
 * @throws {Error} If the DER sequence length is too short, too long, or invalid.
 * @throws {Error} If the R or S length is zero or invalid.
 * @throws {Error} If the R or S value is negative or excessively padded.
 */
function decode(buffer) {
  if (buffer.length < 8) throw new Error('DER sequence length is too short');
  if (buffer.length > 72) throw new Error('DER sequence length is too long');
  if (buffer[0] !== 0x30) throw new Error('Expected DER sequence');
  if (buffer[1] !== buffer.length - 2) throw new Error('DER sequence length is invalid');
  if (buffer[2] !== 0x02) throw new Error('Expected DER integer');
  var lenR = buffer[3];
  if (lenR === 0) throw new Error('R length is zero');
  if (5 + lenR >= buffer.length) throw new Error('R length is too long');
  if (buffer[4 + lenR] !== 0x02) throw new Error('Expected DER integer (2)');
  var lenS = buffer[5 + lenR];
  if (lenS === 0) throw new Error('S length is zero');
  if (6 + lenR + lenS !== buffer.length) throw new Error('S length is invalid');
  if (buffer[4] & 0x80) throw new Error('R value is negative');
  if (lenR > 1 && buffer[4] === 0x00 && !(buffer[5] & 0x80)) throw new Error('R value excessively padded');
  if (buffer[lenR + 6] & 0x80) throw new Error('S value is negative');
  if (lenS > 1 && buffer[lenR + 6] === 0x00 && !(buffer[lenR + 7] & 0x80)) throw new Error('S value excessively padded');
  // non-BIP66 - extract R, S values
  return {
    r: buffer.slice(4, 4 + lenR),
    s: buffer.slice(6 + lenR)
  };
}
/*
 * Expects r and s to be positive DER integers.
 *
 * The DER format uses the most significant bit as a sign bit (& 0x80).
 * If the significant bit is set AND the integer is positive, a 0x00 is prepended.
 *
 * Examples:
 *
 *      0 =>     0x00
 *      1 =>     0x01
 *     -1 =>     0xff
 *    127 =>     0x7f
 *   -127 =>     0x81
 *    128 =>   0x0080
 *   -128 =>     0x80
 *    255 =>   0x00ff
 *   -255 =>   0xff01
 *  16300 =>   0x3fac
 * -16300 =>   0xc054
 *  62300 => 0x00f35c
 * -62300 => 0xff0ca4
 */
function encode(r, s) {
  var lenR = r.length;
  var lenS = s.length;
  if (lenR === 0) throw new Error('R length is zero');
  if (lenS === 0) throw new Error('S length is zero');
  if (lenR > 33) throw new Error('R length is too long');
  if (lenS > 33) throw new Error('S length is too long');
  if (r[0] & 0x80) throw new Error('R value is negative');
  if (s[0] & 0x80) throw new Error('S value is negative');
  if (lenR > 1 && r[0] === 0x00 && !(r[1] & 0x80)) throw new Error('R value excessively padded');
  if (lenS > 1 && s[0] === 0x00 && !(s[1] & 0x80)) throw new Error('S value excessively padded');
  var signature = new Uint8Array(6 + lenR + lenS);
  // 0x30 [total-length] 0x02 [R-length] [R] 0x02 [S-length] [S]
  signature[0] = 0x30;
  signature[1] = signature.length - 2;
  signature[2] = 0x02;
  signature[3] = r.length;
  signature.set(r, 4);
  signature[4 + lenR] = 0x02;
  signature[5 + lenR] = s.length;
  signature.set(s, 6 + lenR);
  return signature;
}

},{}],69:[function(require,module,exports){
'use strict';

function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function"); }
function _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }
function _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: !1 }), e; }
function _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
var __createBinding = void 0 && (void 0).__createBinding || (Object.create ? function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  var desc = Object.getOwnPropertyDescriptor(m, k);
  if (!desc || ('get' in desc ? !m.__esModule : desc.writable || desc.configurable)) {
    desc = {
      enumerable: true,
      get: function get() {
        return m[k];
      }
    };
  }
  Object.defineProperty(o, k2, desc);
} : function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  o[k2] = m[k];
});
var __setModuleDefault = void 0 && (void 0).__setModuleDefault || (Object.create ? function (o, v) {
  Object.defineProperty(o, 'default', {
    enumerable: true,
    value: v
  });
} : function (o, v) {
  o['default'] = v;
});
var __importStar = void 0 && (void 0).__importStar || function (mod) {
  if (mod && mod.__esModule) return mod;
  var result = {};
  if (mod != null) for (var k in mod) if (k !== 'default' && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
  __setModuleDefault(result, mod);
  return result;
};
Object.defineProperty(exports, '__esModule', {
  value: true
});
exports.Block = void 0;
var bufferutils_js_1 = require('./bufferutils.cjs');
var bcrypto = __importStar(require('./crypto.cjs'));
var merkle_js_1 = require('./merkle.cjs');
var transaction_js_1 = require('./transaction.cjs');
var v = __importStar(require('valibot'));
var tools = __importStar(require('uint8array-tools'));
var errorMerkleNoTxes = new TypeError('Cannot compute merkle root for zero transactions');
var errorWitnessNotSegwit = new TypeError('Cannot compute witness commit for non-segwit block');
var Block = /*#__PURE__*/function () {
  function Block() {
    _classCallCheck(this, Block);
    _defineProperty(this, "version", 1);
    _defineProperty(this, "prevHash", undefined);
    _defineProperty(this, "merkleRoot", undefined);
    _defineProperty(this, "timestamp", 0);
    _defineProperty(this, "witnessCommit", undefined);
    _defineProperty(this, "bits", 0);
    _defineProperty(this, "nonce", 0);
    _defineProperty(this, "transactions", undefined);
  }
  return _createClass(Block, [{
    key: "getWitnessCommit",
    value: function getWitnessCommit() {
      if (!txesHaveWitnessCommit(this.transactions)) return null;
      // The merkle root for the witness data is in an OP_RETURN output.
      // There is no rule for the index of the output, so use filter to find it.
      // The root is prepended with 0xaa21a9ed so check for 0x6a24aa21a9ed
      // If multiple commits are found, the output with highest index is assumed.
      var witnessCommits = this.transactions[0].outs.filter(function (out) {
        return tools.compare(out.script.slice(0, 6), Uint8Array.from([0x6a, 0x24, 0xaa, 0x21, 0xa9, 0xed])) === 0;
      }).map(function (out) {
        return out.script.slice(6, 38);
      });
      if (witnessCommits.length === 0) return null;
      // Use the commit with the highest output (should only be one though)
      var result = witnessCommits[witnessCommits.length - 1];
      if (!(result instanceof Uint8Array && result.length === 32)) return null;
      return result;
    }
  }, {
    key: "hasWitnessCommit",
    value: function hasWitnessCommit() {
      if (this.witnessCommit instanceof Uint8Array && this.witnessCommit.length === 32) return true;
      if (this.getWitnessCommit() !== null) return true;
      return false;
    }
  }, {
    key: "hasWitness",
    value: function hasWitness() {
      return anyTxHasWitness(this.transactions);
    }
  }, {
    key: "weight",
    value: function weight() {
      var base = this.byteLength(false, false);
      var total = this.byteLength(false, true);
      return base * 3 + total;
    }
  }, {
    key: "byteLength",
    value: function byteLength(headersOnly) {
      var allowWitness = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
      if (headersOnly || !this.transactions) return 80;
      return 80 + bufferutils_js_1.varuint.encodingLength(this.transactions.length) + this.transactions.reduce(function (a, x) {
        return a + x.byteLength(allowWitness);
      }, 0);
    }
  }, {
    key: "getHash",
    value: function getHash() {
      return bcrypto.hash256(this.toBuffer(true));
    }
  }, {
    key: "getId",
    value: function getId() {
      return tools.toHex((0, bufferutils_js_1.reverseBuffer)(this.getHash()));
    }
  }, {
    key: "getUTCDate",
    value: function getUTCDate() {
      var date = new Date(0); // epoch
      date.setUTCSeconds(this.timestamp);
      return date;
    }
    // TODO: buffer, offset compatibility
  }, {
    key: "toBuffer",
    value: function toBuffer(headersOnly) {
      var buffer = new Uint8Array(this.byteLength(headersOnly));
      var bufferWriter = new bufferutils_js_1.BufferWriter(buffer);
      bufferWriter.writeInt32(this.version);
      bufferWriter.writeSlice(this.prevHash);
      bufferWriter.writeSlice(this.merkleRoot);
      bufferWriter.writeUInt32(this.timestamp);
      bufferWriter.writeUInt32(this.bits);
      bufferWriter.writeUInt32(this.nonce);
      if (headersOnly || !this.transactions) return buffer;
      var _bufferutils_js_1$var = bufferutils_js_1.varuint.encode(this.transactions.length, buffer, bufferWriter.offset),
        bytes = _bufferutils_js_1$var.bytes;
      bufferWriter.offset += bytes;
      this.transactions.forEach(function (tx) {
        var txSize = tx.byteLength(); // TODO: extract from toBuffer?
        tx.toBuffer(buffer, bufferWriter.offset);
        bufferWriter.offset += txSize;
      });
      return buffer;
    }
  }, {
    key: "toHex",
    value: function toHex(headersOnly) {
      return tools.toHex(this.toBuffer(headersOnly));
    }
  }, {
    key: "checkTxRoots",
    value: function checkTxRoots() {
      // If the Block has segwit transactions but no witness commit,
      // there's no way it can be valid, so fail the check.
      var hasWitnessCommit = this.hasWitnessCommit();
      if (!hasWitnessCommit && this.hasWitness()) return false;
      return this.__checkMerkleRoot() && (hasWitnessCommit ? this.__checkWitnessCommit() : true);
    }
  }, {
    key: "checkProofOfWork",
    value: function checkProofOfWork() {
      var hash = (0, bufferutils_js_1.reverseBuffer)(this.getHash());
      var target = Block.calculateTarget(this.bits);
      return tools.compare(hash, target) <= 0;
    }
  }, {
    key: "__checkMerkleRoot",
    value: function __checkMerkleRoot() {
      if (!this.transactions) throw errorMerkleNoTxes;
      var actualMerkleRoot = Block.calculateMerkleRoot(this.transactions);
      return tools.compare(this.merkleRoot, actualMerkleRoot) === 0;
    }
  }, {
    key: "__checkWitnessCommit",
    value: function __checkWitnessCommit() {
      if (!this.transactions) throw errorMerkleNoTxes;
      if (!this.hasWitnessCommit()) throw errorWitnessNotSegwit;
      var actualWitnessCommit = Block.calculateMerkleRoot(this.transactions, true);
      return tools.compare(this.witnessCommit, actualWitnessCommit) === 0;
    }
  }], [{
    key: "fromBuffer",
    value: function fromBuffer(buffer) {
      if (buffer.length < 80) throw new Error('Buffer too small (< 80 bytes)');
      var bufferReader = new bufferutils_js_1.BufferReader(buffer);
      var block = new Block();
      block.version = bufferReader.readInt32();
      block.prevHash = bufferReader.readSlice(32);
      block.merkleRoot = bufferReader.readSlice(32);
      block.timestamp = bufferReader.readUInt32();
      block.bits = bufferReader.readUInt32();
      block.nonce = bufferReader.readUInt32();
      if (buffer.length === 80) return block;
      var readTransaction = function readTransaction() {
        var tx = transaction_js_1.Transaction.fromBuffer(bufferReader.buffer.slice(bufferReader.offset), true);
        bufferReader.offset += tx.byteLength();
        return tx;
      };
      var nTransactions = bufferReader.readVarInt();
      block.transactions = [];
      for (var i = 0; i < nTransactions; ++i) {
        var tx = readTransaction();
        block.transactions.push(tx);
      }
      var witnessCommit = block.getWitnessCommit();
      // This Block contains a witness commit
      if (witnessCommit) block.witnessCommit = witnessCommit;
      return block;
    }
  }, {
    key: "fromHex",
    value: function fromHex(hex) {
      return Block.fromBuffer(tools.fromHex(hex));
    }
  }, {
    key: "calculateTarget",
    value: function calculateTarget(bits) {
      var exponent = ((bits & 0xff000000) >> 24) - 3;
      var mantissa = bits & 0x007fffff;
      var target = new Uint8Array(32);
      target[29 - exponent] = mantissa >> 16 & 0xff;
      target[30 - exponent] = mantissa >> 8 & 0xff;
      target[31 - exponent] = mantissa & 0xff;
      return target;
    }
  }, {
    key: "calculateMerkleRoot",
    value: function calculateMerkleRoot(transactions, forWitness) {
      v.parse(v.array(v.object({
        getHash: v["function"]()
      })), transactions);
      if (transactions.length === 0) throw errorMerkleNoTxes;
      if (forWitness && !txesHaveWitnessCommit(transactions)) throw errorWitnessNotSegwit;
      var hashes = transactions.map(function (transaction) {
        return transaction.getHash(forWitness);
      });
      var rootHash = (0, merkle_js_1.fastMerkleRoot)(hashes, bcrypto.hash256);
      return forWitness ? bcrypto.hash256(tools.concat([rootHash, transactions[0].ins[0].witness[0]])) : rootHash;
    }
  }]);
}();
exports.Block = Block;
function txesHaveWitnessCommit(transactions) {
  return transactions instanceof Array && transactions[0] && transactions[0].ins && transactions[0].ins instanceof Array && transactions[0].ins[0] && transactions[0].ins[0].witness && transactions[0].ins[0].witness instanceof Array && transactions[0].ins[0].witness.length > 0;
}
function anyTxHasWitness(transactions) {
  return transactions instanceof Array && transactions.some(function (tx) {
    return _typeof(tx) === 'object' && tx.ins instanceof Array && tx.ins.some(function (input) {
      return _typeof(input) === 'object' && input.witness instanceof Array && input.witness.length > 0;
    });
  });
}

},{"./bufferutils.cjs":70,"./crypto.cjs":71,"./merkle.cjs":74,"./transaction.cjs":95,"uint8array-tools":65,"valibot":66}],70:[function(require,module,exports){
'use strict';

function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function"); }
function _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }
function _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: !1 }), e; }
function _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
var __createBinding = void 0 && (void 0).__createBinding || (Object.create ? function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  var desc = Object.getOwnPropertyDescriptor(m, k);
  if (!desc || ('get' in desc ? !m.__esModule : desc.writable || desc.configurable)) {
    desc = {
      enumerable: true,
      get: function get() {
        return m[k];
      }
    };
  }
  Object.defineProperty(o, k2, desc);
} : function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  o[k2] = m[k];
});
var __setModuleDefault = void 0 && (void 0).__setModuleDefault || (Object.create ? function (o, v) {
  Object.defineProperty(o, 'default', {
    enumerable: true,
    value: v
  });
} : function (o, v) {
  o['default'] = v;
});
var __importStar = void 0 && (void 0).__importStar || function (mod) {
  if (mod && mod.__esModule) return mod;
  var result = {};
  if (mod != null) for (var k in mod) if (k !== 'default' && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
  __setModuleDefault(result, mod);
  return result;
};
Object.defineProperty(exports, '__esModule', {
  value: true
});
exports.BufferReader = exports.BufferWriter = exports.varuint = void 0;
exports.reverseBuffer = reverseBuffer;
exports.cloneBuffer = cloneBuffer;
var types = __importStar(require('./types.cjs'));
var varuint = __importStar(require('varuint-bitcoin'));
exports.varuint = varuint;
var v = __importStar(require('valibot'));
var tools = __importStar(require('uint8array-tools'));
var MAX_JS_NUMBER = 0x001fffffffffffff;
// https://github.com/feross/buffer/blob/master/index.js#L1127
function verifuint(value, max) {
  if (typeof value !== 'number' && typeof value !== 'bigint') throw new Error('cannot write a non-number as a number');
  if (value < 0 && value < BigInt(0)) throw new Error('specified a negative value for writing an unsigned value');
  if (value > max && value > BigInt(max)) throw new Error('RangeError: value out of range');
  if (Math.floor(Number(value)) !== Number(value)) throw new Error('value has a fractional component');
}
/**
 * Reverses the order of bytes in a buffer.
 * @param buffer - The buffer to reverse.
 * @returns A new buffer with the bytes reversed.
 */
function reverseBuffer(buffer) {
  if (buffer.length < 1) return buffer;
  var j = buffer.length - 1;
  var tmp = 0;
  for (var i = 0; i < buffer.length / 2; i++) {
    tmp = buffer[i];
    buffer[i] = buffer[j];
    buffer[j] = tmp;
    j--;
  }
  return buffer;
}
function cloneBuffer(buffer) {
  var clone = new Uint8Array(buffer.length);
  clone.set(buffer);
  return clone;
}
/**
 * Helper class for serialization of bitcoin data types into a pre-allocated buffer.
 */
var BufferWriter = /*#__PURE__*/function () {
  function BufferWriter(buffer) {
    var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
    _classCallCheck(this, BufferWriter);
    _defineProperty(this, "buffer", void 0);
    _defineProperty(this, "offset", void 0);
    this.buffer = buffer;
    this.offset = offset;
    v.parse(v.tuple([types.BufferSchema, types.UInt32Schema]), [buffer, offset]);
  }
  return _createClass(BufferWriter, [{
    key: "writeUInt8",
    value: function writeUInt8(i) {
      this.offset = tools.writeUInt8(this.buffer, this.offset, i);
    }
  }, {
    key: "writeInt32",
    value: function writeInt32(i) {
      this.offset = tools.writeInt32(this.buffer, this.offset, i, 'LE');
    }
  }, {
    key: "writeInt64",
    value: function writeInt64(i) {
      this.offset = tools.writeInt64(this.buffer, this.offset, BigInt(i), 'LE');
    }
  }, {
    key: "writeUInt32",
    value: function writeUInt32(i) {
      this.offset = tools.writeUInt32(this.buffer, this.offset, i, 'LE');
    }
  }, {
    key: "writeUInt64",
    value: function writeUInt64(i) {
      this.offset = tools.writeUInt64(this.buffer, this.offset, BigInt(i), 'LE');
    }
  }, {
    key: "writeVarInt",
    value: function writeVarInt(i) {
      var _varuint$encode = varuint.encode(i, this.buffer, this.offset),
        bytes = _varuint$encode.bytes;
      this.offset += bytes;
    }
  }, {
    key: "writeSlice",
    value: function writeSlice(slice) {
      if (this.buffer.length < this.offset + slice.length) {
        throw new Error('Cannot write slice out of bounds');
      }
      this.buffer.set(slice, this.offset);
      this.offset += slice.length;
    }
  }, {
    key: "writeVarSlice",
    value: function writeVarSlice(slice) {
      this.writeVarInt(slice.length);
      this.writeSlice(slice);
    }
  }, {
    key: "writeVector",
    value: function writeVector(vector) {
      var _this = this;
      this.writeVarInt(vector.length);
      vector.forEach(function (buf) {
        return _this.writeVarSlice(buf);
      });
    }
  }, {
    key: "end",
    value: function end() {
      if (this.buffer.length === this.offset) {
        return this.buffer;
      }
      throw new Error("buffer size ".concat(this.buffer.length, ", offset ").concat(this.offset));
    }
  }], [{
    key: "withCapacity",
    value: function withCapacity(size) {
      return new BufferWriter(new Uint8Array(size));
    }
  }]);
}();
exports.BufferWriter = BufferWriter;
/**
 * Helper class for reading of bitcoin data types from a buffer.
 */
var BufferReader = /*#__PURE__*/function () {
  function BufferReader(buffer) {
    var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
    _classCallCheck(this, BufferReader);
    _defineProperty(this, "buffer", void 0);
    _defineProperty(this, "offset", void 0);
    this.buffer = buffer;
    this.offset = offset;
    v.parse(v.tuple([types.BufferSchema, types.UInt32Schema]), [buffer, offset]);
  }
  return _createClass(BufferReader, [{
    key: "readUInt8",
    value: function readUInt8() {
      var result = tools.readUInt8(this.buffer, this.offset);
      this.offset++;
      return result;
    }
  }, {
    key: "readInt32",
    value: function readInt32() {
      var result = tools.readInt32(this.buffer, this.offset, 'LE');
      this.offset += 4;
      return result;
    }
  }, {
    key: "readUInt32",
    value: function readUInt32() {
      var result = tools.readUInt32(this.buffer, this.offset, 'LE');
      this.offset += 4;
      return result;
    }
  }, {
    key: "readInt64",
    value: function readInt64() {
      var result = tools.readInt64(this.buffer, this.offset, 'LE');
      this.offset += 8;
      return result;
    }
  }, {
    key: "readVarInt",
    value: function readVarInt() {
      var _varuint$decode = varuint.decode(this.buffer, this.offset),
        bigintValue = _varuint$decode.bigintValue,
        bytes = _varuint$decode.bytes;
      this.offset += bytes;
      return bigintValue;
    }
  }, {
    key: "readSlice",
    value: function readSlice(n) {
      verifuint(n, MAX_JS_NUMBER);
      var num = Number(n);
      if (this.buffer.length < this.offset + num) {
        throw new Error('Cannot read slice out of bounds');
      }
      var result = this.buffer.slice(this.offset, this.offset + num);
      this.offset += num;
      return result;
    }
  }, {
    key: "readVarSlice",
    value: function readVarSlice() {
      return this.readSlice(this.readVarInt());
    }
  }, {
    key: "readVector",
    value: function readVector() {
      var count = this.readVarInt();
      var vector = [];
      for (var i = 0; i < count; i++) vector.push(this.readVarSlice());
      return vector;
    }
  }]);
}();
exports.BufferReader = BufferReader;

},{"./types.cjs":96,"uint8array-tools":65,"valibot":66,"varuint-bitcoin":109}],71:[function(require,module,exports){
'use strict';

var __createBinding = void 0 && (void 0).__createBinding || (Object.create ? function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  var desc = Object.getOwnPropertyDescriptor(m, k);
  if (!desc || ('get' in desc ? !m.__esModule : desc.writable || desc.configurable)) {
    desc = {
      enumerable: true,
      get: function get() {
        return m[k];
      }
    };
  }
  Object.defineProperty(o, k2, desc);
} : function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  o[k2] = m[k];
});
var __setModuleDefault = void 0 && (void 0).__setModuleDefault || (Object.create ? function (o, v) {
  Object.defineProperty(o, 'default', {
    enumerable: true,
    value: v
  });
} : function (o, v) {
  o['default'] = v;
});
var __importStar = void 0 && (void 0).__importStar || function (mod) {
  if (mod && mod.__esModule) return mod;
  var result = {};
  if (mod != null) for (var k in mod) if (k !== 'default' && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
  __setModuleDefault(result, mod);
  return result;
};
Object.defineProperty(exports, '__esModule', {
  value: true
});
exports.TAGGED_HASH_PREFIXES = exports.TAGS = void 0;
exports.hash160 = hash160;
exports.hash256 = hash256;
exports.taggedHash = taggedHash;
/**
 * A module for hashing functions.
 * include ripemd160sha1sha256hash160hash256taggedHash
 *
 * @packageDocumentation
 */
var ripemd160_1 = require('@noble/hashes/ripemd160');
var sha256_1 = require('@noble/hashes/sha256');
var tools = __importStar(require('uint8array-tools'));
function hash160(buffer) {
  return (0, ripemd160_1.ripemd160)((0, sha256_1.sha256)(buffer));
}
function hash256(buffer) {
  return (0, sha256_1.sha256)((0, sha256_1.sha256)(buffer));
}
exports.TAGS = ['BIP0340/challenge', 'BIP0340/aux', 'BIP0340/nonce', 'TapLeaf', 'TapBranch', 'TapSighash', 'TapTweak', 'KeyAgg list', 'KeyAgg coefficient'];
/** An object mapping tags to their tagged hash prefix of [SHA256(tag) | SHA256(tag)] */
/**
 * Defines the tagged hash prefixes used in the crypto module.
 */
exports.TAGGED_HASH_PREFIXES = {
  'BIP0340/challenge': Uint8Array.from([123, 181, 45, 122, 159, 239, 88, 50, 62, 177, 191, 122, 64, 125, 179, 130, 210, 243, 242, 216, 27, 177, 34, 79, 73, 254, 81, 143, 109, 72, 211, 124, 123, 181, 45, 122, 159, 239, 88, 50, 62, 177, 191, 122, 64, 125, 179, 130, 210, 243, 242, 216, 27, 177, 34, 79, 73, 254, 81, 143, 109, 72, 211, 124]),
  'BIP0340/aux': Uint8Array.from([241, 239, 78, 94, 192, 99, 202, 218, 109, 148, 202, 250, 157, 152, 126, 160, 105, 38, 88, 57, 236, 193, 31, 151, 45, 119, 165, 46, 216, 193, 204, 144, 241, 239, 78, 94, 192, 99, 202, 218, 109, 148, 202, 250, 157, 152, 126, 160, 105, 38, 88, 57, 236, 193, 31, 151, 45, 119, 165, 46, 216, 193, 204, 144]),
  'BIP0340/nonce': Uint8Array.from([7, 73, 119, 52, 167, 155, 203, 53, 91, 155, 140, 125, 3, 79, 18, 28, 244, 52, 215, 62, 247, 45, 218, 25, 135, 0, 97, 251, 82, 191, 235, 47, 7, 73, 119, 52, 167, 155, 203, 53, 91, 155, 140, 125, 3, 79, 18, 28, 244, 52, 215, 62, 247, 45, 218, 25, 135, 0, 97, 251, 82, 191, 235, 47]),
  TapLeaf: Uint8Array.from([174, 234, 143, 220, 66, 8, 152, 49, 5, 115, 75, 88, 8, 29, 30, 38, 56, 211, 95, 28, 181, 64, 8, 212, 211, 87, 202, 3, 190, 120, 233, 238, 174, 234, 143, 220, 66, 8, 152, 49, 5, 115, 75, 88, 8, 29, 30, 38, 56, 211, 95, 28, 181, 64, 8, 212, 211, 87, 202, 3, 190, 120, 233, 238]),
  TapBranch: Uint8Array.from([25, 65, 161, 242, 229, 110, 185, 95, 162, 169, 241, 148, 190, 92, 1, 247, 33, 111, 51, 237, 130, 176, 145, 70, 52, 144, 208, 91, 245, 22, 160, 21, 25, 65, 161, 242, 229, 110, 185, 95, 162, 169, 241, 148, 190, 92, 1, 247, 33, 111, 51, 237, 130, 176, 145, 70, 52, 144, 208, 91, 245, 22, 160, 21]),
  TapSighash: Uint8Array.from([244, 10, 72, 223, 75, 42, 112, 200, 180, 146, 75, 242, 101, 70, 97, 237, 61, 149, 253, 102, 163, 19, 235, 135, 35, 117, 151, 198, 40, 228, 160, 49, 244, 10, 72, 223, 75, 42, 112, 200, 180, 146, 75, 242, 101, 70, 97, 237, 61, 149, 253, 102, 163, 19, 235, 135, 35, 117, 151, 198, 40, 228, 160, 49]),
  TapTweak: Uint8Array.from([232, 15, 225, 99, 156, 156, 160, 80, 227, 175, 27, 57, 193, 67, 198, 62, 66, 156, 188, 235, 21, 217, 64, 251, 181, 197, 161, 244, 175, 87, 197, 233, 232, 15, 225, 99, 156, 156, 160, 80, 227, 175, 27, 57, 193, 67, 198, 62, 66, 156, 188, 235, 21, 217, 64, 251, 181, 197, 161, 244, 175, 87, 197, 233]),
  'KeyAgg list': Uint8Array.from([72, 28, 151, 28, 60, 11, 70, 215, 240, 178, 117, 174, 89, 141, 78, 44, 126, 215, 49, 156, 89, 74, 92, 110, 199, 158, 160, 212, 153, 2, 148, 240, 72, 28, 151, 28, 60, 11, 70, 215, 240, 178, 117, 174, 89, 141, 78, 44, 126, 215, 49, 156, 89, 74, 92, 110, 199, 158, 160, 212, 153, 2, 148, 240]),
  'KeyAgg coefficient': Uint8Array.from([191, 201, 4, 3, 77, 28, 136, 232, 200, 14, 34, 229, 61, 36, 86, 109, 100, 130, 78, 214, 66, 114, 129, 192, 145, 0, 249, 77, 205, 82, 201, 129, 191, 201, 4, 3, 77, 28, 136, 232, 200, 14, 34, 229, 61, 36, 86, 109, 100, 130, 78, 214, 66, 114, 129, 192, 145, 0, 249, 77, 205, 82, 201, 129])
};
function taggedHash(prefix, data) {
  return (0, sha256_1.sha256)(tools.concat([exports.TAGGED_HASH_PREFIXES[prefix], data]));
}

},{"@noble/hashes/ripemd160":10,"@noble/hashes/sha256":11,"uint8array-tools":65}],72:[function(require,module,exports){
'use strict';

var __createBinding = void 0 && (void 0).__createBinding || (Object.create ? function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  var desc = Object.getOwnPropertyDescriptor(m, k);
  if (!desc || ('get' in desc ? !m.__esModule : desc.writable || desc.configurable)) {
    desc = {
      enumerable: true,
      get: function get() {
        return m[k];
      }
    };
  }
  Object.defineProperty(o, k2, desc);
} : function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  o[k2] = m[k];
});
var __setModuleDefault = void 0 && (void 0).__setModuleDefault || (Object.create ? function (o, v) {
  Object.defineProperty(o, 'default', {
    enumerable: true,
    value: v
  });
} : function (o, v) {
  o['default'] = v;
});
var __importStar = void 0 && (void 0).__importStar || function (mod) {
  if (mod && mod.__esModule) return mod;
  var result = {};
  if (mod != null) for (var k in mod) if (k !== 'default' && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
  __setModuleDefault(result, mod);
  return result;
};
Object.defineProperty(exports, '__esModule', {
  value: true
});
exports.initEccLib = initEccLib;
exports.getEccLib = getEccLib;
var tools = __importStar(require('uint8array-tools'));
var _ECCLIB_CACHE = {};
/**
 * Initializes the ECC library with the provided instance.
 * If `eccLib` is `undefined`, the library will be cleared.
 * If `eccLib` is a new instance, it will be verified before setting it as the active library.
 *
 * @param eccLib The instance of the ECC library to initialize.
 */
function initEccLib(eccLib) {
  if (!eccLib) {
    // allow clearing the library
    _ECCLIB_CACHE.eccLib = eccLib;
  } else if (eccLib !== _ECCLIB_CACHE.eccLib) {
    // new instance, verify it
    verifyEcc(eccLib);
    _ECCLIB_CACHE.eccLib = eccLib;
  }
}
/**
 * Retrieves the ECC Library instance.
 * Throws an error if the ECC Library is not provided.
 * You must call initEccLib() with a valid TinySecp256k1Interface instance before calling this function.
 * @returns The ECC Library instance.
 * @throws Error if the ECC Library is not provided.
 */
function getEccLib() {
  if (!_ECCLIB_CACHE.eccLib) throw new Error('No ECC Library provided. You must call initEccLib() with a valid TinySecp256k1Interface instance');
  return _ECCLIB_CACHE.eccLib;
}
var h = function h(hex) {
  return tools.fromHex(hex);
};
/**
 * Verifies the ECC functionality.
 *
 * @param ecc - The TinySecp256k1Interface object.
 */
function verifyEcc(ecc) {
  assert(typeof ecc.isXOnlyPoint === 'function');
  assert(ecc.isXOnlyPoint(h('79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798')));
  assert(ecc.isXOnlyPoint(h('fffffffffffffffffffffffffffffffffffffffffffffffffffffffeeffffc2e')));
  assert(ecc.isXOnlyPoint(h('f9308a019258c31049344f85f89d5229b531c845836f99b08601f113bce036f9')));
  assert(ecc.isXOnlyPoint(h('0000000000000000000000000000000000000000000000000000000000000001')));
  assert(!ecc.isXOnlyPoint(h('0000000000000000000000000000000000000000000000000000000000000000')));
  assert(!ecc.isXOnlyPoint(h('fffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f')));
  assert(typeof ecc.xOnlyPointAddTweak === 'function');
  tweakAddVectors.forEach(function (t) {
    var r = ecc.xOnlyPointAddTweak(h(t.pubkey), h(t.tweak));
    if (t.result === null) {
      assert(r === null);
    } else {
      assert(r !== null);
      assert(r.parity === t.parity);
      assert(tools.compare(r.xOnlyPubkey, h(t.result)) === 0);
    }
  });
}
function assert(bool) {
  if (!bool) throw new Error('ecc library invalid');
}
var tweakAddVectors = [{
  pubkey: '79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798',
  tweak: 'fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364140',
  parity: -1,
  result: null
}, {
  pubkey: '1617d38ed8d8657da4d4761e8057bc396ea9e4b9d29776d4be096016dbd2509b',
  tweak: 'a8397a935f0dfceba6ba9618f6451ef4d80637abf4e6af2669fbc9de6a8fd2ac',
  parity: 1,
  result: 'e478f99dab91052ab39a33ea35fd5e6e4933f4d28023cd597c9a1f6760346adf'
}, {
  pubkey: '2c0b7cf95324a07d05398b240174dc0c2be444d96b159aa6c7f7b1e668680991',
  tweak: '823c3cd2142744b075a87eade7e1b8678ba308d566226a0056ca2b7a76f86b47',
  parity: 0,
  result: '9534f8dc8c6deda2dc007655981c78b49c5d96c778fbf363462a11ec9dfd948c'
}];

},{"uint8array-tools":65}],73:[function(require,module,exports){
'use strict';

var __createBinding = void 0 && (void 0).__createBinding || (Object.create ? function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  var desc = Object.getOwnPropertyDescriptor(m, k);
  if (!desc || ('get' in desc ? !m.__esModule : desc.writable || desc.configurable)) {
    desc = {
      enumerable: true,
      get: function get() {
        return m[k];
      }
    };
  }
  Object.defineProperty(o, k2, desc);
} : function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  o[k2] = m[k];
});
var __setModuleDefault = void 0 && (void 0).__setModuleDefault || (Object.create ? function (o, v) {
  Object.defineProperty(o, 'default', {
    enumerable: true,
    value: v
  });
} : function (o, v) {
  o['default'] = v;
});
var __importStar = void 0 && (void 0).__importStar || function (mod) {
  if (mod && mod.__esModule) return mod;
  var result = {};
  if (mod != null) for (var k in mod) if (k !== 'default' && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
  __setModuleDefault(result, mod);
  return result;
};
Object.defineProperty(exports, '__esModule', {
  value: true
});
exports.initEccLib = exports.Transaction = exports.opcodes = exports.Psbt = exports.Block = exports.script = exports.payments = exports.networks = exports.crypto = exports.address = void 0;
var address = __importStar(require('./address.cjs'));
exports.address = address;
var crypto = __importStar(require('./crypto.cjs'));
exports.crypto = crypto;
var networks = __importStar(require('./networks.cjs'));
exports.networks = networks;
var payments = __importStar(require('./payments/index.cjs'));
exports.payments = payments;
var script = __importStar(require('./script.cjs'));
exports.script = script;
var block_js_1 = require('./block.cjs');
Object.defineProperty(exports, 'Block', {
  enumerable: true,
  get: function get() {
    return block_js_1.Block;
  }
});
var psbt_js_1 = require('./psbt.cjs');
Object.defineProperty(exports, 'Psbt', {
  enumerable: true,
  get: function get() {
    return psbt_js_1.Psbt;
  }
});
/** @hidden */
var ops_js_1 = require('./ops.cjs');
Object.defineProperty(exports, 'opcodes', {
  enumerable: true,
  get: function get() {
    return ops_js_1.OPS;
  }
});
var transaction_js_1 = require('./transaction.cjs');
Object.defineProperty(exports, 'Transaction', {
  enumerable: true,
  get: function get() {
    return transaction_js_1.Transaction;
  }
});
var ecc_lib_js_1 = require('./ecc_lib.cjs');
Object.defineProperty(exports, 'initEccLib', {
  enumerable: true,
  get: function get() {
    return ecc_lib_js_1.initEccLib;
  }
});

},{"./address.cjs":67,"./block.cjs":69,"./crypto.cjs":71,"./ecc_lib.cjs":72,"./networks.cjs":75,"./ops.cjs":76,"./payments/index.cjs":79,"./psbt.cjs":88,"./script.cjs":92,"./transaction.cjs":95}],74:[function(require,module,exports){
'use strict';

var __createBinding = void 0 && (void 0).__createBinding || (Object.create ? function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  var desc = Object.getOwnPropertyDescriptor(m, k);
  if (!desc || ('get' in desc ? !m.__esModule : desc.writable || desc.configurable)) {
    desc = {
      enumerable: true,
      get: function get() {
        return m[k];
      }
    };
  }
  Object.defineProperty(o, k2, desc);
} : function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  o[k2] = m[k];
});
var __setModuleDefault = void 0 && (void 0).__setModuleDefault || (Object.create ? function (o, v) {
  Object.defineProperty(o, 'default', {
    enumerable: true,
    value: v
  });
} : function (o, v) {
  o['default'] = v;
});
var __importStar = void 0 && (void 0).__importStar || function (mod) {
  if (mod && mod.__esModule) return mod;
  var result = {};
  if (mod != null) for (var k in mod) if (k !== 'default' && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
  __setModuleDefault(result, mod);
  return result;
};
Object.defineProperty(exports, '__esModule', {
  value: true
});
exports.fastMerkleRoot = fastMerkleRoot;
var tools = __importStar(require('uint8array-tools'));
/**
 * Calculates the Merkle root of an array of buffers using a specified digest function.
 *
 * @param values - The array of buffers.
 * @param digestFn - The digest function used to calculate the hash of the concatenated buffers.
 * @returns The Merkle root as a buffer.
 * @throws {TypeError} If the values parameter is not an array or the digestFn parameter is not a function.
 */
function fastMerkleRoot(values, digestFn) {
  if (!Array.isArray(values)) throw TypeError('Expected values Array');
  if (typeof digestFn !== 'function') throw TypeError('Expected digest Function');
  var length = values.length;
  var results = values.concat();
  while (length > 1) {
    var j = 0;
    for (var i = 0; i < length; i += 2, ++j) {
      var left = results[i];
      var right = i + 1 === length ? left : results[i + 1];
      var data = tools.concat([left, right]);
      results[j] = digestFn(data);
    }
    length = j;
  }
  return results[0];
}

},{"uint8array-tools":65}],75:[function(require,module,exports){
'use strict';

// https://en.bitcoin.it/wiki/List_of_address_prefixes
// Dogecoin BIP32 is a proposed standard: https://bitcointalk.org/index.php?topic=409731
Object.defineProperty(exports, '__esModule', {
  value: true
});
exports.testnet = exports.regtest = exports.bitcoin = void 0;
/**
 * Represents the Bitcoin network configuration.
 */
exports.bitcoin = {
  /**
   * The message prefix used for signing Bitcoin messages.
   */
  messagePrefix: '\x18Bitcoin Signed Message:\n',
  /**
   * The Bech32 prefix used for Bitcoin addresses.
   */
  bech32: 'bc',
  /**
   * The BIP32 key prefixes for Bitcoin.
   */
  bip32: {
    /**
     * The public key prefix for BIP32 extended public keys.
     */
    "public": 0x0488b21e,
    /**
     * The private key prefix for BIP32 extended private keys.
     */
    "private": 0x0488ade4
  },
  /**
   * The prefix for Bitcoin public key hashes.
   */
  pubKeyHash: 0x00,
  /**
   * The prefix for Bitcoin script hashes.
   */
  scriptHash: 0x05,
  /**
   * The prefix for Bitcoin Wallet Import Format (WIF) private keys.
   */
  wif: 0x80
};
/**
 * Represents the regtest network configuration.
 */
exports.regtest = {
  messagePrefix: '\x18Bitcoin Signed Message:\n',
  bech32: 'bcrt',
  bip32: {
    "public": 0x043587cf,
    "private": 0x04358394
  },
  pubKeyHash: 0x6f,
  scriptHash: 0xc4,
  wif: 0xef
};
/**
 * Represents the testnet network configuration.
 */
exports.testnet = {
  messagePrefix: '\x18Bitcoin Signed Message:\n',
  bech32: 'tb',
  bip32: {
    "public": 0x043587cf,
    "private": 0x04358394
  },
  pubKeyHash: 0x6f,
  scriptHash: 0xc4,
  wif: 0xef
};

},{}],76:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});
exports.REVERSE_OPS = exports.OPS = void 0;
var OPS = {
  OP_FALSE: 0,
  OP_0: 0,
  OP_PUSHDATA1: 76,
  OP_PUSHDATA2: 77,
  OP_PUSHDATA4: 78,
  OP_1NEGATE: 79,
  OP_RESERVED: 80,
  OP_TRUE: 81,
  OP_1: 81,
  OP_2: 82,
  OP_3: 83,
  OP_4: 84,
  OP_5: 85,
  OP_6: 86,
  OP_7: 87,
  OP_8: 88,
  OP_9: 89,
  OP_10: 90,
  OP_11: 91,
  OP_12: 92,
  OP_13: 93,
  OP_14: 94,
  OP_15: 95,
  OP_16: 96,
  OP_NOP: 97,
  OP_VER: 98,
  OP_IF: 99,
  OP_NOTIF: 100,
  OP_VERIF: 101,
  OP_VERNOTIF: 102,
  OP_ELSE: 103,
  OP_ENDIF: 104,
  OP_VERIFY: 105,
  OP_RETURN: 106,
  OP_TOALTSTACK: 107,
  OP_FROMALTSTACK: 108,
  OP_2DROP: 109,
  OP_2DUP: 110,
  OP_3DUP: 111,
  OP_2OVER: 112,
  OP_2ROT: 113,
  OP_2SWAP: 114,
  OP_IFDUP: 115,
  OP_DEPTH: 116,
  OP_DROP: 117,
  OP_DUP: 118,
  OP_NIP: 119,
  OP_OVER: 120,
  OP_PICK: 121,
  OP_ROLL: 122,
  OP_ROT: 123,
  OP_SWAP: 124,
  OP_TUCK: 125,
  OP_CAT: 126,
  OP_SUBSTR: 127,
  OP_LEFT: 128,
  OP_RIGHT: 129,
  OP_SIZE: 130,
  OP_INVERT: 131,
  OP_AND: 132,
  OP_OR: 133,
  OP_XOR: 134,
  OP_EQUAL: 135,
  OP_EQUALVERIFY: 136,
  OP_RESERVED1: 137,
  OP_RESERVED2: 138,
  OP_1ADD: 139,
  OP_1SUB: 140,
  OP_2MUL: 141,
  OP_2DIV: 142,
  OP_NEGATE: 143,
  OP_ABS: 144,
  OP_NOT: 145,
  OP_0NOTEQUAL: 146,
  OP_ADD: 147,
  OP_SUB: 148,
  OP_MUL: 149,
  OP_DIV: 150,
  OP_MOD: 151,
  OP_LSHIFT: 152,
  OP_RSHIFT: 153,
  OP_BOOLAND: 154,
  OP_BOOLOR: 155,
  OP_NUMEQUAL: 156,
  OP_NUMEQUALVERIFY: 157,
  OP_NUMNOTEQUAL: 158,
  OP_LESSTHAN: 159,
  OP_GREATERTHAN: 160,
  OP_LESSTHANOREQUAL: 161,
  OP_GREATERTHANOREQUAL: 162,
  OP_MIN: 163,
  OP_MAX: 164,
  OP_WITHIN: 165,
  OP_RIPEMD160: 166,
  OP_SHA1: 167,
  OP_SHA256: 168,
  OP_HASH160: 169,
  OP_HASH256: 170,
  OP_CODESEPARATOR: 171,
  OP_CHECKSIG: 172,
  OP_CHECKSIGVERIFY: 173,
  OP_CHECKMULTISIG: 174,
  OP_CHECKMULTISIGVERIFY: 175,
  OP_NOP1: 176,
  OP_NOP2: 177,
  OP_CHECKLOCKTIMEVERIFY: 177,
  OP_NOP3: 178,
  OP_CHECKSEQUENCEVERIFY: 178,
  OP_NOP4: 179,
  OP_NOP5: 180,
  OP_NOP6: 181,
  OP_NOP7: 182,
  OP_NOP8: 183,
  OP_NOP9: 184,
  OP_NOP10: 185,
  OP_CHECKSIGADD: 186,
  OP_PUBKEYHASH: 253,
  OP_PUBKEY: 254,
  OP_INVALIDOPCODE: 255
};
exports.OPS = OPS;
var REVERSE_OPS = {};
exports.REVERSE_OPS = REVERSE_OPS;
for (var _i = 0, _Object$keys = Object.keys(OPS); _i < _Object$keys.length; _i++) {
  var op = _Object$keys[_i];
  var code = OPS[op];
  REVERSE_OPS[code] = op;
}

},{}],77:[function(require,module,exports){
'use strict';

function _toConsumableArray(r) { return _arrayWithoutHoles(r) || _iterableToArray(r) || _unsupportedIterableToArray(r) || _nonIterableSpread(); }
function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _unsupportedIterableToArray(r, a) { if (r) { if ("string" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }
function _iterableToArray(r) { if ("undefined" != typeof Symbol && null != r[Symbol.iterator] || null != r["@@iterator"]) return Array.from(r); }
function _arrayWithoutHoles(r) { if (Array.isArray(r)) return _arrayLikeToArray(r); }
function _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }
var __createBinding = void 0 && (void 0).__createBinding || (Object.create ? function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  var desc = Object.getOwnPropertyDescriptor(m, k);
  if (!desc || ('get' in desc ? !m.__esModule : desc.writable || desc.configurable)) {
    desc = {
      enumerable: true,
      get: function get() {
        return m[k];
      }
    };
  }
  Object.defineProperty(o, k2, desc);
} : function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  o[k2] = m[k];
});
var __setModuleDefault = void 0 && (void 0).__setModuleDefault || (Object.create ? function (o, v) {
  Object.defineProperty(o, 'default', {
    enumerable: true,
    value: v
  });
} : function (o, v) {
  o['default'] = v;
});
var __importStar = void 0 && (void 0).__importStar || function (mod) {
  if (mod && mod.__esModule) return mod;
  var result = {};
  if (mod != null) for (var k in mod) if (k !== 'default' && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
  __setModuleDefault(result, mod);
  return result;
};
Object.defineProperty(exports, '__esModule', {
  value: true
});
exports.MAX_TAPTREE_DEPTH = exports.LEAF_VERSION_TAPSCRIPT = void 0;
exports.rootHashFromPath = rootHashFromPath;
exports.toHashTree = toHashTree;
exports.findScriptPath = findScriptPath;
exports.tapleafHash = tapleafHash;
exports.tapTweakHash = tapTweakHash;
exports.tweakKey = tweakKey;
var ecc_lib_js_1 = require('../ecc_lib.cjs');
var bcrypto = __importStar(require('../crypto.cjs'));
var bufferutils_js_1 = require('../bufferutils.cjs');
var types_js_1 = require('../types.cjs');
var tools = __importStar(require('uint8array-tools'));
exports.LEAF_VERSION_TAPSCRIPT = 0xc0;
exports.MAX_TAPTREE_DEPTH = 128;
var isHashBranch = function isHashBranch(ht) {
  return 'left' in ht && 'right' in ht;
};
/**
 * Calculates the root hash from a given control block and leaf hash.
 * @param controlBlock - The control block buffer.
 * @param leafHash - The leaf hash buffer.
 * @returns The root hash buffer.
 * @throws {TypeError} If the control block length is less than 33.
 */
function rootHashFromPath(controlBlock, leafHash) {
  if (controlBlock.length < 33) throw new TypeError("The control-block length is too small. Got ".concat(controlBlock.length, ", expected min 33."));
  var m = (controlBlock.length - 33) / 32;
  var kj = leafHash;
  for (var j = 0; j < m; j++) {
    var ej = controlBlock.slice(33 + 32 * j, 65 + 32 * j);
    if (tools.compare(kj, ej) < 0) {
      kj = tapBranchHash(kj, ej);
    } else {
      kj = tapBranchHash(ej, kj);
    }
  }
  return kj;
}
/**
 * Build a hash tree of merkle nodes from the scripts binary tree.
 * @param scriptTree - the tree of scripts to pairwise hash.
 */
function toHashTree(scriptTree) {
  if ((0, types_js_1.isTapleaf)(scriptTree)) return {
    hash: tapleafHash(scriptTree)
  };
  var hashes = [toHashTree(scriptTree[0]), toHashTree(scriptTree[1])];
  // hashes.sort((a, b) => a.hash.compare(b.hash));
  hashes.sort(function (a, b) {
    return tools.compare(a.hash, b.hash);
  });
  var left = hashes[0],
    right = hashes[1];
  return {
    hash: tapBranchHash(left.hash, right.hash),
    left: left,
    right: right
  };
}
/**
 * Given a HashTree, finds the path from a particular hash to the root.
 * @param node - the root of the tree
 * @param hash - the hash to search for
 * @returns - array of sibling hashes, from leaf (inclusive) to root
 * (exclusive) needed to prove inclusion of the specified hash. undefined if no
 * path is found
 */
function findScriptPath(node, hash) {
  if (isHashBranch(node)) {
    var leftPath = findScriptPath(node.left, hash);
    if (leftPath !== undefined) return [].concat(_toConsumableArray(leftPath), [node.right.hash]);
    var rightPath = findScriptPath(node.right, hash);
    if (rightPath !== undefined) return [].concat(_toConsumableArray(rightPath), [node.left.hash]);
  } else if (tools.compare(node.hash, hash) === 0) {
    return [];
  }
  return undefined;
}
/**
 * Calculates the tapleaf hash for a given Tapleaf object.
 * @param leaf - The Tapleaf object to calculate the hash for.
 * @returns The tapleaf hash as a Buffer.
 */
function tapleafHash(leaf) {
  var version = leaf.version || exports.LEAF_VERSION_TAPSCRIPT;
  return bcrypto.taggedHash('TapLeaf', tools.concat([Uint8Array.from([version]), serializeScript(leaf.output)]));
}
/**
 * Computes the taproot tweak hash for a given public key and optional hash.
 * If a hash is provided, the public key and hash are concatenated before computing the hash.
 * If no hash is provided, only the public key is used to compute the hash.
 *
 * @param pubKey - The public key buffer.
 * @param h - The optional hash buffer.
 * @returns The taproot tweak hash.
 */
function tapTweakHash(pubKey, h) {
  return bcrypto.taggedHash('TapTweak', tools.concat(h ? [pubKey, h] : [pubKey]));
}
/**
 * Tweak a public key with a given tweak hash.
 * @param pubKey - The public key to be tweaked.
 * @param h - The tweak hash.
 * @returns The tweaked public key or null if the input is invalid.
 */
function tweakKey(pubKey, h) {
  if (!(pubKey instanceof Uint8Array)) return null;
  if (pubKey.length !== 32) return null;
  if (h && h.length !== 32) return null;
  var tweakHash = tapTweakHash(pubKey, h);
  var res = (0, ecc_lib_js_1.getEccLib)().xOnlyPointAddTweak(pubKey, tweakHash);
  if (!res || res.xOnlyPubkey === null) return null;
  return {
    parity: res.parity,
    x: Uint8Array.from(res.xOnlyPubkey)
  };
}
/**
 * Computes the TapBranch hash by concatenating two buffers and applying the 'TapBranch' tagged hash algorithm.
 *
 * @param a - The first buffer.
 * @param b - The second buffer.
 * @returns The TapBranch hash of the concatenated buffers.
 */
function tapBranchHash(a, b) {
  return bcrypto.taggedHash('TapBranch', tools.concat([a, b]));
}
/**
 * Serializes a script by encoding its length as a varint and concatenating it with the script.
 *
 * @param s - The script to be serialized.
 * @returns The serialized script as a Buffer.
 */
function serializeScript(s) {
  /* global BigInt */
  var varintLen = bufferutils_js_1.varuint.encodingLength(s.length);
  var buffer = new Uint8Array(varintLen);
  bufferutils_js_1.varuint.encode(s.length, buffer);
  return tools.concat([buffer, s]);
}

},{"../bufferutils.cjs":70,"../crypto.cjs":71,"../ecc_lib.cjs":72,"../types.cjs":96,"uint8array-tools":65}],78:[function(require,module,exports){
'use strict';

var __createBinding = void 0 && (void 0).__createBinding || (Object.create ? function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  var desc = Object.getOwnPropertyDescriptor(m, k);
  if (!desc || ('get' in desc ? !m.__esModule : desc.writable || desc.configurable)) {
    desc = {
      enumerable: true,
      get: function get() {
        return m[k];
      }
    };
  }
  Object.defineProperty(o, k2, desc);
} : function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  o[k2] = m[k];
});
var __setModuleDefault = void 0 && (void 0).__setModuleDefault || (Object.create ? function (o, v) {
  Object.defineProperty(o, 'default', {
    enumerable: true,
    value: v
  });
} : function (o, v) {
  o['default'] = v;
});
var __importStar = void 0 && (void 0).__importStar || function (mod) {
  if (mod && mod.__esModule) return mod;
  var result = {};
  if (mod != null) for (var k in mod) if (k !== 'default' && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
  __setModuleDefault(result, mod);
  return result;
};
Object.defineProperty(exports, '__esModule', {
  value: true
});
exports.p2data = p2data;
var networks_js_1 = require('../networks.cjs');
var bscript = __importStar(require('../script.cjs'));
var types_js_1 = require('../types.cjs');
var lazy = __importStar(require('./lazy.cjs'));
var v = __importStar(require('valibot'));
var OPS = bscript.OPS;
// output: OP_RETURN ...
/**
 * Embeds data in a Bitcoin payment.
 * @param a - The payment object.
 * @param opts - Optional payment options.
 * @returns The modified payment object.
 * @throws {TypeError} If there is not enough data or if the output is invalid.
 */
function p2data(a, opts) {
  if (!a.data && !a.output) throw new TypeError('Not enough data');
  opts = Object.assign({
    validate: true
  }, opts || {});
  v.parse(v.partial(v.object({
    network: v.object({}),
    output: types_js_1.BufferSchema,
    data: v.array(types_js_1.BufferSchema)
  })), a);
  var network = a.network || networks_js_1.bitcoin;
  var o = {
    name: 'embed',
    network: network
  };
  lazy.prop(o, 'output', function () {
    if (!a.data) return;
    return bscript.compile([OPS.OP_RETURN].concat(a.data));
  });
  lazy.prop(o, 'data', function () {
    if (!a.output) return;
    return bscript.decompile(a.output).slice(1);
  });
  // extended validation
  if (opts.validate) {
    if (a.output) {
      var chunks = bscript.decompile(a.output);
      if (chunks[0] !== OPS.OP_RETURN) throw new TypeError('Output is invalid');
      if (!chunks.slice(1).every(function (chunk) {
        return v.is(types_js_1.BufferSchema, chunk);
      })) throw new TypeError('Output is invalid');
      if (a.data && !(0, types_js_1.stacksEqual)(a.data, o.data)) throw new TypeError('Data mismatch');
    }
  }
  return Object.assign(o, a);
}

},{"../networks.cjs":75,"../script.cjs":92,"../types.cjs":96,"./lazy.cjs":80,"valibot":66}],79:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});
exports.p2tr = exports.p2wsh = exports.p2wpkh = exports.p2sh = exports.p2pkh = exports.p2pk = exports.p2ms = exports.embed = void 0;
var embed_js_1 = require('./embed.cjs');
Object.defineProperty(exports, 'embed', {
  enumerable: true,
  get: function get() {
    return embed_js_1.p2data;
  }
});
var p2ms_js_1 = require('./p2ms.cjs');
Object.defineProperty(exports, 'p2ms', {
  enumerable: true,
  get: function get() {
    return p2ms_js_1.p2ms;
  }
});
var p2pk_js_1 = require('./p2pk.cjs');
Object.defineProperty(exports, 'p2pk', {
  enumerable: true,
  get: function get() {
    return p2pk_js_1.p2pk;
  }
});
var p2pkh_js_1 = require('./p2pkh.cjs');
Object.defineProperty(exports, 'p2pkh', {
  enumerable: true,
  get: function get() {
    return p2pkh_js_1.p2pkh;
  }
});
var p2sh_js_1 = require('./p2sh.cjs');
Object.defineProperty(exports, 'p2sh', {
  enumerable: true,
  get: function get() {
    return p2sh_js_1.p2sh;
  }
});
var p2wpkh_js_1 = require('./p2wpkh.cjs');
Object.defineProperty(exports, 'p2wpkh', {
  enumerable: true,
  get: function get() {
    return p2wpkh_js_1.p2wpkh;
  }
});
var p2wsh_js_1 = require('./p2wsh.cjs');
Object.defineProperty(exports, 'p2wsh', {
  enumerable: true,
  get: function get() {
    return p2wsh_js_1.p2wsh;
  }
});
var p2tr_js_1 = require('./p2tr.cjs');
Object.defineProperty(exports, 'p2tr', {
  enumerable: true,
  get: function get() {
    return p2tr_js_1.p2tr;
  }
});
// TODO
// witness commitment

},{"./embed.cjs":78,"./p2ms.cjs":81,"./p2pk.cjs":82,"./p2pkh.cjs":83,"./p2sh.cjs":84,"./p2tr.cjs":85,"./p2wpkh.cjs":86,"./p2wsh.cjs":87}],80:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});
exports.prop = prop;
exports.value = value;
function prop(object, name, f) {
  Object.defineProperty(object, name, {
    configurable: true,
    enumerable: true,
    get: function get() {
      var _value = f.call(this);
      this[name] = _value;
      return _value;
    },
    set: function set(_value) {
      Object.defineProperty(this, name, {
        configurable: true,
        enumerable: true,
        value: _value,
        writable: true
      });
    }
  });
}
function value(f) {
  var _value;
  return function () {
    if (_value !== undefined) return _value;
    _value = f();
    return _value;
  };
}

},{}],81:[function(require,module,exports){
'use strict';

var __createBinding = void 0 && (void 0).__createBinding || (Object.create ? function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  var desc = Object.getOwnPropertyDescriptor(m, k);
  if (!desc || ('get' in desc ? !m.__esModule : desc.writable || desc.configurable)) {
    desc = {
      enumerable: true,
      get: function get() {
        return m[k];
      }
    };
  }
  Object.defineProperty(o, k2, desc);
} : function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  o[k2] = m[k];
});
var __setModuleDefault = void 0 && (void 0).__setModuleDefault || (Object.create ? function (o, v) {
  Object.defineProperty(o, 'default', {
    enumerable: true,
    value: v
  });
} : function (o, v) {
  o['default'] = v;
});
var __importStar = void 0 && (void 0).__importStar || function (mod) {
  if (mod && mod.__esModule) return mod;
  var result = {};
  if (mod != null) for (var k in mod) if (k !== 'default' && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
  __setModuleDefault(result, mod);
  return result;
};
Object.defineProperty(exports, '__esModule', {
  value: true
});
exports.p2ms = p2ms;
var networks_js_1 = require('../networks.cjs');
var bscript = __importStar(require('../script.cjs'));
var types_js_1 = require('../types.cjs');
var lazy = __importStar(require('./lazy.cjs'));
var v = __importStar(require('valibot'));
var OPS = bscript.OPS;
var OP_INT_BASE = OPS.OP_RESERVED; // OP_1 - 1
// input: OP_0 [signatures ...]
// output: m [pubKeys ...] n OP_CHECKMULTISIG
/**
 * Represents a function that creates a Pay-to-Multisig (P2MS) payment object.
 * @param a - The payment object.
 * @param opts - Optional payment options.
 * @returns The created payment object.
 * @throws {TypeError} If the provided data is not valid.
 */
function p2ms(a, opts) {
  if (!a.input && !a.output && !(a.pubkeys && a.m !== undefined) && !a.signatures) throw new TypeError('Not enough data');
  opts = Object.assign({
    validate: true
  }, opts || {});
  function isAcceptableSignature(x) {
    return bscript.isCanonicalScriptSignature(x) || (opts.allowIncomplete && x === OPS.OP_0) !== undefined;
  }
  v.parse(v.partial(v.object({
    network: v.object({}),
    m: v.number(),
    n: v.number(),
    output: types_js_1.BufferSchema,
    pubkeys: v.array(v.custom(types_js_1.isPoint), 'Received invalid pubkey'),
    signatures: v.array(v.custom(isAcceptableSignature), 'Expected signature to be of type isAcceptableSignature'),
    input: types_js_1.BufferSchema
  })), a);
  var network = a.network || networks_js_1.bitcoin;
  var o = {
    network: network
  };
  var chunks = [];
  var decoded = false;
  function decode(output) {
    if (decoded) return;
    decoded = true;
    chunks = bscript.decompile(output);
    o.m = chunks[0] - OP_INT_BASE;
    o.n = chunks[chunks.length - 2] - OP_INT_BASE;
    o.pubkeys = chunks.slice(1, -2);
  }
  lazy.prop(o, 'output', function () {
    if (!a.m) return;
    if (!o.n) return;
    if (!a.pubkeys) return;
    return bscript.compile([].concat(OP_INT_BASE + a.m, a.pubkeys, OP_INT_BASE + o.n, OPS.OP_CHECKMULTISIG));
  });
  lazy.prop(o, 'm', function () {
    if (!o.output) return;
    decode(o.output);
    return o.m;
  });
  lazy.prop(o, 'n', function () {
    if (!o.pubkeys) return;
    return o.pubkeys.length;
  });
  lazy.prop(o, 'pubkeys', function () {
    if (!a.output) return;
    decode(a.output);
    return o.pubkeys;
  });
  lazy.prop(o, 'signatures', function () {
    if (!a.input) return;
    return bscript.decompile(a.input).slice(1);
  });
  lazy.prop(o, 'input', function () {
    if (!a.signatures) return;
    return bscript.compile([OPS.OP_0].concat(a.signatures));
  });
  lazy.prop(o, 'witness', function () {
    if (!o.input) return;
    return [];
  });
  lazy.prop(o, 'name', function () {
    if (!o.m || !o.n) return;
    return "p2ms(".concat(o.m, " of ").concat(o.n, ")");
  });
  // extended validation
  if (opts.validate) {
    if (a.output) {
      decode(a.output);
      v.parse(v.number(), chunks[0], {
        message: 'Output is invalid'
      });
      v.parse(v.number(), chunks[chunks.length - 2], {
        message: 'Output is invalid'
      });
      if (chunks[chunks.length - 1] !== OPS.OP_CHECKMULTISIG) throw new TypeError('Output is invalid');
      if (o.m <= 0 || o.n > 16 || o.m > o.n || o.n !== chunks.length - 3) throw new TypeError('Output is invalid');
      if (!o.pubkeys.every(function (x) {
        return (0, types_js_1.isPoint)(x);
      })) throw new TypeError('Output is invalid');
      if (a.m !== undefined && a.m !== o.m) throw new TypeError('m mismatch');
      if (a.n !== undefined && a.n !== o.n) throw new TypeError('n mismatch');
      if (a.pubkeys && !(0, types_js_1.stacksEqual)(a.pubkeys, o.pubkeys)) throw new TypeError('Pubkeys mismatch');
    }
    if (a.pubkeys) {
      if (a.n !== undefined && a.n !== a.pubkeys.length) throw new TypeError('Pubkey count mismatch');
      o.n = a.pubkeys.length;
      if (o.n < o.m) throw new TypeError('Pubkey count cannot be less than m');
    }
    if (a.signatures) {
      if (a.signatures.length < o.m) throw new TypeError('Not enough signatures provided');
      if (a.signatures.length > o.m) throw new TypeError('Too many signatures provided');
    }
    if (a.input) {
      if (a.input[0] !== OPS.OP_0) throw new TypeError('Input is invalid');
      if (o.signatures.length === 0 || !o.signatures.every(isAcceptableSignature)) throw new TypeError('Input has invalid signature(s)');
      if (a.signatures && !(0, types_js_1.stacksEqual)(a.signatures, o.signatures)) throw new TypeError('Signature mismatch');
      if (a.m !== undefined && a.m !== a.signatures.length) throw new TypeError('Signature count mismatch');
    }
  }
  return Object.assign(o, a);
}

},{"../networks.cjs":75,"../script.cjs":92,"../types.cjs":96,"./lazy.cjs":80,"valibot":66}],82:[function(require,module,exports){
'use strict';

var __createBinding = void 0 && (void 0).__createBinding || (Object.create ? function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  var desc = Object.getOwnPropertyDescriptor(m, k);
  if (!desc || ('get' in desc ? !m.__esModule : desc.writable || desc.configurable)) {
    desc = {
      enumerable: true,
      get: function get() {
        return m[k];
      }
    };
  }
  Object.defineProperty(o, k2, desc);
} : function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  o[k2] = m[k];
});
var __setModuleDefault = void 0 && (void 0).__setModuleDefault || (Object.create ? function (o, v) {
  Object.defineProperty(o, 'default', {
    enumerable: true,
    value: v
  });
} : function (o, v) {
  o['default'] = v;
});
var __importStar = void 0 && (void 0).__importStar || function (mod) {
  if (mod && mod.__esModule) return mod;
  var result = {};
  if (mod != null) for (var k in mod) if (k !== 'default' && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
  __setModuleDefault(result, mod);
  return result;
};
Object.defineProperty(exports, '__esModule', {
  value: true
});
exports.p2pk = p2pk;
var networks_js_1 = require('../networks.cjs');
var bscript = __importStar(require('../script.cjs'));
var types_js_1 = require('../types.cjs');
var lazy = __importStar(require('./lazy.cjs'));
var tools = __importStar(require('uint8array-tools'));
var v = __importStar(require('valibot'));
var OPS = bscript.OPS;
// input: {signature}
// output: {pubKey} OP_CHECKSIG
/**
 * Creates a pay-to-public-key (P2PK) payment object.
 *
 * @param a - The payment object containing the necessary data.
 * @param opts - Optional payment options.
 * @returns The P2PK payment object.
 * @throws {TypeError} If the required data is not provided or if the data is invalid.
 */
function p2pk(a, opts) {
  if (!a.input && !a.output && !a.pubkey && !a.input && !a.signature) throw new TypeError('Not enough data');
  opts = Object.assign({
    validate: true
  }, opts || {});
  v.parse(v.partial(v.object({
    network: v.object({}),
    output: types_js_1.BufferSchema,
    pubkey: v.custom(types_js_1.isPoint, 'invalid pubkey'),
    signature: v.custom(bscript.isCanonicalScriptSignature, 'Expected signature to be of type isCanonicalScriptSignature'),
    input: types_js_1.BufferSchema
  })), a);
  var _chunks = lazy.value(function () {
    return bscript.decompile(a.input);
  });
  var network = a.network || networks_js_1.bitcoin;
  var o = {
    name: 'p2pk',
    network: network
  };
  lazy.prop(o, 'output', function () {
    if (!a.pubkey) return;
    return bscript.compile([a.pubkey, OPS.OP_CHECKSIG]);
  });
  lazy.prop(o, 'pubkey', function () {
    if (!a.output) return;
    return a.output.slice(1, -1);
  });
  lazy.prop(o, 'signature', function () {
    if (!a.input) return;
    return _chunks()[0];
  });
  lazy.prop(o, 'input', function () {
    if (!a.signature) return;
    return bscript.compile([a.signature]);
  });
  lazy.prop(o, 'witness', function () {
    if (!o.input) return;
    return [];
  });
  // extended validation
  if (opts.validate) {
    if (a.output) {
      if (a.output[a.output.length - 1] !== OPS.OP_CHECKSIG) throw new TypeError('Output is invalid');
      if (!(0, types_js_1.isPoint)(o.pubkey)) throw new TypeError('Output pubkey is invalid');
      if (a.pubkey && tools.compare(a.pubkey, o.pubkey) !== 0) throw new TypeError('Pubkey mismatch');
    }
    if (a.signature) {
      if (a.input && tools.compare(a.input, o.input) !== 0) throw new TypeError('Signature mismatch');
    }
    if (a.input) {
      if (_chunks().length !== 1) throw new TypeError('Input is invalid');
      if (!bscript.isCanonicalScriptSignature(o.signature)) throw new TypeError('Input has invalid signature');
    }
  }
  return Object.assign(o, a);
}

},{"../networks.cjs":75,"../script.cjs":92,"../types.cjs":96,"./lazy.cjs":80,"uint8array-tools":65,"valibot":66}],83:[function(require,module,exports){
'use strict';

var __createBinding = void 0 && (void 0).__createBinding || (Object.create ? function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  var desc = Object.getOwnPropertyDescriptor(m, k);
  if (!desc || ('get' in desc ? !m.__esModule : desc.writable || desc.configurable)) {
    desc = {
      enumerable: true,
      get: function get() {
        return m[k];
      }
    };
  }
  Object.defineProperty(o, k2, desc);
} : function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  o[k2] = m[k];
});
var __setModuleDefault = void 0 && (void 0).__setModuleDefault || (Object.create ? function (o, v) {
  Object.defineProperty(o, 'default', {
    enumerable: true,
    value: v
  });
} : function (o, v) {
  o['default'] = v;
});
var __importStar = void 0 && (void 0).__importStar || function (mod) {
  if (mod && mod.__esModule) return mod;
  var result = {};
  if (mod != null) for (var k in mod) if (k !== 'default' && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
  __setModuleDefault(result, mod);
  return result;
};
var __importDefault = void 0 && (void 0).__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};
Object.defineProperty(exports, '__esModule', {
  value: true
});
exports.p2pkh = p2pkh;
var bcrypto = __importStar(require('../crypto.cjs'));
var networks_js_1 = require('../networks.cjs');
var bscript = __importStar(require('../script.cjs'));
var types_js_1 = require('../types.cjs');
var lazy = __importStar(require('./lazy.cjs'));
var bs58check_1 = __importDefault(require('bs58check'));
var tools = __importStar(require('uint8array-tools'));
var v = __importStar(require('valibot'));
var OPS = bscript.OPS;
// input: {signature} {pubkey}
// output: OP_DUP OP_HASH160 {hash160(pubkey)} OP_EQUALVERIFY OP_CHECKSIG
/**
 * Creates a Pay-to-Public-Key-Hash (P2PKH) payment object.
 *
 * @param a - The payment object containing the necessary data.
 * @param opts - Optional payment options.
 * @returns The P2PKH payment object.
 * @throws {TypeError} If the required data is not provided or if the data is invalid.
 */
function p2pkh(a, opts) {
  if (!a.address && !a.hash && !a.output && !a.pubkey && !a.input) throw new TypeError('Not enough data');
  opts = Object.assign({
    validate: true
  }, opts || {});
  v.parse(v.partial(v.object({
    network: v.object({}),
    address: v.string(),
    hash: types_js_1.Hash160bitSchema,
    output: (0, types_js_1.NBufferSchemaFactory)(25),
    pubkey: v.custom(types_js_1.isPoint),
    signature: v.custom(bscript.isCanonicalScriptSignature),
    input: types_js_1.BufferSchema
  })), a);
  var _address = lazy.value(function () {
    var payload = bs58check_1["default"].decode(a.address);
    var version = tools.readUInt8(payload, 0);
    var hash = payload.slice(1);
    return {
      version: version,
      hash: hash
    };
  });
  var _chunks = lazy.value(function () {
    return bscript.decompile(a.input);
  });
  var network = a.network || networks_js_1.bitcoin;
  var o = {
    name: 'p2pkh',
    network: network
  };
  lazy.prop(o, 'address', function () {
    if (!o.hash) return;
    var payload = new Uint8Array(21);
    tools.writeUInt8(payload, 0, network.pubKeyHash);
    payload.set(o.hash, 1);
    return bs58check_1["default"].encode(payload);
  });
  lazy.prop(o, 'hash', function () {
    if (a.output) return a.output.slice(3, 23);
    if (a.address) return _address().hash;
    if (a.pubkey || o.pubkey) return bcrypto.hash160(a.pubkey || o.pubkey);
  });
  lazy.prop(o, 'output', function () {
    if (!o.hash) return;
    return bscript.compile([OPS.OP_DUP, OPS.OP_HASH160, o.hash, OPS.OP_EQUALVERIFY, OPS.OP_CHECKSIG]);
  });
  lazy.prop(o, 'pubkey', function () {
    if (!a.input) return;
    return _chunks()[1];
  });
  lazy.prop(o, 'signature', function () {
    if (!a.input) return;
    return _chunks()[0];
  });
  lazy.prop(o, 'input', function () {
    if (!a.pubkey) return;
    if (!a.signature) return;
    return bscript.compile([a.signature, a.pubkey]);
  });
  lazy.prop(o, 'witness', function () {
    if (!o.input) return;
    return [];
  });
  // extended validation
  if (opts.validate) {
    var hash = Uint8Array.from([]);
    if (a.address) {
      if (_address().version !== network.pubKeyHash) throw new TypeError('Invalid version or Network mismatch');
      if (_address().hash.length !== 20) throw new TypeError('Invalid address');
      hash = _address().hash;
    }
    if (a.hash) {
      if (hash.length > 0 && tools.compare(hash, a.hash) !== 0) throw new TypeError('Hash mismatch');else hash = a.hash;
    }
    if (a.output) {
      if (a.output.length !== 25 || a.output[0] !== OPS.OP_DUP || a.output[1] !== OPS.OP_HASH160 || a.output[2] !== 0x14 || a.output[23] !== OPS.OP_EQUALVERIFY || a.output[24] !== OPS.OP_CHECKSIG) throw new TypeError('Output is invalid');
      var hash2 = a.output.slice(3, 23);
      if (hash.length > 0 && tools.compare(hash, hash2) !== 0) throw new TypeError('Hash mismatch');else hash = hash2;
    }
    if (a.pubkey) {
      var pkh = bcrypto.hash160(a.pubkey);
      if (hash.length > 0 && tools.compare(hash, pkh) !== 0) throw new TypeError('Hash mismatch');else hash = pkh;
    }
    if (a.input) {
      var chunks = _chunks();
      if (chunks.length !== 2) throw new TypeError('Input is invalid');
      if (!bscript.isCanonicalScriptSignature(chunks[0])) throw new TypeError('Input has invalid signature');
      if (!(0, types_js_1.isPoint)(chunks[1])) throw new TypeError('Input has invalid pubkey');
      if (a.signature && tools.compare(a.signature, chunks[0]) !== 0) throw new TypeError('Signature mismatch');
      if (a.pubkey && tools.compare(a.pubkey, chunks[1]) !== 0) throw new TypeError('Pubkey mismatch');
      var _pkh = bcrypto.hash160(chunks[1]);
      if (hash.length > 0 && tools.compare(hash, _pkh) !== 0) throw new TypeError('Hash mismatch');
    }
  }
  return Object.assign(o, a);
}

},{"../crypto.cjs":71,"../networks.cjs":75,"../script.cjs":92,"../types.cjs":96,"./lazy.cjs":80,"bs58check":100,"uint8array-tools":65,"valibot":66}],84:[function(require,module,exports){
'use strict';

var __createBinding = void 0 && (void 0).__createBinding || (Object.create ? function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  var desc = Object.getOwnPropertyDescriptor(m, k);
  if (!desc || ('get' in desc ? !m.__esModule : desc.writable || desc.configurable)) {
    desc = {
      enumerable: true,
      get: function get() {
        return m[k];
      }
    };
  }
  Object.defineProperty(o, k2, desc);
} : function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  o[k2] = m[k];
});
var __setModuleDefault = void 0 && (void 0).__setModuleDefault || (Object.create ? function (o, v) {
  Object.defineProperty(o, 'default', {
    enumerable: true,
    value: v
  });
} : function (o, v) {
  o['default'] = v;
});
var __importStar = void 0 && (void 0).__importStar || function (mod) {
  if (mod && mod.__esModule) return mod;
  var result = {};
  if (mod != null) for (var k in mod) if (k !== 'default' && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
  __setModuleDefault(result, mod);
  return result;
};
var __importDefault = void 0 && (void 0).__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};
Object.defineProperty(exports, '__esModule', {
  value: true
});
exports.p2sh = p2sh;
var bcrypto = __importStar(require('../crypto.cjs'));
var networks_js_1 = require('../networks.cjs');
var bscript = __importStar(require('../script.cjs'));
var types_js_1 = require('../types.cjs');
var lazy = __importStar(require('./lazy.cjs'));
var bs58check_1 = __importDefault(require('bs58check'));
var tools = __importStar(require('uint8array-tools'));
var v = __importStar(require('valibot'));
var OPS = bscript.OPS;
// input: [redeemScriptSig ...] {redeemScript}
// witness: <?>
// output: OP_HASH160 {hash160(redeemScript)} OP_EQUAL
/**
 * Creates a Pay-to-Script-Hash (P2SH) payment object.
 *
 * @param a - The payment object containing the necessary data.
 * @param opts - Optional payment options.
 * @returns The P2SH payment object.
 * @throws {TypeError} If the required data is not provided or if the data is invalid.
 */
function p2sh(a, opts) {
  if (!a.address && !a.hash && !a.output && !a.redeem && !a.input) throw new TypeError('Not enough data');
  opts = Object.assign({
    validate: true
  }, opts || {});
  v.parse(v.partial(v.object({
    network: v.object({}),
    address: v.string(),
    hash: (0, types_js_1.NBufferSchemaFactory)(20),
    output: (0, types_js_1.NBufferSchemaFactory)(23),
    redeem: v.partial(v.object({
      network: v.object({}),
      output: types_js_1.BufferSchema,
      input: types_js_1.BufferSchema,
      witness: v.array(types_js_1.BufferSchema)
    })),
    input: types_js_1.BufferSchema,
    witness: v.array(types_js_1.BufferSchema)
  })), a);
  var network = a.network;
  if (!network) {
    network = a.redeem && a.redeem.network || networks_js_1.bitcoin;
  }
  var o = {
    network: network
  };
  var _address = lazy.value(function () {
    var payload = bs58check_1["default"].decode(a.address);
    var version = tools.readUInt8(payload, 0);
    var hash = payload.slice(1);
    return {
      version: version,
      hash: hash
    };
  });
  var _chunks = lazy.value(function () {
    return bscript.decompile(a.input);
  });
  var _redeem = lazy.value(function () {
    var chunks = _chunks();
    var lastChunk = chunks[chunks.length - 1];
    return {
      network: network,
      output: lastChunk === OPS.OP_FALSE ? Uint8Array.from([]) : lastChunk,
      input: bscript.compile(chunks.slice(0, -1)),
      witness: a.witness || []
    };
  });
  // output dependents
  lazy.prop(o, 'address', function () {
    if (!o.hash) return;
    var payload = new Uint8Array(21);
    tools.writeUInt8(payload, 0, o.network.scriptHash);
    payload.set(o.hash, 1);
    return bs58check_1["default"].encode(payload);
  });
  lazy.prop(o, 'hash', function () {
    // in order of least effort
    if (a.output) return a.output.slice(2, 22);
    if (a.address) return _address().hash;
    if (o.redeem && o.redeem.output) return bcrypto.hash160(o.redeem.output);
  });
  lazy.prop(o, 'output', function () {
    if (!o.hash) return;
    return bscript.compile([OPS.OP_HASH160, o.hash, OPS.OP_EQUAL]);
  });
  // input dependents
  lazy.prop(o, 'redeem', function () {
    if (!a.input) return;
    return _redeem();
  });
  lazy.prop(o, 'input', function () {
    if (!a.redeem || !a.redeem.input || !a.redeem.output) return;
    return bscript.compile([].concat(bscript.decompile(a.redeem.input), a.redeem.output));
  });
  lazy.prop(o, 'witness', function () {
    if (o.redeem && o.redeem.witness) return o.redeem.witness;
    if (o.input) return [];
  });
  lazy.prop(o, 'name', function () {
    var nameParts = ['p2sh'];
    if (o.redeem !== undefined && o.redeem.name !== undefined) nameParts.push(o.redeem.name);
    return nameParts.join('-');
  });
  if (opts.validate) {
    var hash = Uint8Array.from([]);
    if (a.address) {
      if (_address().version !== network.scriptHash) throw new TypeError('Invalid version or Network mismatch');
      if (_address().hash.length !== 20) throw new TypeError('Invalid address');
      hash = _address().hash;
    }
    if (a.hash) {
      if (hash.length > 0 && tools.compare(hash, a.hash) !== 0) throw new TypeError('Hash mismatch');else hash = a.hash;
    }
    if (a.output) {
      if (a.output.length !== 23 || a.output[0] !== OPS.OP_HASH160 || a.output[1] !== 0x14 || a.output[22] !== OPS.OP_EQUAL) throw new TypeError('Output is invalid');
      var hash2 = a.output.slice(2, 22);
      if (hash.length > 0 && tools.compare(hash, hash2) !== 0) throw new TypeError('Hash mismatch');else hash = hash2;
    }
    // inlined to prevent 'no-inner-declarations' failing
    var checkRedeem = function checkRedeem(redeem) {
      // is the redeem output empty/invalid?
      if (redeem.output) {
        var decompile = bscript.decompile(redeem.output);
        if (!decompile || decompile.length < 1) throw new TypeError('Redeem.output too short');
        if (redeem.output.byteLength > 520) throw new TypeError('Redeem.output unspendable if larger than 520 bytes');
        if (bscript.countNonPushOnlyOPs(decompile) > 201) throw new TypeError('Redeem.output unspendable with more than 201 non-push ops');
        // match hash against other sources
        var _hash = bcrypto.hash160(redeem.output);
        if (hash.length > 0 && tools.compare(hash, _hash) !== 0) throw new TypeError('Hash mismatch');else hash = _hash;
      }
      if (redeem.input) {
        var hasInput = redeem.input.length > 0;
        var hasWitness = redeem.witness && redeem.witness.length > 0;
        if (!hasInput && !hasWitness) throw new TypeError('Empty input');
        if (hasInput && hasWitness) throw new TypeError('Input and witness provided');
        if (hasInput) {
          var richunks = bscript.decompile(redeem.input);
          if (!bscript.isPushOnly(richunks)) throw new TypeError('Non push-only scriptSig');
        }
      }
    };
    if (a.input) {
      var chunks = _chunks();
      if (!chunks || chunks.length < 1) throw new TypeError('Input too short');
      if (!(_redeem().output instanceof Uint8Array)) throw new TypeError('Input is invalid');
      checkRedeem(_redeem());
    }
    if (a.redeem) {
      if (a.redeem.network && a.redeem.network !== network) throw new TypeError('Network mismatch');
      if (a.input) {
        var redeem = _redeem();
        if (a.redeem.output && tools.compare(a.redeem.output, redeem.output) !== 0) throw new TypeError('Redeem.output mismatch');
        if (a.redeem.input && tools.compare(a.redeem.input, redeem.input) !== 0) throw new TypeError('Redeem.input mismatch');
      }
      checkRedeem(a.redeem);
    }
    if (a.witness) {
      if (a.redeem && a.redeem.witness && !(0, types_js_1.stacksEqual)(a.redeem.witness, a.witness)) throw new TypeError('Witness and redeem.witness mismatch');
    }
  }
  return Object.assign(o, a);
}

},{"../crypto.cjs":71,"../networks.cjs":75,"../script.cjs":92,"../types.cjs":96,"./lazy.cjs":80,"bs58check":100,"uint8array-tools":65,"valibot":66}],85:[function(require,module,exports){
'use strict';

var __createBinding = void 0 && (void 0).__createBinding || (Object.create ? function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  var desc = Object.getOwnPropertyDescriptor(m, k);
  if (!desc || ('get' in desc ? !m.__esModule : desc.writable || desc.configurable)) {
    desc = {
      enumerable: true,
      get: function get() {
        return m[k];
      }
    };
  }
  Object.defineProperty(o, k2, desc);
} : function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  o[k2] = m[k];
});
var __setModuleDefault = void 0 && (void 0).__setModuleDefault || (Object.create ? function (o, v) {
  Object.defineProperty(o, 'default', {
    enumerable: true,
    value: v
  });
} : function (o, v) {
  o['default'] = v;
});
var __importStar = void 0 && (void 0).__importStar || function (mod) {
  if (mod && mod.__esModule) return mod;
  var result = {};
  if (mod != null) for (var k in mod) if (k !== 'default' && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
  __setModuleDefault(result, mod);
  return result;
};
Object.defineProperty(exports, '__esModule', {
  value: true
});
exports.p2tr = p2tr;
var networks_js_1 = require('../networks.cjs');
var bscript = __importStar(require('../script.cjs'));
var types_js_1 = require('../types.cjs');
var ecc_lib_js_1 = require('../ecc_lib.cjs');
var bip341_js_1 = require('./bip341.cjs');
var lazy = __importStar(require('./lazy.cjs'));
var bech32_1 = require('bech32');
var address_js_1 = require('../address.cjs');
var tools = __importStar(require('uint8array-tools'));
var v = __importStar(require('valibot'));
var OPS = bscript.OPS;
var TAPROOT_WITNESS_VERSION = 0x01;
var ANNEX_PREFIX = 0x50;
/**
 * Creates a Pay-to-Taproot (P2TR) payment object.
 *
 * @param a - The payment object containing the necessary data for P2TR.
 * @param opts - Optional payment options.
 * @returns The P2TR payment object.
 * @throws {TypeError} If the provided data is invalid or insufficient.
 */
function p2tr(a, opts) {
  if (!a.address && !a.output && !a.pubkey && !a.internalPubkey && !(a.witness && a.witness.length > 1)) throw new TypeError('Not enough data');
  opts = Object.assign({
    validate: true
  }, opts || {});
  v.parse(v.partial(v.object({
    address: v.string(),
    input: (0, types_js_1.NBufferSchemaFactory)(0),
    network: v.object({}),
    output: (0, types_js_1.NBufferSchemaFactory)(34),
    internalPubkey: (0, types_js_1.NBufferSchemaFactory)(32),
    hash: (0, types_js_1.NBufferSchemaFactory)(32),
    // merkle root hash, the tweak
    pubkey: (0, types_js_1.NBufferSchemaFactory)(32),
    // tweaked with `hash` from `internalPubkey`
    signature: v.union([(0, types_js_1.NBufferSchemaFactory)(64), (0, types_js_1.NBufferSchemaFactory)(65)]),
    witness: v.array(types_js_1.BufferSchema),
    scriptTree: v.custom(types_js_1.isTaptree, 'Taptree is not of type isTaptree'),
    redeem: v.partial(v.object({
      output: types_js_1.BufferSchema,
      // tapleaf script
      redeemVersion: v.number(),
      // tapleaf version
      witness: v.array(types_js_1.BufferSchema)
    })),
    redeemVersion: v.number()
  })), a);
  var _address = lazy.value(function () {
    return (0, address_js_1.fromBech32)(a.address);
  });
  // remove annex if present, ignored by taproot
  var _witness = lazy.value(function () {
    if (!a.witness || !a.witness.length) return;
    if (a.witness.length >= 2 && a.witness[a.witness.length - 1][0] === ANNEX_PREFIX) {
      return a.witness.slice(0, -1);
    }
    return a.witness.slice();
  });
  var _hashTree = lazy.value(function () {
    if (a.scriptTree) return (0, bip341_js_1.toHashTree)(a.scriptTree);
    if (a.hash) return {
      hash: a.hash
    };
    return;
  });
  var network = a.network || networks_js_1.bitcoin;
  var o = {
    name: 'p2tr',
    network: network
  };
  lazy.prop(o, 'address', function () {
    if (!o.pubkey) return;
    var words = bech32_1.bech32m.toWords(o.pubkey);
    words.unshift(TAPROOT_WITNESS_VERSION);
    return bech32_1.bech32m.encode(network.bech32, words);
  });
  lazy.prop(o, 'hash', function () {
    var hashTree = _hashTree();
    if (hashTree) return hashTree.hash;
    var w = _witness();
    if (w && w.length > 1) {
      var controlBlock = w[w.length - 1];
      var leafVersion = controlBlock[0] & types_js_1.TAPLEAF_VERSION_MASK;
      var script = w[w.length - 2];
      var leafHash = (0, bip341_js_1.tapleafHash)({
        output: script,
        version: leafVersion
      });
      return (0, bip341_js_1.rootHashFromPath)(controlBlock, leafHash);
    }
    return null;
  });
  lazy.prop(o, 'output', function () {
    if (!o.pubkey) return;
    return bscript.compile([OPS.OP_1, o.pubkey]);
  });
  lazy.prop(o, 'redeemVersion', function () {
    if (a.redeemVersion) return a.redeemVersion;
    if (a.redeem && a.redeem.redeemVersion !== undefined && a.redeem.redeemVersion !== null) {
      return a.redeem.redeemVersion;
    }
    return bip341_js_1.LEAF_VERSION_TAPSCRIPT;
  });
  lazy.prop(o, 'redeem', function () {
    var witness = _witness(); // witness without annex
    if (!witness || witness.length < 2) return;
    return {
      output: witness[witness.length - 2],
      witness: witness.slice(0, -2),
      redeemVersion: witness[witness.length - 1][0] & types_js_1.TAPLEAF_VERSION_MASK
    };
  });
  lazy.prop(o, 'pubkey', function () {
    if (a.pubkey) return a.pubkey;
    if (a.output) return a.output.slice(2);
    if (a.address) return _address().data;
    if (o.internalPubkey) {
      var tweakedKey = (0, bip341_js_1.tweakKey)(o.internalPubkey, o.hash);
      if (tweakedKey) return tweakedKey.x;
    }
  });
  lazy.prop(o, 'internalPubkey', function () {
    if (a.internalPubkey) return a.internalPubkey;
    var witness = _witness();
    if (witness && witness.length > 1) return witness[witness.length - 1].slice(1, 33);
  });
  lazy.prop(o, 'signature', function () {
    if (a.signature) return a.signature;
    var witness = _witness(); // witness without annex
    if (!witness || witness.length !== 1) return;
    return witness[0];
  });
  lazy.prop(o, 'witness', function () {
    if (a.witness) return a.witness;
    var hashTree = _hashTree();
    if (hashTree && a.redeem && a.redeem.output && a.internalPubkey) {
      var leafHash = (0, bip341_js_1.tapleafHash)({
        output: a.redeem.output,
        version: o.redeemVersion
      });
      var path = (0, bip341_js_1.findScriptPath)(hashTree, leafHash);
      if (!path) return;
      var outputKey = (0, bip341_js_1.tweakKey)(a.internalPubkey, hashTree.hash);
      if (!outputKey) return;
      var controlBock = tools.concat([Uint8Array.from([o.redeemVersion | outputKey.parity]), a.internalPubkey].concat(path));
      return [a.redeem.output, controlBock];
    }
    if (a.signature) return [a.signature];
  });
  // extended validation
  if (opts.validate) {
    var pubkey = Uint8Array.from([]);
    if (a.address) {
      if (network && network.bech32 !== _address().prefix) throw new TypeError('Invalid prefix or Network mismatch');
      if (_address().version !== TAPROOT_WITNESS_VERSION) throw new TypeError('Invalid address version');
      if (_address().data.length !== 32) throw new TypeError('Invalid address data');
      pubkey = _address().data;
    }
    if (a.pubkey) {
      if (pubkey.length > 0 && tools.compare(pubkey, a.pubkey) !== 0) throw new TypeError('Pubkey mismatch');else pubkey = a.pubkey;
    }
    if (a.output) {
      if (a.output.length !== 34 || a.output[0] !== OPS.OP_1 || a.output[1] !== 0x20) throw new TypeError('Output is invalid');
      if (pubkey.length > 0 && tools.compare(pubkey, a.output.slice(2)) !== 0) throw new TypeError('Pubkey mismatch');else pubkey = a.output.slice(2);
    }
    if (a.internalPubkey) {
      var tweakedKey = (0, bip341_js_1.tweakKey)(a.internalPubkey, o.hash);
      if (pubkey.length > 0 && tools.compare(pubkey, tweakedKey.x) !== 0) throw new TypeError('Pubkey mismatch');else pubkey = tweakedKey.x;
    }
    if (pubkey && pubkey.length) {
      if (!(0, ecc_lib_js_1.getEccLib)().isXOnlyPoint(pubkey)) throw new TypeError('Invalid pubkey for p2tr');
    }
    var hashTree = _hashTree();
    if (a.hash && hashTree) {
      if (tools.compare(a.hash, hashTree.hash) !== 0) throw new TypeError('Hash mismatch');
    }
    if (a.redeem && a.redeem.output && hashTree) {
      var leafHash = (0, bip341_js_1.tapleafHash)({
        output: a.redeem.output,
        version: o.redeemVersion
      });
      if (!(0, bip341_js_1.findScriptPath)(hashTree, leafHash)) throw new TypeError('Redeem script not in tree');
    }
    var witness = _witness();
    // compare the provided redeem data with the one computed from witness
    if (a.redeem && o.redeem) {
      if (a.redeem.redeemVersion) {
        if (a.redeem.redeemVersion !== o.redeem.redeemVersion) throw new TypeError('Redeem.redeemVersion and witness mismatch');
      }
      if (a.redeem.output) {
        if (bscript.decompile(a.redeem.output).length === 0) throw new TypeError('Redeem.output is invalid');
        // output redeem is constructed from the witness
        if (o.redeem.output && tools.compare(a.redeem.output, o.redeem.output) !== 0) throw new TypeError('Redeem.output and witness mismatch');
      }
      if (a.redeem.witness) {
        if (o.redeem.witness && !(0, types_js_1.stacksEqual)(a.redeem.witness, o.redeem.witness)) throw new TypeError('Redeem.witness and witness mismatch');
      }
    }
    if (witness && witness.length) {
      if (witness.length === 1) {
        // key spending
        if (a.signature && tools.compare(a.signature, witness[0]) !== 0) throw new TypeError('Signature mismatch');
      } else {
        // script path spending
        var controlBlock = witness[witness.length - 1];
        if (controlBlock.length < 33) throw new TypeError("The control-block length is too small. Got ".concat(controlBlock.length, ", expected min 33."));
        if ((controlBlock.length - 33) % 32 !== 0) throw new TypeError("The control-block length of ".concat(controlBlock.length, " is incorrect!"));
        var m = (controlBlock.length - 33) / 32;
        if (m > 128) throw new TypeError("The script path is too long. Got ".concat(m, ", expected max 128."));
        var internalPubkey = controlBlock.slice(1, 33);
        if (a.internalPubkey && tools.compare(a.internalPubkey, internalPubkey) !== 0) throw new TypeError('Internal pubkey mismatch');
        if (!(0, ecc_lib_js_1.getEccLib)().isXOnlyPoint(internalPubkey)) throw new TypeError('Invalid internalPubkey for p2tr witness');
        var leafVersion = controlBlock[0] & types_js_1.TAPLEAF_VERSION_MASK;
        var script = witness[witness.length - 2];
        var _leafHash = (0, bip341_js_1.tapleafHash)({
          output: script,
          version: leafVersion
        });
        var hash = (0, bip341_js_1.rootHashFromPath)(controlBlock, _leafHash);
        var outputKey = (0, bip341_js_1.tweakKey)(internalPubkey, hash);
        if (!outputKey)
          // todo: needs test data
          throw new TypeError('Invalid outputKey for p2tr witness');
        if (pubkey.length && tools.compare(pubkey, outputKey.x) !== 0) throw new TypeError('Pubkey mismatch for p2tr witness');
        if (outputKey.parity !== (controlBlock[0] & 1)) throw new Error('Incorrect parity');
      }
    }
  }
  return Object.assign(o, a);
}

},{"../address.cjs":67,"../ecc_lib.cjs":72,"../networks.cjs":75,"../script.cjs":92,"../types.cjs":96,"./bip341.cjs":77,"./lazy.cjs":80,"bech32":17,"uint8array-tools":65,"valibot":66}],86:[function(require,module,exports){
'use strict';

var __createBinding = void 0 && (void 0).__createBinding || (Object.create ? function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  var desc = Object.getOwnPropertyDescriptor(m, k);
  if (!desc || ('get' in desc ? !m.__esModule : desc.writable || desc.configurable)) {
    desc = {
      enumerable: true,
      get: function get() {
        return m[k];
      }
    };
  }
  Object.defineProperty(o, k2, desc);
} : function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  o[k2] = m[k];
});
var __setModuleDefault = void 0 && (void 0).__setModuleDefault || (Object.create ? function (o, v) {
  Object.defineProperty(o, 'default', {
    enumerable: true,
    value: v
  });
} : function (o, v) {
  o['default'] = v;
});
var __importStar = void 0 && (void 0).__importStar || function (mod) {
  if (mod && mod.__esModule) return mod;
  var result = {};
  if (mod != null) for (var k in mod) if (k !== 'default' && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
  __setModuleDefault(result, mod);
  return result;
};
Object.defineProperty(exports, '__esModule', {
  value: true
});
exports.p2wpkh = p2wpkh;
var bcrypto = __importStar(require('../crypto.cjs'));
var networks_js_1 = require('../networks.cjs');
var bscript = __importStar(require('../script.cjs'));
var types_js_1 = require('../types.cjs');
var lazy = __importStar(require('./lazy.cjs'));
var bech32_1 = require('bech32');
var tools = __importStar(require('uint8array-tools'));
var v = __importStar(require('valibot'));
var OPS = bscript.OPS;
var EMPTY_BUFFER = new Uint8Array(0);
// witness: {signature} {pubKey}
// input: <>
// output: OP_0 {pubKeyHash}
/**
 * Creates a pay-to-witness-public-key-hash (p2wpkh) payment object.
 *
 * @param a - The payment object containing the necessary data.
 * @param opts - Optional payment options.
 * @returns The p2wpkh payment object.
 * @throws {TypeError} If the required data is missing or invalid.
 */
function p2wpkh(a, opts) {
  if (!a.address && !a.hash && !a.output && !a.pubkey && !a.witness) throw new TypeError('Not enough data');
  opts = Object.assign({
    validate: true
  }, opts || {});
  v.parse(v.partial(v.object({
    address: v.string(),
    hash: (0, types_js_1.NBufferSchemaFactory)(20),
    input: (0, types_js_1.NBufferSchemaFactory)(0),
    network: v.object({}),
    output: (0, types_js_1.NBufferSchemaFactory)(22),
    pubkey: v.custom(types_js_1.isPoint, 'Not a valid pubkey'),
    signature: v.custom(bscript.isCanonicalScriptSignature),
    witness: v.array(types_js_1.BufferSchema)
  })), a);
  var _address = lazy.value(function () {
    var result = bech32_1.bech32.decode(a.address);
    var version = result.words.shift();
    var data = bech32_1.bech32.fromWords(result.words);
    return {
      version: version,
      prefix: result.prefix,
      data: Uint8Array.from(data)
    };
  });
  var network = a.network || networks_js_1.bitcoin;
  var o = {
    name: 'p2wpkh',
    network: network
  };
  lazy.prop(o, 'address', function () {
    if (!o.hash) return;
    var words = bech32_1.bech32.toWords(o.hash);
    words.unshift(0x00);
    return bech32_1.bech32.encode(network.bech32, words);
  });
  lazy.prop(o, 'hash', function () {
    if (a.output) return a.output.slice(2, 22);
    if (a.address) return _address().data;
    if (a.pubkey || o.pubkey) return bcrypto.hash160(a.pubkey || o.pubkey);
  });
  lazy.prop(o, 'output', function () {
    if (!o.hash) return;
    return bscript.compile([OPS.OP_0, o.hash]);
  });
  lazy.prop(o, 'pubkey', function () {
    if (a.pubkey) return a.pubkey;
    if (!a.witness) return;
    return a.witness[1];
  });
  lazy.prop(o, 'signature', function () {
    if (!a.witness) return;
    return a.witness[0];
  });
  lazy.prop(o, 'input', function () {
    if (!o.witness) return;
    return EMPTY_BUFFER;
  });
  lazy.prop(o, 'witness', function () {
    if (!a.pubkey) return;
    if (!a.signature) return;
    return [a.signature, a.pubkey];
  });
  // extended validation
  if (opts.validate) {
    var hash = Uint8Array.from([]);
    if (a.address) {
      if (network && network.bech32 !== _address().prefix) throw new TypeError('Invalid prefix or Network mismatch');
      if (_address().version !== 0x00) throw new TypeError('Invalid address version');
      if (_address().data.length !== 20) throw new TypeError('Invalid address data');
      hash = _address().data;
    }
    if (a.hash) {
      if (hash.length > 0 && tools.compare(hash, a.hash) !== 0) throw new TypeError('Hash mismatch');else hash = a.hash;
    }
    if (a.output) {
      if (a.output.length !== 22 || a.output[0] !== OPS.OP_0 || a.output[1] !== 0x14) throw new TypeError('Output is invalid');
      if (hash.length > 0 && tools.compare(hash, a.output.slice(2)) !== 0) throw new TypeError('Hash mismatch');else hash = a.output.slice(2);
    }
    if (a.pubkey) {
      var pkh = bcrypto.hash160(a.pubkey);
      if (hash.length > 0 && tools.compare(hash, pkh) !== 0) throw new TypeError('Hash mismatch');else hash = pkh;
      if (!(0, types_js_1.isPoint)(a.pubkey) || a.pubkey.length !== 33) throw new TypeError('Invalid pubkey for p2wpkh');
    }
    if (a.witness) {
      if (a.witness.length !== 2) throw new TypeError('Witness is invalid');
      if (!bscript.isCanonicalScriptSignature(a.witness[0])) throw new TypeError('Witness has invalid signature');
      if (!(0, types_js_1.isPoint)(a.witness[1]) || a.witness[1].length !== 33) throw new TypeError('Witness has invalid pubkey');
      if (a.signature && tools.compare(a.signature, a.witness[0]) !== 0) throw new TypeError('Signature mismatch');
      // if (a.pubkey && !a.pubkey.equals(a.witness[1]))
      if (a.pubkey && tools.compare(a.pubkey, a.witness[1]) !== 0) throw new TypeError('Pubkey mismatch');
      var _pkh = bcrypto.hash160(a.witness[1]);
      if (hash.length > 0 && tools.compare(hash, _pkh) !== 0) throw new TypeError('Hash mismatch');
    }
  }
  return Object.assign(o, a);
}

},{"../crypto.cjs":71,"../networks.cjs":75,"../script.cjs":92,"../types.cjs":96,"./lazy.cjs":80,"bech32":17,"uint8array-tools":65,"valibot":66}],87:[function(require,module,exports){
'use strict';

var __createBinding = void 0 && (void 0).__createBinding || (Object.create ? function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  var desc = Object.getOwnPropertyDescriptor(m, k);
  if (!desc || ('get' in desc ? !m.__esModule : desc.writable || desc.configurable)) {
    desc = {
      enumerable: true,
      get: function get() {
        return m[k];
      }
    };
  }
  Object.defineProperty(o, k2, desc);
} : function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  o[k2] = m[k];
});
var __setModuleDefault = void 0 && (void 0).__setModuleDefault || (Object.create ? function (o, v) {
  Object.defineProperty(o, 'default', {
    enumerable: true,
    value: v
  });
} : function (o, v) {
  o['default'] = v;
});
var __importStar = void 0 && (void 0).__importStar || function (mod) {
  if (mod && mod.__esModule) return mod;
  var result = {};
  if (mod != null) for (var k in mod) if (k !== 'default' && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
  __setModuleDefault(result, mod);
  return result;
};
Object.defineProperty(exports, '__esModule', {
  value: true
});
exports.p2wsh = p2wsh;
var sha256_1 = require('@noble/hashes/sha256');
var networks_js_1 = require('../networks.cjs');
var bscript = __importStar(require('../script.cjs'));
var types_js_1 = require('../types.cjs');
var lazy = __importStar(require('./lazy.cjs'));
var bech32_1 = require('bech32');
var tools = __importStar(require('uint8array-tools'));
var v = __importStar(require('valibot'));
var OPS = bscript.OPS;
var EMPTY_BUFFER = new Uint8Array(0);
function chunkHasUncompressedPubkey(chunk) {
  if (chunk instanceof Uint8Array && chunk.length === 65 && chunk[0] === 0x04 && (0, types_js_1.isPoint)(chunk)) {
    return true;
  } else {
    return false;
  }
}
// input: <>
// witness: [redeemScriptSig ...] {redeemScript}
// output: OP_0 {sha256(redeemScript)}
/**
 * Creates a Pay-to-Witness-Script-Hash (P2WSH) payment object.
 *
 * @param a - The payment object containing the necessary data.
 * @param opts - Optional payment options.
 * @returns The P2WSH payment object.
 * @throws {TypeError} If the required data is missing or invalid.
 */
function p2wsh(a, opts) {
  if (!a.address && !a.hash && !a.output && !a.redeem && !a.witness) throw new TypeError('Not enough data');
  opts = Object.assign({
    validate: true
  }, opts || {});
  v.parse((0, types_js_1.NullablePartial)({
    network: v.object({}),
    address: v.string(),
    hash: types_js_1.Buffer256bitSchema,
    output: (0, types_js_1.NBufferSchemaFactory)(34),
    redeem: (0, types_js_1.NullablePartial)({
      input: types_js_1.BufferSchema,
      network: v.object({}),
      output: types_js_1.BufferSchema,
      witness: v.array(types_js_1.BufferSchema)
    }),
    input: (0, types_js_1.NBufferSchemaFactory)(0),
    witness: v.array(types_js_1.BufferSchema)
  }), a);
  var _address = lazy.value(function () {
    var result = bech32_1.bech32.decode(a.address);
    var version = result.words.shift();
    var data = bech32_1.bech32.fromWords(result.words);
    return {
      version: version,
      prefix: result.prefix,
      data: Uint8Array.from(data)
    };
  });
  var _rchunks = lazy.value(function () {
    return bscript.decompile(a.redeem.input);
  });
  var network = a.network;
  if (!network) {
    network = a.redeem && a.redeem.network || networks_js_1.bitcoin;
  }
  var o = {
    network: network
  };
  lazy.prop(o, 'address', function () {
    if (!o.hash) return;
    var words = bech32_1.bech32.toWords(o.hash);
    words.unshift(0x00);
    return bech32_1.bech32.encode(network.bech32, words);
  });
  lazy.prop(o, 'hash', function () {
    if (a.output) return a.output.slice(2);
    if (a.address) return _address().data;
    if (o.redeem && o.redeem.output) return (0, sha256_1.sha256)(o.redeem.output);
  });
  lazy.prop(o, 'output', function () {
    if (!o.hash) return;
    return bscript.compile([OPS.OP_0, o.hash]);
  });
  lazy.prop(o, 'redeem', function () {
    if (!a.witness) return;
    return {
      output: a.witness[a.witness.length - 1],
      input: EMPTY_BUFFER,
      witness: a.witness.slice(0, -1)
    };
  });
  lazy.prop(o, 'input', function () {
    if (!o.witness) return;
    return EMPTY_BUFFER;
  });
  lazy.prop(o, 'witness', function () {
    // transform redeem input to witness stack?
    if (a.redeem && a.redeem.input && a.redeem.input.length > 0 && a.redeem.output && a.redeem.output.length > 0) {
      var stack = bscript.toStack(_rchunks());
      // assign, and blank the existing input
      o.redeem = Object.assign({
        witness: stack
      }, a.redeem);
      o.redeem.input = EMPTY_BUFFER;
      return [].concat(stack, a.redeem.output);
    }
    if (!a.redeem) return;
    if (!a.redeem.output) return;
    if (!a.redeem.witness) return;
    return [].concat(a.redeem.witness, a.redeem.output);
  });
  lazy.prop(o, 'name', function () {
    var nameParts = ['p2wsh'];
    if (o.redeem !== undefined && o.redeem.name !== undefined) nameParts.push(o.redeem.name);
    return nameParts.join('-');
  });
  // extended validation
  if (opts.validate) {
    var hash = Uint8Array.from([]);
    if (a.address) {
      if (_address().prefix !== network.bech32) throw new TypeError('Invalid prefix or Network mismatch');
      if (_address().version !== 0x00) throw new TypeError('Invalid address version');
      if (_address().data.length !== 32) throw new TypeError('Invalid address data');
      hash = _address().data;
    }
    if (a.hash) {
      if (hash.length > 0 && tools.compare(hash, a.hash) !== 0) throw new TypeError('Hash mismatch');else hash = a.hash;
    }
    if (a.output) {
      if (a.output.length !== 34 || a.output[0] !== OPS.OP_0 || a.output[1] !== 0x20) throw new TypeError('Output is invalid');
      var hash2 = a.output.slice(2);
      if (hash.length > 0 && tools.compare(hash, hash2) !== 0) throw new TypeError('Hash mismatch');else hash = hash2;
    }
    if (a.redeem) {
      if (a.redeem.network && a.redeem.network !== network) throw new TypeError('Network mismatch');
      // is there two redeem sources?
      if (a.redeem.input && a.redeem.input.length > 0 && a.redeem.witness && a.redeem.witness.length > 0) throw new TypeError('Ambiguous witness source');
      // is the redeem output non-empty/valid?
      if (a.redeem.output) {
        var decompile = bscript.decompile(a.redeem.output);
        if (!decompile || decompile.length < 1) throw new TypeError('Redeem.output is invalid');
        if (a.redeem.output.byteLength > 3600) throw new TypeError('Redeem.output unspendable if larger than 3600 bytes');
        if (bscript.countNonPushOnlyOPs(decompile) > 201) throw new TypeError('Redeem.output unspendable with more than 201 non-push ops');
        // match hash against other sources
        var _hash = (0, sha256_1.sha256)(a.redeem.output);
        if (hash.length > 0 && tools.compare(hash, _hash) !== 0) throw new TypeError('Hash mismatch');else hash = _hash;
      }
      if (a.redeem.input && !bscript.isPushOnly(_rchunks())) throw new TypeError('Non push-only scriptSig');
      if (a.witness && a.redeem.witness && !(0, types_js_1.stacksEqual)(a.witness, a.redeem.witness)) throw new TypeError('Witness and redeem.witness mismatch');
      if (a.redeem.input && _rchunks().some(chunkHasUncompressedPubkey) || a.redeem.output && (bscript.decompile(a.redeem.output) || []).some(chunkHasUncompressedPubkey)) {
        throw new TypeError('redeem.input or redeem.output contains uncompressed pubkey');
      }
    }
    if (a.witness && a.witness.length > 0) {
      var wScript = a.witness[a.witness.length - 1];
      if (a.redeem && a.redeem.output && tools.compare(a.redeem.output, wScript) !== 0) throw new TypeError('Witness and redeem.output mismatch');
      if (a.witness.some(chunkHasUncompressedPubkey) || (bscript.decompile(wScript) || []).some(chunkHasUncompressedPubkey)) throw new TypeError('Witness contains uncompressed pubkey');
    }
  }
  return Object.assign(o, a);
}

},{"../networks.cjs":75,"../script.cjs":92,"../types.cjs":96,"./lazy.cjs":80,"@noble/hashes/sha256":11,"bech32":17,"uint8array-tools":65,"valibot":66}],88:[function(require,module,exports){
'use strict';

function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _regeneratorRuntime() { "use strict"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return e; }; var t, e = {}, r = Object.prototype, n = r.hasOwnProperty, o = Object.defineProperty || function (t, e, r) { t[e] = r.value; }, i = "function" == typeof Symbol ? Symbol : {}, a = i.iterator || "@@iterator", c = i.asyncIterator || "@@asyncIterator", u = i.toStringTag || "@@toStringTag"; function define(t, e, r) { return Object.defineProperty(t, e, { value: r, enumerable: !0, configurable: !0, writable: !0 }), t[e]; } try { define({}, ""); } catch (t) { define = function define(t, e, r) { return t[e] = r; }; } function wrap(t, e, r, n) { var i = e && e.prototype instanceof Generator ? e : Generator, a = Object.create(i.prototype), c = new Context(n || []); return o(a, "_invoke", { value: makeInvokeMethod(t, r, c) }), a; } function tryCatch(t, e, r) { try { return { type: "normal", arg: t.call(e, r) }; } catch (t) { return { type: "throw", arg: t }; } } e.wrap = wrap; var h = "suspendedStart", l = "suspendedYield", f = "executing", s = "completed", y = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var p = {}; define(p, a, function () { return this; }); var d = Object.getPrototypeOf, v = d && d(d(values([]))); v && v !== r && n.call(v, a) && (p = v); var g = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(p); function defineIteratorMethods(t) { ["next", "throw", "return"].forEach(function (e) { define(t, e, function (t) { return this._invoke(e, t); }); }); } function AsyncIterator(t, e) { function invoke(r, o, i, a) { var c = tryCatch(t[r], t, o); if ("throw" !== c.type) { var u = c.arg, h = u.value; return h && "object" == _typeof(h) && n.call(h, "__await") ? e.resolve(h.__await).then(function (t) { invoke("next", t, i, a); }, function (t) { invoke("throw", t, i, a); }) : e.resolve(h).then(function (t) { u.value = t, i(u); }, function (t) { return invoke("throw", t, i, a); }); } a(c.arg); } var r; o(this, "_invoke", { value: function value(t, n) { function callInvokeWithMethodAndArg() { return new e(function (e, r) { invoke(t, n, e, r); }); } return r = r ? r.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); } }); } function makeInvokeMethod(e, r, n) { var o = h; return function (i, a) { if (o === f) throw Error("Generator is already running"); if (o === s) { if ("throw" === i) throw a; return { value: t, done: !0 }; } for (n.method = i, n.arg = a;;) { var c = n.delegate; if (c) { var u = maybeInvokeDelegate(c, n); if (u) { if (u === y) continue; return u; } } if ("next" === n.method) n.sent = n._sent = n.arg;else if ("throw" === n.method) { if (o === h) throw o = s, n.arg; n.dispatchException(n.arg); } else "return" === n.method && n.abrupt("return", n.arg); o = f; var p = tryCatch(e, r, n); if ("normal" === p.type) { if (o = n.done ? s : l, p.arg === y) continue; return { value: p.arg, done: n.done }; } "throw" === p.type && (o = s, n.method = "throw", n.arg = p.arg); } }; } function maybeInvokeDelegate(e, r) { var n = r.method, o = e.iterator[n]; if (o === t) return r.delegate = null, "throw" === n && e.iterator["return"] && (r.method = "return", r.arg = t, maybeInvokeDelegate(e, r), "throw" === r.method) || "return" !== n && (r.method = "throw", r.arg = new TypeError("The iterator does not provide a '" + n + "' method")), y; var i = tryCatch(o, e.iterator, r.arg); if ("throw" === i.type) return r.method = "throw", r.arg = i.arg, r.delegate = null, y; var a = i.arg; return a ? a.done ? (r[e.resultName] = a.value, r.next = e.nextLoc, "return" !== r.method && (r.method = "next", r.arg = t), r.delegate = null, y) : a : (r.method = "throw", r.arg = new TypeError("iterator result is not an object"), r.delegate = null, y); } function pushTryEntry(t) { var e = { tryLoc: t[0] }; 1 in t && (e.catchLoc = t[1]), 2 in t && (e.finallyLoc = t[2], e.afterLoc = t[3]), this.tryEntries.push(e); } function resetTryEntry(t) { var e = t.completion || {}; e.type = "normal", delete e.arg, t.completion = e; } function Context(t) { this.tryEntries = [{ tryLoc: "root" }], t.forEach(pushTryEntry, this), this.reset(!0); } function values(e) { if (e || "" === e) { var r = e[a]; if (r) return r.call(e); if ("function" == typeof e.next) return e; if (!isNaN(e.length)) { var o = -1, i = function next() { for (; ++o < e.length;) if (n.call(e, o)) return next.value = e[o], next.done = !1, next; return next.value = t, next.done = !0, next; }; return i.next = i; } } throw new TypeError(_typeof(e) + " is not iterable"); } return GeneratorFunction.prototype = GeneratorFunctionPrototype, o(g, "constructor", { value: GeneratorFunctionPrototype, configurable: !0 }), o(GeneratorFunctionPrototype, "constructor", { value: GeneratorFunction, configurable: !0 }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, u, "GeneratorFunction"), e.isGeneratorFunction = function (t) { var e = "function" == typeof t && t.constructor; return !!e && (e === GeneratorFunction || "GeneratorFunction" === (e.displayName || e.name)); }, e.mark = function (t) { return Object.setPrototypeOf ? Object.setPrototypeOf(t, GeneratorFunctionPrototype) : (t.__proto__ = GeneratorFunctionPrototype, define(t, u, "GeneratorFunction")), t.prototype = Object.create(g), t; }, e.awrap = function (t) { return { __await: t }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, c, function () { return this; }), e.AsyncIterator = AsyncIterator, e.async = function (t, r, n, o, i) { void 0 === i && (i = Promise); var a = new AsyncIterator(wrap(t, r, n, o), i); return e.isGeneratorFunction(r) ? a : a.next().then(function (t) { return t.done ? t.value : a.next(); }); }, defineIteratorMethods(g), define(g, u, "Generator"), define(g, a, function () { return this; }), define(g, "toString", function () { return "[object Generator]"; }), e.keys = function (t) { var e = Object(t), r = []; for (var n in e) r.push(n); return r.reverse(), function next() { for (; r.length;) { var t = r.pop(); if (t in e) return next.value = t, next.done = !1, next; } return next.done = !0, next; }; }, e.values = values, Context.prototype = { constructor: Context, reset: function reset(e) { if (this.prev = 0, this.next = 0, this.sent = this._sent = t, this.done = !1, this.delegate = null, this.method = "next", this.arg = t, this.tryEntries.forEach(resetTryEntry), !e) for (var r in this) "t" === r.charAt(0) && n.call(this, r) && !isNaN(+r.slice(1)) && (this[r] = t); }, stop: function stop() { this.done = !0; var t = this.tryEntries[0].completion; if ("throw" === t.type) throw t.arg; return this.rval; }, dispatchException: function dispatchException(e) { if (this.done) throw e; var r = this; function handle(n, o) { return a.type = "throw", a.arg = e, r.next = n, o && (r.method = "next", r.arg = t), !!o; } for (var o = this.tryEntries.length - 1; o >= 0; --o) { var i = this.tryEntries[o], a = i.completion; if ("root" === i.tryLoc) return handle("end"); if (i.tryLoc <= this.prev) { var c = n.call(i, "catchLoc"), u = n.call(i, "finallyLoc"); if (c && u) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } else if (c) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); } else { if (!u) throw Error("try statement without catch or finally"); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } } } }, abrupt: function abrupt(t, e) { for (var r = this.tryEntries.length - 1; r >= 0; --r) { var o = this.tryEntries[r]; if (o.tryLoc <= this.prev && n.call(o, "finallyLoc") && this.prev < o.finallyLoc) { var i = o; break; } } i && ("break" === t || "continue" === t) && i.tryLoc <= e && e <= i.finallyLoc && (i = null); var a = i ? i.completion : {}; return a.type = t, a.arg = e, i ? (this.method = "next", this.next = i.finallyLoc, y) : this.complete(a); }, complete: function complete(t, e) { if ("throw" === t.type) throw t.arg; return "break" === t.type || "continue" === t.type ? this.next = t.arg : "return" === t.type ? (this.rval = this.arg = t.arg, this.method = "return", this.next = "end") : "normal" === t.type && e && (this.next = e), y; }, finish: function finish(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.finallyLoc === t) return this.complete(r.completion, r.afterLoc), resetTryEntry(r), y; } }, "catch": function _catch(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.tryLoc === t) { var n = r.completion; if ("throw" === n.type) { var o = n.arg; resetTryEntry(r); } return o; } } throw Error("illegal catch attempt"); }, delegateYield: function delegateYield(e, r, n) { return this.delegate = { iterator: values(e), resultName: r, nextLoc: n }, "next" === this.method && (this.arg = t), y; } }, e; }
function asyncGeneratorStep(n, t, e, r, o, a, c) { try { var i = n[a](c), u = i.value; } catch (n) { return void e(n); } i.done ? t(u) : Promise.resolve(u).then(r, o); }
function _asyncToGenerator(n) { return function () { var t = this, e = arguments; return new Promise(function (r, o) { var a = n.apply(t, e); function _next(n) { asyncGeneratorStep(a, r, o, _next, _throw, "next", n); } function _throw(n) { asyncGeneratorStep(a, r, o, _next, _throw, "throw", n); } _next(void 0); }); }; }
function _slicedToArray(r, e) { return _arrayWithHoles(r) || _iterableToArrayLimit(r, e) || _unsupportedIterableToArray(r, e) || _nonIterableRest(); }
function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _iterableToArrayLimit(r, l) { var t = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (null != t) { var e, n, i, u, a = [], f = !0, o = !1; try { if (i = (t = t.call(r)).next, 0 === l) { if (Object(t) !== t) return; f = !1; } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0); } catch (r) { o = !0, n = r; } finally { try { if (!f && null != t["return"] && (u = t["return"](), Object(u) !== u)) return; } finally { if (o) throw n; } } return a; } }
function _arrayWithHoles(r) { if (Array.isArray(r)) return r; }
function _createForOfIteratorHelper(r, e) { var t = "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (!t) { if (Array.isArray(r) || (t = _unsupportedIterableToArray(r)) || e && r && "number" == typeof r.length) { t && (r = t); var _n = 0, F = function F() {}; return { s: F, n: function n() { return _n >= r.length ? { done: !0 } : { done: !1, value: r[_n++] }; }, e: function e(r) { throw r; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var o, a = !0, u = !1; return { s: function s() { t = t.call(r); }, n: function n() { var r = t.next(); return a = r.done, r; }, e: function e(r) { u = !0, o = r; }, f: function f() { try { a || null == t["return"] || t["return"](); } finally { if (u) throw o; } } }; }
function _toConsumableArray(r) { return _arrayWithoutHoles(r) || _iterableToArray(r) || _unsupportedIterableToArray(r) || _nonIterableSpread(); }
function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _unsupportedIterableToArray(r, a) { if (r) { if ("string" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }
function _iterableToArray(r) { if ("undefined" != typeof Symbol && null != r[Symbol.iterator] || null != r["@@iterator"]) return Array.from(r); }
function _arrayWithoutHoles(r) { if (Array.isArray(r)) return _arrayLikeToArray(r); }
function _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }
function _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function"); }
function _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }
function _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: !1 }), e; }
function _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
var __createBinding = void 0 && (void 0).__createBinding || (Object.create ? function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  var desc = Object.getOwnPropertyDescriptor(m, k);
  if (!desc || ('get' in desc ? !m.__esModule : desc.writable || desc.configurable)) {
    desc = {
      enumerable: true,
      get: function get() {
        return m[k];
      }
    };
  }
  Object.defineProperty(o, k2, desc);
} : function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  o[k2] = m[k];
});
var __setModuleDefault = void 0 && (void 0).__setModuleDefault || (Object.create ? function (o, v) {
  Object.defineProperty(o, 'default', {
    enumerable: true,
    value: v
  });
} : function (o, v) {
  o['default'] = v;
});
var __importStar = void 0 && (void 0).__importStar || function (mod) {
  if (mod && mod.__esModule) return mod;
  var result = {};
  if (mod != null) for (var k in mod) if (k !== 'default' && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
  __setModuleDefault(result, mod);
  return result;
};
Object.defineProperty(exports, '__esModule', {
  value: true
});
exports.Psbt = void 0;
var bip174_1 = require('bip174');
var varuint = __importStar(require('varuint-bitcoin'));
var bip174_2 = require('bip174');
var address_js_1 = require('./address.cjs');
var bufferutils_js_1 = require('./bufferutils.cjs');
var networks_js_1 = require('./networks.cjs');
var payments = __importStar(require('./payments/index.cjs'));
var bip341_js_1 = require('./payments/bip341.cjs');
var bscript = __importStar(require('./script.cjs'));
var transaction_js_1 = require('./transaction.cjs');
var bip371_js_1 = require('./psbt/bip371.cjs');
var psbtutils_js_1 = require('./psbt/psbtutils.cjs');
var tools = __importStar(require('uint8array-tools'));
/**
 * These are the default arguments for a Psbt instance.
 */
var DEFAULT_OPTS = {
  /**
   * A bitcoinjs Network object. This is only used if you pass an `address`
   * parameter to addOutput. Otherwise it is not needed and can be left default.
   */
  network: networks_js_1.bitcoin,
  /**
   * When extractTransaction is called, the fee rate is checked.
   * THIS IS NOT TO BE RELIED ON.
   * It is only here as a last ditch effort to prevent sending a 500 BTC fee etc.
   */
  maximumFeeRate: 5000 // satoshi per byte
};
/**
 * Psbt class can parse and generate a PSBT binary based off of the BIP174.
 * There are 6 roles that this class fulfills. (Explained in BIP174)
 *
 * Creator: This can be done with `new Psbt()`
 *
 * Updater: This can be done with `psbt.addInput(input)`, `psbt.addInputs(inputs)`,
 *   `psbt.addOutput(output)`, `psbt.addOutputs(outputs)` when you are looking to
 *   add new inputs and outputs to the PSBT, and `psbt.updateGlobal(itemObject)`,
 *   `psbt.updateInput(itemObject)`, `psbt.updateOutput(itemObject)`
 *   addInput requires hash: Buffer | string; and index: number; as attributes
 *   and can also include any attributes that are used in updateInput method.
 *   addOutput requires script: Buffer; and value: number; and likewise can include
 *   data for updateOutput.
 *   For a list of what attributes should be what types. Check the bip174 library.
 *   Also, check the integration tests for some examples of usage.
 *
 * Signer: There are a few methods. signAllInputs and signAllInputsAsync, which will search all input
 *   information for your pubkey or pubkeyhash, and only sign inputs where it finds
 *   your info. Or you can explicitly sign a specific input with signInput and
 *   signInputAsync. For the async methods you can create a SignerAsync object
 *   and use something like a hardware wallet to sign with. (You must implement this)
 *
 * Combiner: psbts can be combined easily with `psbt.combine(psbt2, psbt3, psbt4 ...)`
 *   the psbt calling combine will always have precedence when a conflict occurs.
 *   Combine checks if the internal bitcoin transaction is the same, so be sure that
 *   all sequences, version, locktime, etc. are the same before combining.
 *
 * Input Finalizer: This role is fairly important. Not only does it need to construct
 *   the input scriptSigs and witnesses, but it SHOULD verify the signatures etc.
 *   Before running `psbt.finalizeAllInputs()` please run `psbt.validateSignaturesOfAllInputs()`
 *   Running any finalize method will delete any data in the input(s) that are no longer
 *   needed due to the finalized scripts containing the information.
 *
 * Transaction Extractor: This role will perform some checks before returning a
 *   Transaction object. Such as fee rate not being larger than maximumFeeRate etc.
 */
var Psbt = /*#__PURE__*/function () {
  function Psbt() {
    var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    var data = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : new bip174_1.Psbt(new PsbtTransaction());
    _classCallCheck(this, Psbt);
    _defineProperty(this, "data", void 0);
    _defineProperty(this, "__CACHE", void 0);
    _defineProperty(this, "opts", void 0);
    this.data = data;
    // set defaults
    this.opts = Object.assign({}, DEFAULT_OPTS, opts);
    this.__CACHE = {
      __NON_WITNESS_UTXO_TX_CACHE: [],
      __NON_WITNESS_UTXO_BUF_CACHE: [],
      __TX_IN_CACHE: {},
      __TX: this.data.globalMap.unsignedTx.tx,
      // Psbt's predecessor (TransactionBuilder - now removed) behavior
      // was to not confirm input values  before signing.
      // Even though we highly encourage people to get
      // the full parent transaction to verify values, the ability to
      // sign non-segwit inputs without the full transaction was often
      // requested. So the only way to activate is to use @ts-ignore.
      // We will disable exporting the Psbt when unsafe sign is active.
      // because it is not BIP174 compliant.
      __UNSAFE_SIGN_NONSEGWIT: false
    };
    if (this.data.inputs.length === 0) this.setVersion(2);
    // Make data hidden when enumerating
    var dpew = function dpew(obj, attr, enumerable, writable) {
      return Object.defineProperty(obj, attr, {
        enumerable: enumerable,
        writable: writable
      });
    };
    dpew(this, '__CACHE', false, true);
    dpew(this, 'opts', false, true);
  }
  return _createClass(Psbt, [{
    key: "inputCount",
    get: function get() {
      return this.data.inputs.length;
    }
  }, {
    key: "version",
    get: function get() {
      return this.__CACHE.__TX.version;
    },
    set: function set(version) {
      this.setVersion(version);
    }
  }, {
    key: "locktime",
    get: function get() {
      return this.__CACHE.__TX.locktime;
    },
    set: function set(locktime) {
      this.setLocktime(locktime);
    }
  }, {
    key: "txInputs",
    get: function get() {
      return this.__CACHE.__TX.ins.map(function (input) {
        return {
          hash: (0, bufferutils_js_1.cloneBuffer)(input.hash),
          index: input.index,
          sequence: input.sequence
        };
      });
    }
  }, {
    key: "txOutputs",
    get: function get() {
      var _this = this;
      return this.__CACHE.__TX.outs.map(function (output) {
        var address;
        try {
          address = (0, address_js_1.fromOutputScript)(output.script, _this.opts.network);
        } catch (_) {}
        return {
          script: (0, bufferutils_js_1.cloneBuffer)(output.script),
          value: output.value,
          address: address
        };
      });
    }
  }, {
    key: "combine",
    value: function combine() {
      var _this$data;
      for (var _len = arguments.length, those = new Array(_len), _key = 0; _key < _len; _key++) {
        those[_key] = arguments[_key];
      }
      (_this$data = this.data).combine.apply(_this$data, _toConsumableArray(those.map(function (o) {
        return o.data;
      })));
      return this;
    }
  }, {
    key: "clone",
    value: function clone() {
      // TODO: more efficient cloning
      var res = Psbt.fromBuffer(this.data.toBuffer());
      res.opts = JSON.parse(JSON.stringify(this.opts));
      return res;
    }
  }, {
    key: "setMaximumFeeRate",
    value: function setMaximumFeeRate(satoshiPerByte) {
      check32Bit(satoshiPerByte); // 42.9 BTC per byte IS excessive... so throw
      this.opts.maximumFeeRate = satoshiPerByte;
    }
  }, {
    key: "setVersion",
    value: function setVersion(version) {
      check32Bit(version);
      checkInputsForPartialSig(this.data.inputs, 'setVersion');
      var c = this.__CACHE;
      c.__TX.version = version;
      c.__EXTRACTED_TX = undefined;
      return this;
    }
  }, {
    key: "setLocktime",
    value: function setLocktime(locktime) {
      check32Bit(locktime);
      checkInputsForPartialSig(this.data.inputs, 'setLocktime');
      var c = this.__CACHE;
      c.__TX.locktime = locktime;
      c.__EXTRACTED_TX = undefined;
      return this;
    }
  }, {
    key: "setInputSequence",
    value: function setInputSequence(inputIndex, sequence) {
      check32Bit(sequence);
      checkInputsForPartialSig(this.data.inputs, 'setInputSequence');
      var c = this.__CACHE;
      if (c.__TX.ins.length <= inputIndex) {
        throw new Error('Input index too high');
      }
      c.__TX.ins[inputIndex].sequence = sequence;
      c.__EXTRACTED_TX = undefined;
      return this;
    }
  }, {
    key: "addInputs",
    value: function addInputs(inputDatas) {
      var _this2 = this;
      inputDatas.forEach(function (inputData) {
        return _this2.addInput(inputData);
      });
      return this;
    }
  }, {
    key: "addInput",
    value: function addInput(inputData) {
      if (arguments.length > 1 || !inputData || inputData.hash === undefined || inputData.index === undefined) {
        throw new Error("Invalid arguments for Psbt.addInput. " + "Requires single object with at least [hash] and [index]");
      }
      (0, bip371_js_1.checkTaprootInputFields)(inputData, inputData, 'addInput');
      checkInputsForPartialSig(this.data.inputs, 'addInput');
      if (inputData.witnessScript) checkInvalidP2WSH(inputData.witnessScript);
      var c = this.__CACHE;
      this.data.addInput(inputData);
      var txIn = c.__TX.ins[c.__TX.ins.length - 1];
      checkTxInputCache(c, txIn);
      var inputIndex = this.data.inputs.length - 1;
      var input = this.data.inputs[inputIndex];
      if (input.nonWitnessUtxo) {
        addNonWitnessTxCache(this.__CACHE, input, inputIndex);
      }
      c.__FEE = undefined;
      c.__FEE_RATE = undefined;
      c.__EXTRACTED_TX = undefined;
      return this;
    }
  }, {
    key: "addOutputs",
    value: function addOutputs(outputDatas) {
      var _this3 = this;
      outputDatas.forEach(function (outputData) {
        return _this3.addOutput(outputData);
      });
      return this;
    }
  }, {
    key: "addOutput",
    value: function addOutput(outputData) {
      if (arguments.length > 1 || !outputData || outputData.value === undefined || outputData.address === undefined && outputData.script === undefined) {
        throw new Error("Invalid arguments for Psbt.addOutput. " + "Requires single object with at least [script or address] and [value]");
      }
      checkInputsForPartialSig(this.data.inputs, 'addOutput');
      var _outputData = outputData,
        address = _outputData.address;
      if (typeof address === 'string') {
        var network = this.opts.network;
        var script = (0, address_js_1.toOutputScript)(address, network);
        outputData = Object.assign({}, outputData, {
          script: script
        });
      }
      (0, bip371_js_1.checkTaprootOutputFields)(outputData, outputData, 'addOutput');
      var c = this.__CACHE;
      this.data.addOutput(outputData);
      c.__FEE = undefined;
      c.__FEE_RATE = undefined;
      c.__EXTRACTED_TX = undefined;
      return this;
    }
  }, {
    key: "extractTransaction",
    value: function extractTransaction(disableFeeCheck) {
      if (!this.data.inputs.every(isFinalized)) throw new Error('Not finalized');
      var c = this.__CACHE;
      if (!disableFeeCheck) {
        checkFees(this, c, this.opts);
      }
      if (c.__EXTRACTED_TX) return c.__EXTRACTED_TX;
      var tx = c.__TX.clone();
      inputFinalizeGetAmts(this.data.inputs, tx, c, true);
      return tx;
    }
  }, {
    key: "getFeeRate",
    value: function getFeeRate() {
      return getTxCacheValue('__FEE_RATE', 'fee rate', this.data.inputs, this.__CACHE);
    }
  }, {
    key: "getFee",
    value: function getFee() {
      return getTxCacheValue('__FEE', 'fee', this.data.inputs, this.__CACHE);
    }
  }, {
    key: "finalizeAllInputs",
    value: function finalizeAllInputs() {
      var _this4 = this;
      (0, bip174_2.checkForInput)(this.data.inputs, 0); // making sure we have at least one
      range(this.data.inputs.length).forEach(function (idx) {
        return _this4.finalizeInput(idx);
      });
      return this;
    }
  }, {
    key: "finalizeInput",
    value: function finalizeInput(inputIndex, finalScriptsFunc) {
      var input = (0, bip174_2.checkForInput)(this.data.inputs, inputIndex);
      if ((0, bip371_js_1.isTaprootInput)(input)) return this._finalizeTaprootInput(inputIndex, input, undefined, finalScriptsFunc);
      return this._finalizeInput(inputIndex, input, finalScriptsFunc);
    }
  }, {
    key: "finalizeTaprootInput",
    value: function finalizeTaprootInput(inputIndex, tapLeafHashToFinalize) {
      var finalScriptsFunc = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : bip371_js_1.tapScriptFinalizer;
      var input = (0, bip174_2.checkForInput)(this.data.inputs, inputIndex);
      if ((0, bip371_js_1.isTaprootInput)(input)) return this._finalizeTaprootInput(inputIndex, input, tapLeafHashToFinalize, finalScriptsFunc);
      throw new Error("Cannot finalize input #".concat(inputIndex, ". Not Taproot."));
    }
  }, {
    key: "_finalizeInput",
    value: function _finalizeInput(inputIndex, input) {
      var finalScriptsFunc = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : getFinalScripts;
      var _getScriptFromInput = getScriptFromInput(inputIndex, input, this.__CACHE),
        script = _getScriptFromInput.script,
        isP2SH = _getScriptFromInput.isP2SH,
        isP2WSH = _getScriptFromInput.isP2WSH,
        isSegwit = _getScriptFromInput.isSegwit;
      if (!script) throw new Error("No script found for input #".concat(inputIndex));
      checkPartialSigSighashes(input);
      var _finalScriptsFunc = finalScriptsFunc(inputIndex, input, script, isSegwit, isP2SH, isP2WSH),
        finalScriptSig = _finalScriptsFunc.finalScriptSig,
        finalScriptWitness = _finalScriptsFunc.finalScriptWitness;
      if (finalScriptSig) this.data.updateInput(inputIndex, {
        finalScriptSig: finalScriptSig
      });
      if (finalScriptWitness) this.data.updateInput(inputIndex, {
        finalScriptWitness: finalScriptWitness
      });
      if (!finalScriptSig && !finalScriptWitness) throw new Error("Unknown error finalizing input #".concat(inputIndex));
      this.data.clearFinalizedInput(inputIndex);
      return this;
    }
  }, {
    key: "_finalizeTaprootInput",
    value: function _finalizeTaprootInput(inputIndex, input, tapLeafHashToFinalize) {
      var finalScriptsFunc = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : bip371_js_1.tapScriptFinalizer;
      if (!input.witnessUtxo) throw new Error("Cannot finalize input #".concat(inputIndex, ". Missing withness utxo."));
      // Check key spend first. Increased privacy and reduced block space.
      if (input.tapKeySig) {
        var payment = payments.p2tr({
          output: input.witnessUtxo.script,
          signature: input.tapKeySig
        });
        var finalScriptWitness = (0, psbtutils_js_1.witnessStackToScriptWitness)(payment.witness);
        this.data.updateInput(inputIndex, {
          finalScriptWitness: finalScriptWitness
        });
      } else {
        var _finalScriptsFunc2 = finalScriptsFunc(inputIndex, input, tapLeafHashToFinalize),
          _finalScriptWitness = _finalScriptsFunc2.finalScriptWitness;
        this.data.updateInput(inputIndex, {
          finalScriptWitness: _finalScriptWitness
        });
      }
      this.data.clearFinalizedInput(inputIndex);
      return this;
    }
  }, {
    key: "getInputType",
    value: function getInputType(inputIndex) {
      var input = (0, bip174_2.checkForInput)(this.data.inputs, inputIndex);
      var script = getScriptFromUtxo(inputIndex, input, this.__CACHE);
      var result = getMeaningfulScript(script, inputIndex, 'input', input.redeemScript || redeemFromFinalScriptSig(input.finalScriptSig), input.witnessScript || redeemFromFinalWitnessScript(input.finalScriptWitness));
      var type = result.type === 'raw' ? '' : result.type + '-';
      var mainType = classifyScript(result.meaningfulScript);
      return type + mainType;
    }
  }, {
    key: "inputHasPubkey",
    value: function inputHasPubkey(inputIndex, pubkey) {
      var input = (0, bip174_2.checkForInput)(this.data.inputs, inputIndex);
      return pubkeyInInput(pubkey, input, inputIndex, this.__CACHE);
    }
  }, {
    key: "inputHasHDKey",
    value: function inputHasHDKey(inputIndex, root) {
      var input = (0, bip174_2.checkForInput)(this.data.inputs, inputIndex);
      var derivationIsMine = bip32DerivationIsMine(root);
      return !!input.bip32Derivation && input.bip32Derivation.some(derivationIsMine);
    }
  }, {
    key: "outputHasPubkey",
    value: function outputHasPubkey(outputIndex, pubkey) {
      var output = (0, bip174_2.checkForOutput)(this.data.outputs, outputIndex);
      return pubkeyInOutput(pubkey, output, outputIndex, this.__CACHE);
    }
  }, {
    key: "outputHasHDKey",
    value: function outputHasHDKey(outputIndex, root) {
      var output = (0, bip174_2.checkForOutput)(this.data.outputs, outputIndex);
      var derivationIsMine = bip32DerivationIsMine(root);
      return !!output.bip32Derivation && output.bip32Derivation.some(derivationIsMine);
    }
  }, {
    key: "validateSignaturesOfAllInputs",
    value: function validateSignaturesOfAllInputs(validator) {
      var _this5 = this;
      (0, bip174_2.checkForInput)(this.data.inputs, 0); // making sure we have at least one
      var results = range(this.data.inputs.length).map(function (idx) {
        return _this5.validateSignaturesOfInput(idx, validator);
      });
      return results.reduce(function (_final, res) {
        return res === true && _final;
      }, true);
    }
  }, {
    key: "validateSignaturesOfInput",
    value: function validateSignaturesOfInput(inputIndex, validator, pubkey) {
      var input = this.data.inputs[inputIndex];
      if ((0, bip371_js_1.isTaprootInput)(input)) return this.validateSignaturesOfTaprootInput(inputIndex, validator, pubkey);
      return this._validateSignaturesOfInput(inputIndex, validator, pubkey);
    }
  }, {
    key: "_validateSignaturesOfInput",
    value: function _validateSignaturesOfInput(inputIndex, validator, pubkey) {
      var input = this.data.inputs[inputIndex];
      var partialSig = (input || {}).partialSig;
      if (!input || !partialSig || partialSig.length < 1) throw new Error('No signatures to validate');
      if (typeof validator !== 'function') throw new Error('Need validator function to validate signatures');
      var mySigs = pubkey ? partialSig.filter(function (sig) {
        return tools.compare(sig.pubkey, pubkey) === 0;
      }) : partialSig;
      if (mySigs.length < 1) throw new Error('No signatures for this pubkey');
      var results = [];
      var hashCache;
      var scriptCache;
      var sighashCache;
      var _iterator = _createForOfIteratorHelper(mySigs),
        _step;
      try {
        for (_iterator.s(); !(_step = _iterator.n()).done;) {
          var pSig = _step.value;
          var sig = bscript.signature.decode(pSig.signature);
          var _ref = sighashCache !== sig.hashType ? getHashForSig(inputIndex, Object.assign({}, input, {
              sighashType: sig.hashType
            }), this.__CACHE, true) : {
              hash: hashCache,
              script: scriptCache
            },
            hash = _ref.hash,
            script = _ref.script;
          sighashCache = sig.hashType;
          hashCache = hash;
          scriptCache = script;
          checkScriptForPubkey(pSig.pubkey, script, 'verify');
          results.push(validator(pSig.pubkey, hash, sig.signature));
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }
      return results.every(function (res) {
        return res === true;
      });
    }
  }, {
    key: "validateSignaturesOfTaprootInput",
    value: function validateSignaturesOfTaprootInput(inputIndex, validator, pubkey) {
      var input = this.data.inputs[inputIndex];
      var tapKeySig = (input || {}).tapKeySig;
      var tapScriptSig = (input || {}).tapScriptSig;
      if (!input && !tapKeySig && !(tapScriptSig && !tapScriptSig.length)) throw new Error('No signatures to validate');
      if (typeof validator !== 'function') throw new Error('Need validator function to validate signatures');
      pubkey = pubkey && (0, bip371_js_1.toXOnly)(pubkey);
      var allHashses = pubkey ? getTaprootHashesForSig(inputIndex, input, this.data.inputs, pubkey, this.__CACHE) : getAllTaprootHashesForSig(inputIndex, input, this.data.inputs, this.__CACHE);
      if (!allHashses.length) throw new Error('No signatures for this pubkey');
      var tapKeyHash = allHashses.find(function (h) {
        return !h.leafHash;
      });
      var validationResultCount = 0;
      if (tapKeySig && tapKeyHash) {
        var isValidTapkeySig = validator(tapKeyHash.pubkey, tapKeyHash.hash, trimTaprootSig(tapKeySig));
        if (!isValidTapkeySig) return false;
        validationResultCount++;
      }
      if (tapScriptSig) {
        var _iterator2 = _createForOfIteratorHelper(tapScriptSig),
          _step2;
        try {
          var _loop = function _loop() {
              var tapSig = _step2.value;
              var tapSigHash = allHashses.find(function (h) {
                return tools.compare(h.pubkey, tapSig.pubkey) === 0;
              });
              if (tapSigHash) {
                var isValidTapScriptSig = validator(tapSig.pubkey, tapSigHash.hash, trimTaprootSig(tapSig.signature));
                if (!isValidTapScriptSig) return {
                  v: false
                };
                validationResultCount++;
              }
            },
            _ret;
          for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
            _ret = _loop();
            if (_ret) return _ret.v;
          }
        } catch (err) {
          _iterator2.e(err);
        } finally {
          _iterator2.f();
        }
      }
      return validationResultCount > 0;
    }
  }, {
    key: "signAllInputsHD",
    value: function signAllInputsHD(hdKeyPair) {
      var sighashTypes = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [transaction_js_1.Transaction.SIGHASH_ALL];
      if (!hdKeyPair || !hdKeyPair.publicKey || !hdKeyPair.fingerprint) {
        throw new Error('Need HDSigner to sign input');
      }
      var results = [];
      var _iterator3 = _createForOfIteratorHelper(range(this.data.inputs.length)),
        _step3;
      try {
        for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
          var i = _step3.value;
          try {
            this.signInputHD(i, hdKeyPair, sighashTypes);
            results.push(true);
          } catch (err) {
            results.push(false);
          }
        }
      } catch (err) {
        _iterator3.e(err);
      } finally {
        _iterator3.f();
      }
      if (results.every(function (v) {
        return v === false;
      })) {
        throw new Error('No inputs were signed');
      }
      return this;
    }
  }, {
    key: "signAllInputsHDAsync",
    value: function signAllInputsHDAsync(hdKeyPair) {
      var _this6 = this;
      var sighashTypes = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [transaction_js_1.Transaction.SIGHASH_ALL];
      return new Promise(function (resolve, reject) {
        if (!hdKeyPair || !hdKeyPair.publicKey || !hdKeyPair.fingerprint) {
          return reject(new Error('Need HDSigner to sign input'));
        }
        var results = [];
        var promises = [];
        var _iterator4 = _createForOfIteratorHelper(range(_this6.data.inputs.length)),
          _step4;
        try {
          for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {
            var i = _step4.value;
            promises.push(_this6.signInputHDAsync(i, hdKeyPair, sighashTypes).then(function () {
              results.push(true);
            }, function () {
              results.push(false);
            }));
          }
        } catch (err) {
          _iterator4.e(err);
        } finally {
          _iterator4.f();
        }
        return Promise.all(promises).then(function () {
          if (results.every(function (v) {
            return v === false;
          })) {
            return reject(new Error('No inputs were signed'));
          }
          resolve();
        });
      });
    }
  }, {
    key: "signInputHD",
    value: function signInputHD(inputIndex, hdKeyPair) {
      var _this7 = this;
      var sighashTypes = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [transaction_js_1.Transaction.SIGHASH_ALL];
      if (!hdKeyPair || !hdKeyPair.publicKey || !hdKeyPair.fingerprint) {
        throw new Error('Need HDSigner to sign input');
      }
      var signers = getSignersFromHD(inputIndex, this.data.inputs, hdKeyPair);
      signers.forEach(function (signer) {
        return _this7.signInput(inputIndex, signer, sighashTypes);
      });
      return this;
    }
  }, {
    key: "signInputHDAsync",
    value: function signInputHDAsync(inputIndex, hdKeyPair) {
      var _this8 = this;
      var sighashTypes = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [transaction_js_1.Transaction.SIGHASH_ALL];
      return new Promise(function (resolve, reject) {
        if (!hdKeyPair || !hdKeyPair.publicKey || !hdKeyPair.fingerprint) {
          return reject(new Error('Need HDSigner to sign input'));
        }
        var signers = getSignersFromHD(inputIndex, _this8.data.inputs, hdKeyPair);
        var promises = signers.map(function (signer) {
          return _this8.signInputAsync(inputIndex, signer, sighashTypes);
        });
        return Promise.all(promises).then(function () {
          resolve();
        })["catch"](reject);
      });
    }
  }, {
    key: "signAllInputs",
    value: function signAllInputs(keyPair, sighashTypes) {
      if (!keyPair || !keyPair.publicKey) throw new Error('Need Signer to sign input');
      // TODO: Add a pubkey/pubkeyhash cache to each input
      // as input information is added, then eventually
      // optimize this method.
      var results = [];
      var _iterator5 = _createForOfIteratorHelper(range(this.data.inputs.length)),
        _step5;
      try {
        for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {
          var i = _step5.value;
          try {
            this.signInput(i, keyPair, sighashTypes);
            results.push(true);
          } catch (err) {
            results.push(false);
          }
        }
      } catch (err) {
        _iterator5.e(err);
      } finally {
        _iterator5.f();
      }
      if (results.every(function (v) {
        return v === false;
      })) {
        throw new Error('No inputs were signed');
      }
      return this;
    }
  }, {
    key: "signAllInputsAsync",
    value: function signAllInputsAsync(keyPair, sighashTypes) {
      var _this9 = this;
      return new Promise(function (resolve, reject) {
        if (!keyPair || !keyPair.publicKey) return reject(new Error('Need Signer to sign input'));
        // TODO: Add a pubkey/pubkeyhash cache to each input
        // as input information is added, then eventually
        // optimize this method.
        var results = [];
        var promises = [];
        var _iterator6 = _createForOfIteratorHelper(_this9.data.inputs.entries()),
          _step6;
        try {
          for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {
            var _step6$value = _slicedToArray(_step6.value, 1),
              i = _step6$value[0];
            promises.push(_this9.signInputAsync(i, keyPair, sighashTypes).then(function () {
              results.push(true);
            }, function () {
              results.push(false);
            }));
          }
        } catch (err) {
          _iterator6.e(err);
        } finally {
          _iterator6.f();
        }
        return Promise.all(promises).then(function () {
          if (results.every(function (v) {
            return v === false;
          })) {
            return reject(new Error('No inputs were signed'));
          }
          resolve();
        });
      });
    }
  }, {
    key: "signInput",
    value: function signInput(inputIndex, keyPair, sighashTypes) {
      if (!keyPair || !keyPair.publicKey) throw new Error('Need Signer to sign input');
      var input = (0, bip174_2.checkForInput)(this.data.inputs, inputIndex);
      if ((0, bip371_js_1.isTaprootInput)(input)) {
        return this._signTaprootInput(inputIndex, input, keyPair, undefined, sighashTypes);
      }
      return this._signInput(inputIndex, keyPair, sighashTypes);
    }
  }, {
    key: "signTaprootInput",
    value: function signTaprootInput(inputIndex, keyPair, tapLeafHashToSign, sighashTypes) {
      if (!keyPair || !keyPair.publicKey) throw new Error('Need Signer to sign input');
      var input = (0, bip174_2.checkForInput)(this.data.inputs, inputIndex);
      if ((0, bip371_js_1.isTaprootInput)(input)) return this._signTaprootInput(inputIndex, input, keyPair, tapLeafHashToSign, sighashTypes);
      throw new Error("Input #".concat(inputIndex, " is not of type Taproot."));
    }
  }, {
    key: "_signInput",
    value: function _signInput(inputIndex, keyPair) {
      var sighashTypes = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [transaction_js_1.Transaction.SIGHASH_ALL];
      var _getHashAndSighashTyp = getHashAndSighashType(this.data.inputs, inputIndex, keyPair.publicKey, this.__CACHE, sighashTypes),
        hash = _getHashAndSighashTyp.hash,
        sighashType = _getHashAndSighashTyp.sighashType;
      var partialSig = [{
        pubkey: keyPair.publicKey,
        signature: bscript.signature.encode(keyPair.sign(hash), sighashType)
      }];
      this.data.updateInput(inputIndex, {
        partialSig: partialSig
      });
      return this;
    }
  }, {
    key: "_signTaprootInput",
    value: function _signTaprootInput(inputIndex, input, keyPair, tapLeafHashToSign) {
      var allowedSighashTypes = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : [transaction_js_1.Transaction.SIGHASH_DEFAULT];
      var hashesForSig = this.checkTaprootHashesForSig(inputIndex, input, keyPair, tapLeafHashToSign, allowedSighashTypes);
      var tapKeySig = hashesForSig.filter(function (h) {
        return !h.leafHash;
      }).map(function (h) {
        return (0, bip371_js_1.serializeTaprootSignature)(keyPair.signSchnorr(h.hash), input.sighashType);
      })[0];
      var tapScriptSig = hashesForSig.filter(function (h) {
        return !!h.leafHash;
      }).map(function (h) {
        return {
          pubkey: (0, bip371_js_1.toXOnly)(keyPair.publicKey),
          signature: (0, bip371_js_1.serializeTaprootSignature)(keyPair.signSchnorr(h.hash), input.sighashType),
          leafHash: h.leafHash
        };
      });
      if (tapKeySig) {
        this.data.updateInput(inputIndex, {
          tapKeySig: tapKeySig
        });
      }
      if (tapScriptSig.length) {
        this.data.updateInput(inputIndex, {
          tapScriptSig: tapScriptSig
        });
      }
      return this;
    }
  }, {
    key: "signInputAsync",
    value: function signInputAsync(inputIndex, keyPair, sighashTypes) {
      var _this10 = this;
      return Promise.resolve().then(function () {
        if (!keyPair || !keyPair.publicKey) throw new Error('Need Signer to sign input');
        var input = (0, bip174_2.checkForInput)(_this10.data.inputs, inputIndex);
        if ((0, bip371_js_1.isTaprootInput)(input)) return _this10._signTaprootInputAsync(inputIndex, input, keyPair, undefined, sighashTypes);
        return _this10._signInputAsync(inputIndex, keyPair, sighashTypes);
      });
    }
  }, {
    key: "signTaprootInputAsync",
    value: function signTaprootInputAsync(inputIndex, keyPair, tapLeafHash, sighashTypes) {
      var _this11 = this;
      return Promise.resolve().then(function () {
        if (!keyPair || !keyPair.publicKey) throw new Error('Need Signer to sign input');
        var input = (0, bip174_2.checkForInput)(_this11.data.inputs, inputIndex);
        if ((0, bip371_js_1.isTaprootInput)(input)) return _this11._signTaprootInputAsync(inputIndex, input, keyPair, tapLeafHash, sighashTypes);
        throw new Error("Input #".concat(inputIndex, " is not of type Taproot."));
      });
    }
  }, {
    key: "_signInputAsync",
    value: function _signInputAsync(inputIndex, keyPair) {
      var _this12 = this;
      var sighashTypes = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [transaction_js_1.Transaction.SIGHASH_ALL];
      var _getHashAndSighashTyp2 = getHashAndSighashType(this.data.inputs, inputIndex, keyPair.publicKey, this.__CACHE, sighashTypes),
        hash = _getHashAndSighashTyp2.hash,
        sighashType = _getHashAndSighashTyp2.sighashType;
      return Promise.resolve(keyPair.sign(hash)).then(function (signature) {
        var partialSig = [{
          pubkey: keyPair.publicKey,
          signature: bscript.signature.encode(signature, sighashType)
        }];
        _this12.data.updateInput(inputIndex, {
          partialSig: partialSig
        });
      });
    }
  }, {
    key: "_signTaprootInputAsync",
    value: function () {
      var _signTaprootInputAsync2 = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee(inputIndex, input, keyPair, tapLeafHash) {
        var _this13 = this;
        var sighashTypes,
          hashesForSig,
          signaturePromises,
          tapKeyHash,
          tapKeySigPromise,
          tapScriptHashes,
          tapScriptSigPromises,
          _args = arguments;
        return _regeneratorRuntime().wrap(function _callee$(_context) {
          while (1) switch (_context.prev = _context.next) {
            case 0:
              sighashTypes = _args.length > 4 && _args[4] !== undefined ? _args[4] : [transaction_js_1.Transaction.SIGHASH_DEFAULT];
              hashesForSig = this.checkTaprootHashesForSig(inputIndex, input, keyPair, tapLeafHash, sighashTypes);
              signaturePromises = [];
              tapKeyHash = hashesForSig.filter(function (h) {
                return !h.leafHash;
              })[0];
              if (tapKeyHash) {
                tapKeySigPromise = Promise.resolve(keyPair.signSchnorr(tapKeyHash.hash)).then(function (sig) {
                  return {
                    tapKeySig: (0, bip371_js_1.serializeTaprootSignature)(sig, input.sighashType)
                  };
                });
                signaturePromises.push(tapKeySigPromise);
              }
              tapScriptHashes = hashesForSig.filter(function (h) {
                return !!h.leafHash;
              });
              if (tapScriptHashes.length) {
                tapScriptSigPromises = tapScriptHashes.map(function (tsh) {
                  return Promise.resolve(keyPair.signSchnorr(tsh.hash)).then(function (signature) {
                    var tapScriptSig = [{
                      pubkey: (0, bip371_js_1.toXOnly)(keyPair.publicKey),
                      signature: (0, bip371_js_1.serializeTaprootSignature)(signature, input.sighashType),
                      leafHash: tsh.leafHash
                    }];
                    return {
                      tapScriptSig: tapScriptSig
                    };
                  });
                });
                signaturePromises.push.apply(signaturePromises, _toConsumableArray(tapScriptSigPromises));
              }
              return _context.abrupt("return", Promise.all(signaturePromises).then(function (results) {
                results.forEach(function (v) {
                  return _this13.data.updateInput(inputIndex, v);
                });
              }));
            case 8:
            case "end":
              return _context.stop();
          }
        }, _callee, this);
      }));
      function _signTaprootInputAsync(_x, _x2, _x3, _x4) {
        return _signTaprootInputAsync2.apply(this, arguments);
      }
      return _signTaprootInputAsync;
    }()
  }, {
    key: "checkTaprootHashesForSig",
    value: function checkTaprootHashesForSig(inputIndex, input, keyPair, tapLeafHashToSign, allowedSighashTypes) {
      if (typeof keyPair.signSchnorr !== 'function') throw new Error("Need Schnorr Signer to sign taproot input #".concat(inputIndex, "."));
      var hashesForSig = getTaprootHashesForSig(inputIndex, input, this.data.inputs, keyPair.publicKey, this.__CACHE, tapLeafHashToSign, allowedSighashTypes);
      if (!hashesForSig || !hashesForSig.length) throw new Error("Can not sign for input #".concat(inputIndex, " with the key ").concat(tools.toHex(keyPair.publicKey)));
      return hashesForSig;
    }
  }, {
    key: "toBuffer",
    value: function toBuffer() {
      checkCache(this.__CACHE);
      return this.data.toBuffer();
    }
  }, {
    key: "toHex",
    value: function toHex() {
      checkCache(this.__CACHE);
      return this.data.toHex();
    }
  }, {
    key: "toBase64",
    value: function toBase64() {
      checkCache(this.__CACHE);
      return this.data.toBase64();
    }
  }, {
    key: "updateGlobal",
    value: function updateGlobal(updateData) {
      this.data.updateGlobal(updateData);
      return this;
    }
  }, {
    key: "updateInput",
    value: function updateInput(inputIndex, updateData) {
      if (updateData.witnessScript) checkInvalidP2WSH(updateData.witnessScript);
      (0, bip371_js_1.checkTaprootInputFields)(this.data.inputs[inputIndex], updateData, 'updateInput');
      this.data.updateInput(inputIndex, updateData);
      if (updateData.nonWitnessUtxo) {
        addNonWitnessTxCache(this.__CACHE, this.data.inputs[inputIndex], inputIndex);
      }
      return this;
    }
  }, {
    key: "updateOutput",
    value: function updateOutput(outputIndex, updateData) {
      var outputData = this.data.outputs[outputIndex];
      (0, bip371_js_1.checkTaprootOutputFields)(outputData, updateData, 'updateOutput');
      this.data.updateOutput(outputIndex, updateData);
      return this;
    }
  }, {
    key: "addUnknownKeyValToGlobal",
    value: function addUnknownKeyValToGlobal(keyVal) {
      this.data.addUnknownKeyValToGlobal(keyVal);
      return this;
    }
  }, {
    key: "addUnknownKeyValToInput",
    value: function addUnknownKeyValToInput(inputIndex, keyVal) {
      this.data.addUnknownKeyValToInput(inputIndex, keyVal);
      return this;
    }
  }, {
    key: "addUnknownKeyValToOutput",
    value: function addUnknownKeyValToOutput(outputIndex, keyVal) {
      this.data.addUnknownKeyValToOutput(outputIndex, keyVal);
      return this;
    }
  }, {
    key: "clearFinalizedInput",
    value: function clearFinalizedInput(inputIndex) {
      this.data.clearFinalizedInput(inputIndex);
      return this;
    }
  }], [{
    key: "fromBase64",
    value: function fromBase64(data) {
      var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      var buffer = tools.fromBase64(data);
      return this.fromBuffer(buffer, opts);
    }
  }, {
    key: "fromHex",
    value: function fromHex(data) {
      var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      var buffer = tools.fromHex(data);
      return this.fromBuffer(buffer, opts);
    }
  }, {
    key: "fromBuffer",
    value: function fromBuffer(buffer) {
      var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      var psbtBase = bip174_1.Psbt.fromBuffer(buffer, transactionFromBuffer);
      var psbt = new Psbt(opts, psbtBase);
      checkTxForDupeIns(psbt.__CACHE.__TX, psbt.__CACHE);
      return psbt;
    }
  }]);
}();
exports.Psbt = Psbt;
/**
 * This function is needed to pass to the bip174 base class's fromBuffer.
 * It takes the "transaction buffer" portion of the psbt buffer and returns a
 * Transaction (From the bip174 library) interface.
 */
var transactionFromBuffer = function transactionFromBuffer(buffer) {
  return new PsbtTransaction(buffer);
};
/**
 * This class implements the Transaction interface from bip174 library.
 * It contains a bitcoinjs-lib Transaction object.
 */
var PsbtTransaction = /*#__PURE__*/function () {
  function PsbtTransaction() {
    var buffer = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : Uint8Array.from([2, 0, 0, 0, 0, 0, 0, 0, 0, 0]);
    _classCallCheck(this, PsbtTransaction);
    _defineProperty(this, "tx", void 0);
    this.tx = transaction_js_1.Transaction.fromBuffer(buffer);
    checkTxEmpty(this.tx);
    Object.defineProperty(this, 'tx', {
      enumerable: false,
      writable: true
    });
  }
  return _createClass(PsbtTransaction, [{
    key: "getInputOutputCounts",
    value: function getInputOutputCounts() {
      return {
        inputCount: this.tx.ins.length,
        outputCount: this.tx.outs.length
      };
    }
  }, {
    key: "addInput",
    value: function addInput(input) {
      if (input.hash === undefined || input.index === undefined || !(input.hash instanceof Uint8Array) && typeof input.hash !== 'string' || typeof input.index !== 'number') {
        throw new Error('Error adding input.');
      }
      var hash = typeof input.hash === 'string' ? (0, bufferutils_js_1.reverseBuffer)(tools.fromHex(input.hash)) : input.hash;
      this.tx.addInput(hash, input.index, input.sequence);
    }
  }, {
    key: "addOutput",
    value: function addOutput(output) {
      if (output.script === undefined || output.value === undefined || !(output.script instanceof Uint8Array) || typeof output.value !== 'bigint') {
        throw new Error('Error adding output.');
      }
      this.tx.addOutput(output.script, output.value);
    }
  }, {
    key: "toBuffer",
    value: function toBuffer() {
      return this.tx.toBuffer();
    }
  }]);
}();
function canFinalize(input, script, scriptType) {
  switch (scriptType) {
    case 'pubkey':
    case 'pubkeyhash':
    case 'witnesspubkeyhash':
      return hasSigs(1, input.partialSig);
    case 'multisig':
      var p2ms = payments.p2ms({
        output: script
      });
      return hasSigs(p2ms.m, input.partialSig, p2ms.pubkeys);
    default:
      return false;
  }
}
function checkCache(cache) {
  if (cache.__UNSAFE_SIGN_NONSEGWIT !== false) {
    throw new Error('Not BIP174 compliant, can not export');
  }
}
function hasSigs(neededSigs, partialSig, pubkeys) {
  if (!partialSig) return false;
  var sigs;
  if (pubkeys) {
    sigs = pubkeys.map(function (pkey) {
      var pubkey = compressPubkey(pkey);
      return partialSig.find(function (pSig) {
        return tools.compare(pSig.pubkey, pubkey) === 0;
      });
    }).filter(function (v) {
      return !!v;
    });
  } else {
    sigs = partialSig;
  }
  if (sigs.length > neededSigs) throw new Error('Too many signatures');
  return sigs.length === neededSigs;
}
function isFinalized(input) {
  return !!input.finalScriptSig || !!input.finalScriptWitness;
}
function bip32DerivationIsMine(root) {
  return function (d) {
    if (tools.compare(root.fingerprint, d.masterFingerprint)) return false;
    if (tools.compare(root.derivePath(d.path).publicKey, d.pubkey)) return false;
    return true;
  };
}
function check32Bit(num) {
  if (typeof num !== 'number' || num !== Math.floor(num) || num > 0xffffffff || num < 0) {
    throw new Error('Invalid 32 bit integer');
  }
}
function checkFees(psbt, cache, opts) {
  var feeRate = cache.__FEE_RATE || psbt.getFeeRate();
  var vsize = cache.__EXTRACTED_TX.virtualSize();
  var satoshis = feeRate * vsize;
  if (feeRate >= opts.maximumFeeRate) {
    throw new Error("Warning: You are paying around ".concat((satoshis / 1e8).toFixed(8), " in ") + "fees, which is ".concat(feeRate, " satoshi per byte for a transaction ") + "with a VSize of ".concat(vsize, " bytes (segwit counted as 0.25 byte per ") + "byte). Use setMaximumFeeRate method to raise your threshold, or " + "pass true to the first arg of extractTransaction.");
  }
}
function checkInputsForPartialSig(inputs, action) {
  inputs.forEach(function (input) {
    var _throws = (0, bip371_js_1.isTaprootInput)(input) ? (0, bip371_js_1.checkTaprootInputForSigs)(input, action) : (0, psbtutils_js_1.checkInputForSig)(input, action);
    if (_throws) throw new Error('Can not modify transaction, signatures exist.');
  });
}
function checkPartialSigSighashes(input) {
  if (!input.sighashType || !input.partialSig) return;
  var partialSig = input.partialSig,
    sighashType = input.sighashType;
  partialSig.forEach(function (pSig) {
    var _bscript$signature$de = bscript.signature.decode(pSig.signature),
      hashType = _bscript$signature$de.hashType;
    if (sighashType !== hashType) {
      throw new Error('Signature sighash does not match input sighash type');
    }
  });
}
function checkScriptForPubkey(pubkey, script, action) {
  if (!(0, psbtutils_js_1.pubkeyInScript)(pubkey, script)) {
    throw new Error("Can not ".concat(action, " for this input with the key ").concat(tools.toHex(pubkey)));
  }
}
function checkTxEmpty(tx) {
  var isEmpty = tx.ins.every(function (input) {
    return input.script && input.script.length === 0 && input.witness && input.witness.length === 0;
  });
  if (!isEmpty) {
    throw new Error('Format Error: Transaction ScriptSigs are not empty');
  }
}
function checkTxForDupeIns(tx, cache) {
  tx.ins.forEach(function (input) {
    checkTxInputCache(cache, input);
  });
}
function checkTxInputCache(cache, input) {
  var key = tools.toHex((0, bufferutils_js_1.reverseBuffer)(Uint8Array.from(input.hash))) + ':' + input.index;
  if (cache.__TX_IN_CACHE[key]) throw new Error('Duplicate input detected.');
  cache.__TX_IN_CACHE[key] = 1;
}
function scriptCheckerFactory(payment, paymentScriptName) {
  return function (inputIndex, scriptPubKey, redeemScript, ioType) {
    var redeemScriptOutput = payment({
      redeem: {
        output: redeemScript
      }
    }).output;
    if (tools.compare(scriptPubKey, redeemScriptOutput)) {
      throw new Error("".concat(paymentScriptName, " for ").concat(ioType, " #").concat(inputIndex, " doesn't match the scriptPubKey in the prevout"));
    }
  };
}
var checkRedeemScript = scriptCheckerFactory(payments.p2sh, 'Redeem script');
var checkWitnessScript = scriptCheckerFactory(payments.p2wsh, 'Witness script');
function getTxCacheValue(key, name, inputs, c) {
  if (!inputs.every(isFinalized)) throw new Error("PSBT must be finalized to calculate ".concat(name));
  if (key === '__FEE_RATE' && c.__FEE_RATE) return c.__FEE_RATE;
  if (key === '__FEE' && c.__FEE) return c.__FEE;
  var tx;
  var mustFinalize = true;
  if (c.__EXTRACTED_TX) {
    tx = c.__EXTRACTED_TX;
    mustFinalize = false;
  } else {
    tx = c.__TX.clone();
  }
  inputFinalizeGetAmts(inputs, tx, c, mustFinalize);
  if (key === '__FEE_RATE') return c.__FEE_RATE;else if (key === '__FEE') return c.__FEE;
}
function getFinalScripts(inputIndex, input, script, isSegwit, isP2SH, isP2WSH) {
  var scriptType = classifyScript(script);
  if (!canFinalize(input, script, scriptType)) throw new Error("Can not finalize input #".concat(inputIndex));
  return prepareFinalScripts(script, scriptType, input.partialSig, isSegwit, isP2SH, isP2WSH);
}
function prepareFinalScripts(script, scriptType, partialSig, isSegwit, isP2SH, isP2WSH) {
  var finalScriptSig;
  var finalScriptWitness;
  // Wow, the payments API is very handy
  var payment = getPayment(script, scriptType, partialSig);
  var p2wsh = !isP2WSH ? null : payments.p2wsh({
    redeem: payment
  });
  var p2sh = !isP2SH ? null : payments.p2sh({
    redeem: p2wsh || payment
  });
  if (isSegwit) {
    if (p2wsh) {
      finalScriptWitness = (0, psbtutils_js_1.witnessStackToScriptWitness)(p2wsh.witness);
    } else {
      finalScriptWitness = (0, psbtutils_js_1.witnessStackToScriptWitness)(payment.witness);
    }
    if (p2sh) {
      finalScriptSig = p2sh.input;
    }
  } else {
    if (p2sh) {
      finalScriptSig = p2sh.input;
    } else {
      finalScriptSig = payment.input;
    }
  }
  return {
    finalScriptSig: finalScriptSig,
    finalScriptWitness: finalScriptWitness
  };
}
function getHashAndSighashType(inputs, inputIndex, pubkey, cache, sighashTypes) {
  var input = (0, bip174_2.checkForInput)(inputs, inputIndex);
  var _getHashForSig = getHashForSig(inputIndex, input, cache, false, sighashTypes),
    hash = _getHashForSig.hash,
    sighashType = _getHashForSig.sighashType,
    script = _getHashForSig.script;
  checkScriptForPubkey(pubkey, script, 'sign');
  return {
    hash: hash,
    sighashType: sighashType
  };
}
function getHashForSig(inputIndex, input, cache, forValidate, sighashTypes) {
  var unsignedTx = cache.__TX;
  var sighashType = input.sighashType || transaction_js_1.Transaction.SIGHASH_ALL;
  checkSighashTypeAllowed(sighashType, sighashTypes);
  var hash;
  var prevout;
  if (input.nonWitnessUtxo) {
    var nonWitnessUtxoTx = nonWitnessUtxoTxFromCache(cache, input, inputIndex);
    var prevoutHash = unsignedTx.ins[inputIndex].hash;
    var utxoHash = nonWitnessUtxoTx.getHash();
    // If a non-witness UTXO is provided, its hash must match the hash specified in the prevout
    if (tools.compare(prevoutHash, utxoHash) !== 0) {
      throw new Error("Non-witness UTXO hash for input #".concat(inputIndex, " doesn't match the hash specified in the prevout"));
    }
    var prevoutIndex = unsignedTx.ins[inputIndex].index;
    prevout = nonWitnessUtxoTx.outs[prevoutIndex];
  } else if (input.witnessUtxo) {
    prevout = input.witnessUtxo;
  } else {
    throw new Error('Need a Utxo input item for signing');
  }
  var _getMeaningfulScript = getMeaningfulScript(prevout.script, inputIndex, 'input', input.redeemScript, input.witnessScript),
    meaningfulScript = _getMeaningfulScript.meaningfulScript,
    type = _getMeaningfulScript.type;
  if (['p2sh-p2wsh', 'p2wsh'].indexOf(type) >= 0) {
    hash = unsignedTx.hashForWitnessV0(inputIndex, meaningfulScript, prevout.value, sighashType);
  } else if ((0, psbtutils_js_1.isP2WPKH)(meaningfulScript)) {
    // P2WPKH uses the P2PKH template for prevoutScript when signing
    var signingScript = payments.p2pkh({
      hash: meaningfulScript.slice(2)
    }).output;
    hash = unsignedTx.hashForWitnessV0(inputIndex, signingScript, prevout.value, sighashType);
  } else {
    // non-segwit
    if (input.nonWitnessUtxo === undefined && cache.__UNSAFE_SIGN_NONSEGWIT === false) throw new Error("Input #".concat(inputIndex, " has witnessUtxo but non-segwit script: ") + "".concat(tools.toHex(meaningfulScript)));
    if (!forValidate && cache.__UNSAFE_SIGN_NONSEGWIT !== false) console.warn('Warning: Signing non-segwit inputs without the full parent transaction ' + 'means there is a chance that a miner could feed you incorrect information ' + "to trick you into paying large fees. This behavior is the same as Psbt's predecessor " + '(TransactionBuilder - now removed) when signing non-segwit scripts. You are not ' + 'able to export this Psbt with toBuffer|toBase64|toHex since it is not ' + 'BIP174 compliant.\n*********************\nPROCEED WITH CAUTION!\n' + '*********************');
    hash = unsignedTx.hashForSignature(inputIndex, meaningfulScript, sighashType);
  }
  return {
    script: meaningfulScript,
    sighashType: sighashType,
    hash: hash
  };
}
function getAllTaprootHashesForSig(inputIndex, input, inputs, cache) {
  var allPublicKeys = [];
  if (input.tapInternalKey) {
    var key = getPrevoutTaprootKey(inputIndex, input, cache);
    if (key) {
      allPublicKeys.push(key);
    }
  }
  if (input.tapScriptSig) {
    var tapScriptPubkeys = input.tapScriptSig.map(function (tss) {
      return tss.pubkey;
    });
    allPublicKeys.push.apply(allPublicKeys, _toConsumableArray(tapScriptPubkeys));
  }
  var allHashes = allPublicKeys.map(function (publicKey) {
    return getTaprootHashesForSig(inputIndex, input, inputs, publicKey, cache);
  });
  return allHashes.flat();
}
function getPrevoutTaprootKey(inputIndex, input, cache) {
  var _getScriptAndAmountFr = getScriptAndAmountFromUtxo(inputIndex, input, cache),
    script = _getScriptAndAmountFr.script;
  return (0, psbtutils_js_1.isP2TR)(script) ? script.subarray(2, 34) : null;
}
function trimTaprootSig(signature) {
  return signature.length === 64 ? signature : signature.subarray(0, 64);
}
function getTaprootHashesForSig(inputIndex, input, inputs, pubkey, cache, tapLeafHashToSign, allowedSighashTypes) {
  var unsignedTx = cache.__TX;
  var sighashType = input.sighashType || transaction_js_1.Transaction.SIGHASH_DEFAULT;
  checkSighashTypeAllowed(sighashType, allowedSighashTypes);
  var prevOuts = inputs.map(function (i, index) {
    return getScriptAndAmountFromUtxo(index, i, cache);
  });
  var signingScripts = prevOuts.map(function (o) {
    return o.script;
  });
  var values = prevOuts.map(function (o) {
    return o.value;
  });
  var hashes = [];
  if (input.tapInternalKey && !tapLeafHashToSign) {
    var outputKey = getPrevoutTaprootKey(inputIndex, input, cache) || Uint8Array.from([]);
    if (tools.compare((0, bip371_js_1.toXOnly)(pubkey), outputKey) === 0) {
      var tapKeyHash = unsignedTx.hashForWitnessV1(inputIndex, signingScripts, values, sighashType);
      hashes.push({
        pubkey: pubkey,
        hash: tapKeyHash
      });
    }
  }
  var tapLeafHashes = (input.tapLeafScript || []).filter(function (tapLeaf) {
    return (0, psbtutils_js_1.pubkeyInScript)(pubkey, tapLeaf.script);
  }).map(function (tapLeaf) {
    var hash = (0, bip341_js_1.tapleafHash)({
      output: tapLeaf.script,
      version: tapLeaf.leafVersion
    });
    return Object.assign({
      hash: hash
    }, tapLeaf);
  }).filter(function (tapLeaf) {
    return !tapLeafHashToSign || tools.compare(tapLeafHashToSign, tapLeaf.hash) === 0;
  }).map(function (tapLeaf) {
    var tapScriptHash = unsignedTx.hashForWitnessV1(inputIndex, signingScripts, values, sighashType, tapLeaf.hash);
    return {
      pubkey: pubkey,
      hash: tapScriptHash,
      leafHash: tapLeaf.hash
    };
  });
  return hashes.concat(tapLeafHashes);
}
function checkSighashTypeAllowed(sighashType, sighashTypes) {
  if (sighashTypes && sighashTypes.indexOf(sighashType) < 0) {
    var str = sighashTypeToString(sighashType);
    throw new Error("Sighash type is not allowed. Retry the sign method passing the " + "sighashTypes array of whitelisted types. Sighash type: ".concat(str));
  }
}
function getPayment(script, scriptType, partialSig) {
  var payment;
  switch (scriptType) {
    case 'multisig':
      var sigs = getSortedSigs(script, partialSig);
      payment = payments.p2ms({
        output: script,
        signatures: sigs
      });
      break;
    case 'pubkey':
      payment = payments.p2pk({
        output: script,
        signature: partialSig[0].signature
      });
      break;
    case 'pubkeyhash':
      payment = payments.p2pkh({
        output: script,
        pubkey: partialSig[0].pubkey,
        signature: partialSig[0].signature
      });
      break;
    case 'witnesspubkeyhash':
      payment = payments.p2wpkh({
        output: script,
        pubkey: partialSig[0].pubkey,
        signature: partialSig[0].signature
      });
      break;
  }
  return payment;
}
function getScriptFromInput(inputIndex, input, cache) {
  var unsignedTx = cache.__TX;
  var res = {
    script: null,
    isSegwit: false,
    isP2SH: false,
    isP2WSH: false
  };
  res.isP2SH = !!input.redeemScript;
  res.isP2WSH = !!input.witnessScript;
  if (input.witnessScript) {
    res.script = input.witnessScript;
  } else if (input.redeemScript) {
    res.script = input.redeemScript;
  } else {
    if (input.nonWitnessUtxo) {
      var nonWitnessUtxoTx = nonWitnessUtxoTxFromCache(cache, input, inputIndex);
      var prevoutIndex = unsignedTx.ins[inputIndex].index;
      res.script = nonWitnessUtxoTx.outs[prevoutIndex].script;
    } else if (input.witnessUtxo) {
      res.script = input.witnessUtxo.script;
    }
  }
  if (input.witnessScript || (0, psbtutils_js_1.isP2WPKH)(res.script)) {
    res.isSegwit = true;
  }
  return res;
}
function getSignersFromHD(inputIndex, inputs, hdKeyPair) {
  var input = (0, bip174_2.checkForInput)(inputs, inputIndex);
  if (!input.bip32Derivation || input.bip32Derivation.length === 0) {
    throw new Error('Need bip32Derivation to sign with HD');
  }
  var myDerivations = input.bip32Derivation.map(function (bipDv) {
    if (tools.compare(bipDv.masterFingerprint, hdKeyPair.fingerprint) === 0) {
      return bipDv;
    } else {
      return;
    }
  }).filter(function (v) {
    return !!v;
  });
  if (myDerivations.length === 0) {
    throw new Error('Need one bip32Derivation masterFingerprint to match the HDSigner fingerprint');
  }
  var signers = myDerivations.map(function (bipDv) {
    var node = hdKeyPair.derivePath(bipDv.path);
    if (tools.compare(bipDv.pubkey, node.publicKey) !== 0) {
      throw new Error('pubkey did not match bip32Derivation');
    }
    return node;
  });
  return signers;
}
function getSortedSigs(script, partialSig) {
  var p2ms = payments.p2ms({
    output: script
  });
  // for each pubkey in order of p2ms script
  return p2ms.pubkeys.map(function (pk) {
    // filter partialSig array by pubkey being equal
    return (partialSig.filter(function (ps) {
      return tools.compare(ps.pubkey, pk) === 0;
    })[0] || {}).signature;
    // Any pubkey without a match will return undefined
    // this last filter removes all the undefined items in the array.
  }).filter(function (v) {
    return !!v;
  });
}
function scriptWitnessToWitnessStack(buffer) {
  var offset = 0;
  function readSlice(n) {
    offset += n;
    return buffer.slice(offset - n, offset);
  }
  function readVarInt() {
    var vi = varuint.decode(buffer, offset);
    offset += varuint.encodingLength(vi.bigintValue);
    return vi.numberValue;
  }
  function readVarSlice() {
    return readSlice(readVarInt());
  }
  function readVector() {
    var count = readVarInt();
    var vector = [];
    for (var i = 0; i < count; i++) vector.push(readVarSlice());
    return vector;
  }
  return readVector();
}
function sighashTypeToString(sighashType) {
  var text = sighashType & transaction_js_1.Transaction.SIGHASH_ANYONECANPAY ? 'SIGHASH_ANYONECANPAY | ' : '';
  var sigMod = sighashType & 0x1f;
  switch (sigMod) {
    case transaction_js_1.Transaction.SIGHASH_ALL:
      text += 'SIGHASH_ALL';
      break;
    case transaction_js_1.Transaction.SIGHASH_SINGLE:
      text += 'SIGHASH_SINGLE';
      break;
    case transaction_js_1.Transaction.SIGHASH_NONE:
      text += 'SIGHASH_NONE';
      break;
  }
  return text;
}
function addNonWitnessTxCache(cache, input, inputIndex) {
  cache.__NON_WITNESS_UTXO_BUF_CACHE[inputIndex] = input.nonWitnessUtxo;
  var tx = transaction_js_1.Transaction.fromBuffer(input.nonWitnessUtxo);
  cache.__NON_WITNESS_UTXO_TX_CACHE[inputIndex] = tx;
  var self = cache;
  var selfIndex = inputIndex;
  delete input.nonWitnessUtxo;
  Object.defineProperty(input, 'nonWitnessUtxo', {
    enumerable: true,
    get: function get() {
      var buf = self.__NON_WITNESS_UTXO_BUF_CACHE[selfIndex];
      var txCache = self.__NON_WITNESS_UTXO_TX_CACHE[selfIndex];
      if (buf !== undefined) {
        return buf;
      } else {
        var newBuf = txCache.toBuffer();
        self.__NON_WITNESS_UTXO_BUF_CACHE[selfIndex] = newBuf;
        return newBuf;
      }
    },
    set: function set(data) {
      self.__NON_WITNESS_UTXO_BUF_CACHE[selfIndex] = data;
    }
  });
}
function inputFinalizeGetAmts(inputs, tx, cache, mustFinalize) {
  var inputAmount = 0n;
  inputs.forEach(function (input, idx) {
    if (mustFinalize && input.finalScriptSig) tx.ins[idx].script = input.finalScriptSig;
    if (mustFinalize && input.finalScriptWitness) {
      tx.ins[idx].witness = scriptWitnessToWitnessStack(input.finalScriptWitness);
    }
    if (input.witnessUtxo) {
      inputAmount += input.witnessUtxo.value;
    } else if (input.nonWitnessUtxo) {
      var nwTx = nonWitnessUtxoTxFromCache(cache, input, idx);
      var vout = tx.ins[idx].index;
      var out = nwTx.outs[vout];
      inputAmount += out.value;
    }
  });
  var outputAmount = tx.outs.reduce(function (total, o) {
    return total + o.value;
  }, 0n);
  var fee = inputAmount - outputAmount;
  if (fee < 0) {
    throw new Error('Outputs are spending more than Inputs');
  }
  var bytes = tx.virtualSize();
  cache.__FEE = fee;
  cache.__EXTRACTED_TX = tx;
  cache.__FEE_RATE = Math.floor(Number(fee / BigInt(bytes)));
}
function nonWitnessUtxoTxFromCache(cache, input, inputIndex) {
  var c = cache.__NON_WITNESS_UTXO_TX_CACHE;
  if (!c[inputIndex]) {
    addNonWitnessTxCache(cache, input, inputIndex);
  }
  return c[inputIndex];
}
function getScriptFromUtxo(inputIndex, input, cache) {
  var _getScriptAndAmountFr2 = getScriptAndAmountFromUtxo(inputIndex, input, cache),
    script = _getScriptAndAmountFr2.script;
  return script;
}
function getScriptAndAmountFromUtxo(inputIndex, input, cache) {
  if (input.witnessUtxo !== undefined) {
    return {
      script: input.witnessUtxo.script,
      value: input.witnessUtxo.value
    };
  } else if (input.nonWitnessUtxo !== undefined) {
    var nonWitnessUtxoTx = nonWitnessUtxoTxFromCache(cache, input, inputIndex);
    var o = nonWitnessUtxoTx.outs[cache.__TX.ins[inputIndex].index];
    return {
      script: o.script,
      value: o.value
    };
  } else {
    throw new Error("Can't find pubkey in input without Utxo data");
  }
}
function pubkeyInInput(pubkey, input, inputIndex, cache) {
  var script = getScriptFromUtxo(inputIndex, input, cache);
  var _getMeaningfulScript2 = getMeaningfulScript(script, inputIndex, 'input', input.redeemScript, input.witnessScript),
    meaningfulScript = _getMeaningfulScript2.meaningfulScript;
  return (0, psbtutils_js_1.pubkeyInScript)(pubkey, meaningfulScript);
}
function pubkeyInOutput(pubkey, output, outputIndex, cache) {
  var script = cache.__TX.outs[outputIndex].script;
  var _getMeaningfulScript3 = getMeaningfulScript(script, outputIndex, 'output', output.redeemScript, output.witnessScript),
    meaningfulScript = _getMeaningfulScript3.meaningfulScript;
  return (0, psbtutils_js_1.pubkeyInScript)(pubkey, meaningfulScript);
}
function redeemFromFinalScriptSig(finalScript) {
  if (!finalScript) return;
  var decomp = bscript.decompile(finalScript);
  if (!decomp) return;
  var lastItem = decomp[decomp.length - 1];
  if (!(lastItem instanceof Uint8Array) || isPubkeyLike(lastItem) || isSigLike(lastItem)) return;
  var sDecomp = bscript.decompile(lastItem);
  if (!sDecomp) return;
  return lastItem;
}
function redeemFromFinalWitnessScript(finalScript) {
  if (!finalScript) return;
  var decomp = scriptWitnessToWitnessStack(finalScript);
  var lastItem = decomp[decomp.length - 1];
  if (isPubkeyLike(lastItem)) return;
  var sDecomp = bscript.decompile(lastItem);
  if (!sDecomp) return;
  return lastItem;
}
function compressPubkey(pubkey) {
  if (pubkey.length === 65) {
    var parity = pubkey[64] & 1;
    var newKey = pubkey.slice(0, 33);
    newKey[0] = 2 | parity;
    return newKey;
  }
  return pubkey.slice();
}
function isPubkeyLike(buf) {
  return buf.length === 33 && bscript.isCanonicalPubKey(buf);
}
function isSigLike(buf) {
  return bscript.isCanonicalScriptSignature(buf);
}
function getMeaningfulScript(script, index, ioType, redeemScript, witnessScript) {
  var isP2SH = (0, psbtutils_js_1.isP2SHScript)(script);
  var isP2SHP2WSH = isP2SH && redeemScript && (0, psbtutils_js_1.isP2WSHScript)(redeemScript);
  var isP2WSH = (0, psbtutils_js_1.isP2WSHScript)(script);
  if (isP2SH && redeemScript === undefined) throw new Error('scriptPubkey is P2SH but redeemScript missing');
  if ((isP2WSH || isP2SHP2WSH) && witnessScript === undefined) throw new Error('scriptPubkey or redeemScript is P2WSH but witnessScript missing');
  var meaningfulScript;
  if (isP2SHP2WSH) {
    meaningfulScript = witnessScript;
    checkRedeemScript(index, script, redeemScript, ioType);
    checkWitnessScript(index, redeemScript, witnessScript, ioType);
    checkInvalidP2WSH(meaningfulScript);
  } else if (isP2WSH) {
    meaningfulScript = witnessScript;
    checkWitnessScript(index, script, witnessScript, ioType);
    checkInvalidP2WSH(meaningfulScript);
  } else if (isP2SH) {
    meaningfulScript = redeemScript;
    checkRedeemScript(index, script, redeemScript, ioType);
  } else {
    meaningfulScript = script;
  }
  return {
    meaningfulScript: meaningfulScript,
    type: isP2SHP2WSH ? 'p2sh-p2wsh' : isP2SH ? 'p2sh' : isP2WSH ? 'p2wsh' : 'raw'
  };
}
function checkInvalidP2WSH(script) {
  if ((0, psbtutils_js_1.isP2WPKH)(script) || (0, psbtutils_js_1.isP2SHScript)(script)) {
    throw new Error('P2WPKH or P2SH can not be contained within P2WSH');
  }
}
function classifyScript(script) {
  if ((0, psbtutils_js_1.isP2WPKH)(script)) return 'witnesspubkeyhash';
  if ((0, psbtutils_js_1.isP2PKH)(script)) return 'pubkeyhash';
  if ((0, psbtutils_js_1.isP2MS)(script)) return 'multisig';
  if ((0, psbtutils_js_1.isP2PK)(script)) return 'pubkey';
  return 'nonstandard';
}
function range(n) {
  return _toConsumableArray(Array(n).keys());
}

},{"./address.cjs":67,"./bufferutils.cjs":70,"./networks.cjs":75,"./payments/bip341.cjs":77,"./payments/index.cjs":79,"./psbt/bip371.cjs":89,"./psbt/psbtutils.cjs":90,"./script.cjs":92,"./transaction.cjs":95,"bip174":45,"uint8array-tools":65,"varuint-bitcoin":109}],89:[function(require,module,exports){
'use strict';

function _createForOfIteratorHelper(r, e) { var t = "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (!t) { if (Array.isArray(r) || (t = _unsupportedIterableToArray(r)) || e && r && "number" == typeof r.length) { t && (r = t); var _n = 0, F = function F() {}; return { s: F, n: function n() { return _n >= r.length ? { done: !0 } : { done: !1, value: r[_n++] }; }, e: function e(r) { throw r; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var o, a = !0, u = !1; return { s: function s() { t = t.call(r); }, n: function n() { var r = t.next(); return a = r.done, r; }, e: function e(r) { u = !0, o = r; }, f: function f() { try { a || null == t["return"] || t["return"](); } finally { if (u) throw o; } } }; }
function _toConsumableArray(r) { return _arrayWithoutHoles(r) || _iterableToArray(r) || _unsupportedIterableToArray(r) || _nonIterableSpread(); }
function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _unsupportedIterableToArray(r, a) { if (r) { if ("string" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }
function _iterableToArray(r) { if ("undefined" != typeof Symbol && null != r[Symbol.iterator] || null != r["@@iterator"]) return Array.from(r); }
function _arrayWithoutHoles(r) { if (Array.isArray(r)) return _arrayLikeToArray(r); }
function _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }
var __createBinding = void 0 && (void 0).__createBinding || (Object.create ? function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  var desc = Object.getOwnPropertyDescriptor(m, k);
  if (!desc || ('get' in desc ? !m.__esModule : desc.writable || desc.configurable)) {
    desc = {
      enumerable: true,
      get: function get() {
        return m[k];
      }
    };
  }
  Object.defineProperty(o, k2, desc);
} : function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  o[k2] = m[k];
});
var __setModuleDefault = void 0 && (void 0).__setModuleDefault || (Object.create ? function (o, v) {
  Object.defineProperty(o, 'default', {
    enumerable: true,
    value: v
  });
} : function (o, v) {
  o['default'] = v;
});
var __importStar = void 0 && (void 0).__importStar || function (mod) {
  if (mod && mod.__esModule) return mod;
  var result = {};
  if (mod != null) for (var k in mod) if (k !== 'default' && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
  __setModuleDefault(result, mod);
  return result;
};
Object.defineProperty(exports, '__esModule', {
  value: true
});
exports.toXOnly = void 0;
exports.tapScriptFinalizer = tapScriptFinalizer;
exports.serializeTaprootSignature = serializeTaprootSignature;
exports.isTaprootInput = isTaprootInput;
exports.isTaprootOutput = isTaprootOutput;
exports.checkTaprootInputFields = checkTaprootInputFields;
exports.checkTaprootOutputFields = checkTaprootOutputFields;
exports.tweakInternalPubKey = tweakInternalPubKey;
exports.tapTreeToList = tapTreeToList;
exports.tapTreeFromList = tapTreeFromList;
exports.checkTaprootInputForSigs = checkTaprootInputForSigs;
var types_js_1 = require('../types.cjs');
var transaction_js_1 = require('../transaction.cjs');
var psbtutils_js_1 = require('./psbtutils.cjs');
var bip341_js_1 = require('../payments/bip341.cjs');
var index_js_1 = require('../payments/index.cjs');
var tools = __importStar(require('uint8array-tools'));
var psbtutils_js_2 = require('./psbtutils.cjs');
/**
 * Converts a public key to an X-only public key.
 * @param pubKey The public key to convert.
 * @returns The X-only public key.
 */
var toXOnly = function toXOnly(pubKey) {
  return pubKey.length === 32 ? pubKey : pubKey.slice(1, 33);
};
exports.toXOnly = toXOnly;
/**
 * Default tapscript finalizer. It searches for the `tapLeafHashToFinalize` if provided.
 * Otherwise it will search for the tapleaf that has at least one signature and has the shortest path.
 * @param inputIndex the position of the PSBT input.
 * @param input the PSBT input.
 * @param tapLeafHashToFinalize optional, if provided the finalizer will search for a tapleaf that has this hash
 *                              and will try to build the finalScriptWitness.
 * @returns the finalScriptWitness or throws an exception if no tapleaf found.
 */
function tapScriptFinalizer(inputIndex, input, tapLeafHashToFinalize) {
  var tapLeaf = findTapLeafToFinalize(input, inputIndex, tapLeafHashToFinalize);
  try {
    var sigs = sortSignatures(input, tapLeaf);
    var witness = sigs.concat(tapLeaf.script).concat(tapLeaf.controlBlock);
    return {
      finalScriptWitness: (0, psbtutils_js_1.witnessStackToScriptWitness)(witness)
    };
  } catch (err) {
    throw new Error("Can not finalize taproot input #".concat(inputIndex, ": ").concat(err));
  }
}
/**
 * Serializes a taproot signature.
 * @param sig The signature to serialize.
 * @param sighashType The sighash type. Optional.
 * @returns The serialized taproot signature.
 */
function serializeTaprootSignature(sig, sighashType) {
  var sighashTypeByte = sighashType ? Uint8Array.from([sighashType]) : Uint8Array.from([]);
  return tools.concat([sig, sighashTypeByte]);
}
/**
 * Checks if a PSBT input is a taproot input.
 * @param input The PSBT input to check.
 * @returns True if the input is a taproot input, false otherwise.
 */
function isTaprootInput(input) {
  return input && !!(input.tapInternalKey || input.tapMerkleRoot || input.tapLeafScript && input.tapLeafScript.length || input.tapBip32Derivation && input.tapBip32Derivation.length || input.witnessUtxo && (0, psbtutils_js_1.isP2TR)(input.witnessUtxo.script));
}
/**
 * Checks if a PSBT output is a taproot output.
 * @param output The PSBT output to check.
 * @param script The script to check. Optional.
 * @returns True if the output is a taproot output, false otherwise.
 */
function isTaprootOutput(output, script) {
  return output && !!(output.tapInternalKey || output.tapTree || output.tapBip32Derivation && output.tapBip32Derivation.length || script && (0, psbtutils_js_1.isP2TR)(script));
}
/**
 * Checks the taproot input fields for consistency.
 * @param inputData The original input data.
 * @param newInputData The new input data.
 * @param action The action being performed.
 * @throws Throws an error if the input fields are inconsistent.
 */
function checkTaprootInputFields(inputData, newInputData, action) {
  checkMixedTaprootAndNonTaprootInputFields(inputData, newInputData, action);
  checkIfTapLeafInTree(inputData, newInputData, action);
}
/**
 * Checks the taproot output fields for consistency.
 * @param outputData The original output data.
 * @param newOutputData The new output data.
 * @param action The action being performed.
 * @throws Throws an error if the output fields are inconsistent.
 */
function checkTaprootOutputFields(outputData, newOutputData, action) {
  checkMixedTaprootAndNonTaprootOutputFields(outputData, newOutputData, action);
  checkTaprootScriptPubkey(outputData, newOutputData);
}
function checkTaprootScriptPubkey(outputData, newOutputData) {
  if (!newOutputData.tapTree && !newOutputData.tapInternalKey) return;
  var tapInternalKey = newOutputData.tapInternalKey || outputData.tapInternalKey;
  var tapTree = newOutputData.tapTree || outputData.tapTree;
  if (tapInternalKey) {
    var scriptPubkey = outputData.script;
    var script = getTaprootScripPubkey(tapInternalKey, tapTree);
    if (scriptPubkey && tools.compare(script, scriptPubkey) !== 0) throw new Error('Error adding output. Script or address mismatch.');
  }
}
/**
 * Returns the Taproot script public key.
 *
 * @param tapInternalKey - The Taproot internal key.
 * @param tapTree - The Taproot tree (optional).
 * @returns The Taproot script public key.
 */
function getTaprootScripPubkey(tapInternalKey, tapTree) {
  var scriptTree = tapTree && tapTreeFromList(tapTree.leaves);
  var _ref = (0, index_js_1.p2tr)({
      internalPubkey: tapInternalKey,
      scriptTree: scriptTree
    }),
    output = _ref.output;
  return output;
}
/**
 * Tweak the internal public key for a specific input.
 * @param inputIndex - The index of the input.
 * @param input - The PsbtInput object representing the input.
 * @returns The tweaked internal public key.
 * @throws Error if the tap internal key cannot be tweaked.
 */
function tweakInternalPubKey(inputIndex, input) {
  var tapInternalKey = input.tapInternalKey;
  var outputKey = tapInternalKey && (0, bip341_js_1.tweakKey)(tapInternalKey, input.tapMerkleRoot);
  if (!outputKey) throw new Error("Cannot tweak tap internal key for input #".concat(inputIndex, ". Public key: ").concat(
  // tapInternalKey && tapInternalKey.toString('hex')
  tapInternalKey && tools.toHex(tapInternalKey)));
  return outputKey.x;
}
/**
 * Convert a binary tree to a BIP371 type list. Each element of the list is (according to BIP371):
 * One or more tuples representing the depth, leaf version, and script for a leaf in the Taproot tree,
 * allowing the entire tree to be reconstructed. The tuples must be in depth first search order so that
 * the tree is correctly reconstructed.
 * @param tree the binary tap tree
 * @returns a list of BIP 371 tapleaves
 */
function tapTreeToList(tree) {
  if (!(0, types_js_1.isTaptree)(tree)) throw new Error('Cannot convert taptree to tapleaf list. Expecting a tapree structure.');
  return _tapTreeToList(tree);
}
/**
 * Convert a BIP371 TapLeaf list to a TapTree (binary).
 * @param leaves a list of tapleaves where each element of the list is (according to BIP371):
 * One or more tuples representing the depth, leaf version, and script for a leaf in the Taproot tree,
 * allowing the entire tree to be reconstructed. The tuples must be in depth first search order so that
 * the tree is correctly reconstructed.
 * @returns the corresponding taptree, or throws an exception if the tree cannot be reconstructed
 */
function tapTreeFromList() {
  var leaves = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
  if (leaves.length === 1 && leaves[0].depth === 0) return {
    output: leaves[0].script,
    version: leaves[0].leafVersion
  };
  return instertLeavesInTree(leaves);
}
/**
 * Checks the taproot input for signatures.
 * @param input The PSBT input to check.
 * @param action The action being performed.
 * @returns True if the input has taproot signatures, false otherwise.
 */
function checkTaprootInputForSigs(input, action) {
  var sigs = extractTaprootSigs(input);
  return sigs.some(function (sig) {
    return (0, psbtutils_js_2.signatureBlocksAction)(sig, decodeSchnorrSignature, action);
  });
}
/**
 * Decodes a Schnorr signature.
 * @param signature The signature to decode.
 * @returns The decoded Schnorr signature.
 */
function decodeSchnorrSignature(signature) {
  return {
    signature: signature.slice(0, 64),
    hashType: signature.slice(64)[0] || transaction_js_1.Transaction.SIGHASH_DEFAULT
  };
}
/**
 * Extracts taproot signatures from a PSBT input.
 * @param input The PSBT input to extract signatures from.
 * @returns An array of taproot signatures.
 */
function extractTaprootSigs(input) {
  var sigs = [];
  if (input.tapKeySig) sigs.push(input.tapKeySig);
  if (input.tapScriptSig) sigs.push.apply(sigs, _toConsumableArray(input.tapScriptSig.map(function (s) {
    return s.signature;
  })));
  if (!sigs.length) {
    var finalTapKeySig = getTapKeySigFromWithness(input.finalScriptWitness);
    if (finalTapKeySig) sigs.push(finalTapKeySig);
  }
  return sigs;
}
/**
 * Gets the taproot signature from the witness.
 * @param finalScriptWitness The final script witness.
 * @returns The taproot signature, or undefined if not found.
 */
function getTapKeySigFromWithness(finalScriptWitness) {
  if (!finalScriptWitness) return;
  var witness = finalScriptWitness.slice(2);
  // todo: add schnorr signature validation
  if (witness.length === 64 || witness.length === 65) return witness;
}
/**
 * Converts a binary tree to a BIP371 type list.
 * @param tree The binary tap tree.
 * @param leaves A list of tapleaves. Optional.
 * @param depth The current depth. Optional.
 * @returns A list of BIP 371 tapleaves.
 * @throws Throws an error if the taptree cannot be converted to a tapleaf list.
 */
function _tapTreeToList(tree) {
  var leaves = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
  var depth = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
  if (depth > bip341_js_1.MAX_TAPTREE_DEPTH) throw new Error('Max taptree depth exceeded.');
  if (!tree) return [];
  if ((0, types_js_1.isTapleaf)(tree)) {
    leaves.push({
      depth: depth,
      leafVersion: tree.version || bip341_js_1.LEAF_VERSION_TAPSCRIPT,
      script: tree.output
    });
    return leaves;
  }
  if (tree[0]) _tapTreeToList(tree[0], leaves, depth + 1);
  if (tree[1]) _tapTreeToList(tree[1], leaves, depth + 1);
  return leaves;
}
/**
 * Inserts the tapleaves into the taproot tree.
 * @param leaves The tapleaves to insert.
 * @returns The taproot tree.
 * @throws Throws an error if there is no room left to insert a tapleaf in the tree.
 */
function instertLeavesInTree(leaves) {
  var tree;
  var _iterator = _createForOfIteratorHelper(leaves),
    _step;
  try {
    for (_iterator.s(); !(_step = _iterator.n()).done;) {
      var leaf = _step.value;
      tree = instertLeafInTree(leaf, tree);
      if (!tree) throw new Error("No room left to insert tapleaf in tree");
    }
  } catch (err) {
    _iterator.e(err);
  } finally {
    _iterator.f();
  }
  return tree;
}
/**
 * Inserts a tapleaf into the taproot tree.
 * @param leaf The tapleaf to insert.
 * @param tree The taproot tree.
 * @param depth The current depth. Optional.
 * @returns The updated taproot tree.
 */
function instertLeafInTree(leaf, tree) {
  var depth = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
  if (depth > bip341_js_1.MAX_TAPTREE_DEPTH) throw new Error('Max taptree depth exceeded.');
  if (leaf.depth === depth) {
    if (!tree) return {
      output: leaf.script,
      version: leaf.leafVersion
    };
    return;
  }
  if ((0, types_js_1.isTapleaf)(tree)) return;
  var leftSide = instertLeafInTree(leaf, tree && tree[0], depth + 1);
  if (leftSide) return [leftSide, tree && tree[1]];
  var rightSide = instertLeafInTree(leaf, tree && tree[1], depth + 1);
  if (rightSide) return [tree && tree[0], rightSide];
}
/**
 * Checks the input fields for mixed taproot and non-taproot fields.
 * @param inputData The original input data.
 * @param newInputData The new input data.
 * @param action The action being performed.
 * @throws Throws an error if the input fields are inconsistent.
 */
function checkMixedTaprootAndNonTaprootInputFields(inputData, newInputData, action) {
  var isBadTaprootUpdate = isTaprootInput(inputData) && hasNonTaprootFields(newInputData);
  var isBadNonTaprootUpdate = hasNonTaprootFields(inputData) && isTaprootInput(newInputData);
  var hasMixedFields = inputData === newInputData && isTaprootInput(newInputData) && hasNonTaprootFields(newInputData); // todo: bad? use !===
  if (isBadTaprootUpdate || isBadNonTaprootUpdate || hasMixedFields) throw new Error("Invalid arguments for Psbt.".concat(action, ". ") + "Cannot use both taproot and non-taproot fields.");
}
/**
 * Checks the output fields for mixed taproot and non-taproot fields.
 * @param inputData The original output data.
 * @param newInputData The new output data.
 * @param action The action being performed.
 * @throws Throws an error if the output fields are inconsistent.
 */
function checkMixedTaprootAndNonTaprootOutputFields(inputData, newInputData, action) {
  var isBadTaprootUpdate = isTaprootOutput(inputData) && hasNonTaprootFields(newInputData);
  var isBadNonTaprootUpdate = hasNonTaprootFields(inputData) && isTaprootOutput(newInputData);
  var hasMixedFields = inputData === newInputData && isTaprootOutput(newInputData) && hasNonTaprootFields(newInputData);
  if (isBadTaprootUpdate || isBadNonTaprootUpdate || hasMixedFields) throw new Error("Invalid arguments for Psbt.".concat(action, ". ") + "Cannot use both taproot and non-taproot fields.");
}
/**
 * Checks if the tap leaf is part of the tap tree for the given input data.
 * Throws an error if the tap leaf is not part of the tap tree.
 * @param inputData - The original PsbtInput data.
 * @param newInputData - The new PsbtInput data.
 * @param action - The action being performed.
 * @throws {Error} - If the tap leaf is not part of the tap tree.
 */
function checkIfTapLeafInTree(inputData, newInputData, action) {
  if (newInputData.tapMerkleRoot) {
    var newLeafsInTree = (newInputData.tapLeafScript || []).every(function (l) {
      return isTapLeafInTree(l, newInputData.tapMerkleRoot);
    });
    var oldLeafsInTree = (inputData.tapLeafScript || []).every(function (l) {
      return isTapLeafInTree(l, newInputData.tapMerkleRoot);
    });
    if (!newLeafsInTree || !oldLeafsInTree) throw new Error("Invalid arguments for Psbt.".concat(action, ". Tapleaf not part of taptree."));
  } else if (inputData.tapMerkleRoot) {
    var _newLeafsInTree = (newInputData.tapLeafScript || []).every(function (l) {
      return isTapLeafInTree(l, inputData.tapMerkleRoot);
    });
    if (!_newLeafsInTree) throw new Error("Invalid arguments for Psbt.".concat(action, ". Tapleaf not part of taptree."));
  }
}
/**
 * Checks if a TapLeafScript is present in a Merkle tree.
 * @param tapLeaf The TapLeafScript to check.
 * @param merkleRoot The Merkle root of the tree. If not provided, the function assumes the TapLeafScript is present.
 * @returns A boolean indicating whether the TapLeafScript is present in the tree.
 */
function isTapLeafInTree(tapLeaf, merkleRoot) {
  if (!merkleRoot) return true;
  var leafHash = (0, bip341_js_1.tapleafHash)({
    output: tapLeaf.script,
    version: tapLeaf.leafVersion
  });
  var rootHash = (0, bip341_js_1.rootHashFromPath)(tapLeaf.controlBlock, leafHash);
  return tools.compare(rootHash, merkleRoot) === 0;
}
/**
 * Sorts the signatures in the input's tapScriptSig array based on their position in the tapLeaf script.
 *
 * @param input - The PsbtInput object.
 * @param tapLeaf - The TapLeafScript object.
 * @returns An array of sorted signatures as Buffers.
 */
function sortSignatures(input, tapLeaf) {
  var leafHash = (0, bip341_js_1.tapleafHash)({
    output: tapLeaf.script,
    version: tapLeaf.leafVersion
  });
  return (input.tapScriptSig || []
  // .filter(tss => tss.leafHash.equals(leafHash))
  ).filter(function (tss) {
    return tools.compare(tss.leafHash, leafHash) === 0;
  }).map(function (tss) {
    return addPubkeyPositionInScript(tapLeaf.script, tss);
  }).sort(function (t1, t2) {
    return t2.positionInScript - t1.positionInScript;
  }).map(function (t) {
    return t.signature;
  });
}
/**
 * Adds the position of a public key in a script to a TapScriptSig object.
 * @param script The script in which to find the position of the public key.
 * @param tss The TapScriptSig object to add the position to.
 * @returns A TapScriptSigWitPosition object with the added position.
 */
function addPubkeyPositionInScript(script, tss) {
  return Object.assign({
    positionInScript: (0, psbtutils_js_1.pubkeyPositionInScript)(tss.pubkey, script)
  }, tss);
}
/**
 * Find tapleaf by hash, or get the signed tapleaf with the shortest path.
 */
function findTapLeafToFinalize(input, inputIndex, leafHashToFinalize) {
  if (!input.tapScriptSig || !input.tapScriptSig.length) throw new Error("Can not finalize taproot input #".concat(inputIndex, ". No tapleaf script signature provided."));
  var tapLeaf = (input.tapLeafScript || []).sort(function (a, b) {
    return a.controlBlock.length - b.controlBlock.length;
  }).find(function (leaf) {
    return canFinalizeLeaf(leaf, input.tapScriptSig, leafHashToFinalize);
  });
  if (!tapLeaf) throw new Error("Can not finalize taproot input #".concat(inputIndex, ". Signature for tapleaf script not found."));
  return tapLeaf;
}
/**
 * Determines whether a TapLeafScript can be finalized.
 *
 * @param leaf - The TapLeafScript to check.
 * @param tapScriptSig - The array of TapScriptSig objects.
 * @param hash - The optional hash to compare with the leaf hash.
 * @returns A boolean indicating whether the TapLeafScript can be finalized.
 */
function canFinalizeLeaf(leaf, tapScriptSig, hash) {
  var leafHash = (0, bip341_js_1.tapleafHash)({
    output: leaf.script,
    version: leaf.leafVersion
  });
  var whiteListedHash = !hash || tools.compare(leafHash, hash) === 0;
  return whiteListedHash && tapScriptSig.find(function (tss) {
    return tools.compare(tss.leafHash, leafHash) === 0;
  }) !== undefined;
}
/**
 * Checks if the given PsbtInput or PsbtOutput has non-taproot fields.
 * Non-taproot fields include redeemScript, witnessScript, and bip32Derivation.
 * @param io The PsbtInput or PsbtOutput to check.
 * @returns A boolean indicating whether the given input or output has non-taproot fields.
 */
function hasNonTaprootFields(io) {
  return io && !!(io.redeemScript || io.witnessScript || io.bip32Derivation && io.bip32Derivation.length);
}

},{"../payments/bip341.cjs":77,"../payments/index.cjs":79,"../transaction.cjs":95,"../types.cjs":96,"./psbtutils.cjs":90,"uint8array-tools":65}],90:[function(require,module,exports){
'use strict';

var __createBinding = void 0 && (void 0).__createBinding || (Object.create ? function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  var desc = Object.getOwnPropertyDescriptor(m, k);
  if (!desc || ('get' in desc ? !m.__esModule : desc.writable || desc.configurable)) {
    desc = {
      enumerable: true,
      get: function get() {
        return m[k];
      }
    };
  }
  Object.defineProperty(o, k2, desc);
} : function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  o[k2] = m[k];
});
var __setModuleDefault = void 0 && (void 0).__setModuleDefault || (Object.create ? function (o, v) {
  Object.defineProperty(o, 'default', {
    enumerable: true,
    value: v
  });
} : function (o, v) {
  o['default'] = v;
});
var __importStar = void 0 && (void 0).__importStar || function (mod) {
  if (mod && mod.__esModule) return mod;
  var result = {};
  if (mod != null) for (var k in mod) if (k !== 'default' && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
  __setModuleDefault(result, mod);
  return result;
};
Object.defineProperty(exports, '__esModule', {
  value: true
});
exports.isP2TR = exports.isP2SHScript = exports.isP2WSHScript = exports.isP2WPKH = exports.isP2PKH = exports.isP2PK = exports.isP2MS = void 0;
exports.witnessStackToScriptWitness = witnessStackToScriptWitness;
exports.pubkeyPositionInScript = pubkeyPositionInScript;
exports.pubkeyInScript = pubkeyInScript;
exports.checkInputForSig = checkInputForSig;
exports.signatureBlocksAction = signatureBlocksAction;
var varuint = __importStar(require('varuint-bitcoin'));
var bscript = __importStar(require('../script.cjs'));
var transaction_js_1 = require('../transaction.cjs');
var crypto_js_1 = require('../crypto.cjs');
var payments = __importStar(require('../payments/index.cjs'));
var tools = __importStar(require('uint8array-tools'));
/**
 * Checks if a given payment factory can generate a payment script from a given script.
 * @param payment The payment factory to check.
 * @returns A function that takes a script and returns a boolean indicating whether the payment factory can generate a payment script from the script.
 */
function isPaymentFactory(payment) {
  return function (script) {
    try {
      payment({
        output: script
      });
      return true;
    } catch (err) {
      return false;
    }
  };
}
exports.isP2MS = isPaymentFactory(payments.p2ms);
exports.isP2PK = isPaymentFactory(payments.p2pk);
exports.isP2PKH = isPaymentFactory(payments.p2pkh);
exports.isP2WPKH = isPaymentFactory(payments.p2wpkh);
exports.isP2WSHScript = isPaymentFactory(payments.p2wsh);
exports.isP2SHScript = isPaymentFactory(payments.p2sh);
exports.isP2TR = isPaymentFactory(payments.p2tr);
/**
 * Converts a witness stack to a script witness.
 * @param witness The witness stack to convert.
 * @returns The script witness as a Buffer.
 */
function witnessStackToScriptWitness(witness) {
  var buffer = new Uint8Array(0);
  function writeSlice(slice) {
    buffer = tools.concat([buffer, slice]);
  }
  function writeVarInt(i) {
    var currentLen = buffer.length;
    var varintLen = varuint.encodingLength(i);
    buffer = tools.concat([buffer, new Uint8Array(varintLen)]);
    varuint.encode(i, buffer, currentLen);
  }
  function writeVarSlice(slice) {
    writeVarInt(slice.length);
    writeSlice(slice);
  }
  function writeVector(vector) {
    writeVarInt(vector.length);
    vector.forEach(writeVarSlice);
  }
  writeVector(witness);
  return buffer;
}
/**
 * Finds the position of a public key in a script.
 * @param pubkey The public key to search for.
 * @param script The script to search in.
 * @returns The index of the public key in the script, or -1 if not found.
 * @throws {Error} If there is an unknown script error.
 */
function pubkeyPositionInScript(pubkey, script) {
  var pubkeyHash = (0, crypto_js_1.hash160)(pubkey);
  var pubkeyXOnly = pubkey.slice(1, 33); // slice before calling?
  var decompiled = bscript.decompile(script);
  if (decompiled === null) throw new Error('Unknown script error');
  return decompiled.findIndex(function (element) {
    if (typeof element === 'number') return false;
    return tools.compare(pubkey, element) === 0 || tools.compare(pubkeyHash, element) === 0 || tools.compare(pubkeyXOnly, element) === 0;
  });
}
/**
 * Checks if a public key is present in a script.
 * @param pubkey The public key to check.
 * @param script The script to search in.
 * @returns A boolean indicating whether the public key is present in the script.
 */
function pubkeyInScript(pubkey, script) {
  return pubkeyPositionInScript(pubkey, script) !== -1;
}
/**
 * Checks if an input contains a signature for a specific action.
 * @param input - The input to check.
 * @param action - The action to check for.
 * @returns A boolean indicating whether the input contains a signature for the specified action.
 */
function checkInputForSig(input, action) {
  var pSigs = extractPartialSigs(input);
  return pSigs.some(function (pSig) {
    return signatureBlocksAction(pSig, bscript.signature.decode, action);
  });
}
/**
 * Determines if a given action is allowed for a signature block.
 * @param signature - The signature block.
 * @param signatureDecodeFn - The function used to decode the signature.
 * @param action - The action to be checked.
 * @returns True if the action is allowed, false otherwise.
 */
function signatureBlocksAction(signature, signatureDecodeFn, action) {
  var _signatureDecodeFn = signatureDecodeFn(signature),
    hashType = _signatureDecodeFn.hashType;
  var whitelist = [];
  var isAnyoneCanPay = hashType & transaction_js_1.Transaction.SIGHASH_ANYONECANPAY;
  if (isAnyoneCanPay) whitelist.push('addInput');
  var hashMod = hashType & 0x1f;
  switch (hashMod) {
    case transaction_js_1.Transaction.SIGHASH_ALL:
      break;
    case transaction_js_1.Transaction.SIGHASH_SINGLE:
    case transaction_js_1.Transaction.SIGHASH_NONE:
      whitelist.push('addOutput');
      whitelist.push('setInputSequence');
      break;
  }
  if (whitelist.indexOf(action) === -1) {
    return true;
  }
  return false;
}
/**
 * Extracts the signatures from a PsbtInput object.
 * If the input has partial signatures, it returns an array of the signatures.
 * If the input does not have partial signatures, it checks if it has a finalScriptSig or finalScriptWitness.
 * If it does, it extracts the signatures from the final scripts and returns them.
 * If none of the above conditions are met, it returns an empty array.
 *
 * @param input - The PsbtInput object from which to extract the signatures.
 * @returns An array of signatures extracted from the PsbtInput object.
 */
function extractPartialSigs(input) {
  var pSigs = [];
  if ((input.partialSig || []).length === 0) {
    if (!input.finalScriptSig && !input.finalScriptWitness) return [];
    pSigs = getPsigsFromInputFinalScripts(input);
  } else {
    pSigs = input.partialSig;
  }
  return pSigs.map(function (p) {
    return p.signature;
  });
}
/**
 * Retrieves the partial signatures (Psigs) from the input's final scripts.
 * Psigs are extracted from both the final scriptSig and final scriptWitness of the input.
 * Only canonical script signatures are considered.
 *
 * @param input - The PsbtInput object representing the input.
 * @returns An array of PartialSig objects containing the extracted Psigs.
 */
function getPsigsFromInputFinalScripts(input) {
  var scriptItems = !input.finalScriptSig ? [] : bscript.decompile(input.finalScriptSig) || [];
  var witnessItems = !input.finalScriptWitness ? [] : bscript.decompile(input.finalScriptWitness) || [];
  return scriptItems.concat(witnessItems).filter(function (item) {
    return item instanceof Uint8Array && bscript.isCanonicalScriptSignature(item);
  }).map(function (sig) {
    return {
      signature: sig
    };
  });
}

},{"../crypto.cjs":71,"../payments/index.cjs":79,"../script.cjs":92,"../transaction.cjs":95,"uint8array-tools":65,"varuint-bitcoin":109}],91:[function(require,module,exports){
'use strict';

var __createBinding = void 0 && (void 0).__createBinding || (Object.create ? function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  var desc = Object.getOwnPropertyDescriptor(m, k);
  if (!desc || ('get' in desc ? !m.__esModule : desc.writable || desc.configurable)) {
    desc = {
      enumerable: true,
      get: function get() {
        return m[k];
      }
    };
  }
  Object.defineProperty(o, k2, desc);
} : function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  o[k2] = m[k];
});
var __setModuleDefault = void 0 && (void 0).__setModuleDefault || (Object.create ? function (o, v) {
  Object.defineProperty(o, 'default', {
    enumerable: true,
    value: v
  });
} : function (o, v) {
  o['default'] = v;
});
var __importStar = void 0 && (void 0).__importStar || function (mod) {
  if (mod && mod.__esModule) return mod;
  var result = {};
  if (mod != null) for (var k in mod) if (k !== 'default' && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
  __setModuleDefault(result, mod);
  return result;
};
Object.defineProperty(exports, '__esModule', {
  value: true
});
exports.encodingLength = encodingLength;
exports.encode = encode;
exports.decode = decode;
var ops_js_1 = require('./ops.cjs');
var tools = __importStar(require('uint8array-tools'));
/**
 * Calculates the encoding length of a number used for push data in Bitcoin transactions.
 * @param i The number to calculate the encoding length for.
 * @returns The encoding length of the number.
 */
function encodingLength(i) {
  return i < ops_js_1.OPS.OP_PUSHDATA1 ? 1 : i <= 0xff ? 2 : i <= 0xffff ? 3 : 5;
}
/**
 * Encodes a number into a buffer using a variable-length encoding scheme.
 * The encoded buffer is written starting at the specified offset.
 * Returns the size of the encoded buffer.
 *
 * @param buffer - The buffer to write the encoded data into.
 * @param num - The number to encode.
 * @param offset - The offset at which to start writing the encoded buffer.
 * @returns The size of the encoded buffer.
 */
function encode(buffer, num, offset) {
  var size = encodingLength(num);
  // ~6 bit
  if (size === 1) {
    tools.writeUInt8(buffer, offset, num);
    // 8 bit
  } else if (size === 2) {
    tools.writeUInt8(buffer, offset, ops_js_1.OPS.OP_PUSHDATA1);
    tools.writeUInt8(buffer, offset + 1, num);
    // 16 bit
  } else if (size === 3) {
    tools.writeUInt8(buffer, offset, ops_js_1.OPS.OP_PUSHDATA2);
    tools.writeUInt16(buffer, offset + 1, num, 'LE');
    // 32 bit
  } else {
    tools.writeUInt8(buffer, offset, ops_js_1.OPS.OP_PUSHDATA4);
    tools.writeUInt32(buffer, offset + 1, num, 'LE');
  }
  return size;
}
/**
 * Decodes a buffer and returns information about the opcode, number, and size.
 * @param buffer - The buffer to decode.
 * @param offset - The offset within the buffer to start decoding.
 * @returns An object containing the opcode, number, and size, or null if decoding fails.
 */
function decode(buffer, offset) {
  var opcode = tools.readUInt8(buffer, offset);
  var num;
  var size;
  // ~6 bit
  if (opcode < ops_js_1.OPS.OP_PUSHDATA1) {
    num = opcode;
    size = 1;
    // 8 bit
  } else if (opcode === ops_js_1.OPS.OP_PUSHDATA1) {
    if (offset + 2 > buffer.length) return null;
    num = tools.readUInt8(buffer, offset + 1);
    size = 2;
    // 16 bit
  } else if (opcode === ops_js_1.OPS.OP_PUSHDATA2) {
    if (offset + 3 > buffer.length) return null;
    num = tools.readUInt16(buffer, offset + 1, 'LE');
    size = 3;
    // 32 bit
  } else {
    if (offset + 5 > buffer.length) return null;
    if (opcode !== ops_js_1.OPS.OP_PUSHDATA4) throw new Error('Unexpected opcode');
    num = tools.readUInt32(buffer, offset + 1, 'LE');
    size = 5;
  }
  return {
    opcode: opcode,
    number: num,
    size: size
  };
}

},{"./ops.cjs":76,"uint8array-tools":65}],92:[function(require,module,exports){
'use strict';

var __createBinding = void 0 && (void 0).__createBinding || (Object.create ? function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  var desc = Object.getOwnPropertyDescriptor(m, k);
  if (!desc || ('get' in desc ? !m.__esModule : desc.writable || desc.configurable)) {
    desc = {
      enumerable: true,
      get: function get() {
        return m[k];
      }
    };
  }
  Object.defineProperty(o, k2, desc);
} : function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  o[k2] = m[k];
});
var __setModuleDefault = void 0 && (void 0).__setModuleDefault || (Object.create ? function (o, v) {
  Object.defineProperty(o, 'default', {
    enumerable: true,
    value: v
  });
} : function (o, v) {
  o['default'] = v;
});
var __importStar = void 0 && (void 0).__importStar || function (mod) {
  if (mod && mod.__esModule) return mod;
  var result = {};
  if (mod != null) for (var k in mod) if (k !== 'default' && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
  __setModuleDefault(result, mod);
  return result;
};
Object.defineProperty(exports, '__esModule', {
  value: true
});
exports.signature = exports.number = exports.OPS = void 0;
exports.isPushOnly = isPushOnly;
exports.countNonPushOnlyOPs = countNonPushOnlyOPs;
exports.compile = compile;
exports.decompile = decompile;
exports.toASM = toASM;
exports.fromASM = fromASM;
exports.toStack = toStack;
exports.isCanonicalPubKey = isCanonicalPubKey;
exports.isDefinedHashType = isDefinedHashType;
exports.isCanonicalScriptSignature = isCanonicalScriptSignature;
/**
 * Script tools, including decompile, compile, toASM, fromASM, toStack, isCanonicalPubKey, isCanonicalScriptSignature
 * @packageDocumentation
 */
var bip66 = __importStar(require('./bip66.cjs'));
var ops_js_1 = require('./ops.cjs');
Object.defineProperty(exports, 'OPS', {
  enumerable: true,
  get: function get() {
    return ops_js_1.OPS;
  }
});
var pushdata = __importStar(require('./push_data.cjs'));
var scriptNumber = __importStar(require('./script_number.cjs'));
var scriptSignature = __importStar(require('./script_signature.cjs'));
var types = __importStar(require('./types.cjs'));
var tools = __importStar(require('uint8array-tools'));
var v = __importStar(require('valibot'));
var OP_INT_BASE = ops_js_1.OPS.OP_RESERVED; // OP_1 - 1
var StackSchema = v.array(v.union([v.instance(Uint8Array), v.number()]));
function isOPInt(value) {
  return v.is(v.number(), value) && (value === ops_js_1.OPS.OP_0 || value >= ops_js_1.OPS.OP_1 && value <= ops_js_1.OPS.OP_16 || value === ops_js_1.OPS.OP_1NEGATE);
}
function isPushOnlyChunk(value) {
  return v.is(types.BufferSchema, value) || isOPInt(value);
}
function isPushOnly(value) {
  return v.is(v.pipe(v.any(), v.everyItem(isPushOnlyChunk)), value);
}
function countNonPushOnlyOPs(value) {
  return value.length - value.filter(isPushOnlyChunk).length;
}
function asMinimalOP(buffer) {
  if (buffer.length === 0) return ops_js_1.OPS.OP_0;
  if (buffer.length !== 1) return;
  if (buffer[0] >= 1 && buffer[0] <= 16) return OP_INT_BASE + buffer[0];
  if (buffer[0] === 0x81) return ops_js_1.OPS.OP_1NEGATE;
}
function chunksIsBuffer(buf) {
  return buf instanceof Uint8Array;
}
function chunksIsArray(buf) {
  return v.is(StackSchema, buf);
}
function singleChunkIsBuffer(buf) {
  return buf instanceof Uint8Array;
}
/**
 * Compiles an array of chunks into a Buffer.
 *
 * @param chunks - The array of chunks to compile.
 * @returns The compiled Buffer.
 * @throws Error if the compilation fails.
 */
function compile(chunks) {
  // TODO: remove me
  if (chunksIsBuffer(chunks)) return chunks;
  v.parse(StackSchema, chunks);
  var bufferSize = chunks.reduce(function (accum, chunk) {
    // data chunk
    if (singleChunkIsBuffer(chunk)) {
      // adhere to BIP62.3, minimal push policy
      if (chunk.length === 1 && asMinimalOP(chunk) !== undefined) {
        return accum + 1;
      }
      return accum + pushdata.encodingLength(chunk.length) + chunk.length;
    }
    // opcode
    return accum + 1;
  }, 0.0);
  var buffer = new Uint8Array(bufferSize);
  var offset = 0;
  chunks.forEach(function (chunk) {
    // data chunk
    if (singleChunkIsBuffer(chunk)) {
      // adhere to BIP62.3, minimal push policy
      var opcode = asMinimalOP(chunk);
      if (opcode !== undefined) {
        tools.writeUInt8(buffer, offset, opcode);
        offset += 1;
        return;
      }
      offset += pushdata.encode(buffer, chunk.length, offset);
      buffer.set(chunk, offset);
      offset += chunk.length;
      // opcode
    } else {
      tools.writeUInt8(buffer, offset, chunk);
      offset += 1;
    }
  });
  if (offset !== buffer.length) throw new Error('Could not decode chunks');
  return buffer;
}
function decompile(buffer) {
  // TODO: remove me
  if (chunksIsArray(buffer)) return buffer;
  v.parse(types.BufferSchema, buffer);
  var chunks = [];
  var i = 0;
  while (i < buffer.length) {
    var opcode = buffer[i];
    // data chunk
    if (opcode > ops_js_1.OPS.OP_0 && opcode <= ops_js_1.OPS.OP_PUSHDATA4) {
      var d = pushdata.decode(buffer, i);
      // did reading a pushDataInt fail?
      if (d === null) return null;
      i += d.size;
      // attempt to read too much data?
      if (i + d.number > buffer.length) return null;
      var data = buffer.slice(i, i + d.number);
      i += d.number;
      // decompile minimally
      var op = asMinimalOP(data);
      if (op !== undefined) {
        chunks.push(op);
      } else {
        chunks.push(data);
      }
      // opcode
    } else {
      chunks.push(opcode);
      i += 1;
    }
  }
  return chunks;
}
/**
 * Converts the given chunks into an ASM (Assembly) string representation.
 * If the chunks parameter is a Buffer, it will be decompiled into a Stack before conversion.
 * @param chunks - The chunks to convert into ASM.
 * @returns The ASM string representation of the chunks.
 */
function toASM(chunks) {
  if (chunksIsBuffer(chunks)) {
    chunks = decompile(chunks);
  }
  if (!chunks) {
    throw new Error('Could not convert invalid chunks to ASM');
  }
  return chunks.map(function (chunk) {
    // data?
    if (singleChunkIsBuffer(chunk)) {
      var op = asMinimalOP(chunk);
      if (op === undefined) return tools.toHex(chunk);
      chunk = op;
    }
    // opcode!
    return ops_js_1.REVERSE_OPS[chunk];
  }).join(' ');
}
/**
 * Converts an ASM string to a Buffer.
 * @param asm The ASM string to convert.
 * @returns The converted Buffer.
 */
function fromASM(asm) {
  v.parse(v.string(), asm);
  return compile(asm.split(' ').map(function (chunkStr) {
    // opcode?
    if (ops_js_1.OPS[chunkStr] !== undefined) return ops_js_1.OPS[chunkStr];
    v.parse(types.HexSchema, chunkStr);
    // data!
    return tools.fromHex(chunkStr);
  }));
}
/**
 * Converts the given chunks into a stack of buffers.
 *
 * @param chunks - The chunks to convert.
 * @returns The stack of buffers.
 */
function toStack(chunks) {
  chunks = decompile(chunks);
  v.parse(v.custom(isPushOnly), chunks);
  return chunks.map(function (op) {
    if (singleChunkIsBuffer(op)) return op;
    if (op === ops_js_1.OPS.OP_0) return new Uint8Array(0);
    return scriptNumber.encode(op - OP_INT_BASE);
  });
}
function isCanonicalPubKey(buffer) {
  return types.isPoint(buffer);
}
function isDefinedHashType(hashType) {
  var hashTypeMod = hashType & ~0x80;
  return hashTypeMod > 0x00 && hashTypeMod < 0x04;
}
function isCanonicalScriptSignature(buffer) {
  if (!(buffer instanceof Uint8Array)) return false;
  if (!isDefinedHashType(buffer[buffer.length - 1])) return false;
  return bip66.check(buffer.slice(0, -1));
}
exports.number = scriptNumber;
exports.signature = scriptSignature;

},{"./bip66.cjs":68,"./ops.cjs":76,"./push_data.cjs":91,"./script_number.cjs":93,"./script_signature.cjs":94,"./types.cjs":96,"uint8array-tools":65,"valibot":66}],93:[function(require,module,exports){
'use strict';

var __createBinding = void 0 && (void 0).__createBinding || (Object.create ? function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  var desc = Object.getOwnPropertyDescriptor(m, k);
  if (!desc || ('get' in desc ? !m.__esModule : desc.writable || desc.configurable)) {
    desc = {
      enumerable: true,
      get: function get() {
        return m[k];
      }
    };
  }
  Object.defineProperty(o, k2, desc);
} : function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  o[k2] = m[k];
});
var __setModuleDefault = void 0 && (void 0).__setModuleDefault || (Object.create ? function (o, v) {
  Object.defineProperty(o, 'default', {
    enumerable: true,
    value: v
  });
} : function (o, v) {
  o['default'] = v;
});
var __importStar = void 0 && (void 0).__importStar || function (mod) {
  if (mod && mod.__esModule) return mod;
  var result = {};
  if (mod != null) for (var k in mod) if (k !== 'default' && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
  __setModuleDefault(result, mod);
  return result;
};
Object.defineProperty(exports, '__esModule', {
  value: true
});
exports.decode = decode;
exports.encode = encode;
var tools = __importStar(require('uint8array-tools'));
/**
 * Decodes a script number from a buffer.
 *
 * @param buffer - The buffer containing the script number.
 * @param maxLength - The maximum length of the script number. Defaults to 4.
 * @param minimal - Whether the script number should be minimal. Defaults to true.
 * @returns The decoded script number.
 * @throws {TypeError} If the script number overflows the maximum length.
 * @throws {Error} If the script number is not minimally encoded when minimal is true.
 */
function decode(buffer, maxLength, minimal) {
  maxLength = maxLength || 4;
  minimal = minimal === undefined ? true : minimal;
  var length = buffer.length;
  if (length === 0) return 0;
  if (length > maxLength) throw new TypeError('Script number overflow');
  if (minimal) {
    if ((buffer[length - 1] & 0x7f) === 0) {
      if (length <= 1 || (buffer[length - 2] & 0x80) === 0) throw new Error('Non-minimally encoded script number');
    }
  }
  // 40-bit
  if (length === 5) {
    var a = tools.readUInt32(buffer, 0, 'LE');
    var b = tools.readUInt8(buffer, 4);
    if (b & 0x80) return -((b & ~0x80) * 0x100000000 + a);
    return b * 0x100000000 + a;
  }
  // 32-bit / 24-bit / 16-bit / 8-bit
  var result = 0;
  for (var i = 0; i < length; ++i) {
    result |= buffer[i] << 8 * i;
  }
  if (buffer[length - 1] & 0x80) return -(result & ~(0x80 << 8 * (length - 1)));
  return result;
}
function scriptNumSize(i) {
  return i > 0x7fffffff ? 5 : i > 0x7fffff ? 4 : i > 0x7fff ? 3 : i > 0x7f ? 2 : i > 0x00 ? 1 : 0;
}
/**
 * Encodes a number into a Uint8Array using a specific format.
 *
 * @param _number - The number to encode.
 * @returns The encoded number as a Uint8Array.
 */
function encode(_number) {
  var value = Math.abs(_number);
  var size = scriptNumSize(value);
  var buffer = new Uint8Array(size);
  var negative = _number < 0;
  for (var i = 0; i < size; ++i) {
    tools.writeUInt8(buffer, i, value & 0xff);
    value >>= 8;
  }
  if (buffer[size - 1] & 0x80) {
    tools.writeUInt8(buffer, size - 1, negative ? 0x80 : 0x00);
  } else if (negative) {
    buffer[size - 1] |= 0x80;
  }
  return buffer;
}

},{"uint8array-tools":65}],94:[function(require,module,exports){
'use strict';

var __createBinding = void 0 && (void 0).__createBinding || (Object.create ? function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  var desc = Object.getOwnPropertyDescriptor(m, k);
  if (!desc || ('get' in desc ? !m.__esModule : desc.writable || desc.configurable)) {
    desc = {
      enumerable: true,
      get: function get() {
        return m[k];
      }
    };
  }
  Object.defineProperty(o, k2, desc);
} : function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  o[k2] = m[k];
});
var __setModuleDefault = void 0 && (void 0).__setModuleDefault || (Object.create ? function (o, v) {
  Object.defineProperty(o, 'default', {
    enumerable: true,
    value: v
  });
} : function (o, v) {
  o['default'] = v;
});
var __importStar = void 0 && (void 0).__importStar || function (mod) {
  if (mod && mod.__esModule) return mod;
  var result = {};
  if (mod != null) for (var k in mod) if (k !== 'default' && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
  __setModuleDefault(result, mod);
  return result;
};
Object.defineProperty(exports, '__esModule', {
  value: true
});
exports.decode = decode;
exports.encode = encode;
var bip66 = __importStar(require('./bip66.cjs'));
var script_js_1 = require('./script.cjs');
var v = __importStar(require('valibot'));
var tools = __importStar(require('uint8array-tools'));
var types_js_1 = require('./types.cjs');
var ZERO = new Uint8Array(1);
/**
 * Converts a buffer to a DER-encoded buffer.
 * @param x - The buffer to be converted.
 * @returns The DER-encoded buffer.
 */
function toDER(x) {
  var i = 0;
  while (x[i] === 0) ++i;
  if (i === x.length) return ZERO;
  x = x.slice(i);
  if (x[0] & 0x80) return tools.concat([ZERO, x]);
  return x;
}
/**
 * Converts a DER-encoded signature to a buffer.
 * If the first byte of the input buffer is 0x00, it is skipped.
 * The resulting buffer is 32 bytes long, filled with zeros if necessary.
 * @param x - The DER-encoded signature.
 * @returns The converted buffer.
 */
function fromDER(x) {
  if (x[0] === 0x00) x = x.slice(1);
  var buffer = new Uint8Array(32);
  var bstart = Math.max(0, 32 - x.length);
  buffer.set(x, bstart);
  return buffer;
}
// BIP62: 1 byte hashType flag (only 0x01, 0x02, 0x03, 0x81, 0x82 and 0x83 are allowed)
/**
 * Decodes a buffer into a ScriptSignature object.
 * @param buffer - The buffer to decode.
 * @returns The decoded ScriptSignature object.
 * @throws Error if the hashType is invalid.
 */
function decode(buffer) {
  var hashType = tools.readUInt8(buffer, buffer.length - 1);
  if (!(0, script_js_1.isDefinedHashType)(hashType)) {
    throw new Error('Invalid hashType ' + hashType);
  }
  var decoded = bip66.decode(buffer.subarray(0, -1));
  var r = fromDER(decoded.r);
  var s = fromDER(decoded.s);
  var signature = tools.concat([r, s]);
  return {
    signature: signature,
    hashType: hashType
  };
}
/**
 * Encodes a signature and hash type into a buffer.
 * @param signature - The signature to encode.
 * @param hashType - The hash type to encode.
 * @returns The encoded buffer.
 * @throws Error if the hashType is invalid.
 */
function encode(signature, hashType) {
  v.parse(v.object({
    signature: (0, types_js_1.NBufferSchemaFactory)(64),
    hashType: types_js_1.UInt8Schema
  }), {
    signature: signature,
    hashType: hashType
  });
  if (!(0, script_js_1.isDefinedHashType)(hashType)) {
    throw new Error('Invalid hashType ' + hashType);
  }
  var hashTypeBuffer = new Uint8Array(1);
  tools.writeUInt8(hashTypeBuffer, 0, hashType);
  var r = toDER(signature.slice(0, 32));
  var s = toDER(signature.slice(32, 64));
  return tools.concat([bip66.encode(r, s), hashTypeBuffer]);
}

},{"./bip66.cjs":68,"./script.cjs":92,"./types.cjs":96,"uint8array-tools":65,"valibot":66}],95:[function(require,module,exports){
'use strict';

function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function"); }
function _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }
function _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: !1 }), e; }
function _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
var __createBinding = void 0 && (void 0).__createBinding || (Object.create ? function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  var desc = Object.getOwnPropertyDescriptor(m, k);
  if (!desc || ('get' in desc ? !m.__esModule : desc.writable || desc.configurable)) {
    desc = {
      enumerable: true,
      get: function get() {
        return m[k];
      }
    };
  }
  Object.defineProperty(o, k2, desc);
} : function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  o[k2] = m[k];
});
var __setModuleDefault = void 0 && (void 0).__setModuleDefault || (Object.create ? function (o, v) {
  Object.defineProperty(o, 'default', {
    enumerable: true,
    value: v
  });
} : function (o, v) {
  o['default'] = v;
});
var __importStar = void 0 && (void 0).__importStar || function (mod) {
  if (mod && mod.__esModule) return mod;
  var result = {};
  if (mod != null) for (var k in mod) if (k !== 'default' && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
  __setModuleDefault(result, mod);
  return result;
};
Object.defineProperty(exports, '__esModule', {
  value: true
});
exports.Transaction = void 0;
var bufferutils_js_1 = require('./bufferutils.cjs');
var bcrypto = __importStar(require('./crypto.cjs'));
var sha256_1 = require('@noble/hashes/sha256');
var bscript = __importStar(require('./script.cjs'));
var script_js_1 = require('./script.cjs');
var types = __importStar(require('./types.cjs'));
var tools = __importStar(require('uint8array-tools'));
var v = __importStar(require('valibot'));
function varSliceSize(someScript) {
  var length = someScript.length;
  return bufferutils_js_1.varuint.encodingLength(length) + length;
}
function vectorSize(someVector) {
  var length = someVector.length;
  return bufferutils_js_1.varuint.encodingLength(length) + someVector.reduce(function (sum, witness) {
    return sum + varSliceSize(witness);
  }, 0);
}
var EMPTY_BUFFER = new Uint8Array(0);
var EMPTY_WITNESS = [];
var ZERO = tools.fromHex('0000000000000000000000000000000000000000000000000000000000000000');
var ONE = tools.fromHex('0000000000000000000000000000000000000000000000000000000000000001');
var VALUE_UINT64_MAX = tools.fromHex('ffffffffffffffff');
var BLANK_OUTPUT = {
  script: EMPTY_BUFFER,
  valueBuffer: VALUE_UINT64_MAX
};
function isOutput(out) {
  return out.value !== undefined;
}
/**
 * Represents a Bitcoin transaction.
 */
var Transaction = /*#__PURE__*/function () {
  function Transaction() {
    _classCallCheck(this, Transaction);
    _defineProperty(this, "version", 1);
    _defineProperty(this, "locktime", 0);
    _defineProperty(this, "ins", []);
    _defineProperty(this, "outs", []);
  }
  return _createClass(Transaction, [{
    key: "isCoinbase",
    value: function isCoinbase() {
      return this.ins.length === 1 && Transaction.isCoinbaseHash(this.ins[0].hash);
    }
  }, {
    key: "addInput",
    value: function addInput(hash, index, sequence, scriptSig) {
      v.parse(v.tuple([types.Hash256bitSchema, types.UInt32Schema, v.nullable(v.optional(types.UInt32Schema)), v.nullable(v.optional(types.BufferSchema))]), [hash, index, sequence, scriptSig]);
      if (sequence === undefined || sequence === null) {
        sequence = Transaction.DEFAULT_SEQUENCE;
      }
      // Add the input and return the input's index
      return this.ins.push({
        hash: hash,
        index: index,
        script: scriptSig || EMPTY_BUFFER,
        sequence: sequence,
        witness: EMPTY_WITNESS
      }) - 1;
    }
  }, {
    key: "addOutput",
    value: function addOutput(scriptPubKey, value) {
      v.parse(v.tuple([types.BufferSchema, types.SatoshiSchema]), [scriptPubKey, value]);
      // Add the output and return the output's index
      return this.outs.push({
        script: scriptPubKey,
        value: value
      }) - 1;
    }
  }, {
    key: "hasWitnesses",
    value: function hasWitnesses() {
      return this.ins.some(function (x) {
        return x.witness.length !== 0;
      });
    }
  }, {
    key: "weight",
    value: function weight() {
      var base = this.byteLength(false);
      var total = this.byteLength(true);
      return base * 3 + total;
    }
  }, {
    key: "virtualSize",
    value: function virtualSize() {
      return Math.ceil(this.weight() / 4);
    }
  }, {
    key: "byteLength",
    value: function byteLength() {
      var _ALLOW_WITNESS = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;
      var hasWitnesses = _ALLOW_WITNESS && this.hasWitnesses();
      return (hasWitnesses ? 10 : 8) + bufferutils_js_1.varuint.encodingLength(this.ins.length) + bufferutils_js_1.varuint.encodingLength(this.outs.length) + this.ins.reduce(function (sum, input) {
        return sum + 40 + varSliceSize(input.script);
      }, 0) + this.outs.reduce(function (sum, output) {
        return sum + 8 + varSliceSize(output.script);
      }, 0) + (hasWitnesses ? this.ins.reduce(function (sum, input) {
        return sum + vectorSize(input.witness);
      }, 0) : 0);
    }
  }, {
    key: "clone",
    value: function clone() {
      var newTx = new Transaction();
      newTx.version = this.version;
      newTx.locktime = this.locktime;
      newTx.ins = this.ins.map(function (txIn) {
        return {
          hash: txIn.hash,
          index: txIn.index,
          script: txIn.script,
          sequence: txIn.sequence,
          witness: txIn.witness
        };
      });
      newTx.outs = this.outs.map(function (txOut) {
        return {
          script: txOut.script,
          value: txOut.value
        };
      });
      return newTx;
    }
    /**
     * Hash transaction for signing a specific input.
     *
     * Bitcoin uses a different hash for each signed transaction input.
     * This method copies the transaction, makes the necessary changes based on the
     * hashType, and then hashes the result.
     * This hash can then be used to sign the provided transaction input.
     */
  }, {
    key: "hashForSignature",
    value: function hashForSignature(inIndex, prevOutScript, hashType) {
      v.parse(v.tuple([types.UInt32Schema, types.BufferSchema, v.number()]), [inIndex, prevOutScript, hashType]);
      // https://github.com/bitcoin/bitcoin/blob/master/src/test/sighash_tests.cpp#L29
      if (inIndex >= this.ins.length) return ONE;
      // ignore OP_CODESEPARATOR
      var ourScript = bscript.compile(bscript.decompile(prevOutScript).filter(function (x) {
        return x !== script_js_1.OPS.OP_CODESEPARATOR;
      }));
      var txTmp = this.clone();
      // SIGHASH_NONE: ignore all outputs? (wildcard payee)
      if ((hashType & 0x1f) === Transaction.SIGHASH_NONE) {
        txTmp.outs = [];
        // ignore sequence numbers (except at inIndex)
        txTmp.ins.forEach(function (input, i) {
          if (i === inIndex) return;
          input.sequence = 0;
        });
        // SIGHASH_SINGLE: ignore all outputs, except at the same index?
      } else if ((hashType & 0x1f) === Transaction.SIGHASH_SINGLE) {
        // https://github.com/bitcoin/bitcoin/blob/master/src/test/sighash_tests.cpp#L60
        if (inIndex >= this.outs.length) return ONE;
        // truncate outputs after
        txTmp.outs.length = inIndex + 1;
        // "blank" outputs before
        for (var i = 0; i < inIndex; i++) {
          txTmp.outs[i] = BLANK_OUTPUT;
        }
        // ignore sequence numbers (except at inIndex)
        txTmp.ins.forEach(function (input, y) {
          if (y === inIndex) return;
          input.sequence = 0;
        });
      }
      // SIGHASH_ANYONECANPAY: ignore inputs entirely?
      if (hashType & Transaction.SIGHASH_ANYONECANPAY) {
        txTmp.ins = [txTmp.ins[inIndex]];
        txTmp.ins[0].script = ourScript;
        // SIGHASH_ALL: only ignore input scripts
      } else {
        // "blank" others input scripts
        txTmp.ins.forEach(function (input) {
          input.script = EMPTY_BUFFER;
        });
        txTmp.ins[inIndex].script = ourScript;
      }
      // serialize and hash
      var buffer = new Uint8Array(txTmp.byteLength(false) + 4);
      tools.writeInt32(buffer, buffer.length - 4, hashType, 'LE');
      txTmp.__toBuffer(buffer, 0, false);
      return bcrypto.hash256(buffer);
    }
  }, {
    key: "hashForWitnessV1",
    value: function hashForWitnessV1(inIndex, prevOutScripts, values, hashType, leafHash, annex) {
      // https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki#common-signature-message
      v.parse(v.tuple([types.UInt32Schema, v.array(types.BufferSchema), v.array(types.SatoshiSchema), types.UInt32Schema]), [inIndex, prevOutScripts, values, hashType]);
      if (values.length !== this.ins.length || prevOutScripts.length !== this.ins.length) {
        throw new Error('Must supply prevout script and value for all inputs');
      }
      var outputType = hashType === Transaction.SIGHASH_DEFAULT ? Transaction.SIGHASH_ALL : hashType & Transaction.SIGHASH_OUTPUT_MASK;
      var inputType = hashType & Transaction.SIGHASH_INPUT_MASK;
      var isAnyoneCanPay = inputType === Transaction.SIGHASH_ANYONECANPAY;
      var isNone = outputType === Transaction.SIGHASH_NONE;
      var isSingle = outputType === Transaction.SIGHASH_SINGLE;
      var hashPrevouts = EMPTY_BUFFER;
      var hashAmounts = EMPTY_BUFFER;
      var hashScriptPubKeys = EMPTY_BUFFER;
      var hashSequences = EMPTY_BUFFER;
      var hashOutputs = EMPTY_BUFFER;
      if (!isAnyoneCanPay) {
        var bufferWriter = bufferutils_js_1.BufferWriter.withCapacity(36 * this.ins.length);
        this.ins.forEach(function (txIn) {
          bufferWriter.writeSlice(txIn.hash);
          bufferWriter.writeUInt32(txIn.index);
        });
        hashPrevouts = (0, sha256_1.sha256)(bufferWriter.end());
        bufferWriter = bufferutils_js_1.BufferWriter.withCapacity(8 * this.ins.length);
        values.forEach(function (value) {
          return bufferWriter.writeInt64(value);
        });
        hashAmounts = (0, sha256_1.sha256)(bufferWriter.end());
        bufferWriter = bufferutils_js_1.BufferWriter.withCapacity(prevOutScripts.map(varSliceSize).reduce(function (a, b) {
          return a + b;
        }));
        prevOutScripts.forEach(function (prevOutScript) {
          return bufferWriter.writeVarSlice(prevOutScript);
        });
        hashScriptPubKeys = (0, sha256_1.sha256)(bufferWriter.end());
        bufferWriter = bufferutils_js_1.BufferWriter.withCapacity(4 * this.ins.length);
        this.ins.forEach(function (txIn) {
          return bufferWriter.writeUInt32(txIn.sequence);
        });
        hashSequences = (0, sha256_1.sha256)(bufferWriter.end());
      }
      if (!(isNone || isSingle)) {
        if (!this.outs.length) throw new Error('Add outputs to the transaction before signing.');
        var txOutsSize = this.outs.map(function (output) {
          return 8 + varSliceSize(output.script);
        }).reduce(function (a, b) {
          return a + b;
        });
        var _bufferWriter = bufferutils_js_1.BufferWriter.withCapacity(txOutsSize);
        this.outs.forEach(function (out) {
          _bufferWriter.writeInt64(out.value);
          _bufferWriter.writeVarSlice(out.script);
        });
        hashOutputs = (0, sha256_1.sha256)(_bufferWriter.end());
      } else if (isSingle && inIndex < this.outs.length) {
        var output = this.outs[inIndex];
        var _bufferWriter2 = bufferutils_js_1.BufferWriter.withCapacity(8 + varSliceSize(output.script));
        _bufferWriter2.writeInt64(output.value);
        _bufferWriter2.writeVarSlice(output.script);
        hashOutputs = (0, sha256_1.sha256)(_bufferWriter2.end());
      }
      var spendType = (leafHash ? 2 : 0) + (annex ? 1 : 0);
      // Length calculation from:
      // https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki#cite_note-14
      // With extension from:
      // https://github.com/bitcoin/bips/blob/master/bip-0342.mediawiki#signature-validation
      var sigMsgSize = 174 - (isAnyoneCanPay ? 49 : 0) - (isNone ? 32 : 0) + (annex ? 32 : 0) + (leafHash ? 37 : 0);
      var sigMsgWriter = bufferutils_js_1.BufferWriter.withCapacity(sigMsgSize);
      sigMsgWriter.writeUInt8(hashType);
      // Transaction
      sigMsgWriter.writeInt32(this.version);
      sigMsgWriter.writeUInt32(this.locktime);
      sigMsgWriter.writeSlice(hashPrevouts);
      sigMsgWriter.writeSlice(hashAmounts);
      sigMsgWriter.writeSlice(hashScriptPubKeys);
      sigMsgWriter.writeSlice(hashSequences);
      if (!(isNone || isSingle)) {
        sigMsgWriter.writeSlice(hashOutputs);
      }
      // Input
      sigMsgWriter.writeUInt8(spendType);
      if (isAnyoneCanPay) {
        var input = this.ins[inIndex];
        sigMsgWriter.writeSlice(input.hash);
        sigMsgWriter.writeUInt32(input.index);
        sigMsgWriter.writeInt64(values[inIndex]);
        sigMsgWriter.writeVarSlice(prevOutScripts[inIndex]);
        sigMsgWriter.writeUInt32(input.sequence);
      } else {
        sigMsgWriter.writeUInt32(inIndex);
      }
      if (annex) {
        var _bufferWriter3 = bufferutils_js_1.BufferWriter.withCapacity(varSliceSize(annex));
        _bufferWriter3.writeVarSlice(annex);
        sigMsgWriter.writeSlice((0, sha256_1.sha256)(_bufferWriter3.end()));
      }
      // Output
      if (isSingle) {
        sigMsgWriter.writeSlice(hashOutputs);
      }
      // BIP342 extension
      if (leafHash) {
        sigMsgWriter.writeSlice(leafHash);
        sigMsgWriter.writeUInt8(0);
        sigMsgWriter.writeUInt32(0xffffffff);
      }
      // Extra zero byte because:
      // https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki#cite_note-19
      return bcrypto.taggedHash('TapSighash', tools.concat([Uint8Array.from([0x00]), sigMsgWriter.end()]));
    }
  }, {
    key: "hashForWitnessV0",
    value: function hashForWitnessV0(inIndex, prevOutScript, value, hashType) {
      v.parse(v.tuple([types.UInt32Schema, types.BufferSchema, types.SatoshiSchema, types.UInt32Schema]), [inIndex, prevOutScript, value, hashType]);
      var tbuffer = Uint8Array.from([]);
      var bufferWriter;
      var hashOutputs = ZERO;
      var hashPrevouts = ZERO;
      var hashSequence = ZERO;
      if (!(hashType & Transaction.SIGHASH_ANYONECANPAY)) {
        tbuffer = new Uint8Array(36 * this.ins.length);
        bufferWriter = new bufferutils_js_1.BufferWriter(tbuffer, 0);
        this.ins.forEach(function (txIn) {
          bufferWriter.writeSlice(txIn.hash);
          bufferWriter.writeUInt32(txIn.index);
        });
        hashPrevouts = bcrypto.hash256(tbuffer);
      }
      if (!(hashType & Transaction.SIGHASH_ANYONECANPAY) && (hashType & 0x1f) !== Transaction.SIGHASH_SINGLE && (hashType & 0x1f) !== Transaction.SIGHASH_NONE) {
        tbuffer = new Uint8Array(4 * this.ins.length);
        bufferWriter = new bufferutils_js_1.BufferWriter(tbuffer, 0);
        this.ins.forEach(function (txIn) {
          bufferWriter.writeUInt32(txIn.sequence);
        });
        hashSequence = bcrypto.hash256(tbuffer);
      }
      if ((hashType & 0x1f) !== Transaction.SIGHASH_SINGLE && (hashType & 0x1f) !== Transaction.SIGHASH_NONE) {
        var txOutsSize = this.outs.reduce(function (sum, output) {
          return sum + 8 + varSliceSize(output.script);
        }, 0);
        tbuffer = new Uint8Array(txOutsSize);
        bufferWriter = new bufferutils_js_1.BufferWriter(tbuffer, 0);
        this.outs.forEach(function (out) {
          bufferWriter.writeInt64(out.value);
          bufferWriter.writeVarSlice(out.script);
        });
        hashOutputs = bcrypto.hash256(tbuffer);
      } else if ((hashType & 0x1f) === Transaction.SIGHASH_SINGLE && inIndex < this.outs.length) {
        var output = this.outs[inIndex];
        tbuffer = new Uint8Array(8 + varSliceSize(output.script));
        bufferWriter = new bufferutils_js_1.BufferWriter(tbuffer, 0);
        bufferWriter.writeInt64(output.value);
        bufferWriter.writeVarSlice(output.script);
        hashOutputs = bcrypto.hash256(tbuffer);
      }
      tbuffer = new Uint8Array(156 + varSliceSize(prevOutScript));
      bufferWriter = new bufferutils_js_1.BufferWriter(tbuffer, 0);
      var input = this.ins[inIndex];
      bufferWriter.writeInt32(this.version);
      bufferWriter.writeSlice(hashPrevouts);
      bufferWriter.writeSlice(hashSequence);
      bufferWriter.writeSlice(input.hash);
      bufferWriter.writeUInt32(input.index);
      bufferWriter.writeVarSlice(prevOutScript);
      bufferWriter.writeInt64(value);
      bufferWriter.writeUInt32(input.sequence);
      bufferWriter.writeSlice(hashOutputs);
      bufferWriter.writeUInt32(this.locktime);
      bufferWriter.writeUInt32(hashType);
      return bcrypto.hash256(tbuffer);
    }
  }, {
    key: "getHash",
    value: function getHash(forWitness) {
      // wtxid for coinbase is always 32 bytes of 0x00
      if (forWitness && this.isCoinbase()) return new Uint8Array(32);
      return bcrypto.hash256(this.__toBuffer(undefined, undefined, forWitness));
    }
  }, {
    key: "getId",
    value: function getId() {
      // transaction hash's are displayed in reverse order
      return tools.toHex((0, bufferutils_js_1.reverseBuffer)(this.getHash(false)));
    }
  }, {
    key: "toBuffer",
    value: function toBuffer(buffer, initialOffset) {
      return this.__toBuffer(buffer, initialOffset, true);
    }
  }, {
    key: "toHex",
    value: function toHex() {
      return tools.toHex(this.toBuffer(undefined, undefined));
    }
  }, {
    key: "setInputScript",
    value: function setInputScript(index, scriptSig) {
      v.parse(v.tuple([v.number(), types.BufferSchema]), [index, scriptSig]);
      this.ins[index].script = scriptSig;
    }
  }, {
    key: "setWitness",
    value: function setWitness(index, witness) {
      v.parse(v.tuple([v.number(), v.array(types.BufferSchema)]), [index, witness]);
      this.ins[index].witness = witness;
    }
  }, {
    key: "__toBuffer",
    value: function __toBuffer(buffer, initialOffset) {
      var _ALLOW_WITNESS = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
      if (!buffer) buffer = new Uint8Array(this.byteLength(_ALLOW_WITNESS));
      var bufferWriter = new bufferutils_js_1.BufferWriter(buffer, initialOffset || 0);
      bufferWriter.writeInt32(this.version);
      var hasWitnesses = _ALLOW_WITNESS && this.hasWitnesses();
      if (hasWitnesses) {
        bufferWriter.writeUInt8(Transaction.ADVANCED_TRANSACTION_MARKER);
        bufferWriter.writeUInt8(Transaction.ADVANCED_TRANSACTION_FLAG);
      }
      bufferWriter.writeVarInt(this.ins.length);
      this.ins.forEach(function (txIn) {
        bufferWriter.writeSlice(txIn.hash);
        bufferWriter.writeUInt32(txIn.index);
        bufferWriter.writeVarSlice(txIn.script);
        bufferWriter.writeUInt32(txIn.sequence);
      });
      bufferWriter.writeVarInt(this.outs.length);
      this.outs.forEach(function (txOut) {
        if (isOutput(txOut)) {
          bufferWriter.writeInt64(txOut.value);
        } else {
          bufferWriter.writeSlice(txOut.valueBuffer);
        }
        bufferWriter.writeVarSlice(txOut.script);
      });
      if (hasWitnesses) {
        this.ins.forEach(function (input) {
          bufferWriter.writeVector(input.witness);
        });
      }
      bufferWriter.writeUInt32(this.locktime);
      // avoid slicing unless necessary
      if (initialOffset !== undefined) return buffer.slice(initialOffset, bufferWriter.offset);
      return buffer;
    }
  }], [{
    key: "fromBuffer",
    value: function fromBuffer(buffer, _NO_STRICT) {
      var bufferReader = new bufferutils_js_1.BufferReader(buffer);
      var tx = new Transaction();
      tx.version = bufferReader.readInt32();
      var marker = bufferReader.readUInt8();
      var flag = bufferReader.readUInt8();
      var hasWitnesses = false;
      if (marker === Transaction.ADVANCED_TRANSACTION_MARKER && flag === Transaction.ADVANCED_TRANSACTION_FLAG) {
        hasWitnesses = true;
      } else {
        bufferReader.offset -= 2;
      }
      var vinLen = bufferReader.readVarInt();
      for (var i = 0; i < vinLen; ++i) {
        tx.ins.push({
          hash: bufferReader.readSlice(32),
          index: bufferReader.readUInt32(),
          script: bufferReader.readVarSlice(),
          sequence: bufferReader.readUInt32(),
          witness: EMPTY_WITNESS
        });
      }
      var voutLen = bufferReader.readVarInt();
      for (var _i = 0; _i < voutLen; ++_i) {
        tx.outs.push({
          value: bufferReader.readInt64(),
          script: bufferReader.readVarSlice()
        });
      }
      if (hasWitnesses) {
        for (var _i2 = 0; _i2 < vinLen; ++_i2) {
          tx.ins[_i2].witness = bufferReader.readVector();
        }
        // was this pointless?
        if (!tx.hasWitnesses()) throw new Error('Transaction has superfluous witness data');
      }
      tx.locktime = bufferReader.readUInt32();
      if (_NO_STRICT) return tx;
      if (bufferReader.offset !== buffer.length) throw new Error('Transaction has unexpected data');
      return tx;
    }
  }, {
    key: "fromHex",
    value: function fromHex(hex) {
      return Transaction.fromBuffer(tools.fromHex(hex), false);
    }
  }, {
    key: "isCoinbaseHash",
    value: function isCoinbaseHash(buffer) {
      v.parse(types.Hash256bitSchema, buffer);
      for (var i = 0; i < 32; ++i) {
        if (buffer[i] !== 0) return false;
      }
      return true;
    }
  }]);
}();
_defineProperty(Transaction, "DEFAULT_SEQUENCE", 0xffffffff);
_defineProperty(Transaction, "SIGHASH_DEFAULT", 0x00);
_defineProperty(Transaction, "SIGHASH_ALL", 0x01);
_defineProperty(Transaction, "SIGHASH_NONE", 0x02);
_defineProperty(Transaction, "SIGHASH_SINGLE", 0x03);
_defineProperty(Transaction, "SIGHASH_ANYONECANPAY", 0x80);
_defineProperty(Transaction, "SIGHASH_OUTPUT_MASK", 0x03);
_defineProperty(Transaction, "SIGHASH_INPUT_MASK", 0x80);
_defineProperty(Transaction, "ADVANCED_TRANSACTION_MARKER", 0x00);
_defineProperty(Transaction, "ADVANCED_TRANSACTION_FLAG", 0x01);
exports.Transaction = Transaction;

},{"./bufferutils.cjs":70,"./crypto.cjs":71,"./script.cjs":92,"./types.cjs":96,"@noble/hashes/sha256":11,"uint8array-tools":65,"valibot":66}],96:[function(require,module,exports){
'use strict';

function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
function _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
var __createBinding = void 0 && (void 0).__createBinding || (Object.create ? function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  var desc = Object.getOwnPropertyDescriptor(m, k);
  if (!desc || ('get' in desc ? !m.__esModule : desc.writable || desc.configurable)) {
    desc = {
      enumerable: true,
      get: function get() {
        return m[k];
      }
    };
  }
  Object.defineProperty(o, k2, desc);
} : function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  o[k2] = m[k];
});
var __setModuleDefault = void 0 && (void 0).__setModuleDefault || (Object.create ? function (o, v) {
  Object.defineProperty(o, 'default', {
    enumerable: true,
    value: v
  });
} : function (o, v) {
  o['default'] = v;
});
var __importStar = void 0 && (void 0).__importStar || function (mod) {
  if (mod && mod.__esModule) return mod;
  var result = {};
  if (mod != null) for (var k in mod) if (k !== 'default' && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
  __setModuleDefault(result, mod);
  return result;
};
Object.defineProperty(exports, '__esModule', {
  value: true
});
exports.NullablePartial = exports.SatoshiSchema = exports.UInt32Schema = exports.UInt8Schema = exports.HexSchema = exports.BufferSchema = exports.Hash256bitSchema = exports.Hash160bitSchema = exports.Buffer256bitSchema = exports.TAPLEAF_VERSION_MASK = exports.NBufferSchemaFactory = void 0;
exports.stacksEqual = stacksEqual;
exports.isPoint = isPoint;
exports.isTapleaf = isTapleaf;
exports.isTaptree = isTaptree;
var tools = __importStar(require('uint8array-tools'));
var v = __importStar(require('valibot'));
var ZERO32 = new Uint8Array(32);
var EC_P = tools.fromHex('fffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f');
var NBufferSchemaFactory = function NBufferSchemaFactory(size) {
  return v.pipe(v.instance(Uint8Array), v.length(size));
};
exports.NBufferSchemaFactory = NBufferSchemaFactory;
/**
 * Checks if two arrays of Buffers are equal.
 * @param a - The first array of Buffers.
 * @param b - The second array of Buffers.
 * @returns True if the arrays are equal, false otherwise.
 */
function stacksEqual(a, b) {
  if (a.length !== b.length) return false;
  return a.every(function (x, i) {
    return tools.compare(x, b[i]) === 0;
  });
}
/**
 * Checks if the given value is a valid elliptic curve point.
 * @param p - The value to check.
 * @returns True if the value is a valid elliptic curve point, false otherwise.
 */
function isPoint(p) {
  if (!(p instanceof Uint8Array)) return false;
  if (p.length < 33) return false;
  var t = p[0];
  var x = p.slice(1, 33);
  if (tools.compare(ZERO32, x) === 0) return false;
  if (tools.compare(x, EC_P) >= 0) return false;
  if ((t === 0x02 || t === 0x03) && p.length === 33) {
    return true;
  }
  var y = p.slice(33);
  if (tools.compare(ZERO32, y) === 0) return false;
  if (tools.compare(y, EC_P) >= 0) return false;
  if (t === 0x04 && p.length === 65) return true;
  return false;
}
exports.TAPLEAF_VERSION_MASK = 0xfe;
function isTapleaf(o) {
  if (!o || !('output' in o)) return false;
  if (!(o.output instanceof Uint8Array)) return false;
  if (o.version !== undefined) return (o.version & exports.TAPLEAF_VERSION_MASK) === o.version;
  return true;
}
function isTaptree(scriptTree) {
  if (!Array.isArray(scriptTree)) return isTapleaf(scriptTree);
  if (scriptTree.length !== 2) return false;
  return scriptTree.every(function (t) {
    return isTaptree(t);
  });
}
exports.Buffer256bitSchema = (0, exports.NBufferSchemaFactory)(32);
exports.Hash160bitSchema = (0, exports.NBufferSchemaFactory)(20);
exports.Hash256bitSchema = (0, exports.NBufferSchemaFactory)(32);
exports.BufferSchema = v.instance(Uint8Array);
exports.HexSchema = v.pipe(v.string(), v.regex(/^([0-9a-f]{2})+$/i));
exports.UInt8Schema = v.pipe(v.number(), v.integer(), v.minValue(0), v.maxValue(0xff));
exports.UInt32Schema = v.pipe(v.number(), v.integer(), v.minValue(0), v.maxValue(0xffffffff));
exports.SatoshiSchema = v.pipe(v.bigint(), v.minValue(0n), v.maxValue(0x7fffffffffffffffn));
var NullablePartial = function NullablePartial(a) {
  return v.object(Object.entries(a).reduce(function (acc, next) {
    return _objectSpread(_objectSpread({}, acc), {}, _defineProperty({}, next[0], v.nullish(next[1])));
  }, {}));
};
exports.NullablePartial = NullablePartial;

},{"uint8array-tools":65,"valibot":66}],97:[function(require,module,exports){
"use strict";

},{}],98:[function(require,module,exports){
"use strict";

var __importDefault = void 0 && (void 0).__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};
Object.defineProperty(exports, "__esModule", {
  value: true
});
var base_x_1 = __importDefault(require("base-x"));
var ALPHABET = '123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz';
exports["default"] = (0, base_x_1["default"])(ALPHABET);

},{"base-x":15}],99:[function(require,module,exports){
'use strict';

var __importDefault = void 0 && (void 0).__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = default_1;
var bs58_1 = __importDefault(require("bs58"));
function default_1(checksumFn) {
  // Encode a buffer as a base58-check encoded string
  function encode(payload) {
    var payloadU8 = Uint8Array.from(payload);
    var checksum = checksumFn(payloadU8);
    var length = payloadU8.length + 4;
    var both = new Uint8Array(length);
    both.set(payloadU8, 0);
    both.set(checksum.subarray(0, 4), payloadU8.length);
    return bs58_1["default"].encode(both);
  }
  function decodeRaw(buffer) {
    var payload = buffer.slice(0, -4);
    var checksum = buffer.slice(-4);
    var newChecksum = checksumFn(payload);
    // eslint-disable-next-line
    if (checksum[0] ^ newChecksum[0] | checksum[1] ^ newChecksum[1] | checksum[2] ^ newChecksum[2] | checksum[3] ^ newChecksum[3]) return;
    return payload;
  }
  // Decode a base58-check encoded string to a buffer, no result if checksum is wrong
  function decodeUnsafe(str) {
    var buffer = bs58_1["default"].decodeUnsafe(str);
    if (buffer == null) return;
    return decodeRaw(buffer);
  }
  function decode(str) {
    var buffer = bs58_1["default"].decode(str);
    var payload = decodeRaw(buffer);
    if (payload == null) throw new Error('Invalid checksum');
    return payload;
  }
  return {
    encode: encode,
    decode: decode,
    decodeUnsafe: decodeUnsafe
  };
}

},{"bs58":98}],100:[function(require,module,exports){
'use strict';

var __importDefault = void 0 && (void 0).__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};
Object.defineProperty(exports, "__esModule", {
  value: true
});
var sha256_1 = require("@noble/hashes/sha256");
var base_js_1 = __importDefault(require("./base.cjs"));
// SHA256(SHA256(buffer))
function sha256x2(buffer) {
  return (0, sha256_1.sha256)((0, sha256_1.sha256)(buffer));
}
exports["default"] = (0, base_js_1["default"])(sha256x2);

},{"./base.cjs":99,"@noble/hashes/sha256":11}],101:[function(require,module,exports){
'use strict';

function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function"); }
function _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }
function _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: !1 }), e; }
function _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
var __createBinding = void 0 && (void 0).__createBinding || (Object.create ? function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  var desc = Object.getOwnPropertyDescriptor(m, k);
  if (!desc || ('get' in desc ? !m.__esModule : desc.writable || desc.configurable)) {
    desc = {
      enumerable: true,
      get: function get() {
        return m[k];
      }
    };
  }
  Object.defineProperty(o, k2, desc);
} : function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  o[k2] = m[k];
});
var __setModuleDefault = void 0 && (void 0).__setModuleDefault || (Object.create ? function (o, v) {
  Object.defineProperty(o, 'default', {
    enumerable: true,
    value: v
  });
} : function (o, v) {
  o['default'] = v;
});
var __importStar = void 0 && (void 0).__importStar || function (mod) {
  if (mod && mod.__esModule) return mod;
  var result = {};
  if (mod != null) for (var k in mod) if (k !== 'default' && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
  __setModuleDefault(result, mod);
  return result;
};
Object.defineProperty(exports, '__esModule', {
  value: true
});
exports.networks = void 0;
exports.ECPairFactory = ECPairFactory;
var networks = __importStar(require('./networks.cjs'));
exports.networks = networks;
var types = __importStar(require('./types.cjs'));
var wif = __importStar(require('wif'));
var testecc_1 = require('./testecc.cjs');
var v = __importStar(require('valibot'));
var tools = __importStar(require('uint8array-tools'));
var ECPairOptionsSchema = v.optional(v.object({
  compressed: v.optional(v["boolean"]()),
  network: v.optional(types.NetworkSchema),
  // https://github.com/fabian-hiller/valibot/issues/243#issuecomment-2182514063
  rng: v.optional(v.pipe(v.instance(Function), v.transform(function (func) {
    return function (arg) {
      var parsedArg = v.parse(v.optional(v.number()), arg);
      var returnedValue = func(parsedArg);
      var parsedReturn = v.parse(v.instance(Uint8Array), returnedValue);
      return parsedReturn;
    };
  })))
}));
var toXOnly = function toXOnly(pubKey) {
  return pubKey.length === 32 ? pubKey : pubKey.subarray(1, 33);
};
function ECPairFactory(ecc) {
  (0, testecc_1.testEcc)(ecc);
  function isPoint(maybePoint) {
    return ecc.isPoint(maybePoint);
  }
  function fromPrivateKey(buffer, options) {
    v.parse(types.Buffer256Bit, buffer);
    if (!ecc.isPrivate(buffer)) throw new TypeError('Private key not in range [1, n)');
    v.parse(ECPairOptionsSchema, options);
    return new ECPair(buffer, undefined, options);
  }
  function fromPublicKey(buffer, options) {
    if (!ecc.isPoint(buffer)) {
      throw new Error('Point not on the curve');
    }
    v.parse(ECPairOptionsSchema, options);
    return new ECPair(undefined, buffer, options);
  }
  function fromWIF(wifString, network) {
    var decoded = wif.decode(wifString);
    var version = decoded.version;
    // list of networks?
    if (Array.isArray(network)) {
      network = network.filter(function (x) {
        return version === x.wif;
      }).pop();
      if (!network) throw new Error('Unknown network version');
      // otherwise, assume a network object (or default to bitcoin)
    } else {
      network = network || networks.bitcoin;
      if (version !== network.wif) throw new Error('Invalid network version');
    }
    return fromPrivateKey(decoded.privateKey, {
      compressed: decoded.compressed,
      network: network
    });
  }
  function makeRandom(options) {
    v.parse(ECPairOptionsSchema, options);
    if (options === undefined) options = {};
    var rng = options.rng || function (size) {
      return crypto.getRandomValues(new Uint8Array(size));
    };
    var d;
    do {
      d = rng(32);
      v.parse(types.Buffer256Bit, d);
    } while (!ecc.isPrivate(d));
    return fromPrivateKey(d, options);
  }
  var ECPair = /*#__PURE__*/function () {
    function ECPair(__D, __Q, options) {
      _classCallCheck(this, ECPair);
      _defineProperty(this, "__D", void 0);
      _defineProperty(this, "__Q", void 0);
      _defineProperty(this, "compressed", void 0);
      _defineProperty(this, "network", void 0);
      _defineProperty(this, "lowR", void 0);
      this.__D = __D;
      this.__Q = __Q;
      this.lowR = false;
      if (options === undefined) options = {};
      this.compressed = options.compressed === undefined ? true : options.compressed;
      this.network = options.network || networks.bitcoin;
      if (__Q !== undefined) this.__Q = ecc.pointCompress(__Q, this.compressed);
    }
    return _createClass(ECPair, [{
      key: "privateKey",
      get: function get() {
        return this.__D;
      }
    }, {
      key: "publicKey",
      get: function get() {
        if (!this.__Q) {
          // It is not possible for both `__Q` and `__D` to be `undefined` at the same time.
          // The factory methods guard for this.
          var p = ecc.pointFromScalar(this.__D, this.compressed);
          // It is not possible for `p` to be null.
          // `fromPrivateKey()` checks that `__D` is a valid scalar.
          this.__Q = p;
        }
        return this.__Q;
      }
    }, {
      key: "toWIF",
      value: function toWIF() {
        if (!this.__D) throw new Error('Missing private key');
        return wif.encode({
          compressed: this.compressed,
          privateKey: this.__D,
          version: this.network.wif
        });
      }
    }, {
      key: "tweak",
      value: function tweak(t) {
        if (this.privateKey) return this.tweakFromPrivateKey(t);
        return this.tweakFromPublicKey(t);
      }
    }, {
      key: "sign",
      value: function sign(hash, lowR) {
        if (!this.__D) throw new Error('Missing private key');
        if (lowR === undefined) lowR = this.lowR;
        if (lowR === false) {
          return ecc.sign(hash, this.__D);
        } else {
          var sig = ecc.sign(hash, this.__D);
          var extraData = new Uint8Array(32);
          var counter = 0;
          // if first try is lowR, skip the loop
          // for second try and on, add extra entropy counting up
          while (sig[0] > 0x7f) {
            counter++;
            tools.writeUInt32(extraData, 0, counter, 'LE');
            sig = ecc.sign(hash, this.__D, extraData);
          }
          return sig;
        }
      }
    }, {
      key: "signSchnorr",
      value: function signSchnorr(hash) {
        if (!this.privateKey) throw new Error('Missing private key');
        if (!ecc.signSchnorr) throw new Error('signSchnorr not supported by ecc library');
        return ecc.signSchnorr(hash, this.privateKey);
      }
    }, {
      key: "verify",
      value: function verify(hash, signature) {
        return ecc.verify(hash, this.publicKey, signature);
      }
    }, {
      key: "verifySchnorr",
      value: function verifySchnorr(hash, signature) {
        if (!ecc.verifySchnorr) throw new Error('verifySchnorr not supported by ecc library');
        return ecc.verifySchnorr(hash, this.publicKey.subarray(1, 33), signature);
      }
    }, {
      key: "tweakFromPublicKey",
      value: function tweakFromPublicKey(t) {
        var xOnlyPubKey = toXOnly(this.publicKey);
        var tweakedPublicKey = ecc.xOnlyPointAddTweak(xOnlyPubKey, t);
        if (!tweakedPublicKey || tweakedPublicKey.xOnlyPubkey === null) throw new Error('Cannot tweak public key!');
        var parityByte = Uint8Array.from([tweakedPublicKey.parity === 0 ? 0x02 : 0x03]);
        return fromPublicKey(tools.concat([parityByte, tweakedPublicKey.xOnlyPubkey]), {
          network: this.network,
          compressed: this.compressed
        });
      }
    }, {
      key: "tweakFromPrivateKey",
      value: function tweakFromPrivateKey(t) {
        var hasOddY = this.publicKey[0] === 3 || this.publicKey[0] === 4 && (this.publicKey[64] & 1) === 1;
        var privateKey = hasOddY ? ecc.privateNegate(this.privateKey) : this.privateKey;
        var tweakedPrivateKey = ecc.privateAdd(privateKey, t);
        if (!tweakedPrivateKey) throw new Error('Invalid tweaked private key!');
        return fromPrivateKey(tweakedPrivateKey, {
          network: this.network,
          compressed: this.compressed
        });
      }
    }]);
  }();
  return {
    isPoint: isPoint,
    fromPrivateKey: fromPrivateKey,
    fromPublicKey: fromPublicKey,
    fromWIF: fromWIF,
    makeRandom: makeRandom
  };
}

},{"./networks.cjs":103,"./testecc.cjs":104,"./types.cjs":105,"uint8array-tools":107,"valibot":108,"wif":110}],102:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});
exports.networks = exports.ECPairFactory = exports["default"] = void 0;
var ecpair_1 = require('./ecpair.cjs');
Object.defineProperty(exports, 'default', {
  enumerable: true,
  get: function get() {
    return ecpair_1.ECPairFactory;
  }
});
Object.defineProperty(exports, 'ECPairFactory', {
  enumerable: true,
  get: function get() {
    return ecpair_1.ECPairFactory;
  }
});
Object.defineProperty(exports, 'networks', {
  enumerable: true,
  get: function get() {
    return ecpair_1.networks;
  }
});

},{"./ecpair.cjs":101}],103:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});
exports.testnet = exports.bitcoin = void 0;
exports.bitcoin = {
  messagePrefix: '\x18Bitcoin Signed Message:\n',
  bech32: 'bc',
  bip32: {
    "public": 0x0488b21e,
    "private": 0x0488ade4
  },
  pubKeyHash: 0x00,
  scriptHash: 0x05,
  wif: 0x80
};
exports.testnet = {
  messagePrefix: '\x18Bitcoin Signed Message:\n',
  bech32: 'tb',
  bip32: {
    "public": 0x043587cf,
    "private": 0x04358394
  },
  pubKeyHash: 0x6f,
  scriptHash: 0xc4,
  wif: 0xef
};

},{}],104:[function(require,module,exports){
(function (Buffer){(function (){
'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});
exports.testEcc = testEcc;
var h = function h(hex) {
  return Buffer.from(hex, 'hex');
};
function testEcc(ecc) {
  assert(ecc.isPoint(h('0279be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798')));
  assert(!ecc.isPoint(h('030000000000000000000000000000000000000000000000000000000000000005')));
  assert(ecc.isPrivate(h('79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798')));
  // order - 1
  assert(ecc.isPrivate(h('fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364140')));
  // 0
  assert(!ecc.isPrivate(h('0000000000000000000000000000000000000000000000000000000000000000')));
  // order
  assert(!ecc.isPrivate(h('fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141')));
  // order + 1
  assert(!ecc.isPrivate(h('fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364142')));
  // 1 + 0 == 1
  assert(Buffer.from(ecc.privateAdd(h('0000000000000000000000000000000000000000000000000000000000000001'), h('0000000000000000000000000000000000000000000000000000000000000000'))).equals(h('0000000000000000000000000000000000000000000000000000000000000001')));
  // -3 + 3 == 0
  assert(ecc.privateAdd(h('fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd036413e'), h('0000000000000000000000000000000000000000000000000000000000000003')) === null);
  assert(Buffer.from(ecc.privateAdd(h('e211078564db65c3ce7704f08262b1f38f1ef412ad15b5ac2d76657a63b2c500'), h('b51fbb69051255d1becbd683de5848242a89c229348dd72896a87ada94ae8665'))).equals(h('9730c2ee69edbb958d42db7460bafa18fef9d955325aec99044c81c8282b0a24')));
  assert(Buffer.from(ecc.privateNegate(h('0000000000000000000000000000000000000000000000000000000000000001'))).equals(h('fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364140')));
  assert(Buffer.from(ecc.privateNegate(h('fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd036413e'))).equals(h('0000000000000000000000000000000000000000000000000000000000000003')));
  assert(Buffer.from(ecc.privateNegate(h('b1121e4088a66a28f5b6b0f5844943ecd9f610196d7bb83b25214b60452c09af'))).equals(h('4eede1bf775995d70a494f0a7bb6bc11e0b8cccd41cce8009ab1132c8b0a3792')));
  assert(Buffer.from(ecc.pointCompress(h('0479be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8'), true)).equals(h('0279be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798')));
  assert(Buffer.from(ecc.pointCompress(h('0479be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8'), false)).equals(h('0479be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8')));
  assert(Buffer.from(ecc.pointCompress(h('0279be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798'), true)).equals(h('0279be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798')));
  assert(Buffer.from(ecc.pointCompress(h('0279be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798'), false)).equals(h('0479be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8')));
  assert(Buffer.from(ecc.pointFromScalar(h('b1121e4088a66a28f5b6b0f5844943ecd9f610196d7bb83b25214b60452c09af'))).equals(h('02b07ba9dca9523b7ef4bd97703d43d20399eb698e194704791a25ce77a400df99')));
  assert(ecc.xOnlyPointAddTweak(h('79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798'), h('fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364140')) === null);
  var xOnlyRes = ecc.xOnlyPointAddTweak(h('1617d38ed8d8657da4d4761e8057bc396ea9e4b9d29776d4be096016dbd2509b'), h('a8397a935f0dfceba6ba9618f6451ef4d80637abf4e6af2669fbc9de6a8fd2ac'));
  assert(Buffer.from(xOnlyRes.xOnlyPubkey).equals(h('e478f99dab91052ab39a33ea35fd5e6e4933f4d28023cd597c9a1f6760346adf')) && xOnlyRes.parity === 1);
  xOnlyRes = ecc.xOnlyPointAddTweak(h('2c0b7cf95324a07d05398b240174dc0c2be444d96b159aa6c7f7b1e668680991'), h('823c3cd2142744b075a87eade7e1b8678ba308d566226a0056ca2b7a76f86b47'));
  assert(Buffer.from(xOnlyRes.xOnlyPubkey).equals(h('9534f8dc8c6deda2dc007655981c78b49c5d96c778fbf363462a11ec9dfd948c')) && xOnlyRes.parity === 0);
  assert(Buffer.from(ecc.sign(h('5e9f0a0d593efdcf78ac923bc3313e4e7d408d574354ee2b3288c0da9fbba6ed'), h('fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364140'))).equals(h('54c4a33c6423d689378f160a7ff8b61330444abb58fb470f96ea16d99d4a2fed07082304410efa6b2943111b6a4e0aaa7b7db55a07e9861d1fb3cb1f421044a5')));
  assert(ecc.verify(h('5e9f0a0d593efdcf78ac923bc3313e4e7d408d574354ee2b3288c0da9fbba6ed'), h('0379be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798'), h('54c4a33c6423d689378f160a7ff8b61330444abb58fb470f96ea16d99d4a2fed07082304410efa6b2943111b6a4e0aaa7b7db55a07e9861d1fb3cb1f421044a5')));
  if (ecc.signSchnorr) {
    assert(Buffer.from(ecc.signSchnorr(h('7e2d58d8b3bcdf1abadec7829054f90dda9805aab56c77333024b9d0a508b75c'), h('c90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b14e5c9'), h('c87aa53824b4d7ae2eb035a2b5bbbccc080e76cdc6d1692c4b0b62d798e6d906'))).equals(h('5831aaeed7b44bb74e5eab94ba9d4294c49bcf2a60728d8b4c200f50dd313c1bab745879a5ad954a72c45a91c3a51d3c7adea98d82f8481e0e1e03674a6f3fb7')));
  }
  if (ecc.verifySchnorr) {
    assert(ecc.verifySchnorr(h('7e2d58d8b3bcdf1abadec7829054f90dda9805aab56c77333024b9d0a508b75c'), h('dd308afec5777e13121fa72b9cc1b7cc0139715309b086c960e18fd969774eb8'), h('5831aaeed7b44bb74e5eab94ba9d4294c49bcf2a60728d8b4c200f50dd313c1bab745879a5ad954a72c45a91c3a51d3c7adea98d82f8481e0e1e03674a6f3fb7')));
  }
}
function assert(bool) {
  if (!bool) throw new Error('ecc library invalid');
}

}).call(this)}).call(this,require("buffer").Buffer)
},{"buffer":"buffer"}],105:[function(require,module,exports){
'use strict';

var __createBinding = void 0 && (void 0).__createBinding || (Object.create ? function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  var desc = Object.getOwnPropertyDescriptor(m, k);
  if (!desc || ('get' in desc ? !m.__esModule : desc.writable || desc.configurable)) {
    desc = {
      enumerable: true,
      get: function get() {
        return m[k];
      }
    };
  }
  Object.defineProperty(o, k2, desc);
} : function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  o[k2] = m[k];
});
var __setModuleDefault = void 0 && (void 0).__setModuleDefault || (Object.create ? function (o, v) {
  Object.defineProperty(o, 'default', {
    enumerable: true,
    value: v
  });
} : function (o, v) {
  o['default'] = v;
});
var __importStar = void 0 && (void 0).__importStar || function (mod) {
  if (mod && mod.__esModule) return mod;
  var result = {};
  if (mod != null) for (var k in mod) if (k !== 'default' && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
  __setModuleDefault(result, mod);
  return result;
};
Object.defineProperty(exports, '__esModule', {
  value: true
});
exports.Buffer256Bit = exports.NetworkSchema = void 0;
var v = __importStar(require('valibot'));
var Uint32Schema = v.pipe(v.number(), v.integer(), v.minValue(0), v.maxValue(0xffffffff));
var Uint8Schema = v.pipe(v.number(), v.integer(), v.minValue(0), v.maxValue(0xff));
exports.NetworkSchema = v.object({
  messagePrefix: v.union([v.string(), v.instance(Uint8Array)]),
  bech32: v.string(),
  bip32: v.object({
    "public": Uint32Schema,
    "private": Uint32Schema
  }),
  pubKeyHash: Uint8Schema,
  scriptHash: Uint8Schema,
  wif: Uint8Schema
});
exports.Buffer256Bit = v.pipe(v.instance(Uint8Array), v.length(32));

},{"valibot":108}],106:[function(require,module,exports){
"use strict";

/*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */
exports.read = function (buffer, offset, isLE, mLen, nBytes) {
  var e, m;
  var eLen = nBytes * 8 - mLen - 1;
  var eMax = (1 << eLen) - 1;
  var eBias = eMax >> 1;
  var nBits = -7;
  var i = isLE ? nBytes - 1 : 0;
  var d = isLE ? -1 : 1;
  var s = buffer[offset + i];
  i += d;
  e = s & (1 << -nBits) - 1;
  s >>= -nBits;
  nBits += eLen;
  for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {}
  m = e & (1 << -nBits) - 1;
  e >>= -nBits;
  nBits += mLen;
  for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {}
  if (e === 0) {
    e = 1 - eBias;
  } else if (e === eMax) {
    return m ? NaN : (s ? -1 : 1) * Infinity;
  } else {
    m = m + Math.pow(2, mLen);
    e = e - eBias;
  }
  return (s ? -1 : 1) * m * Math.pow(2, e - mLen);
};
exports.write = function (buffer, value, offset, isLE, mLen, nBytes) {
  var e, m, c;
  var eLen = nBytes * 8 - mLen - 1;
  var eMax = (1 << eLen) - 1;
  var eBias = eMax >> 1;
  var rt = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;
  var i = isLE ? 0 : nBytes - 1;
  var d = isLE ? 1 : -1;
  var s = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;
  value = Math.abs(value);
  if (isNaN(value) || value === Infinity) {
    m = isNaN(value) ? 1 : 0;
    e = eMax;
  } else {
    e = Math.floor(Math.log(value) / Math.LN2);
    if (value * (c = Math.pow(2, -e)) < 1) {
      e--;
      c *= 2;
    }
    if (e + eBias >= 1) {
      value += rt / c;
    } else {
      value += rt * Math.pow(2, 1 - eBias);
    }
    if (value * c >= 2) {
      e++;
      c /= 2;
    }
    if (e + eBias >= eMax) {
      m = 0;
      e = eMax;
    } else if (e + eBias >= 1) {
      m = (value * c - 1) * Math.pow(2, mLen);
      e = e + eBias;
    } else {
      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
      e = 0;
    }
  }
  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}
  e = e << mLen | m;
  eLen += mLen;
  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}
  buffer[offset + i - d] |= s * 128;
};

},{}],107:[function(require,module,exports){
(function (Buffer){(function (){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.readUInt64 = exports.readUInt32 = exports.readUInt16 = exports.readUInt8 = exports.writeUInt64 = exports.writeUInt32 = exports.writeUInt16 = exports.writeUInt8 = exports.compare = exports.fromBase64 = exports.toBase64 = exports.fromHex = exports.toHex = exports.concat = exports.fromUtf8 = exports.toUtf8 = void 0;
function toUtf8(bytes) {
  return Buffer.from(bytes || []).toString();
}
exports.toUtf8 = toUtf8;
function fromUtf8(s) {
  return Uint8Array.from(Buffer.from(s || "", "utf8"));
}
exports.fromUtf8 = fromUtf8;
function concat(arrays) {
  return Uint8Array.from(Buffer.concat(arrays));
}
exports.concat = concat;
function toHex(bytes) {
  return Buffer.from(bytes || []).toString("hex");
}
exports.toHex = toHex;
function fromHex(hexString) {
  return Uint8Array.from(Buffer.from(hexString || "", "hex"));
}
exports.fromHex = fromHex;
function toBase64(bytes) {
  return Buffer.from(bytes).toString("base64");
}
exports.toBase64 = toBase64;
function fromBase64(base64) {
  return Uint8Array.from(Buffer.from(base64 || "", "base64"));
}
exports.fromBase64 = fromBase64;
function compare(v1, v2) {
  return Buffer.from(v1).compare(Buffer.from(v2));
}
exports.compare = compare;
function writeUInt8(buffer, offset, value) {
  if (offset + 1 > buffer.length) {
    throw new Error("Offset is outside the bounds of Uint8Array");
  }
  var buf = Buffer.alloc(1);
  buf.writeUInt8(value, 0);
  buffer.set(Uint8Array.from(buf), offset);
}
exports.writeUInt8 = writeUInt8;
function writeUInt16(buffer, offset, value, littleEndian) {
  if (offset + 2 > buffer.length) {
    throw new Error("Offset is outside the bounds of Uint8Array");
  }
  littleEndian = littleEndian.toUpperCase();
  var buf = Buffer.alloc(2);
  if (littleEndian === "LE") {
    buf.writeUInt16LE(value, 0);
  } else {
    buf.writeUInt16BE(value, 0);
  }
  buffer.set(Uint8Array.from(buf), offset);
}
exports.writeUInt16 = writeUInt16;
function writeUInt32(buffer, offset, value, littleEndian) {
  if (offset + 4 > buffer.length) {
    throw new Error("Offset is outside the bounds of Uint8Array");
  }
  littleEndian = littleEndian.toUpperCase();
  var buf = Buffer.alloc(4);
  if (littleEndian === "LE") {
    buf.writeUInt32LE(value, 0);
  } else {
    buf.writeUInt32BE(value, 0);
  }
  buffer.set(Uint8Array.from(buf), offset);
}
exports.writeUInt32 = writeUInt32;
function writeUInt64(buffer, offset, value, littleEndian) {
  if (offset + 8 > buffer.length) {
    throw new Error("Offset is outside the bounds of Uint8Array");
  }
  littleEndian = littleEndian.toUpperCase();
  var buf = Buffer.alloc(8);
  if (value > 0xffffffffffffffffn) {
    throw new Error("The value of \"value\" is out of range. It must be >= 0 and <= ".concat(0xffffffffffffffffn, ". Received ", value));
  }
  if (littleEndian === "LE") {
    buf.writeBigUInt64LE(value, 0);
  } else {
    buf.writeBigUInt64BE(value, 0);
  }
  buffer.set(Uint8Array.from(buf), offset);
}
exports.writeUInt64 = writeUInt64;
function readUInt8(buffer, offset) {
  if (offset + 1 > buffer.length) {
    throw new Error("Offset is outside the bounds of Uint8Array");
  }
  var buf = Buffer.from(buffer);
  return buf.readUInt8(offset);
}
exports.readUInt8 = readUInt8;
function readUInt16(buffer, offset, littleEndian) {
  if (offset + 2 > buffer.length) {
    throw new Error("Offset is outside the bounds of Uint8Array");
  }
  littleEndian = littleEndian.toUpperCase();
  var buf = Buffer.from(buffer);
  if (littleEndian === "LE") {
    return buf.readUInt16LE(offset);
  } else {
    return buf.readUInt16BE(offset);
  }
}
exports.readUInt16 = readUInt16;
function readUInt32(buffer, offset, littleEndian) {
  if (offset + 4 > buffer.length) {
    throw new Error("Offset is outside the bounds of Uint8Array");
  }
  littleEndian = littleEndian.toUpperCase();
  var buf = Buffer.from(buffer);
  if (littleEndian === "LE") {
    return buf.readUInt32LE(offset);
  } else {
    return buf.readUInt32BE(offset);
  }
}
exports.readUInt32 = readUInt32;
function readUInt64(buffer, offset, littleEndian) {
  if (offset + 8 > buffer.length) {
    throw new Error("Offset is outside the bounds of Uint8Array");
  }
  littleEndian = littleEndian.toUpperCase();
  var buf = Buffer.from(buffer);
  if (littleEndian === "LE") {
    return buf.readBigUInt64LE(offset);
  } else {
    return buf.readBigUInt64BE(offset);
  }
}
exports.readUInt64 = readUInt64;

}).call(this)}).call(this,require("buffer").Buffer)
},{"buffer":"buffer"}],108:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ValiError = exports.UUID_REGEX = exports.ULID_REGEX = exports.OCTAL_REGEX = exports.MAC_REGEX = exports.MAC64_REGEX = exports.MAC48_REGEX = exports.ISO_WEEK_REGEX = exports.ISO_TIME_SECOND_REGEX = exports.ISO_TIME_REGEX = exports.ISO_TIMESTAMP_REGEX = exports.ISO_DATE_TIME_REGEX = exports.ISO_DATE_REGEX = exports.IP_REGEX = exports.IPV6_REGEX = exports.IPV4_REGEX = exports.IMEI_REGEX = exports.HEX_COLOR_REGEX = exports.HEXADECIMAL_REGEX = exports.EMOJI_REGEX = exports.EMAIL_REGEX = exports.DECIMAL_REGEX = exports.CUID2_REGEX = exports.BIC_REGEX = exports.BASE64_REGEX = void 0;
exports._addIssue = _addIssue;
exports._isLuhnAlgo = _isLuhnAlgo;
exports._isValidObjectKey = _isValidObjectKey;
exports._stringify = _stringify;
exports.any = any;
exports.array = array;
exports.arrayAsync = arrayAsync;
exports.awaitAsync = awaitAsync;
exports.base64 = base64;
exports.bic = bic;
exports.bigint = bigint;
exports.blob = blob;
exports["boolean"] = _boolean;
exports.brand = brand;
exports.bytes = bytes;
exports.check = check;
exports.checkAsync = checkAsync;
exports.checkItems = checkItems;
exports.config = config;
exports.creditCard = creditCard;
exports.cuid2 = cuid2;
exports.custom = custom;
exports.customAsync = customAsync;
exports.date = date;
exports.decimal = decimal;
exports.deleteGlobalConfig = deleteGlobalConfig;
exports.deleteGlobalMessage = deleteGlobalMessage;
exports.deleteSchemaMessage = deleteSchemaMessage;
exports.deleteSpecificMessage = deleteSpecificMessage;
exports.description = description;
exports.email = email;
exports.emoji = emoji;
exports.empty = empty;
exports.endsWith = endsWith;
exports.entriesFromList = entriesFromList;
exports.enum_ = exports["enum"] = enum_;
exports.everyItem = everyItem;
exports.excludes = excludes;
exports.fallback = fallback;
exports.fallbackAsync = fallbackAsync;
exports.file = file;
exports.filterItems = filterItems;
exports.findItem = findItem;
exports.finite = finite;
exports.flatten = flatten;
exports.forward = forward;
exports.forwardAsync = forwardAsync;
exports.function_ = exports["function"] = function_;
exports.getDefault = getDefault;
exports.getDefaults = getDefaults;
exports.getDefaultsAsync = getDefaultsAsync;
exports.getDotPath = getDotPath;
exports.getFallback = getFallback;
exports.getFallbacks = getFallbacks;
exports.getFallbacksAsync = getFallbacksAsync;
exports.getGlobalConfig = getGlobalConfig;
exports.getGlobalMessage = getGlobalMessage;
exports.getSchemaMessage = getSchemaMessage;
exports.getSpecificMessage = getSpecificMessage;
exports.hash = hash;
exports.hexColor = hexColor;
exports.hexadecimal = hexadecimal;
exports.imei = imei;
exports.includes = includes;
exports.instance = instance;
exports.integer = integer;
exports.intersect = intersect;
exports.intersectAsync = intersectAsync;
exports.ip = ip;
exports.ipv4 = ipv4;
exports.ipv6 = ipv6;
exports.is = is;
exports.isOfKind = isOfKind;
exports.isOfType = isOfType;
exports.isValiError = isValiError;
exports.isoDate = isoDate;
exports.isoDateTime = isoDateTime;
exports.isoTime = isoTime;
exports.isoTimeSecond = isoTimeSecond;
exports.isoTimestamp = isoTimestamp;
exports.isoWeek = isoWeek;
exports.keyof = keyof;
exports.lazy = lazy;
exports.lazyAsync = lazyAsync;
exports.length = length;
exports.literal = literal;
exports.looseObject = looseObject;
exports.looseObjectAsync = looseObjectAsync;
exports.looseTuple = looseTuple;
exports.looseTupleAsync = looseTupleAsync;
exports.mac = mac;
exports.mac48 = mac48;
exports.mac64 = mac64;
exports.map = map;
exports.mapAsync = mapAsync;
exports.mapItems = mapItems;
exports.maxBytes = maxBytes;
exports.maxLength = maxLength;
exports.maxSize = maxSize;
exports.maxValue = maxValue;
exports.mimeType = mimeType;
exports.minBytes = minBytes;
exports.minLength = minLength;
exports.minSize = minSize;
exports.minValue = minValue;
exports.multipleOf = multipleOf;
exports.nan = nan;
exports.never = never;
exports.nonEmpty = nonEmpty;
exports.nonNullable = nonNullable;
exports.nonNullableAsync = nonNullableAsync;
exports.nonNullish = nonNullish;
exports.nonNullishAsync = nonNullishAsync;
exports.nonOptional = nonOptional;
exports.nonOptionalAsync = nonOptionalAsync;
exports.normalize = normalize;
exports.notBytes = notBytes;
exports.notLength = notLength;
exports.notSize = notSize;
exports.notValue = notValue;
exports.null_ = exports["null"] = null_;
exports.nullable = nullable;
exports.nullableAsync = nullableAsync;
exports.nullish = nullish;
exports.nullishAsync = nullishAsync;
exports.number = number;
exports.object = object;
exports.objectAsync = objectAsync;
exports.objectWithRest = objectWithRest;
exports.objectWithRestAsync = objectWithRestAsync;
exports.octal = octal;
exports.omit = omit;
exports.optional = optional;
exports.optionalAsync = optionalAsync;
exports.parse = parse;
exports.parseAsync = parseAsync;
exports.parser = parser;
exports.parserAsync = parserAsync;
exports.partial = partial;
exports.partialAsync = partialAsync;
exports.partialCheck = partialCheck;
exports.partialCheckAsync = partialCheckAsync;
exports.pick = pick;
exports.picklist = picklist;
exports.pipe = pipe;
exports.pipeAsync = pipeAsync;
exports.promise = promise;
exports.rawCheck = rawCheck;
exports.rawCheckAsync = rawCheckAsync;
exports.rawTransform = rawTransform;
exports.rawTransformAsync = rawTransformAsync;
exports.readonly = readonly;
exports.record = record;
exports.recordAsync = recordAsync;
exports.reduceItems = reduceItems;
exports.regex = regex;
exports.required = required;
exports.requiredAsync = requiredAsync;
exports.safeInteger = safeInteger;
exports.safeParse = safeParse;
exports.safeParseAsync = safeParseAsync;
exports.safeParser = safeParser;
exports.safeParserAsync = safeParserAsync;
exports.set = set;
exports.setAsync = setAsync;
exports.setGlobalConfig = setGlobalConfig;
exports.setGlobalMessage = setGlobalMessage;
exports.setSchemaMessage = setSchemaMessage;
exports.setSpecificMessage = setSpecificMessage;
exports.size = size;
exports.someItem = someItem;
exports.sortItems = sortItems;
exports.startsWith = startsWith;
exports.strictObject = strictObject;
exports.strictObjectAsync = strictObjectAsync;
exports.strictTuple = strictTuple;
exports.strictTupleAsync = strictTupleAsync;
exports.string = string;
exports.symbol = symbol;
exports.toLowerCase = toLowerCase;
exports.toMaxValue = toMaxValue;
exports.toMinValue = toMinValue;
exports.toUpperCase = toUpperCase;
exports.transform = transform;
exports.transformAsync = transformAsync;
exports.trim = trim;
exports.trimEnd = trimEnd;
exports.trimStart = trimStart;
exports.tuple = tuple;
exports.tupleAsync = tupleAsync;
exports.tupleWithRest = tupleWithRest;
exports.tupleWithRestAsync = tupleWithRestAsync;
exports.ulid = ulid;
exports.undefined_ = exports.undefined = undefined_;
exports.union = union;
exports.unionAsync = unionAsync;
exports.unknown = unknown;
exports.unwrap = unwrap;
exports.url = url;
exports.uuid = uuid;
exports.value = value;
exports.variant = variant;
exports.variantAsync = variantAsync;
exports.void_ = exports["void"] = void_;
function _slicedToArray(r, e) { return _arrayWithHoles(r) || _iterableToArrayLimit(r, e) || _unsupportedIterableToArray(r, e) || _nonIterableRest(); }
function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _iterableToArrayLimit(r, l) { var t = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (null != t) { var e, n, i, u, a = [], f = !0, o = !1; try { if (i = (t = t.call(r)).next, 0 === l) { if (Object(t) !== t) return; f = !1; } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0); } catch (r) { o = !0, n = r; } finally { try { if (!f && null != t["return"] && (u = t["return"](), Object(u) !== u)) return; } finally { if (o) throw n; } } return a; } }
function _arrayWithHoles(r) { if (Array.isArray(r)) return r; }
function _toConsumableArray(r) { return _arrayWithoutHoles(r) || _iterableToArray(r) || _unsupportedIterableToArray(r) || _nonIterableSpread(); }
function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _iterableToArray(r) { if ("undefined" != typeof Symbol && null != r[Symbol.iterator] || null != r["@@iterator"]) return Array.from(r); }
function _arrayWithoutHoles(r) { if (Array.isArray(r)) return _arrayLikeToArray(r); }
function _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }
function _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: !1 }), e; }
function _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function"); }
function _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }
function _possibleConstructorReturn(t, e) { if (e && ("object" == _typeof(e) || "function" == typeof e)) return e; if (void 0 !== e) throw new TypeError("Derived constructors may only return object or undefined"); return _assertThisInitialized(t); }
function _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); return e; }
function _inherits(t, e) { if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, "prototype", { writable: !1 }), e && _setPrototypeOf(t, e); }
function _wrapNativeSuper(t) { var r = "function" == typeof Map ? new Map() : void 0; return _wrapNativeSuper = function _wrapNativeSuper(t) { if (null === t || !_isNativeFunction(t)) return t; if ("function" != typeof t) throw new TypeError("Super expression must either be null or a function"); if (void 0 !== r) { if (r.has(t)) return r.get(t); r.set(t, Wrapper); } function Wrapper() { return _construct(t, arguments, _getPrototypeOf(this).constructor); } return Wrapper.prototype = Object.create(t.prototype, { constructor: { value: Wrapper, enumerable: !1, writable: !0, configurable: !0 } }), _setPrototypeOf(Wrapper, t); }, _wrapNativeSuper(t); }
function _construct(t, e, r) { if (_isNativeReflectConstruct()) return Reflect.construct.apply(null, arguments); var o = [null]; o.push.apply(o, e); var p = new (t.bind.apply(t, o))(); return r && _setPrototypeOf(p, r.prototype), p; }
function _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }
function _isNativeFunction(t) { try { return -1 !== Function.toString.call(t).indexOf("[native code]"); } catch (n) { return "function" == typeof t; } }
function _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }
function _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }
function _createForOfIteratorHelper(r, e) { var t = "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (!t) { if (Array.isArray(r) || (t = _unsupportedIterableToArray(r)) || e && r && "number" == typeof r.length) { t && (r = t); var _n = 0, F = function F() {}; return { s: F, n: function n() { return _n >= r.length ? { done: !0 } : { done: !1, value: r[_n++] }; }, e: function e(r) { throw r; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var o, a = !0, u = !1; return { s: function s() { t = t.call(r); }, n: function n() { var r = t.next(); return a = r.done, r; }, e: function e(r) { u = !0, o = r; }, f: function f() { try { a || null == t["return"] || t["return"](); } finally { if (u) throw o; } } }; }
function _unsupportedIterableToArray(r, a) { if (r) { if ("string" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }
function _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
function _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
function _regeneratorRuntime() { "use strict"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return e; }; var t, e = {}, r = Object.prototype, n = r.hasOwnProperty, o = Object.defineProperty || function (t, e, r) { t[e] = r.value; }, i = "function" == typeof Symbol ? Symbol : {}, a = i.iterator || "@@iterator", c = i.asyncIterator || "@@asyncIterator", u = i.toStringTag || "@@toStringTag"; function define(t, e, r) { return Object.defineProperty(t, e, { value: r, enumerable: !0, configurable: !0, writable: !0 }), t[e]; } try { define({}, ""); } catch (t) { define = function define(t, e, r) { return t[e] = r; }; } function wrap(t, e, r, n) { var i = e && e.prototype instanceof Generator ? e : Generator, a = Object.create(i.prototype), c = new Context(n || []); return o(a, "_invoke", { value: makeInvokeMethod(t, r, c) }), a; } function tryCatch(t, e, r) { try { return { type: "normal", arg: t.call(e, r) }; } catch (t) { return { type: "throw", arg: t }; } } e.wrap = wrap; var h = "suspendedStart", l = "suspendedYield", f = "executing", s = "completed", y = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var p = {}; define(p, a, function () { return this; }); var d = Object.getPrototypeOf, v = d && d(d(values([]))); v && v !== r && n.call(v, a) && (p = v); var g = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(p); function defineIteratorMethods(t) { ["next", "throw", "return"].forEach(function (e) { define(t, e, function (t) { return this._invoke(e, t); }); }); } function AsyncIterator(t, e) { function invoke(r, o, i, a) { var c = tryCatch(t[r], t, o); if ("throw" !== c.type) { var u = c.arg, h = u.value; return h && "object" == _typeof(h) && n.call(h, "__await") ? e.resolve(h.__await).then(function (t) { invoke("next", t, i, a); }, function (t) { invoke("throw", t, i, a); }) : e.resolve(h).then(function (t) { u.value = t, i(u); }, function (t) { return invoke("throw", t, i, a); }); } a(c.arg); } var r; o(this, "_invoke", { value: function value(t, n) { function callInvokeWithMethodAndArg() { return new e(function (e, r) { invoke(t, n, e, r); }); } return r = r ? r.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); } }); } function makeInvokeMethod(e, r, n) { var o = h; return function (i, a) { if (o === f) throw Error("Generator is already running"); if (o === s) { if ("throw" === i) throw a; return { value: t, done: !0 }; } for (n.method = i, n.arg = a;;) { var c = n.delegate; if (c) { var u = maybeInvokeDelegate(c, n); if (u) { if (u === y) continue; return u; } } if ("next" === n.method) n.sent = n._sent = n.arg;else if ("throw" === n.method) { if (o === h) throw o = s, n.arg; n.dispatchException(n.arg); } else "return" === n.method && n.abrupt("return", n.arg); o = f; var p = tryCatch(e, r, n); if ("normal" === p.type) { if (o = n.done ? s : l, p.arg === y) continue; return { value: p.arg, done: n.done }; } "throw" === p.type && (o = s, n.method = "throw", n.arg = p.arg); } }; } function maybeInvokeDelegate(e, r) { var n = r.method, o = e.iterator[n]; if (o === t) return r.delegate = null, "throw" === n && e.iterator["return"] && (r.method = "return", r.arg = t, maybeInvokeDelegate(e, r), "throw" === r.method) || "return" !== n && (r.method = "throw", r.arg = new TypeError("The iterator does not provide a '" + n + "' method")), y; var i = tryCatch(o, e.iterator, r.arg); if ("throw" === i.type) return r.method = "throw", r.arg = i.arg, r.delegate = null, y; var a = i.arg; return a ? a.done ? (r[e.resultName] = a.value, r.next = e.nextLoc, "return" !== r.method && (r.method = "next", r.arg = t), r.delegate = null, y) : a : (r.method = "throw", r.arg = new TypeError("iterator result is not an object"), r.delegate = null, y); } function pushTryEntry(t) { var e = { tryLoc: t[0] }; 1 in t && (e.catchLoc = t[1]), 2 in t && (e.finallyLoc = t[2], e.afterLoc = t[3]), this.tryEntries.push(e); } function resetTryEntry(t) { var e = t.completion || {}; e.type = "normal", delete e.arg, t.completion = e; } function Context(t) { this.tryEntries = [{ tryLoc: "root" }], t.forEach(pushTryEntry, this), this.reset(!0); } function values(e) { if (e || "" === e) { var r = e[a]; if (r) return r.call(e); if ("function" == typeof e.next) return e; if (!isNaN(e.length)) { var o = -1, i = function next() { for (; ++o < e.length;) if (n.call(e, o)) return next.value = e[o], next.done = !1, next; return next.value = t, next.done = !0, next; }; return i.next = i; } } throw new TypeError(_typeof(e) + " is not iterable"); } return GeneratorFunction.prototype = GeneratorFunctionPrototype, o(g, "constructor", { value: GeneratorFunctionPrototype, configurable: !0 }), o(GeneratorFunctionPrototype, "constructor", { value: GeneratorFunction, configurable: !0 }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, u, "GeneratorFunction"), e.isGeneratorFunction = function (t) { var e = "function" == typeof t && t.constructor; return !!e && (e === GeneratorFunction || "GeneratorFunction" === (e.displayName || e.name)); }, e.mark = function (t) { return Object.setPrototypeOf ? Object.setPrototypeOf(t, GeneratorFunctionPrototype) : (t.__proto__ = GeneratorFunctionPrototype, define(t, u, "GeneratorFunction")), t.prototype = Object.create(g), t; }, e.awrap = function (t) { return { __await: t }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, c, function () { return this; }), e.AsyncIterator = AsyncIterator, e.async = function (t, r, n, o, i) { void 0 === i && (i = Promise); var a = new AsyncIterator(wrap(t, r, n, o), i); return e.isGeneratorFunction(r) ? a : a.next().then(function (t) { return t.done ? t.value : a.next(); }); }, defineIteratorMethods(g), define(g, u, "Generator"), define(g, a, function () { return this; }), define(g, "toString", function () { return "[object Generator]"; }), e.keys = function (t) { var e = Object(t), r = []; for (var n in e) r.push(n); return r.reverse(), function next() { for (; r.length;) { var t = r.pop(); if (t in e) return next.value = t, next.done = !1, next; } return next.done = !0, next; }; }, e.values = values, Context.prototype = { constructor: Context, reset: function reset(e) { if (this.prev = 0, this.next = 0, this.sent = this._sent = t, this.done = !1, this.delegate = null, this.method = "next", this.arg = t, this.tryEntries.forEach(resetTryEntry), !e) for (var r in this) "t" === r.charAt(0) && n.call(this, r) && !isNaN(+r.slice(1)) && (this[r] = t); }, stop: function stop() { this.done = !0; var t = this.tryEntries[0].completion; if ("throw" === t.type) throw t.arg; return this.rval; }, dispatchException: function dispatchException(e) { if (this.done) throw e; var r = this; function handle(n, o) { return a.type = "throw", a.arg = e, r.next = n, o && (r.method = "next", r.arg = t), !!o; } for (var o = this.tryEntries.length - 1; o >= 0; --o) { var i = this.tryEntries[o], a = i.completion; if ("root" === i.tryLoc) return handle("end"); if (i.tryLoc <= this.prev) { var c = n.call(i, "catchLoc"), u = n.call(i, "finallyLoc"); if (c && u) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } else if (c) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); } else { if (!u) throw Error("try statement without catch or finally"); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } } } }, abrupt: function abrupt(t, e) { for (var r = this.tryEntries.length - 1; r >= 0; --r) { var o = this.tryEntries[r]; if (o.tryLoc <= this.prev && n.call(o, "finallyLoc") && this.prev < o.finallyLoc) { var i = o; break; } } i && ("break" === t || "continue" === t) && i.tryLoc <= e && e <= i.finallyLoc && (i = null); var a = i ? i.completion : {}; return a.type = t, a.arg = e, i ? (this.method = "next", this.next = i.finallyLoc, y) : this.complete(a); }, complete: function complete(t, e) { if ("throw" === t.type) throw t.arg; return "break" === t.type || "continue" === t.type ? this.next = t.arg : "return" === t.type ? (this.rval = this.arg = t.arg, this.method = "return", this.next = "end") : "normal" === t.type && e && (this.next = e), y; }, finish: function finish(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.finallyLoc === t) return this.complete(r.completion, r.afterLoc), resetTryEntry(r), y; } }, "catch": function _catch(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.tryLoc === t) { var n = r.completion; if ("throw" === n.type) { var o = n.arg; resetTryEntry(r); } return o; } } throw Error("illegal catch attempt"); }, delegateYield: function delegateYield(e, r, n) { return this.delegate = { iterator: values(e), resultName: r, nextLoc: n }, "next" === this.method && (this.arg = t), y; } }, e; }
function asyncGeneratorStep(n, t, e, r, o, a, c) { try { var i = n[a](c), u = i.value; } catch (n) { return void e(n); } i.done ? t(u) : Promise.resolve(u).then(r, o); }
function _asyncToGenerator(n) { return function () { var t = this, e = arguments; return new Promise(function (r, o) { var a = n.apply(t, e); function _next(n) { asyncGeneratorStep(a, r, o, _next, _throw, "next", n); } function _throw(n) { asyncGeneratorStep(a, r, o, _next, _throw, "throw", n); } _next(void 0); }); }; }
// src/actions/await/awaitAsync.ts
function awaitAsync() {
  return {
    kind: "transformation",
    type: "await",
    reference: awaitAsync,
    async: true,
    _run: function _run(dataset) {
      return _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee() {
        return _regeneratorRuntime().wrap(function _callee$(_context) {
          while (1) switch (_context.prev = _context.next) {
            case 0:
              _context.next = 2;
              return dataset.value;
            case 2:
              dataset.value = _context.sent;
              return _context.abrupt("return", dataset);
            case 4:
            case "end":
              return _context.stop();
          }
        }, _callee);
      }))();
    }
  };
}

// src/regex.ts
var BASE64_REGEX = exports.BASE64_REGEX = /^(?:[\+\/-9a-z\u017F\u212A]{4})*(?:[\+\/-9a-z\u017F\u212A]{2}==|[\+\/-9a-z\u017F\u212A]{3}=)?$/i;
var BIC_REGEX = exports.BIC_REGEX = /^[A-Z]{6}(?!00)[0-9A-Z]{2}(?:[0-9A-Z]{3})?$/;
var CUID2_REGEX = exports.CUID2_REGEX = /^[a-z][0-9a-z]*$/;
var DECIMAL_REGEX = exports.DECIMAL_REGEX = /^[0-9]+$/;
var EMAIL_REGEX = exports.EMAIL_REGEX = /^[\+\x2D0-9A-Z_a-z\u017F\u212A]+(?:\.[\+\x2D0-9A-Z_a-z\u017F\u212A]+)*@[0-9a-z\u017F\u212A]+(?:[\x2D\.][0-9a-z\u017F\u212A]+)*\.[a-z\u017F\u212A]{2,}$/i;
var EMOJI_REGEX = exports.EMOJI_REGEX =
// eslint-disable-next-line redos-detector/no-unsafe-regex, regexp/no-dupe-disjunctions -- false positives
/^(?:(?:\uD83C[\uDDE6-\uDDFF]){2}|(?:\uD83C\uDFF4)(?:\uDB40[\uDC61-\uDC7A]){2}(?:\uDB40[\uDC30-\uDC39\uDC61-\uDC7A]){1,3}(?:\uDB40\uDC7F)|(?:(?:[#\*0-9\xA9\xAE\u203C\u2049\u2122\u2139\u2194-\u2199\u21A9\u21AA\u231A\u231B\u2328\u23CF\u23E9-\u23F3\u23F8-\u23FA\u24C2\u25AA\u25AB\u25B6\u25C0\u25FB-\u25FE\u2600-\u2604\u260E\u2611\u2614\u2615\u2618\u261D\u2620\u2622\u2623\u2626\u262A\u262E\u262F\u2638-\u263A\u2640\u2642\u2648-\u2653\u265F\u2660\u2663\u2665\u2666\u2668\u267B\u267E\u267F\u2692-\u2697\u2699\u269B\u269C\u26A0\u26A1\u26A7\u26AA\u26AB\u26B0\u26B1\u26BD\u26BE\u26C4\u26C5\u26C8\u26CE\u26CF\u26D1\u26D3\u26D4\u26E9\u26EA\u26F0-\u26F5\u26F7-\u26FA\u26FD\u2702\u2705\u2708-\u270D\u270F\u2712\u2714\u2716\u271D\u2721\u2728\u2733\u2734\u2744\u2747\u274C\u274E\u2753-\u2755\u2757\u2763\u2764\u2795-\u2797\u27A1\u27B0\u27BF\u2934\u2935\u2B05-\u2B07\u2B1B\u2B1C\u2B50\u2B55\u3030\u303D\u3297\u3299]|\uD83C[\uDC04\uDCCF\uDD70\uDD71\uDD7E\uDD7F\uDD8E\uDD91-\uDD9A\uDDE6-\uDDFF\uDE01\uDE02\uDE1A\uDE2F\uDE32-\uDE3A\uDE50\uDE51\uDF00-\uDF21\uDF24-\uDF93\uDF96\uDF97\uDF99-\uDF9B\uDF9E-\uDFF0\uDFF3-\uDFF5\uDFF7-\uDFFF]|\uD83D[\uDC00-\uDCFD\uDCFF-\uDD3D\uDD49-\uDD4E\uDD50-\uDD67\uDD6F\uDD70\uDD73-\uDD7A\uDD87\uDD8A-\uDD8D\uDD90\uDD95\uDD96\uDDA4\uDDA5\uDDA8\uDDB1\uDDB2\uDDBC\uDDC2-\uDDC4\uDDD1-\uDDD3\uDDDC-\uDDDE\uDDE1\uDDE3\uDDE8\uDDEF\uDDF3\uDDFA-\uDE4F\uDE80-\uDEC5\uDECB-\uDED2\uDED5-\uDED7\uDEDC-\uDEE5\uDEE9\uDEEB\uDEEC\uDEF0\uDEF3-\uDEFC\uDFE0-\uDFEB\uDFF0]|\uD83E[\uDD0C-\uDD3A\uDD3C-\uDD45\uDD47-\uDDFF\uDE70-\uDE7C\uDE80-\uDE89\uDE8F-\uDEC6\uDECE-\uDEDC\uDEDF-\uDEE9\uDEF0-\uDEF8])\uFE0F\u20E3?|(?:[\u261D\u26F9\u270A-\u270D]|\uD83C[\uDF85\uDFC2-\uDFC4\uDFC7\uDFCA-\uDFCC]|\uD83D[\uDC42\uDC43\uDC46-\uDC50\uDC66-\uDC78\uDC7C\uDC81-\uDC83\uDC85-\uDC87\uDC8F\uDC91\uDCAA\uDD74\uDD75\uDD7A\uDD90\uDD95\uDD96\uDE45-\uDE47\uDE4B-\uDE4F\uDEA3\uDEB4-\uDEB6\uDEC0\uDECC]|\uD83E[\uDD0C\uDD0F\uDD18-\uDD1F\uDD26\uDD30-\uDD39\uDD3C-\uDD3E\uDD77\uDDB5\uDDB6\uDDB8\uDDB9\uDDBB\uDDCD-\uDDCF\uDDD1-\uDDDD\uDEC3-\uDEC5\uDEF0-\uDEF8])(?:\uD83C[\uDFFB-\uDFFF])?|(?:[\u231A\u231B\u23E9-\u23EC\u23F0\u23F3\u25FD\u25FE\u2614\u2615\u2648-\u2653\u267F\u2693\u26A1\u26AA\u26AB\u26BD\u26BE\u26C4\u26C5\u26CE\u26D4\u26EA\u26F2\u26F3\u26F5\u26FA\u26FD\u2705\u270A\u270B\u2728\u274C\u274E\u2753-\u2755\u2757\u2795-\u2797\u27B0\u27BF\u2B1B\u2B1C\u2B50\u2B55]|\uD83C[\uDC04\uDCCF\uDD8E\uDD91-\uDD9A\uDDE6-\uDDFF\uDE01\uDE1A\uDE2F\uDE32-\uDE36\uDE38-\uDE3A\uDE50\uDE51\uDF00-\uDF20\uDF2D-\uDF35\uDF37-\uDF7C\uDF7E-\uDF93\uDFA0-\uDFCA\uDFCF-\uDFD3\uDFE0-\uDFF0\uDFF4\uDFF8-\uDFFF]|\uD83D[\uDC00-\uDC3E\uDC40\uDC42-\uDCFC\uDCFF-\uDD3D\uDD4B-\uDD4E\uDD50-\uDD67\uDD7A\uDD95\uDD96\uDDA4\uDDFB-\uDE4F\uDE80-\uDEC5\uDECC\uDED0-\uDED2\uDED5-\uDED7\uDEDC-\uDEDF\uDEEB\uDEEC\uDEF4-\uDEFC\uDFE0-\uDFEB\uDFF0]|\uD83E[\uDD0C-\uDD3A\uDD3C-\uDD45\uDD47-\uDDFF\uDE70-\uDE7C\uDE80-\uDE89\uDE8F-\uDEC6\uDECE-\uDEDC\uDEDF-\uDEE9\uDEF0-\uDEF8]))(?:\u200D(?:(?:[#\*0-9\xA9\xAE\u203C\u2049\u2122\u2139\u2194-\u2199\u21A9\u21AA\u231A\u231B\u2328\u23CF\u23E9-\u23F3\u23F8-\u23FA\u24C2\u25AA\u25AB\u25B6\u25C0\u25FB-\u25FE\u2600-\u2604\u260E\u2611\u2614\u2615\u2618\u261D\u2620\u2622\u2623\u2626\u262A\u262E\u262F\u2638-\u263A\u2640\u2642\u2648-\u2653\u265F\u2660\u2663\u2665\u2666\u2668\u267B\u267E\u267F\u2692-\u2697\u2699\u269B\u269C\u26A0\u26A1\u26A7\u26AA\u26AB\u26B0\u26B1\u26BD\u26BE\u26C4\u26C5\u26C8\u26CE\u26CF\u26D1\u26D3\u26D4\u26E9\u26EA\u26F0-\u26F5\u26F7-\u26FA\u26FD\u2702\u2705\u2708-\u270D\u270F\u2712\u2714\u2716\u271D\u2721\u2728\u2733\u2734\u2744\u2747\u274C\u274E\u2753-\u2755\u2757\u2763\u2764\u2795-\u2797\u27A1\u27B0\u27BF\u2934\u2935\u2B05-\u2B07\u2B1B\u2B1C\u2B50\u2B55\u3030\u303D\u3297\u3299]|\uD83C[\uDC04\uDCCF\uDD70\uDD71\uDD7E\uDD7F\uDD8E\uDD91-\uDD9A\uDDE6-\uDDFF\uDE01\uDE02\uDE1A\uDE2F\uDE32-\uDE3A\uDE50\uDE51\uDF00-\uDF21\uDF24-\uDF93\uDF96\uDF97\uDF99-\uDF9B\uDF9E-\uDFF0\uDFF3-\uDFF5\uDFF7-\uDFFF]|\uD83D[\uDC00-\uDCFD\uDCFF-\uDD3D\uDD49-\uDD4E\uDD50-\uDD67\uDD6F\uDD70\uDD73-\uDD7A\uDD87\uDD8A-\uDD8D\uDD90\uDD95\uDD96\uDDA4\uDDA5\uDDA8\uDDB1\uDDB2\uDDBC\uDDC2-\uDDC4\uDDD1-\uDDD3\uDDDC-\uDDDE\uDDE1\uDDE3\uDDE8\uDDEF\uDDF3\uDDFA-\uDE4F\uDE80-\uDEC5\uDECB-\uDED2\uDED5-\uDED7\uDEDC-\uDEE5\uDEE9\uDEEB\uDEEC\uDEF0\uDEF3-\uDEFC\uDFE0-\uDFEB\uDFF0]|\uD83E[\uDD0C-\uDD3A\uDD3C-\uDD45\uDD47-\uDDFF\uDE70-\uDE7C\uDE80-\uDE89\uDE8F-\uDEC6\uDECE-\uDEDC\uDEDF-\uDEE9\uDEF0-\uDEF8])\uFE0F\u20E3?|(?:[\u261D\u26F9\u270A-\u270D]|\uD83C[\uDF85\uDFC2-\uDFC4\uDFC7\uDFCA-\uDFCC]|\uD83D[\uDC42\uDC43\uDC46-\uDC50\uDC66-\uDC78\uDC7C\uDC81-\uDC83\uDC85-\uDC87\uDC8F\uDC91\uDCAA\uDD74\uDD75\uDD7A\uDD90\uDD95\uDD96\uDE45-\uDE47\uDE4B-\uDE4F\uDEA3\uDEB4-\uDEB6\uDEC0\uDECC]|\uD83E[\uDD0C\uDD0F\uDD18-\uDD1F\uDD26\uDD30-\uDD39\uDD3C-\uDD3E\uDD77\uDDB5\uDDB6\uDDB8\uDDB9\uDDBB\uDDCD-\uDDCF\uDDD1-\uDDDD\uDEC3-\uDEC5\uDEF0-\uDEF8])(?:\uD83C[\uDFFB-\uDFFF])?|(?:[\u231A\u231B\u23E9-\u23EC\u23F0\u23F3\u25FD\u25FE\u2614\u2615\u2648-\u2653\u267F\u2693\u26A1\u26AA\u26AB\u26BD\u26BE\u26C4\u26C5\u26CE\u26D4\u26EA\u26F2\u26F3\u26F5\u26FA\u26FD\u2705\u270A\u270B\u2728\u274C\u274E\u2753-\u2755\u2757\u2795-\u2797\u27B0\u27BF\u2B1B\u2B1C\u2B50\u2B55]|\uD83C[\uDC04\uDCCF\uDD8E\uDD91-\uDD9A\uDDE6-\uDDFF\uDE01\uDE1A\uDE2F\uDE32-\uDE36\uDE38-\uDE3A\uDE50\uDE51\uDF00-\uDF20\uDF2D-\uDF35\uDF37-\uDF7C\uDF7E-\uDF93\uDFA0-\uDFCA\uDFCF-\uDFD3\uDFE0-\uDFF0\uDFF4\uDFF8-\uDFFF]|\uD83D[\uDC00-\uDC3E\uDC40\uDC42-\uDCFC\uDCFF-\uDD3D\uDD4B-\uDD4E\uDD50-\uDD67\uDD7A\uDD95\uDD96\uDDA4\uDDFB-\uDE4F\uDE80-\uDEC5\uDECC\uDED0-\uDED2\uDED5-\uDED7\uDEDC-\uDEDF\uDEEB\uDEEC\uDEF4-\uDEFC\uDFE0-\uDFEB\uDFF0]|\uD83E[\uDD0C-\uDD3A\uDD3C-\uDD45\uDD47-\uDDFF\uDE70-\uDE7C\uDE80-\uDE89\uDE8F-\uDEC6\uDECE-\uDEDC\uDEDF-\uDEE9\uDEF0-\uDEF8])))*)+$/;
var HEXADECIMAL_REGEX = exports.HEXADECIMAL_REGEX = /^(?:0[hx])?[0-9a-f]+$/i;
var HEX_COLOR_REGEX = exports.HEX_COLOR_REGEX = /^#(?:[0-9a-f]{3,4}|[0-9a-f]{6}|[0-9a-f]{8})$/i;
var IMEI_REGEX = exports.IMEI_REGEX = /^[0-9]{15}$|^[0-9]{2}-[0-9]{6}-[0-9]{6}-[0-9]$/;
var IPV4_REGEX = exports.IPV4_REGEX =
// eslint-disable-next-line redos-detector/no-unsafe-regex -- false positive
/^(?:(?:[1-9]|1[0-9]|2[0-4])?[0-9]|25[0-5])(?:\.(?:(?:[1-9]|1[0-9]|2[0-4])?[0-9]|25[0-5])){3}$/;
var IPV6_REGEX = exports.IPV6_REGEX = /^(?:(?:[0-9a-f]{1,4}:){7}[0-9a-f]{1,4}|(?:[0-9a-f]{1,4}:){1,7}:|(?:[0-9a-f]{1,4}:){1,6}:[0-9a-f]{1,4}|(?:[0-9a-f]{1,4}:){1,5}(?::[0-9a-f]{1,4}){1,2}|(?:[0-9a-f]{1,4}:){1,4}(?::[0-9a-f]{1,4}){1,3}|(?:[0-9a-f]{1,4}:){1,3}(?::[0-9a-f]{1,4}){1,4}|(?:[0-9a-f]{1,4}:){1,2}(?::[0-9a-f]{1,4}){1,5}|[0-9a-f]{1,4}:(?::[0-9a-f]{1,4}){1,6}|:(?:(?::[0-9a-f]{1,4}){1,7}|:)|fe80:(?::[0-9a-f]{0,4}){0,4}%[0-9a-z\u017F\u212A]+|::(?:f{4}(?::0{1,4})?:)?(?:(?:25[0-5]|(?:2[0-4]|1?[0-9])?[0-9])\.){3}(?:25[0-5]|(?:2[0-4]|1?[0-9])?[0-9])|(?:[0-9a-f]{1,4}:){1,4}:(?:(?:25[0-5]|(?:2[0-4]|1?[0-9])?[0-9])\.){3}(?:25[0-5]|(?:2[0-4]|1?[0-9])?[0-9]))$/i;
var IP_REGEX = exports.IP_REGEX = /^(?:(?:[1-9]|1[0-9]|2[0-4])?[0-9]|25[0-5])(?:\.(?:(?:[1-9]|1[0-9]|2[0-4])?[0-9]|25[0-5])){3}$|^(?:(?:[0-9a-f]{1,4}:){7}[0-9a-f]{1,4}|(?:[0-9a-f]{1,4}:){1,7}:|(?:[0-9a-f]{1,4}:){1,6}:[0-9a-f]{1,4}|(?:[0-9a-f]{1,4}:){1,5}(?::[0-9a-f]{1,4}){1,2}|(?:[0-9a-f]{1,4}:){1,4}(?::[0-9a-f]{1,4}){1,3}|(?:[0-9a-f]{1,4}:){1,3}(?::[0-9a-f]{1,4}){1,4}|(?:[0-9a-f]{1,4}:){1,2}(?::[0-9a-f]{1,4}){1,5}|[0-9a-f]{1,4}:(?::[0-9a-f]{1,4}){1,6}|:(?:(?::[0-9a-f]{1,4}){1,7}|:)|fe80:(?::[0-9a-f]{0,4}){0,4}%[0-9a-z\u017F\u212A]+|::(?:f{4}(?::0{1,4})?:)?(?:(?:25[0-5]|(?:2[0-4]|1?[0-9])?[0-9])\.){3}(?:25[0-5]|(?:2[0-4]|1?[0-9])?[0-9])|(?:[0-9a-f]{1,4}:){1,4}:(?:(?:25[0-5]|(?:2[0-4]|1?[0-9])?[0-9])\.){3}(?:25[0-5]|(?:2[0-4]|1?[0-9])?[0-9]))$/i;
var ISO_DATE_REGEX = exports.ISO_DATE_REGEX = /^[0-9]{4}-(?:0[1-9]|1[0-2])-(?:[12][0-9]|0[1-9]|3[01])$/;
var ISO_DATE_TIME_REGEX = exports.ISO_DATE_TIME_REGEX = /^[0-9]{4}-(?:0[1-9]|1[0-2])-(?:[12][0-9]|0[1-9]|3[01])T(?:0[0-9]|1[0-9]|2[0-3]):[0-5][0-9]$/;
var ISO_TIME_REGEX = exports.ISO_TIME_REGEX = /^(?:0[0-9]|1[0-9]|2[0-3]):[0-5][0-9]$/;
var ISO_TIME_SECOND_REGEX = exports.ISO_TIME_SECOND_REGEX = /^(?:0[0-9]|1[0-9]|2[0-3])(?::[0-5][0-9]){2}$/;
var ISO_TIMESTAMP_REGEX = exports.ISO_TIMESTAMP_REGEX = /^[0-9]{4}-(?:0[1-9]|1[0-2])-(?:[12][0-9]|0[1-9]|3[01])T(?:0[0-9]|1[0-9]|2[0-3])(?::[0-5][0-9]){2}(?:\.[0-9]{1,9})?(?:Z|[\+\x2D](?:0[0-9]|1[0-9]|2[0-3])(?::?[0-5][0-9])?)$/;
var ISO_WEEK_REGEX = exports.ISO_WEEK_REGEX = /^[0-9]{4}-W(?:0[1-9]|[1-4][0-9]|5[0-3])$/;
var MAC48_REGEX = exports.MAC48_REGEX = /^(?:[0-9a-f]{2}:){5}[0-9a-f]{2}$|^(?:[0-9a-f]{2}-){5}[0-9a-f]{2}$|^(?:[0-9a-f]{4}\.){2}[0-9a-f]{4}$/i;
var MAC64_REGEX = exports.MAC64_REGEX = /^(?:[0-9a-f]{2}:){7}[0-9a-f]{2}$|^(?:[0-9a-f]{2}-){7}[0-9a-f]{2}$|^(?:[0-9a-f]{4}\.){3}[0-9a-f]{4}$|^(?:[0-9a-f]{4}:){3}[0-9a-f]{4}$/i;
var MAC_REGEX = exports.MAC_REGEX = /^(?:[0-9a-f]{2}:){5}[0-9a-f]{2}$|^(?:[0-9a-f]{2}-){5}[0-9a-f]{2}$|^(?:[0-9a-f]{4}\.){2}[0-9a-f]{4}$|^(?:[0-9a-f]{2}:){7}[0-9a-f]{2}$|^(?:[0-9a-f]{2}-){7}[0-9a-f]{2}$|^(?:[0-9a-f]{4}\.){3}[0-9a-f]{4}$|^(?:[0-9a-f]{4}:){3}[0-9a-f]{4}$/i;
var OCTAL_REGEX = exports.OCTAL_REGEX = /^(?:0o)?[0-7]+$/i;
var ULID_REGEX = exports.ULID_REGEX = /^[0-9a-hjkmnp-tv-z\u017F\u212A]{26}$/i;
var UUID_REGEX = exports.UUID_REGEX = /^[0-9a-f]{8}(?:-[0-9a-f]{4}){3}-[0-9a-f]{12}$/i;

// src/storages/globalConfig/globalConfig.ts
var store;
function setGlobalConfig(config2) {
  store = _objectSpread(_objectSpread({}, store), config2);
}
function getGlobalConfig(config2) {
  var _config2$lang, _store, _config2$abortEarly, _store2, _config2$abortPipeEar, _store3;
  return {
    lang: (_config2$lang = config2 === null || config2 === void 0 ? void 0 : config2.lang) !== null && _config2$lang !== void 0 ? _config2$lang : (_store = store) === null || _store === void 0 ? void 0 : _store.lang,
    message: config2 === null || config2 === void 0 ? void 0 : config2.message,
    abortEarly: (_config2$abortEarly = config2 === null || config2 === void 0 ? void 0 : config2.abortEarly) !== null && _config2$abortEarly !== void 0 ? _config2$abortEarly : (_store2 = store) === null || _store2 === void 0 ? void 0 : _store2.abortEarly,
    abortPipeEarly: (_config2$abortPipeEar = config2 === null || config2 === void 0 ? void 0 : config2.abortPipeEarly) !== null && _config2$abortPipeEar !== void 0 ? _config2$abortPipeEar : (_store3 = store) === null || _store3 === void 0 ? void 0 : _store3.abortPipeEarly
  };
}
function deleteGlobalConfig() {
  store = void 0;
}

// src/storages/globalMessage/globalMessage.ts
var store2;
function setGlobalMessage(message, lang) {
  if (!store2) store2 = /* @__PURE__ */new Map();
  store2.set(lang, message);
}
function getGlobalMessage(lang) {
  var _store4;
  return (_store4 = store2) === null || _store4 === void 0 ? void 0 : _store4.get(lang);
}
function deleteGlobalMessage(lang) {
  var _store5;
  (_store5 = store2) === null || _store5 === void 0 || _store5["delete"](lang);
}

// src/storages/schemaMessage/schemaMessage.ts
var store3;
function setSchemaMessage(message, lang) {
  if (!store3) store3 = /* @__PURE__ */new Map();
  store3.set(lang, message);
}
function getSchemaMessage(lang) {
  var _store6;
  return (_store6 = store3) === null || _store6 === void 0 ? void 0 : _store6.get(lang);
}
function deleteSchemaMessage(lang) {
  var _store7;
  (_store7 = store3) === null || _store7 === void 0 || _store7["delete"](lang);
}

// src/storages/specificMessage/specificMessage.ts
var store4;
function setSpecificMessage(reference, message, lang) {
  if (!store4) store4 = /* @__PURE__ */new Map();
  if (!store4.get(reference)) store4.set(reference, /* @__PURE__ */new Map());
  store4.get(reference).set(lang, message);
}
function getSpecificMessage(reference, lang) {
  var _store8;
  return (_store8 = store4) === null || _store8 === void 0 || (_store8 = _store8.get(reference)) === null || _store8 === void 0 ? void 0 : _store8.get(lang);
}
function deleteSpecificMessage(reference, lang) {
  var _store9;
  (_store9 = store4) === null || _store9 === void 0 || (_store9 = _store9.get(reference)) === null || _store9 === void 0 || _store9["delete"](lang);
}

// src/utils/_stringify/_stringify.ts
function _stringify(input) {
  var type = _typeof(input);
  if (type === "string") {
    return "\"".concat(input, "\"");
  }
  if (type === "number" || type === "bigint" || type === "boolean") {
    return "".concat(input);
  }
  if (type === "object" || type === "function") {
    var _ref, _Object$getPrototypeO;
    return (_ref = input && ((_Object$getPrototypeO = Object.getPrototypeOf(input)) === null || _Object$getPrototypeO === void 0 || (_Object$getPrototypeO = _Object$getPrototypeO.constructor) === null || _Object$getPrototypeO === void 0 ? void 0 : _Object$getPrototypeO.name)) !== null && _ref !== void 0 ? _ref : "null";
  }
  return type;
}

// src/utils/_addIssue/_addIssue.ts
function _addIssue(context, label, dataset, config2, other) {
  var _ref2, _other$expected, _other$received, _ref3, _ref4, _ref5, _ref6, _other$message;
  var input = other && "input" in other ? other.input : dataset.value;
  var expected = (_ref2 = (_other$expected = other === null || other === void 0 ? void 0 : other.expected) !== null && _other$expected !== void 0 ? _other$expected : context.expects) !== null && _ref2 !== void 0 ? _ref2 : null;
  var received = (_other$received = other === null || other === void 0 ? void 0 : other.received) !== null && _other$received !== void 0 ? _other$received : _stringify(input);
  var issue = {
    kind: context.kind,
    type: context.type,
    input: input,
    expected: expected,
    received: received,
    message: "Invalid ".concat(label, ": ").concat(expected ? "Expected ".concat(expected, " but r") : "R", "eceived ").concat(received),
    // @ts-expect-error
    requirement: context.requirement,
    path: other === null || other === void 0 ? void 0 : other.path,
    issues: other === null || other === void 0 ? void 0 : other.issues,
    lang: config2.lang,
    abortEarly: config2.abortEarly,
    abortPipeEarly: config2.abortPipeEarly
  };
  var isSchema = context.kind === "schema";
  var message = (_ref3 = (_ref4 = (_ref5 = (_ref6 = (_other$message = other === null || other === void 0 ? void 0 : other.message) !== null && _other$message !== void 0 ? _other$message :
  // @ts-expect-error
  context.message) !== null && _ref6 !== void 0 ? _ref6 : getSpecificMessage(context.reference, issue.lang)) !== null && _ref5 !== void 0 ? _ref5 : isSchema ? getSchemaMessage(issue.lang) : null) !== null && _ref4 !== void 0 ? _ref4 : config2.message) !== null && _ref3 !== void 0 ? _ref3 : getGlobalMessage(issue.lang);
  if (message) {
    issue.message = typeof message === "function" ? message(issue) : message;
  }
  if (isSchema) {
    dataset.typed = false;
  }
  if (dataset.issues) {
    dataset.issues.push(issue);
  } else {
    dataset.issues = [issue];
  }
}

// src/utils/_isLuhnAlgo/_isLuhnAlgo.ts
var NON_DIGIT_REGEX = /(?:[\0-\/:-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF][\uDC00-\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])/g;
function _isLuhnAlgo(input) {
  var number2 = input.replace(NON_DIGIT_REGEX, "");
  var length2 = number2.length;
  var bit = 1;
  var sum = 0;
  while (length2) {
    var value2 = +number2[--length2];
    bit ^= 1;
    sum += bit ? [0, 2, 4, 6, 8, 1, 3, 5, 7, 9][value2] : value2;
  }
  return sum % 10 === 0;
}

// src/utils/_isValidObjectKey/_isValidObjectKey.ts
function _isValidObjectKey(object2, key) {
  return Object.hasOwn(object2, key) && key !== "__proto__" && key !== "prototype" && key !== "constructor";
}

// src/utils/entriesFromList/entriesFromList.ts
function entriesFromList(list, schema) {
  var entries = {};
  var _iterator = _createForOfIteratorHelper(list),
    _step;
  try {
    for (_iterator.s(); !(_step = _iterator.n()).done;) {
      var key = _step.value;
      entries[key] = schema;
    }
  } catch (err) {
    _iterator.e(err);
  } finally {
    _iterator.f();
  }
  return entries;
}

// src/utils/getDotPath/getDotPath.ts
function getDotPath(issue) {
  if (issue.path) {
    var key = "";
    var _iterator2 = _createForOfIteratorHelper(issue.path),
      _step2;
    try {
      for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
        var item = _step2.value;
        if (typeof item.key === "string" || typeof item.key === "number") {
          if (key) {
            key += ".".concat(item.key);
          } else {
            key += item.key;
          }
        } else {
          return null;
        }
      }
    } catch (err) {
      _iterator2.e(err);
    } finally {
      _iterator2.f();
    }
    return key;
  }
  return null;
}

// src/utils/isOfKind/isOfKind.ts
function isOfKind(kind, object2) {
  return object2.kind === kind;
}

// src/utils/isOfType/isOfType.ts
function isOfType(type, object2) {
  return object2.type === type;
}

// src/utils/isValiError/isValiError.ts
function isValiError(error) {
  return error instanceof ValiError;
}

// src/utils/ValiError/ValiError.ts
var ValiError = exports.ValiError = /*#__PURE__*/function (_Error) {
  /**
   * Creates a Valibot error with useful information.
   *
   * @param issues The error issues.
   */
  function ValiError(issues) {
    var _this;
    _classCallCheck(this, ValiError);
    _this = _callSuper(this, ValiError, [issues[0].message]);
    /**
     * The error issues.
     */
    _defineProperty(_this, "issues", void 0);
    _this.name = "ValiError";
    _this.issues = issues;
    return _this;
  }
  _inherits(ValiError, _Error);
  return _createClass(ValiError);
}(/*#__PURE__*/_wrapNativeSuper(Error));

// src/actions/base64/base64.ts
function base64(message) {
  return {
    kind: "validation",
    type: "base64",
    reference: base64,
    async: false,
    expects: null,
    requirement: BASE64_REGEX,
    message: message,
    _run: function _run(dataset, config2) {
      if (dataset.typed && !this.requirement.test(dataset.value)) {
        _addIssue(this, "Base64", dataset, config2);
      }
      return dataset;
    }
  };
}

// src/actions/bic/bic.ts
function bic(message) {
  return {
    kind: "validation",
    type: "bic",
    reference: bic,
    async: false,
    expects: null,
    requirement: BIC_REGEX,
    message: message,
    _run: function _run(dataset, config2) {
      if (dataset.typed && !this.requirement.test(dataset.value)) {
        _addIssue(this, "BIC", dataset, config2);
      }
      return dataset;
    }
  };
}

// src/actions/brand/brand.ts
function brand(name) {
  return {
    kind: "transformation",
    type: "brand",
    reference: brand,
    async: false,
    name: name,
    _run: function _run(dataset) {
      return dataset;
    }
  };
}

// src/actions/bytes/bytes.ts
function bytes(requirement, message) {
  return {
    kind: "validation",
    type: "bytes",
    reference: bytes,
    async: false,
    expects: "".concat(requirement),
    requirement: requirement,
    message: message,
    _run: function _run(dataset, config2) {
      if (dataset.typed) {
        var length2 = new TextEncoder().encode(dataset.value).length;
        if (length2 !== this.requirement) {
          _addIssue(this, "bytes", dataset, config2, {
            received: "".concat(length2)
          });
        }
      }
      return dataset;
    }
  };
}

// src/actions/check/check.ts
function check(requirement, message) {
  return {
    kind: "validation",
    type: "check",
    reference: check,
    async: false,
    expects: null,
    requirement: requirement,
    message: message,
    _run: function _run(dataset, config2) {
      if (dataset.typed && !this.requirement(dataset.value)) {
        _addIssue(this, "input", dataset, config2);
      }
      return dataset;
    }
  };
}

// src/actions/check/checkAsync.ts
function checkAsync(requirement, message) {
  return {
    kind: "validation",
    type: "check",
    reference: checkAsync,
    async: true,
    expects: null,
    requirement: requirement,
    message: message,
    _run: function _run(dataset, config2) {
      var _this2 = this;
      return _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee2() {
        return _regeneratorRuntime().wrap(function _callee2$(_context2) {
          while (1) switch (_context2.prev = _context2.next) {
            case 0:
              _context2.t0 = dataset.typed;
              if (!_context2.t0) {
                _context2.next = 5;
                break;
              }
              _context2.next = 4;
              return _this2.requirement(dataset.value);
            case 4:
              _context2.t0 = !_context2.sent;
            case 5:
              if (!_context2.t0) {
                _context2.next = 7;
                break;
              }
              _addIssue(_this2, "input", dataset, config2);
            case 7:
              return _context2.abrupt("return", dataset);
            case 8:
            case "end":
              return _context2.stop();
          }
        }, _callee2);
      }))();
    }
  };
}

// src/actions/checkItems/checkItems.ts
function checkItems(requirement, message) {
  return {
    kind: "validation",
    type: "check_items",
    reference: checkItems,
    async: false,
    expects: null,
    requirement: requirement,
    message: message,
    _run: function _run(dataset, config2) {
      if (dataset.typed) {
        for (var index = 0; index < dataset.value.length; index++) {
          var item = dataset.value[index];
          if (!this.requirement(item, index, dataset.value)) {
            _addIssue(this, "item", dataset, config2, {
              input: item,
              path: [{
                type: "array",
                origin: "value",
                input: dataset.value,
                key: index,
                value: item
              }]
            });
          }
        }
      }
      return dataset;
    }
  };
}

// src/actions/creditCard/creditCard.ts
var CREDIT_CARD_REGEX = /^(?:[0-9]{14,19}|[0-9]{4}(?: [0-9]{3,6}){2,4}|[0-9]{4}(?:-[0-9]{3,6}){2,4})$/;
var SANITIZE_REGEX = /[ \x2D]/g;
var PROVIDER_REGEX_LIST = [
// American Express
/^3[47][0-9]{13}$/,
// Diners Club
/^3(?:0[0-5]|[68][0-9])[0-9]{11,13}$/,
// Discover
/^6(?:011|5[0-9]{2})[0-9]{12,15}$/,
// JCB
/^(?:2131|1800|35[0-9]{3})[0-9]{11}$/,
// Mastercard
/^5[1-5][0-9]{2}|(?:222[0-9]|22[3-9][0-9]|2[3-6][0-9]{2}|27[01][0-9]|2720)[0-9]{12}$/,
// UnionPay
/^(?:6[27][0-9]{14,17}|81[0-9]{14,17})$/,
// Visa
/^4[0-9]{12}(?:[0-9]{3,6})?$/];
function creditCard(message) {
  return {
    kind: "validation",
    type: "credit_card",
    reference: creditCard,
    async: false,
    expects: null,
    requirement: function requirement(input) {
      var sanitized;
      return CREDIT_CARD_REGEX.test(input) && (
      // Remove any hyphens and blanks
      sanitized = input.replace(SANITIZE_REGEX, "")) &&
      // Check if it matches a provider
      PROVIDER_REGEX_LIST.some(function (regex2) {
        return regex2.test(sanitized);
      }) &&
      // Check if passes luhn algorithm
      _isLuhnAlgo(sanitized);
    },
    message: message,
    _run: function _run(dataset, config2) {
      if (dataset.typed && !this.requirement(dataset.value)) {
        _addIssue(this, "credit card", dataset, config2);
      }
      return dataset;
    }
  };
}

// src/actions/cuid2/cuid2.ts
function cuid2(message) {
  return {
    kind: "validation",
    type: "cuid2",
    reference: cuid2,
    async: false,
    expects: null,
    requirement: CUID2_REGEX,
    message: message,
    _run: function _run(dataset, config2) {
      if (dataset.typed && !this.requirement.test(dataset.value)) {
        _addIssue(this, "Cuid2", dataset, config2);
      }
      return dataset;
    }
  };
}

// src/actions/decimal/decimal.ts
function decimal(message) {
  return {
    kind: "validation",
    type: "decimal",
    reference: decimal,
    async: false,
    expects: null,
    requirement: DECIMAL_REGEX,
    message: message,
    _run: function _run(dataset, config2) {
      if (dataset.typed && !this.requirement.test(dataset.value)) {
        _addIssue(this, "decimal", dataset, config2);
      }
      return dataset;
    }
  };
}

// src/actions/description/description.ts
function description(description_) {
  return {
    kind: "metadata",
    type: "description",
    reference: description,
    description: description_
  };
}

// src/actions/email/email.ts
function email(message) {
  return {
    kind: "validation",
    type: "email",
    reference: email,
    expects: null,
    async: false,
    requirement: EMAIL_REGEX,
    message: message,
    _run: function _run(dataset, config2) {
      if (dataset.typed && !this.requirement.test(dataset.value)) {
        _addIssue(this, "email", dataset, config2);
      }
      return dataset;
    }
  };
}

// src/actions/emoji/emoji.ts
function emoji(message) {
  return {
    kind: "validation",
    type: "emoji",
    reference: emoji,
    async: false,
    expects: null,
    requirement: EMOJI_REGEX,
    message: message,
    _run: function _run(dataset, config2) {
      if (dataset.typed && !this.requirement.test(dataset.value)) {
        _addIssue(this, "emoji", dataset, config2);
      }
      return dataset;
    }
  };
}

// src/actions/empty/empty.ts
function empty(message) {
  return {
    kind: "validation",
    type: "empty",
    reference: empty,
    async: false,
    expects: "0",
    message: message,
    _run: function _run(dataset, config2) {
      if (dataset.typed && dataset.value.length > 0) {
        _addIssue(this, "length", dataset, config2, {
          received: "".concat(dataset.value.length)
        });
      }
      return dataset;
    }
  };
}

// src/actions/endsWith/endsWith.ts
function endsWith(requirement, message) {
  return {
    kind: "validation",
    type: "ends_with",
    reference: endsWith,
    async: false,
    expects: "\"".concat(requirement, "\""),
    requirement: requirement,
    message: message,
    _run: function _run(dataset, config2) {
      if (dataset.typed && !dataset.value.endsWith(this.requirement)) {
        _addIssue(this, "end", dataset, config2, {
          received: "\"".concat(dataset.value.slice(-this.requirement.length), "\"")
        });
      }
      return dataset;
    }
  };
}

// src/actions/everyItem/everyItem.ts
function everyItem(requirement, message) {
  return {
    kind: "validation",
    type: "every_item",
    reference: everyItem,
    async: false,
    expects: null,
    requirement: requirement,
    message: message,
    _run: function _run(dataset, config2) {
      if (dataset.typed && !dataset.value.every(this.requirement)) {
        _addIssue(this, "item", dataset, config2);
      }
      return dataset;
    }
  };
}

// src/actions/excludes/excludes.ts
function excludes(requirement, message) {
  var received = _stringify(requirement);
  return {
    kind: "validation",
    type: "excludes",
    reference: excludes,
    async: false,
    expects: "!".concat(received),
    requirement: requirement,
    message: message,
    _run: function _run(dataset, config2) {
      if (dataset.typed && dataset.value.includes(this.requirement)) {
        _addIssue(this, "content", dataset, config2, {
          received: received
        });
      }
      return dataset;
    }
  };
}

// src/actions/filterItems/filterItems.ts
function filterItems(operation) {
  return {
    kind: "transformation",
    type: "filter_items",
    reference: filterItems,
    async: false,
    operation: operation,
    _run: function _run(dataset) {
      dataset.value = dataset.value.filter(this.operation);
      return dataset;
    }
  };
}

// src/actions/findItem/findItem.ts
function findItem(operation) {
  return {
    kind: "transformation",
    type: "find_item",
    reference: findItem,
    async: false,
    operation: operation,
    _run: function _run(dataset) {
      dataset.value = dataset.value.find(this.operation);
      return dataset;
    }
  };
}

// src/actions/finite/finite.ts
function finite(message) {
  return {
    kind: "validation",
    type: "finite",
    reference: finite,
    async: false,
    expects: null,
    requirement: Number.isFinite,
    message: message,
    _run: function _run(dataset, config2) {
      if (dataset.typed && !this.requirement(dataset.value)) {
        _addIssue(this, "finite", dataset, config2);
      }
      return dataset;
    }
  };
}

// src/actions/hash/hash.ts
var HASH_LENGTHS = {
  md4: 32,
  md5: 32,
  sha1: 40,
  sha256: 64,
  sha384: 96,
  sha512: 128,
  ripemd128: 32,
  ripemd160: 40,
  tiger128: 32,
  tiger160: 40,
  tiger192: 48,
  crc32: 8,
  crc32b: 8,
  adler32: 8
};
function hash(types, message) {
  return {
    kind: "validation",
    type: "hash",
    reference: hash,
    expects: null,
    async: false,
    requirement: RegExp(types.map(function (type) {
      return "^[a-f0-9]{".concat(HASH_LENGTHS[type], "}$");
    }).join("|"), "iu"),
    message: message,
    _run: function _run(dataset, config2) {
      if (dataset.typed && !this.requirement.test(dataset.value)) {
        _addIssue(this, "hash", dataset, config2);
      }
      return dataset;
    }
  };
}

// src/actions/hexadecimal/hexadecimal.ts
function hexadecimal(message) {
  return {
    kind: "validation",
    type: "hexadecimal",
    reference: hexadecimal,
    async: false,
    expects: null,
    requirement: HEXADECIMAL_REGEX,
    message: message,
    _run: function _run(dataset, config2) {
      if (dataset.typed && !this.requirement.test(dataset.value)) {
        _addIssue(this, "hexadecimal", dataset, config2);
      }
      return dataset;
    }
  };
}

// src/actions/hexColor/hexColor.ts
function hexColor(message) {
  return {
    kind: "validation",
    type: "hex_color",
    reference: hexColor,
    async: false,
    expects: null,
    requirement: HEX_COLOR_REGEX,
    message: message,
    _run: function _run(dataset, config2) {
      if (dataset.typed && !this.requirement.test(dataset.value)) {
        _addIssue(this, "hex color", dataset, config2);
      }
      return dataset;
    }
  };
}

// src/actions/imei/imei.ts
function imei(message) {
  return {
    kind: "validation",
    type: "imei",
    reference: imei,
    async: false,
    expects: null,
    requirement: function requirement(input) {
      return IMEI_REGEX.test(input) && _isLuhnAlgo(input);
    },
    message: message,
    _run: function _run(dataset, config2) {
      if (dataset.typed && !this.requirement(dataset.value)) {
        _addIssue(this, "IMEI", dataset, config2);
      }
      return dataset;
    }
  };
}

// src/actions/includes/includes.ts
function includes(requirement, message) {
  var expects = _stringify(requirement);
  return {
    kind: "validation",
    type: "includes",
    reference: includes,
    async: false,
    expects: expects,
    requirement: requirement,
    message: message,
    _run: function _run(dataset, config2) {
      if (dataset.typed && !dataset.value.includes(this.requirement)) {
        _addIssue(this, "content", dataset, config2, {
          received: "!".concat(expects)
        });
      }
      return dataset;
    }
  };
}

// src/actions/integer/integer.ts
function integer(message) {
  return {
    kind: "validation",
    type: "integer",
    reference: integer,
    async: false,
    expects: null,
    requirement: Number.isInteger,
    message: message,
    _run: function _run(dataset, config2) {
      if (dataset.typed && !this.requirement(dataset.value)) {
        _addIssue(this, "integer", dataset, config2);
      }
      return dataset;
    }
  };
}

// src/actions/ip/ip.ts
function ip(message) {
  return {
    kind: "validation",
    type: "ip",
    reference: ip,
    async: false,
    expects: null,
    requirement: IP_REGEX,
    message: message,
    _run: function _run(dataset, config2) {
      if (dataset.typed && !this.requirement.test(dataset.value)) {
        _addIssue(this, "IP", dataset, config2);
      }
      return dataset;
    }
  };
}

// src/actions/ipv4/ipv4.ts
function ipv4(message) {
  return {
    kind: "validation",
    type: "ipv4",
    reference: ipv4,
    async: false,
    expects: null,
    requirement: IPV4_REGEX,
    message: message,
    _run: function _run(dataset, config2) {
      if (dataset.typed && !this.requirement.test(dataset.value)) {
        _addIssue(this, "IPv4", dataset, config2);
      }
      return dataset;
    }
  };
}

// src/actions/ipv6/ipv6.ts
function ipv6(message) {
  return {
    kind: "validation",
    type: "ipv6",
    reference: ipv6,
    async: false,
    expects: null,
    requirement: IPV6_REGEX,
    message: message,
    _run: function _run(dataset, config2) {
      if (dataset.typed && !this.requirement.test(dataset.value)) {
        _addIssue(this, "IPv6", dataset, config2);
      }
      return dataset;
    }
  };
}

// src/actions/isoDate/isoDate.ts
function isoDate(message) {
  return {
    kind: "validation",
    type: "iso_date",
    reference: isoDate,
    async: false,
    expects: null,
    requirement: ISO_DATE_REGEX,
    message: message,
    _run: function _run(dataset, config2) {
      if (dataset.typed && !this.requirement.test(dataset.value)) {
        _addIssue(this, "date", dataset, config2);
      }
      return dataset;
    }
  };
}

// src/actions/isoDateTime/isoDateTime.ts
function isoDateTime(message) {
  return {
    kind: "validation",
    type: "iso_date_time",
    reference: isoDateTime,
    async: false,
    expects: null,
    requirement: ISO_DATE_TIME_REGEX,
    message: message,
    _run: function _run(dataset, config2) {
      if (dataset.typed && !this.requirement.test(dataset.value)) {
        _addIssue(this, "date-time", dataset, config2);
      }
      return dataset;
    }
  };
}

// src/actions/isoTime/isoTime.ts
function isoTime(message) {
  return {
    kind: "validation",
    type: "iso_time",
    reference: isoTime,
    async: false,
    expects: null,
    requirement: ISO_TIME_REGEX,
    message: message,
    _run: function _run(dataset, config2) {
      if (dataset.typed && !this.requirement.test(dataset.value)) {
        _addIssue(this, "time", dataset, config2);
      }
      return dataset;
    }
  };
}

// src/actions/isoTimeSecond/isoTimeSecond.ts
function isoTimeSecond(message) {
  return {
    kind: "validation",
    type: "iso_time_second",
    reference: isoTimeSecond,
    async: false,
    expects: null,
    requirement: ISO_TIME_SECOND_REGEX,
    message: message,
    _run: function _run(dataset, config2) {
      if (dataset.typed && !this.requirement.test(dataset.value)) {
        _addIssue(this, "time-second", dataset, config2);
      }
      return dataset;
    }
  };
}

// src/actions/isoTimestamp/isoTimestamp.ts
function isoTimestamp(message) {
  return {
    kind: "validation",
    type: "iso_timestamp",
    reference: isoTimestamp,
    async: false,
    expects: null,
    requirement: ISO_TIMESTAMP_REGEX,
    message: message,
    _run: function _run(dataset, config2) {
      if (dataset.typed && !this.requirement.test(dataset.value)) {
        _addIssue(this, "timestamp", dataset, config2);
      }
      return dataset;
    }
  };
}

// src/actions/isoWeek/isoWeek.ts
function isoWeek(message) {
  return {
    kind: "validation",
    type: "iso_week",
    reference: isoWeek,
    async: false,
    expects: null,
    requirement: ISO_WEEK_REGEX,
    message: message,
    _run: function _run(dataset, config2) {
      if (dataset.typed && !this.requirement.test(dataset.value)) {
        _addIssue(this, "week", dataset, config2);
      }
      return dataset;
    }
  };
}

// src/actions/length/length.ts
function length(requirement, message) {
  return {
    kind: "validation",
    type: "length",
    reference: length,
    async: false,
    expects: "".concat(requirement),
    requirement: requirement,
    message: message,
    _run: function _run(dataset, config2) {
      if (dataset.typed && dataset.value.length !== this.requirement) {
        _addIssue(this, "length", dataset, config2, {
          received: "".concat(dataset.value.length)
        });
      }
      return dataset;
    }
  };
}

// src/actions/mac/mac.ts
function mac(message) {
  return {
    kind: "validation",
    type: "mac",
    reference: mac,
    async: false,
    expects: null,
    requirement: MAC_REGEX,
    message: message,
    _run: function _run(dataset, config2) {
      if (dataset.typed && !this.requirement.test(dataset.value)) {
        _addIssue(this, "MAC", dataset, config2);
      }
      return dataset;
    }
  };
}

// src/actions/mac48/mac48.ts
function mac48(message) {
  return {
    kind: "validation",
    type: "mac48",
    reference: mac48,
    async: false,
    expects: null,
    requirement: MAC48_REGEX,
    message: message,
    _run: function _run(dataset, config2) {
      if (dataset.typed && !this.requirement.test(dataset.value)) {
        _addIssue(this, "48-bit MAC", dataset, config2);
      }
      return dataset;
    }
  };
}

// src/actions/mac64/mac64.ts
function mac64(message) {
  return {
    kind: "validation",
    type: "mac64",
    reference: mac64,
    async: false,
    expects: null,
    requirement: MAC64_REGEX,
    message: message,
    _run: function _run(dataset, config2) {
      if (dataset.typed && !this.requirement.test(dataset.value)) {
        _addIssue(this, "64-bit MAC", dataset, config2);
      }
      return dataset;
    }
  };
}

// src/actions/mapItems/mapItems.ts
function mapItems(operation) {
  return {
    kind: "transformation",
    type: "map_items",
    reference: mapItems,
    async: false,
    operation: operation,
    _run: function _run(dataset) {
      dataset.value = dataset.value.map(this.operation);
      return dataset;
    }
  };
}

// src/actions/maxBytes/maxBytes.ts
function maxBytes(requirement, message) {
  return {
    kind: "validation",
    type: "max_bytes",
    reference: maxBytes,
    async: false,
    expects: "<=".concat(requirement),
    requirement: requirement,
    message: message,
    _run: function _run(dataset, config2) {
      if (dataset.typed) {
        var length2 = new TextEncoder().encode(dataset.value).length;
        if (length2 > this.requirement) {
          _addIssue(this, "bytes", dataset, config2, {
            received: "".concat(length2)
          });
        }
      }
      return dataset;
    }
  };
}

// src/actions/maxLength/maxLength.ts
function maxLength(requirement, message) {
  return {
    kind: "validation",
    type: "max_length",
    reference: maxLength,
    async: false,
    expects: "<=".concat(requirement),
    requirement: requirement,
    message: message,
    _run: function _run(dataset, config2) {
      if (dataset.typed && dataset.value.length > this.requirement) {
        _addIssue(this, "length", dataset, config2, {
          received: "".concat(dataset.value.length)
        });
      }
      return dataset;
    }
  };
}

// src/actions/maxSize/maxSize.ts
function maxSize(requirement, message) {
  return {
    kind: "validation",
    type: "max_size",
    reference: maxSize,
    async: false,
    expects: "<=".concat(requirement),
    requirement: requirement,
    message: message,
    _run: function _run(dataset, config2) {
      if (dataset.typed && dataset.value.size > this.requirement) {
        _addIssue(this, "size", dataset, config2, {
          received: "".concat(dataset.value.size)
        });
      }
      return dataset;
    }
  };
}

// src/actions/maxValue/maxValue.ts
function maxValue(requirement, message) {
  return {
    kind: "validation",
    type: "max_value",
    reference: maxValue,
    async: false,
    expects: "<=".concat(requirement instanceof Date ? requirement.toJSON() : _stringify(requirement)),
    requirement: requirement,
    message: message,
    _run: function _run(dataset, config2) {
      if (dataset.typed && dataset.value > this.requirement) {
        _addIssue(this, "value", dataset, config2, {
          received: dataset.value instanceof Date ? dataset.value.toJSON() : _stringify(dataset.value)
        });
      }
      return dataset;
    }
  };
}

// src/actions/mimeType/mimeType.ts
function mimeType(requirement, message) {
  return {
    kind: "validation",
    type: "mime_type",
    reference: mimeType,
    async: false,
    expects: requirement.map(function (option) {
      return "\"".concat(option, "\"");
    }).join(" | ") || "never",
    requirement: requirement,
    message: message,
    _run: function _run(dataset, config2) {
      if (dataset.typed && !this.requirement.includes(dataset.value.type)) {
        _addIssue(this, "MIME type", dataset, config2, {
          received: "\"".concat(dataset.value.type, "\"")
        });
      }
      return dataset;
    }
  };
}

// src/actions/minBytes/minBytes.ts
function minBytes(requirement, message) {
  return {
    kind: "validation",
    type: "min_bytes",
    reference: minBytes,
    async: false,
    expects: ">=".concat(requirement),
    requirement: requirement,
    message: message,
    _run: function _run(dataset, config2) {
      if (dataset.typed) {
        var length2 = new TextEncoder().encode(dataset.value).length;
        if (length2 < this.requirement) {
          _addIssue(this, "bytes", dataset, config2, {
            received: "".concat(length2)
          });
        }
      }
      return dataset;
    }
  };
}

// src/actions/minLength/minLength.ts
function minLength(requirement, message) {
  return {
    kind: "validation",
    type: "min_length",
    reference: minLength,
    async: false,
    expects: ">=".concat(requirement),
    requirement: requirement,
    message: message,
    _run: function _run(dataset, config2) {
      if (dataset.typed && dataset.value.length < this.requirement) {
        _addIssue(this, "length", dataset, config2, {
          received: "".concat(dataset.value.length)
        });
      }
      return dataset;
    }
  };
}

// src/actions/minSize/minSize.ts
function minSize(requirement, message) {
  return {
    kind: "validation",
    type: "min_size",
    reference: minSize,
    async: false,
    expects: ">=".concat(requirement),
    requirement: requirement,
    message: message,
    _run: function _run(dataset, config2) {
      if (dataset.typed && dataset.value.size < this.requirement) {
        _addIssue(this, "size", dataset, config2, {
          received: "".concat(dataset.value.size)
        });
      }
      return dataset;
    }
  };
}

// src/actions/minValue/minValue.ts
function minValue(requirement, message) {
  return {
    kind: "validation",
    type: "min_value",
    reference: minValue,
    async: false,
    expects: ">=".concat(requirement instanceof Date ? requirement.toJSON() : _stringify(requirement)),
    requirement: requirement,
    message: message,
    _run: function _run(dataset, config2) {
      if (dataset.typed && dataset.value < this.requirement) {
        _addIssue(this, "value", dataset, config2, {
          received: dataset.value instanceof Date ? dataset.value.toJSON() : _stringify(dataset.value)
        });
      }
      return dataset;
    }
  };
}

// src/actions/multipleOf/multipleOf.ts
function multipleOf(requirement, message) {
  return {
    kind: "validation",
    type: "multiple_of",
    reference: multipleOf,
    async: false,
    expects: "%".concat(requirement),
    requirement: requirement,
    message: message,
    _run: function _run(dataset, config2) {
      if (dataset.typed && dataset.value % this.requirement !== 0) {
        _addIssue(this, "multiple", dataset, config2);
      }
      return dataset;
    }
  };
}

// src/actions/nonEmpty/nonEmpty.ts
function nonEmpty(message) {
  return {
    kind: "validation",
    type: "non_empty",
    reference: nonEmpty,
    async: false,
    expects: "!0",
    message: message,
    _run: function _run(dataset, config2) {
      if (dataset.typed && dataset.value.length === 0) {
        _addIssue(this, "length", dataset, config2, {
          received: "0"
        });
      }
      return dataset;
    }
  };
}

// src/actions/normalize/normalize.ts
function normalize(form) {
  return {
    kind: "transformation",
    type: "normalize",
    reference: normalize,
    async: false,
    form: form,
    _run: function _run(dataset) {
      dataset.value = dataset.value.normalize(this.form);
      return dataset;
    }
  };
}

// src/actions/notBytes/notBytes.ts
function notBytes(requirement, message) {
  return {
    kind: "validation",
    type: "not_bytes",
    reference: notBytes,
    async: false,
    expects: "!".concat(requirement),
    requirement: requirement,
    message: message,
    _run: function _run(dataset, config2) {
      if (dataset.typed) {
        var length2 = new TextEncoder().encode(dataset.value).length;
        if (length2 === this.requirement) {
          _addIssue(this, "bytes", dataset, config2, {
            received: "".concat(length2)
          });
        }
      }
      return dataset;
    }
  };
}

// src/actions/notLength/notLength.ts
function notLength(requirement, message) {
  return {
    kind: "validation",
    type: "not_length",
    reference: notLength,
    async: false,
    expects: "!".concat(requirement),
    requirement: requirement,
    message: message,
    _run: function _run(dataset, config2) {
      if (dataset.typed && dataset.value.length === this.requirement) {
        _addIssue(this, "length", dataset, config2, {
          received: "".concat(dataset.value.length)
        });
      }
      return dataset;
    }
  };
}

// src/actions/notSize/notSize.ts
function notSize(requirement, message) {
  return {
    kind: "validation",
    type: "not_size",
    reference: notSize,
    async: false,
    expects: "!".concat(requirement),
    requirement: requirement,
    message: message,
    _run: function _run(dataset, config2) {
      if (dataset.typed && dataset.value.size === this.requirement) {
        _addIssue(this, "size", dataset, config2, {
          received: "".concat(dataset.value.size)
        });
      }
      return dataset;
    }
  };
}

// src/actions/notValue/notValue.ts
function notValue(requirement, message) {
  return {
    kind: "validation",
    type: "not_value",
    reference: notValue,
    async: false,
    expects: requirement instanceof Date ? "!".concat(requirement.toJSON()) : "!".concat(_stringify(requirement)),
    requirement: requirement,
    message: message,
    _run: function _run(dataset, config2) {
      if (dataset.typed && this.requirement <= dataset.value && this.requirement >= dataset.value) {
        _addIssue(this, "value", dataset, config2, {
          received: dataset.value instanceof Date ? dataset.value.toJSON() : _stringify(dataset.value)
        });
      }
      return dataset;
    }
  };
}

// src/actions/octal/octal.ts
function octal(message) {
  return {
    kind: "validation",
    type: "octal",
    reference: octal,
    async: false,
    expects: null,
    requirement: OCTAL_REGEX,
    message: message,
    _run: function _run(dataset, config2) {
      if (dataset.typed && !this.requirement.test(dataset.value)) {
        _addIssue(this, "octal", dataset, config2);
      }
      return dataset;
    }
  };
}

// src/actions/partialCheck/utils/_isPartiallyTyped/_isPartiallyTyped.ts
function _isPartiallyTyped(dataset, pathList) {
  if (dataset.issues) {
    var _iterator3 = _createForOfIteratorHelper(pathList),
      _step3;
    try {
      for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
        var path = _step3.value;
        var _iterator4 = _createForOfIteratorHelper(dataset.issues),
          _step4;
        try {
          for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {
            var _issue$path$length, _issue$path;
            var issue = _step4.value;
            var typed = false;
            var bound = Math.min(path.length, (_issue$path$length = (_issue$path = issue.path) === null || _issue$path === void 0 ? void 0 : _issue$path.length) !== null && _issue$path$length !== void 0 ? _issue$path$length : 0);
            for (var index = 0; index < bound; index++) {
              if (path[index] !== issue.path[index].key) {
                typed = true;
                break;
              }
            }
            if (!typed) {
              return false;
            }
          }
        } catch (err) {
          _iterator4.e(err);
        } finally {
          _iterator4.f();
        }
      }
    } catch (err) {
      _iterator3.e(err);
    } finally {
      _iterator3.f();
    }
  }
  return true;
}

// src/actions/partialCheck/partialCheck.ts
function partialCheck(pathList, requirement, message) {
  return {
    kind: "validation",
    type: "partial_check",
    reference: partialCheck,
    async: false,
    expects: null,
    requirement: requirement,
    message: message,
    _run: function _run(dataset, config2) {
      if (_isPartiallyTyped(dataset, pathList) &&
      // @ts-expect-error
      !this.requirement(dataset.value)) {
        _addIssue(this, "input", dataset, config2);
      }
      return dataset;
    }
  };
}

// src/actions/partialCheck/partialCheckAsync.ts
function partialCheckAsync(pathList, requirement, message) {
  return {
    kind: "validation",
    type: "partial_check",
    reference: partialCheckAsync,
    async: true,
    expects: null,
    requirement: requirement,
    message: message,
    _run: function _run(dataset, config2) {
      var _this3 = this;
      return _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee3() {
        return _regeneratorRuntime().wrap(function _callee3$(_context3) {
          while (1) switch (_context3.prev = _context3.next) {
            case 0:
              _context3.t0 = _isPartiallyTyped(dataset, pathList);
              if (!_context3.t0) {
                _context3.next = 5;
                break;
              }
              _context3.next = 4;
              return _this3.requirement(dataset.value);
            case 4:
              _context3.t0 = !_context3.sent;
            case 5:
              if (!_context3.t0) {
                _context3.next = 7;
                break;
              }
              _addIssue(_this3, "input", dataset, config2);
            case 7:
              return _context3.abrupt("return", dataset);
            case 8:
            case "end":
              return _context3.stop();
          }
        }, _callee3);
      }))();
    }
  };
}

// src/actions/rawCheck/rawCheck.ts
function rawCheck(action) {
  return {
    kind: "validation",
    type: "raw_check",
    reference: rawCheck,
    async: false,
    expects: null,
    _run: function _run(dataset, config2) {
      var _this4 = this;
      action({
        dataset: dataset,
        config: config2,
        addIssue: function addIssue(info) {
          var _info$label;
          return _addIssue(_this4, (_info$label = info === null || info === void 0 ? void 0 : info.label) !== null && _info$label !== void 0 ? _info$label : "input", dataset, config2, info);
        }
      });
      return dataset;
    }
  };
}

// src/actions/rawCheck/rawCheckAsync.ts
function rawCheckAsync(action) {
  return {
    kind: "validation",
    type: "raw_check",
    reference: rawCheckAsync,
    async: true,
    expects: null,
    _run: function _run(dataset, config2) {
      var _this5 = this;
      return _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee4() {
        return _regeneratorRuntime().wrap(function _callee4$(_context4) {
          while (1) switch (_context4.prev = _context4.next) {
            case 0:
              _context4.next = 2;
              return action({
                dataset: dataset,
                config: config2,
                addIssue: function addIssue(info) {
                  var _info$label2;
                  return _addIssue(_this5, (_info$label2 = info === null || info === void 0 ? void 0 : info.label) !== null && _info$label2 !== void 0 ? _info$label2 : "input", dataset, config2, info);
                }
              });
            case 2:
              return _context4.abrupt("return", dataset);
            case 3:
            case "end":
              return _context4.stop();
          }
        }, _callee4);
      }))();
    }
  };
}

// src/actions/rawTransform/rawTransform.ts
function rawTransform(action) {
  return {
    kind: "transformation",
    type: "raw_transform",
    reference: rawTransform,
    async: false,
    _run: function _run(dataset, config2) {
      var _this6 = this;
      var output = action({
        dataset: dataset,
        config: config2,
        addIssue: function addIssue(info) {
          var _info$label3;
          return _addIssue(_this6, (_info$label3 = info === null || info === void 0 ? void 0 : info.label) !== null && _info$label3 !== void 0 ? _info$label3 : "input", dataset, config2, info);
        },
        NEVER: null
      });
      if (dataset.issues) {
        dataset.typed = false;
      } else {
        dataset.value = output;
      }
      return dataset;
    }
  };
}

// src/actions/rawTransform/rawTransformAsync.ts
function rawTransformAsync(action) {
  return {
    kind: "transformation",
    type: "raw_transform",
    reference: rawTransformAsync,
    async: true,
    _run: function _run(dataset, config2) {
      var _this7 = this;
      return _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee5() {
        var output;
        return _regeneratorRuntime().wrap(function _callee5$(_context5) {
          while (1) switch (_context5.prev = _context5.next) {
            case 0:
              _context5.next = 2;
              return action({
                dataset: dataset,
                config: config2,
                addIssue: function addIssue(info) {
                  var _info$label4;
                  return _addIssue(_this7, (_info$label4 = info === null || info === void 0 ? void 0 : info.label) !== null && _info$label4 !== void 0 ? _info$label4 : "input", dataset, config2, info);
                },
                NEVER: null
              });
            case 2:
              output = _context5.sent;
              if (dataset.issues) {
                dataset.typed = false;
              } else {
                dataset.value = output;
              }
              return _context5.abrupt("return", dataset);
            case 5:
            case "end":
              return _context5.stop();
          }
        }, _callee5);
      }))();
    }
  };
}

// src/actions/readonly/readonly.ts
function readonly() {
  return {
    kind: "transformation",
    type: "readonly",
    reference: readonly,
    async: false,
    _run: function _run(dataset) {
      return dataset;
    }
  };
}

// src/actions/reduceItems/reduceItems.ts
function reduceItems(operation, initial) {
  return {
    kind: "transformation",
    type: "reduce_items",
    reference: reduceItems,
    async: false,
    operation: operation,
    initial: initial,
    _run: function _run(dataset) {
      dataset.value = dataset.value.reduce(this.operation, this.initial);
      return dataset;
    }
  };
}

// src/actions/regex/regex.ts
function regex(requirement, message) {
  return {
    kind: "validation",
    type: "regex",
    reference: regex,
    async: false,
    expects: "".concat(requirement),
    requirement: requirement,
    message: message,
    _run: function _run(dataset, config2) {
      if (dataset.typed && !this.requirement.test(dataset.value)) {
        _addIssue(this, "format", dataset, config2);
      }
      return dataset;
    }
  };
}

// src/actions/safeInteger/safeInteger.ts
function safeInteger(message) {
  return {
    kind: "validation",
    type: "safe_integer",
    reference: safeInteger,
    async: false,
    expects: null,
    requirement: Number.isSafeInteger,
    message: message,
    _run: function _run(dataset, config2) {
      if (dataset.typed && !this.requirement(dataset.value)) {
        _addIssue(this, "safe integer", dataset, config2);
      }
      return dataset;
    }
  };
}

// src/actions/size/size.ts
function size(requirement, message) {
  return {
    kind: "validation",
    type: "size",
    reference: size,
    async: false,
    expects: "".concat(requirement),
    requirement: requirement,
    message: message,
    _run: function _run(dataset, config2) {
      if (dataset.typed && dataset.value.size !== this.requirement) {
        _addIssue(this, "size", dataset, config2, {
          received: "".concat(dataset.value.size)
        });
      }
      return dataset;
    }
  };
}

// src/actions/someItem/someItem.ts
function someItem(requirement, message) {
  return {
    kind: "validation",
    type: "some_item",
    reference: someItem,
    async: false,
    expects: null,
    requirement: requirement,
    message: message,
    _run: function _run(dataset, config2) {
      if (dataset.typed && !dataset.value.some(this.requirement)) {
        _addIssue(this, "item", dataset, config2);
      }
      return dataset;
    }
  };
}

// src/actions/sortItems/sortItems.ts
function sortItems(operation) {
  return {
    kind: "transformation",
    type: "sort_items",
    reference: sortItems,
    async: false,
    operation: operation,
    _run: function _run(dataset) {
      dataset.value = dataset.value.sort(this.operation);
      return dataset;
    }
  };
}

// src/actions/startsWith/startsWith.ts
function startsWith(requirement, message) {
  return {
    kind: "validation",
    type: "starts_with",
    reference: startsWith,
    async: false,
    expects: "\"".concat(requirement, "\""),
    requirement: requirement,
    message: message,
    _run: function _run(dataset, config2) {
      if (dataset.typed && !dataset.value.startsWith(this.requirement)) {
        _addIssue(this, "start", dataset, config2, {
          received: "\"".concat(dataset.value.slice(0, this.requirement.length), "\"")
        });
      }
      return dataset;
    }
  };
}

// src/actions/toLowerCase/toLowerCase.ts
function toLowerCase() {
  return {
    kind: "transformation",
    type: "to_lower_case",
    reference: toLowerCase,
    async: false,
    _run: function _run(dataset) {
      dataset.value = dataset.value.toLowerCase();
      return dataset;
    }
  };
}

// src/actions/toMaxValue/toMaxValue.ts
function toMaxValue(requirement) {
  return {
    kind: "transformation",
    type: "to_max_value",
    reference: toMaxValue,
    async: false,
    requirement: requirement,
    _run: function _run(dataset) {
      dataset.value = dataset.value > this.requirement ? this.requirement : dataset.value;
      return dataset;
    }
  };
}

// src/actions/toMinValue/toMinValue.ts
function toMinValue(requirement) {
  return {
    kind: "transformation",
    type: "to_min_value",
    reference: toMinValue,
    async: false,
    requirement: requirement,
    _run: function _run(dataset) {
      dataset.value = dataset.value < this.requirement ? this.requirement : dataset.value;
      return dataset;
    }
  };
}

// src/actions/toUpperCase/toUpperCase.ts
function toUpperCase() {
  return {
    kind: "transformation",
    type: "to_upper_case",
    reference: toUpperCase,
    async: false,
    _run: function _run(dataset) {
      dataset.value = dataset.value.toUpperCase();
      return dataset;
    }
  };
}

// src/actions/transform/transform.ts
function transform(operation) {
  return {
    kind: "transformation",
    type: "transform",
    reference: transform,
    async: false,
    operation: operation,
    _run: function _run(dataset) {
      dataset.value = this.operation(dataset.value);
      return dataset;
    }
  };
}

// src/actions/transform/transformAsync.ts
function transformAsync(operation) {
  return {
    kind: "transformation",
    type: "transform",
    reference: transformAsync,
    async: true,
    operation: operation,
    _run: function _run(dataset) {
      var _this8 = this;
      return _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee6() {
        return _regeneratorRuntime().wrap(function _callee6$(_context6) {
          while (1) switch (_context6.prev = _context6.next) {
            case 0:
              _context6.next = 2;
              return _this8.operation(dataset.value);
            case 2:
              dataset.value = _context6.sent;
              return _context6.abrupt("return", dataset);
            case 4:
            case "end":
              return _context6.stop();
          }
        }, _callee6);
      }))();
    }
  };
}

// src/actions/trim/trim.ts
function trim() {
  return {
    kind: "transformation",
    type: "trim",
    reference: trim,
    async: false,
    _run: function _run(dataset) {
      dataset.value = dataset.value.trim();
      return dataset;
    }
  };
}

// src/actions/trimEnd/trimEnd.ts
function trimEnd() {
  return {
    kind: "transformation",
    type: "trim_end",
    reference: trimEnd,
    async: false,
    _run: function _run(dataset) {
      dataset.value = dataset.value.trimEnd();
      return dataset;
    }
  };
}

// src/actions/trimStart/trimStart.ts
function trimStart() {
  return {
    kind: "transformation",
    type: "trim_start",
    reference: trimStart,
    async: false,
    _run: function _run(dataset) {
      dataset.value = dataset.value.trimStart();
      return dataset;
    }
  };
}

// src/actions/ulid/ulid.ts
function ulid(message) {
  return {
    kind: "validation",
    type: "ulid",
    reference: ulid,
    async: false,
    expects: null,
    requirement: ULID_REGEX,
    message: message,
    _run: function _run(dataset, config2) {
      if (dataset.typed && !this.requirement.test(dataset.value)) {
        _addIssue(this, "ULID", dataset, config2);
      }
      return dataset;
    }
  };
}

// src/actions/url/url.ts
function url(message) {
  return {
    kind: "validation",
    type: "url",
    reference: url,
    async: false,
    expects: null,
    requirement: function requirement(input) {
      try {
        new URL(input);
        return true;
      } catch (_unused) {
        return false;
      }
    },
    message: message,
    _run: function _run(dataset, config2) {
      if (dataset.typed && !this.requirement(dataset.value)) {
        _addIssue(this, "URL", dataset, config2);
      }
      return dataset;
    }
  };
}

// src/actions/uuid/uuid.ts
function uuid(message) {
  return {
    kind: "validation",
    type: "uuid",
    reference: uuid,
    async: false,
    expects: null,
    requirement: UUID_REGEX,
    message: message,
    _run: function _run(dataset, config2) {
      if (dataset.typed && !this.requirement.test(dataset.value)) {
        _addIssue(this, "UUID", dataset, config2);
      }
      return dataset;
    }
  };
}

// src/actions/value/value.ts
function value(requirement, message) {
  return {
    kind: "validation",
    type: "value",
    reference: value,
    async: false,
    expects: requirement instanceof Date ? requirement.toJSON() : _stringify(requirement),
    requirement: requirement,
    message: message,
    _run: function _run(dataset, config2) {
      if (dataset.typed && !(this.requirement <= dataset.value && this.requirement >= dataset.value)) {
        _addIssue(this, "value", dataset, config2, {
          received: dataset.value instanceof Date ? dataset.value.toJSON() : _stringify(dataset.value)
        });
      }
      return dataset;
    }
  };
}

// src/methods/config/config.ts
function config(schema, config2) {
  return _objectSpread(_objectSpread({}, schema), {}, {
    _run: function _run(dataset, config_) {
      return schema._run(dataset, _objectSpread(_objectSpread({}, config_), config2));
    }
  });
}

// src/methods/getFallback/getFallback.ts
function getFallback(schema, dataset, config2) {
  return typeof schema.fallback === "function" ?
  // @ts-expect-error
  schema.fallback(dataset, config2) :
  // @ts-expect-error
  schema.fallback;
}

// src/methods/fallback/fallback.ts
function fallback(schema, fallback2) {
  return _objectSpread(_objectSpread({}, schema), {}, {
    fallback: fallback2,
    _run: function _run(dataset, config2) {
      var outputDataset = schema._run(dataset, config2);
      return outputDataset.issues ? {
        typed: true,
        value: getFallback(this, outputDataset, config2)
      } : outputDataset;
    }
  });
}

// src/methods/fallback/fallbackAsync.ts
function fallbackAsync(schema, fallback2) {
  return _objectSpread(_objectSpread({}, schema), {}, {
    fallback: fallback2,
    async: true,
    _run: function _run(dataset, config2) {
      var _this9 = this;
      return _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee7() {
        var outputDataset;
        return _regeneratorRuntime().wrap(function _callee7$(_context7) {
          while (1) switch (_context7.prev = _context7.next) {
            case 0:
              _context7.next = 2;
              return schema._run(dataset, config2);
            case 2:
              outputDataset = _context7.sent;
              if (!outputDataset.issues) {
                _context7.next = 10;
                break;
              }
              _context7.next = 6;
              return getFallback(_this9, outputDataset, config2);
            case 6:
              _context7.t1 = _context7.sent;
              _context7.t0 = {
                typed: true,
                value: _context7.t1
              };
              _context7.next = 11;
              break;
            case 10:
              _context7.t0 = outputDataset;
            case 11:
              return _context7.abrupt("return", _context7.t0);
            case 12:
            case "end":
              return _context7.stop();
          }
        }, _callee7);
      }))();
    }
  });
}

// src/methods/flatten/flatten.ts
function flatten(issues) {
  var flatErrors = {};
  var _iterator5 = _createForOfIteratorHelper(issues),
    _step5;
  try {
    for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {
      var issue = _step5.value;
      if (issue.path) {
        var dotPath = getDotPath(issue);
        if (dotPath) {
          if (!flatErrors.nested) {
            flatErrors.nested = {};
          }
          if (flatErrors.nested[dotPath]) {
            flatErrors.nested[dotPath].push(issue.message);
          } else {
            flatErrors.nested[dotPath] = [issue.message];
          }
        } else {
          if (flatErrors.other) {
            flatErrors.other.push(issue.message);
          } else {
            flatErrors.other = [issue.message];
          }
        }
      } else {
        if (flatErrors.root) {
          flatErrors.root.push(issue.message);
        } else {
          flatErrors.root = [issue.message];
        }
      }
    }
  } catch (err) {
    _iterator5.e(err);
  } finally {
    _iterator5.f();
  }
  return flatErrors;
}

// src/methods/forward/forward.ts
function forward(action, pathKeys) {
  return _objectSpread(_objectSpread({}, action), {}, {
    _run: function _run(dataset, config2) {
      var prevIssues = dataset.issues && _toConsumableArray(dataset.issues);
      action._run(dataset, config2);
      if (dataset.issues) {
        var _iterator6 = _createForOfIteratorHelper(dataset.issues),
          _step6;
        try {
          for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {
            var issue = _step6.value;
            if (!(prevIssues !== null && prevIssues !== void 0 && prevIssues.includes(issue))) {
              var pathInput = dataset.value;
              var _iterator7 = _createForOfIteratorHelper(pathKeys),
                _step7;
              try {
                for (_iterator7.s(); !(_step7 = _iterator7.n()).done;) {
                  var key = _step7.value;
                  var pathValue = pathInput[key];
                  var pathItem = {
                    type: "unknown",
                    origin: "value",
                    input: pathInput,
                    key: key,
                    value: pathValue
                  };
                  if (issue.path) {
                    issue.path.push(pathItem);
                  } else {
                    issue.path = [pathItem];
                  }
                  if (!pathValue) {
                    break;
                  }
                  pathInput = pathValue;
                }
              } catch (err) {
                _iterator7.e(err);
              } finally {
                _iterator7.f();
              }
            }
          }
        } catch (err) {
          _iterator6.e(err);
        } finally {
          _iterator6.f();
        }
      }
      return dataset;
    }
  });
}

// src/methods/forward/forwardAsync.ts
function forwardAsync(action, pathKeys) {
  return _objectSpread(_objectSpread({}, action), {}, {
    async: true,
    _run: function _run(dataset, config2) {
      return _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee8() {
        var prevIssues, _iterator8, _step8, issue, pathInput, _iterator9, _step9, key, pathValue, pathItem;
        return _regeneratorRuntime().wrap(function _callee8$(_context8) {
          while (1) switch (_context8.prev = _context8.next) {
            case 0:
              prevIssues = dataset.issues && _toConsumableArray(dataset.issues);
              _context8.next = 3;
              return action._run(dataset, config2);
            case 3:
              if (!dataset.issues) {
                _context8.next = 42;
                break;
              }
              _iterator8 = _createForOfIteratorHelper(dataset.issues);
              _context8.prev = 5;
              _iterator8.s();
            case 7:
              if ((_step8 = _iterator8.n()).done) {
                _context8.next = 34;
                break;
              }
              issue = _step8.value;
              if (prevIssues !== null && prevIssues !== void 0 && prevIssues.includes(issue)) {
                _context8.next = 32;
                break;
              }
              pathInput = dataset.value;
              _iterator9 = _createForOfIteratorHelper(pathKeys);
              _context8.prev = 12;
              _iterator9.s();
            case 14:
              if ((_step9 = _iterator9.n()).done) {
                _context8.next = 24;
                break;
              }
              key = _step9.value;
              pathValue = pathInput[key];
              pathItem = {
                type: "unknown",
                origin: "value",
                input: pathInput,
                key: key,
                value: pathValue
              };
              if (issue.path) {
                issue.path.push(pathItem);
              } else {
                issue.path = [pathItem];
              }
              if (pathValue) {
                _context8.next = 21;
                break;
              }
              return _context8.abrupt("break", 24);
            case 21:
              pathInput = pathValue;
            case 22:
              _context8.next = 14;
              break;
            case 24:
              _context8.next = 29;
              break;
            case 26:
              _context8.prev = 26;
              _context8.t0 = _context8["catch"](12);
              _iterator9.e(_context8.t0);
            case 29:
              _context8.prev = 29;
              _iterator9.f();
              return _context8.finish(29);
            case 32:
              _context8.next = 7;
              break;
            case 34:
              _context8.next = 39;
              break;
            case 36:
              _context8.prev = 36;
              _context8.t1 = _context8["catch"](5);
              _iterator8.e(_context8.t1);
            case 39:
              _context8.prev = 39;
              _iterator8.f();
              return _context8.finish(39);
            case 42:
              return _context8.abrupt("return", dataset);
            case 43:
            case "end":
              return _context8.stop();
          }
        }, _callee8, null, [[5, 36, 39, 42], [12, 26, 29, 32]]);
      }))();
    }
  });
}

// src/methods/getDefault/getDefault.ts
function getDefault(schema, dataset, config2) {
  return typeof schema["default"] === "function" ?
  // @ts-expect-error
  schema["default"](dataset, config2) :
  // @ts-expect-error
  schema["default"];
}

// src/methods/getDefaults/getDefaults.ts
function getDefaults(schema) {
  if ("entries" in schema) {
    var object2 = {};
    for (var key in schema.entries) {
      object2[key] = getDefaults(schema.entries[key]);
    }
    return object2;
  }
  if ("items" in schema) {
    return schema.items.map(getDefaults);
  }
  return getDefault(schema);
}

// src/methods/getDefaults/getDefaultsAsync.ts
function getDefaultsAsync(_x) {
  return _getDefaultsAsync.apply(this, arguments);
} // src/methods/getFallbacks/getFallbacks.ts
function _getDefaultsAsync() {
  _getDefaultsAsync = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee45(schema) {
    return _regeneratorRuntime().wrap(function _callee45$(_context45) {
      while (1) switch (_context45.prev = _context45.next) {
        case 0:
          if (!("entries" in schema)) {
            _context45.next = 6;
            break;
          }
          _context45.t0 = Object;
          _context45.next = 4;
          return Promise.all(Object.entries(schema.entries).map(/*#__PURE__*/function () {
            var _ref41 = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee44(_ref40) {
              var _ref42, key, value2;
              return _regeneratorRuntime().wrap(function _callee44$(_context44) {
                while (1) switch (_context44.prev = _context44.next) {
                  case 0:
                    _ref42 = _slicedToArray(_ref40, 2), key = _ref42[0], value2 = _ref42[1];
                    _context44.t0 = key;
                    _context44.next = 4;
                    return getDefaultsAsync(value2);
                  case 4:
                    _context44.t1 = _context44.sent;
                    return _context44.abrupt("return", [_context44.t0, _context44.t1]);
                  case 6:
                  case "end":
                    return _context44.stop();
                }
              }, _callee44);
            }));
            return function (_x25) {
              return _ref41.apply(this, arguments);
            };
          }()));
        case 4:
          _context45.t1 = _context45.sent;
          return _context45.abrupt("return", _context45.t0.fromEntries.call(_context45.t0, _context45.t1));
        case 6:
          if (!("items" in schema)) {
            _context45.next = 8;
            break;
          }
          return _context45.abrupt("return", Promise.all(schema.items.map(getDefaultsAsync)));
        case 8:
          return _context45.abrupt("return", getDefault(schema));
        case 9:
        case "end":
          return _context45.stop();
      }
    }, _callee45);
  }));
  return _getDefaultsAsync.apply(this, arguments);
}
function getFallbacks(schema) {
  if ("entries" in schema) {
    var object2 = {};
    for (var key in schema.entries) {
      object2[key] = getFallbacks(schema.entries[key]);
    }
    return object2;
  }
  if ("items" in schema) {
    return schema.items.map(getFallbacks);
  }
  return getFallback(schema);
}

// src/methods/getFallbacks/getFallbacksAsync.ts
function getFallbacksAsync(_x2) {
  return _getFallbacksAsync.apply(this, arguments);
} // src/methods/is/is.ts
function _getFallbacksAsync() {
  _getFallbacksAsync = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee47(schema) {
    return _regeneratorRuntime().wrap(function _callee47$(_context47) {
      while (1) switch (_context47.prev = _context47.next) {
        case 0:
          if (!("entries" in schema)) {
            _context47.next = 6;
            break;
          }
          _context47.t0 = Object;
          _context47.next = 4;
          return Promise.all(Object.entries(schema.entries).map(/*#__PURE__*/function () {
            var _ref44 = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee46(_ref43) {
              var _ref45, key, value2;
              return _regeneratorRuntime().wrap(function _callee46$(_context46) {
                while (1) switch (_context46.prev = _context46.next) {
                  case 0:
                    _ref45 = _slicedToArray(_ref43, 2), key = _ref45[0], value2 = _ref45[1];
                    _context46.t0 = key;
                    _context46.next = 4;
                    return getFallbacksAsync(value2);
                  case 4:
                    _context46.t1 = _context46.sent;
                    return _context46.abrupt("return", [_context46.t0, _context46.t1]);
                  case 6:
                  case "end":
                    return _context46.stop();
                }
              }, _callee46);
            }));
            return function (_x26) {
              return _ref44.apply(this, arguments);
            };
          }()));
        case 4:
          _context47.t1 = _context47.sent;
          return _context47.abrupt("return", _context47.t0.fromEntries.call(_context47.t0, _context47.t1));
        case 6:
          if (!("items" in schema)) {
            _context47.next = 8;
            break;
          }
          return _context47.abrupt("return", Promise.all(schema.items.map(getFallbacksAsync)));
        case 8:
          return _context47.abrupt("return", getFallback(schema));
        case 9:
        case "end":
          return _context47.stop();
      }
    }, _callee47);
  }));
  return _getFallbacksAsync.apply(this, arguments);
}
function is(schema, input) {
  return !schema._run({
    typed: false,
    value: input
  }, {
    abortEarly: true
  }).issues;
}

// src/schemas/any/any.ts
function any() {
  return {
    kind: "schema",
    type: "any",
    reference: any,
    expects: "any",
    async: false,
    _run: function _run(dataset) {
      dataset.typed = true;
      return dataset;
    }
  };
}

// src/schemas/array/array.ts
function array(item, message) {
  return {
    kind: "schema",
    type: "array",
    reference: array,
    expects: "Array",
    async: false,
    item: item,
    message: message,
    _run: function _run(dataset, config2) {
      var input = dataset.value;
      if (Array.isArray(input)) {
        dataset.typed = true;
        dataset.value = [];
        for (var key = 0; key < input.length; key++) {
          var value2 = input[key];
          var itemDataset = this.item._run({
            typed: false,
            value: value2
          }, config2);
          if (itemDataset.issues) {
            var pathItem = {
              type: "array",
              origin: "value",
              input: input,
              key: key,
              value: value2
            };
            var _iterator10 = _createForOfIteratorHelper(itemDataset.issues),
              _step10;
            try {
              for (_iterator10.s(); !(_step10 = _iterator10.n()).done;) {
                var _dataset$issues;
                var issue = _step10.value;
                if (issue.path) {
                  issue.path.unshift(pathItem);
                } else {
                  issue.path = [pathItem];
                }
                (_dataset$issues = dataset.issues) === null || _dataset$issues === void 0 || _dataset$issues.push(issue);
              }
            } catch (err) {
              _iterator10.e(err);
            } finally {
              _iterator10.f();
            }
            if (!dataset.issues) {
              dataset.issues = itemDataset.issues;
            }
            if (config2.abortEarly) {
              dataset.typed = false;
              break;
            }
          }
          if (!itemDataset.typed) {
            dataset.typed = false;
          }
          dataset.value.push(itemDataset.value);
        }
      } else {
        _addIssue(this, "type", dataset, config2);
      }
      return dataset;
    }
  };
}

// src/schemas/array/arrayAsync.ts
function arrayAsync(item, message) {
  return {
    kind: "schema",
    type: "array",
    reference: arrayAsync,
    expects: "Array",
    async: true,
    item: item,
    message: message,
    _run: function _run(dataset, config2) {
      var _this10 = this;
      return _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee9() {
        var input, itemDatasets, key, itemDataset, pathItem, _iterator11, _step11, _dataset$issues2, issue;
        return _regeneratorRuntime().wrap(function _callee9$(_context9) {
          while (1) switch (_context9.prev = _context9.next) {
            case 0:
              input = dataset.value;
              if (!Array.isArray(input)) {
                _context9.next = 25;
                break;
              }
              dataset.typed = true;
              dataset.value = [];
              _context9.next = 6;
              return Promise.all(input.map(function (value2) {
                return _this10.item._run({
                  typed: false,
                  value: value2
                }, config2);
              }));
            case 6:
              itemDatasets = _context9.sent;
              key = 0;
            case 8:
              if (!(key < itemDatasets.length)) {
                _context9.next = 23;
                break;
              }
              itemDataset = itemDatasets[key];
              if (!itemDataset.issues) {
                _context9.next = 18;
                break;
              }
              pathItem = {
                type: "array",
                origin: "value",
                input: input,
                key: key,
                value: input[key]
              };
              _iterator11 = _createForOfIteratorHelper(itemDataset.issues);
              try {
                for (_iterator11.s(); !(_step11 = _iterator11.n()).done;) {
                  issue = _step11.value;
                  if (issue.path) {
                    issue.path.unshift(pathItem);
                  } else {
                    issue.path = [pathItem];
                  }
                  (_dataset$issues2 = dataset.issues) === null || _dataset$issues2 === void 0 || _dataset$issues2.push(issue);
                }
              } catch (err) {
                _iterator11.e(err);
              } finally {
                _iterator11.f();
              }
              if (!dataset.issues) {
                dataset.issues = itemDataset.issues;
              }
              if (!config2.abortEarly) {
                _context9.next = 18;
                break;
              }
              dataset.typed = false;
              return _context9.abrupt("break", 23);
            case 18:
              if (!itemDataset.typed) {
                dataset.typed = false;
              }
              dataset.value.push(itemDataset.value);
            case 20:
              key++;
              _context9.next = 8;
              break;
            case 23:
              _context9.next = 26;
              break;
            case 25:
              _addIssue(_this10, "type", dataset, config2);
            case 26:
              return _context9.abrupt("return", dataset);
            case 27:
            case "end":
              return _context9.stop();
          }
        }, _callee9);
      }))();
    }
  };
}

// src/schemas/bigint/bigint.ts
function bigint(message) {
  return {
    kind: "schema",
    type: "bigint",
    reference: bigint,
    expects: "bigint",
    async: false,
    message: message,
    _run: function _run(dataset, config2) {
      if (typeof dataset.value === "bigint") {
        dataset.typed = true;
      } else {
        _addIssue(this, "type", dataset, config2);
      }
      return dataset;
    }
  };
}

// src/schemas/blob/blob.ts
function blob(message) {
  return {
    kind: "schema",
    type: "blob",
    reference: blob,
    expects: "Blob",
    async: false,
    message: message,
    _run: function _run(dataset, config2) {
      if (dataset.value instanceof Blob) {
        dataset.typed = true;
      } else {
        _addIssue(this, "type", dataset, config2);
      }
      return dataset;
    }
  };
}

// src/schemas/boolean/boolean.ts
function _boolean(message) {
  return {
    kind: "schema",
    type: "boolean",
    reference: _boolean,
    expects: "boolean",
    async: false,
    message: message,
    _run: function _run(dataset, config2) {
      if (typeof dataset.value === "boolean") {
        dataset.typed = true;
      } else {
        _addIssue(this, "type", dataset, config2);
      }
      return dataset;
    }
  };
}

// src/schemas/custom/custom.ts
function custom(check2, message) {
  return {
    kind: "schema",
    type: "custom",
    reference: custom,
    expects: "unknown",
    async: false,
    check: check2,
    message: message,
    _run: function _run(dataset, config2) {
      if (this.check(dataset.value)) {
        dataset.typed = true;
      } else {
        _addIssue(this, "type", dataset, config2);
      }
      return dataset;
    }
  };
}

// src/schemas/custom/customAsync.ts
function customAsync(check2, message) {
  return {
    kind: "schema",
    type: "custom",
    reference: customAsync,
    expects: "unknown",
    async: true,
    check: check2,
    message: message,
    _run: function _run(dataset, config2) {
      var _this11 = this;
      return _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee10() {
        return _regeneratorRuntime().wrap(function _callee10$(_context10) {
          while (1) switch (_context10.prev = _context10.next) {
            case 0:
              _context10.next = 2;
              return _this11.check(dataset.value);
            case 2:
              if (!_context10.sent) {
                _context10.next = 6;
                break;
              }
              dataset.typed = true;
              _context10.next = 7;
              break;
            case 6:
              _addIssue(_this11, "type", dataset, config2);
            case 7:
              return _context10.abrupt("return", dataset);
            case 8:
            case "end":
              return _context10.stop();
          }
        }, _callee10);
      }))();
    }
  };
}

// src/schemas/date/date.ts
function date(message) {
  return {
    kind: "schema",
    type: "date",
    reference: date,
    expects: "Date",
    async: false,
    message: message,
    _run: function _run(dataset, config2) {
      if (dataset.value instanceof Date) {
        if (!isNaN(dataset.value)) {
          dataset.typed = true;
        } else {
          _addIssue(this, "type", dataset, config2, {
            received: '"Invalid Date"'
          });
        }
      } else {
        _addIssue(this, "type", dataset, config2);
      }
      return dataset;
    }
  };
}

// src/schemas/enum/enum.ts
function enum_(enum__, message) {
  var options = Object.entries(enum__).filter(function (_ref7) {
    var _ref8 = _slicedToArray(_ref7, 1),
      key = _ref8[0];
    return isNaN(+key);
  }).map(function (_ref9) {
    var _ref10 = _slicedToArray(_ref9, 2),
      value2 = _ref10[1];
    return value2;
  });
  return {
    kind: "schema",
    type: "enum",
    reference: enum_,
    expects: options.map(_stringify).join(" | ") || "never",
    async: false,
    "enum": enum__,
    options: options,
    message: message,
    _run: function _run(dataset, config2) {
      if (this.options.includes(dataset.value)) {
        dataset.typed = true;
      } else {
        _addIssue(this, "type", dataset, config2);
      }
      return dataset;
    }
  };
}

// src/schemas/file/file.ts
function file(message) {
  return {
    kind: "schema",
    type: "file",
    reference: file,
    expects: "File",
    async: false,
    message: message,
    _run: function _run(dataset, config2) {
      if (dataset.value instanceof File) {
        dataset.typed = true;
      } else {
        _addIssue(this, "type", dataset, config2);
      }
      return dataset;
    }
  };
}

// src/schemas/function/function.ts
function function_(message) {
  return {
    kind: "schema",
    type: "function",
    reference: function_,
    expects: "Function",
    async: false,
    message: message,
    _run: function _run(dataset, config2) {
      if (typeof dataset.value === "function") {
        dataset.typed = true;
      } else {
        _addIssue(this, "type", dataset, config2);
      }
      return dataset;
    }
  };
}

// src/schemas/instance/instance.ts
function instance(class_, message) {
  return {
    kind: "schema",
    type: "instance",
    reference: instance,
    expects: class_.name,
    async: false,
    "class": class_,
    message: message,
    _run: function _run(dataset, config2) {
      if (dataset.value instanceof this["class"]) {
        dataset.typed = true;
      } else {
        _addIssue(this, "type", dataset, config2);
      }
      return dataset;
    }
  };
}

// src/schemas/intersect/utils/_merge/_merge.ts
function _merge(value1, value2) {
  if (_typeof(value1) === _typeof(value2)) {
    if (value1 === value2 || value1 instanceof Date && value2 instanceof Date && +value1 === +value2) {
      return {
        value: value1
      };
    }
    if (value1 && value2 && value1.constructor === Object && value2.constructor === Object) {
      for (var key in value2) {
        if (key in value1) {
          var dataset = _merge(value1[key], value2[key]);
          if (dataset.issue) {
            return dataset;
          }
          value1[key] = dataset.value;
        } else {
          value1[key] = value2[key];
        }
      }
      return {
        value: value1
      };
    }
    if (Array.isArray(value1) && Array.isArray(value2)) {
      if (value1.length === value2.length) {
        for (var index = 0; index < value1.length; index++) {
          var _dataset = _merge(value1[index], value2[index]);
          if (_dataset.issue) {
            return _dataset;
          }
          value1[index] = _dataset.value;
        }
        return {
          value: value1
        };
      }
    }
  }
  return {
    issue: true
  };
}

// src/schemas/intersect/intersect.ts
function intersect(options, message) {
  return {
    kind: "schema",
    type: "intersect",
    reference: intersect,
    expects: _toConsumableArray(new Set(options.map(function (option) {
      return option.expects;
    }))).join(" & ") || "never",
    async: false,
    options: options,
    message: message,
    _run: function _run(dataset, config2) {
      if (this.options.length) {
        var input = dataset.value;
        var outputs;
        dataset.typed = true;
        var _iterator12 = _createForOfIteratorHelper(this.options),
          _step12;
        try {
          for (_iterator12.s(); !(_step12 = _iterator12.n()).done;) {
            var schema = _step12.value;
            var optionDataset = schema._run({
              typed: false,
              value: input
            }, config2);
            if (optionDataset.issues) {
              if (dataset.issues) {
                var _dataset$issues3;
                (_dataset$issues3 = dataset.issues).push.apply(_dataset$issues3, _toConsumableArray(optionDataset.issues));
              } else {
                dataset.issues = optionDataset.issues;
              }
              if (config2.abortEarly) {
                dataset.typed = false;
                break;
              }
            }
            if (!optionDataset.typed) {
              dataset.typed = false;
            }
            if (dataset.typed) {
              if (outputs) {
                outputs.push(optionDataset.value);
              } else {
                outputs = [optionDataset.value];
              }
            }
          }
        } catch (err) {
          _iterator12.e(err);
        } finally {
          _iterator12.f();
        }
        if (dataset.typed) {
          dataset.value = outputs[0];
          for (var index = 1; index < outputs.length; index++) {
            var mergeDataset = _merge(dataset.value, outputs[index]);
            if (mergeDataset.issue) {
              _addIssue(this, "type", dataset, config2, {
                received: "unknown"
              });
              break;
            }
            dataset.value = mergeDataset.value;
          }
        }
      } else {
        _addIssue(this, "type", dataset, config2);
      }
      return dataset;
    }
  };
}

// src/schemas/intersect/intersectAsync.ts
function intersectAsync(options, message) {
  return {
    kind: "schema",
    type: "intersect",
    reference: intersectAsync,
    expects: _toConsumableArray(new Set(options.map(function (option) {
      return option.expects;
    }))).join(" & ") || "never",
    async: true,
    options: options,
    message: message,
    _run: function _run(dataset, config2) {
      var _this12 = this;
      return _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee11() {
        var input, outputs, optionDatasets, _iterator13, _step13, optionDataset, _dataset$issues4, index, mergeDataset;
        return _regeneratorRuntime().wrap(function _callee11$(_context11) {
          while (1) switch (_context11.prev = _context11.next) {
            case 0:
              if (!_this12.options.length) {
                _context11.next = 42;
                break;
              }
              input = dataset.value;
              dataset.typed = true;
              _context11.next = 5;
              return Promise.all(_this12.options.map(function (schema) {
                return schema._run({
                  typed: false,
                  value: input
                }, config2);
              }));
            case 5:
              optionDatasets = _context11.sent;
              _iterator13 = _createForOfIteratorHelper(optionDatasets);
              _context11.prev = 7;
              _iterator13.s();
            case 9:
              if ((_step13 = _iterator13.n()).done) {
                _context11.next = 20;
                break;
              }
              optionDataset = _step13.value;
              if (!optionDataset.issues) {
                _context11.next = 16;
                break;
              }
              if (dataset.issues) {
                (_dataset$issues4 = dataset.issues).push.apply(_dataset$issues4, _toConsumableArray(optionDataset.issues));
              } else {
                dataset.issues = optionDataset.issues;
              }
              if (!config2.abortEarly) {
                _context11.next = 16;
                break;
              }
              dataset.typed = false;
              return _context11.abrupt("break", 20);
            case 16:
              if (!optionDataset.typed) {
                dataset.typed = false;
              }
              if (dataset.typed) {
                if (outputs) {
                  outputs.push(optionDataset.value);
                } else {
                  outputs = [optionDataset.value];
                }
              }
            case 18:
              _context11.next = 9;
              break;
            case 20:
              _context11.next = 25;
              break;
            case 22:
              _context11.prev = 22;
              _context11.t0 = _context11["catch"](7);
              _iterator13.e(_context11.t0);
            case 25:
              _context11.prev = 25;
              _iterator13.f();
              return _context11.finish(25);
            case 28:
              if (!dataset.typed) {
                _context11.next = 40;
                break;
              }
              dataset.value = outputs[0];
              index = 1;
            case 31:
              if (!(index < outputs.length)) {
                _context11.next = 40;
                break;
              }
              mergeDataset = _merge(dataset.value, outputs[index]);
              if (!mergeDataset.issue) {
                _context11.next = 36;
                break;
              }
              _addIssue(_this12, "type", dataset, config2, {
                received: "unknown"
              });
              return _context11.abrupt("break", 40);
            case 36:
              dataset.value = mergeDataset.value;
            case 37:
              index++;
              _context11.next = 31;
              break;
            case 40:
              _context11.next = 43;
              break;
            case 42:
              _addIssue(_this12, "type", dataset, config2);
            case 43:
              return _context11.abrupt("return", dataset);
            case 44:
            case "end":
              return _context11.stop();
          }
        }, _callee11, null, [[7, 22, 25, 28]]);
      }))();
    }
  };
}

// src/schemas/lazy/lazy.ts
function lazy(getter) {
  return {
    kind: "schema",
    type: "lazy",
    reference: lazy,
    expects: "unknown",
    async: false,
    getter: getter,
    _run: function _run(dataset, config2) {
      return this.getter(dataset.value)._run(dataset, config2);
    }
  };
}

// src/schemas/lazy/lazyAsync.ts
function lazyAsync(getter) {
  return {
    kind: "schema",
    type: "lazy",
    reference: lazyAsync,
    expects: "unknown",
    async: true,
    getter: getter,
    _run: function _run(dataset, config2) {
      var _this13 = this;
      return _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee12() {
        return _regeneratorRuntime().wrap(function _callee12$(_context12) {
          while (1) switch (_context12.prev = _context12.next) {
            case 0:
              _context12.next = 2;
              return _this13.getter(dataset.value);
            case 2:
              return _context12.abrupt("return", _context12.sent._run(dataset, config2));
            case 3:
            case "end":
              return _context12.stop();
          }
        }, _callee12);
      }))();
    }
  };
}

// src/schemas/literal/literal.ts
function literal(literal_, message) {
  return {
    kind: "schema",
    type: "literal",
    reference: literal,
    expects: _stringify(literal_),
    async: false,
    literal: literal_,
    message: message,
    _run: function _run(dataset, config2) {
      if (dataset.value === this.literal) {
        dataset.typed = true;
      } else {
        _addIssue(this, "type", dataset, config2);
      }
      return dataset;
    }
  };
}

// src/schemas/looseObject/looseObject.ts
function looseObject(entries, message) {
  return {
    kind: "schema",
    type: "loose_object",
    reference: looseObject,
    expects: "Object",
    async: false,
    entries: entries,
    message: message,
    _run: function _run(dataset, config2) {
      var input = dataset.value;
      if (input && _typeof(input) === "object") {
        dataset.typed = true;
        dataset.value = {};
        for (var key in this.entries) {
          var value2 = input[key];
          var valueDataset = this.entries[key]._run({
            typed: false,
            value: value2
          }, config2);
          if (valueDataset.issues) {
            var pathItem = {
              type: "object",
              origin: "value",
              input: input,
              key: key,
              value: value2
            };
            var _iterator14 = _createForOfIteratorHelper(valueDataset.issues),
              _step14;
            try {
              for (_iterator14.s(); !(_step14 = _iterator14.n()).done;) {
                var _dataset$issues5;
                var issue = _step14.value;
                if (issue.path) {
                  issue.path.unshift(pathItem);
                } else {
                  issue.path = [pathItem];
                }
                (_dataset$issues5 = dataset.issues) === null || _dataset$issues5 === void 0 || _dataset$issues5.push(issue);
              }
            } catch (err) {
              _iterator14.e(err);
            } finally {
              _iterator14.f();
            }
            if (!dataset.issues) {
              dataset.issues = valueDataset.issues;
            }
            if (config2.abortEarly) {
              dataset.typed = false;
              break;
            }
          }
          if (!valueDataset.typed) {
            dataset.typed = false;
          }
          if (valueDataset.value !== void 0 || key in input) {
            dataset.value[key] = valueDataset.value;
          }
        }
        if (!dataset.issues || !config2.abortEarly) {
          for (var _key in input) {
            if (_isValidObjectKey(input, _key) && !(_key in this.entries)) {
              dataset.value[_key] = input[_key];
            }
          }
        }
      } else {
        _addIssue(this, "type", dataset, config2);
      }
      return dataset;
    }
  };
}

// src/schemas/looseObject/looseObjectAsync.ts
function looseObjectAsync(entries, message) {
  return {
    kind: "schema",
    type: "loose_object",
    reference: looseObjectAsync,
    expects: "Object",
    async: true,
    entries: entries,
    message: message,
    _run: function _run(dataset, config2) {
      var _this14 = this;
      return _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee14() {
        var input, valueDatasets, _iterator15, _step15, _step15$value, _key2, value2, valueDataset, pathItem, _iterator16, _step16, _dataset$issues6, issue, key;
        return _regeneratorRuntime().wrap(function _callee14$(_context14) {
          while (1) switch (_context14.prev = _context14.next) {
            case 0:
              input = dataset.value;
              if (!(input && _typeof(input) === "object")) {
                _context14.next = 35;
                break;
              }
              dataset.typed = true;
              dataset.value = {};
              _context14.next = 6;
              return Promise.all(Object.entries(_this14.entries).map(/*#__PURE__*/function () {
                var _ref12 = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee13(_ref11) {
                  var _ref13, key, schema, value2;
                  return _regeneratorRuntime().wrap(function _callee13$(_context13) {
                    while (1) switch (_context13.prev = _context13.next) {
                      case 0:
                        _ref13 = _slicedToArray(_ref11, 2), key = _ref13[0], schema = _ref13[1];
                        value2 = input[key];
                        _context13.t0 = key;
                        _context13.t1 = value2;
                        _context13.next = 6;
                        return schema._run({
                          typed: false,
                          value: value2
                        }, config2);
                      case 6:
                        _context13.t2 = _context13.sent;
                        return _context13.abrupt("return", [_context13.t0, _context13.t1, _context13.t2]);
                      case 8:
                      case "end":
                        return _context13.stop();
                    }
                  }, _callee13);
                }));
                return function (_x3) {
                  return _ref12.apply(this, arguments);
                };
              }()));
            case 6:
              valueDatasets = _context14.sent;
              _iterator15 = _createForOfIteratorHelper(valueDatasets);
              _context14.prev = 8;
              _iterator15.s();
            case 10:
              if ((_step15 = _iterator15.n()).done) {
                _context14.next = 24;
                break;
              }
              _step15$value = _slicedToArray(_step15.value, 3), _key2 = _step15$value[0], value2 = _step15$value[1], valueDataset = _step15$value[2];
              if (!valueDataset.issues) {
                _context14.next = 20;
                break;
              }
              pathItem = {
                type: "object",
                origin: "value",
                input: input,
                key: _key2,
                value: value2
              };
              _iterator16 = _createForOfIteratorHelper(valueDataset.issues);
              try {
                for (_iterator16.s(); !(_step16 = _iterator16.n()).done;) {
                  issue = _step16.value;
                  if (issue.path) {
                    issue.path.unshift(pathItem);
                  } else {
                    issue.path = [pathItem];
                  }
                  (_dataset$issues6 = dataset.issues) === null || _dataset$issues6 === void 0 || _dataset$issues6.push(issue);
                }
              } catch (err) {
                _iterator16.e(err);
              } finally {
                _iterator16.f();
              }
              if (!dataset.issues) {
                dataset.issues = valueDataset.issues;
              }
              if (!config2.abortEarly) {
                _context14.next = 20;
                break;
              }
              dataset.typed = false;
              return _context14.abrupt("break", 24);
            case 20:
              if (!valueDataset.typed) {
                dataset.typed = false;
              }
              if (valueDataset.value !== void 0 || _key2 in input) {
                dataset.value[_key2] = valueDataset.value;
              }
            case 22:
              _context14.next = 10;
              break;
            case 24:
              _context14.next = 29;
              break;
            case 26:
              _context14.prev = 26;
              _context14.t0 = _context14["catch"](8);
              _iterator15.e(_context14.t0);
            case 29:
              _context14.prev = 29;
              _iterator15.f();
              return _context14.finish(29);
            case 32:
              if (!dataset.issues || !config2.abortEarly) {
                for (key in input) {
                  if (_isValidObjectKey(input, key) && !(key in _this14.entries)) {
                    dataset.value[key] = input[key];
                  }
                }
              }
              _context14.next = 36;
              break;
            case 35:
              _addIssue(_this14, "type", dataset, config2);
            case 36:
              return _context14.abrupt("return", dataset);
            case 37:
            case "end":
              return _context14.stop();
          }
        }, _callee14, null, [[8, 26, 29, 32]]);
      }))();
    }
  };
}

// src/schemas/looseTuple/looseTuple.ts
function looseTuple(items, message) {
  return {
    kind: "schema",
    type: "loose_tuple",
    reference: looseTuple,
    expects: "Array",
    async: false,
    items: items,
    message: message,
    _run: function _run(dataset, config2) {
      var input = dataset.value;
      if (Array.isArray(input)) {
        dataset.typed = true;
        dataset.value = [];
        for (var key = 0; key < this.items.length; key++) {
          var value2 = input[key];
          var itemDataset = this.items[key]._run({
            typed: false,
            value: value2
          }, config2);
          if (itemDataset.issues) {
            var pathItem = {
              type: "array",
              origin: "value",
              input: input,
              key: key,
              value: value2
            };
            var _iterator17 = _createForOfIteratorHelper(itemDataset.issues),
              _step17;
            try {
              for (_iterator17.s(); !(_step17 = _iterator17.n()).done;) {
                var _dataset$issues7;
                var issue = _step17.value;
                if (issue.path) {
                  issue.path.unshift(pathItem);
                } else {
                  issue.path = [pathItem];
                }
                (_dataset$issues7 = dataset.issues) === null || _dataset$issues7 === void 0 || _dataset$issues7.push(issue);
              }
            } catch (err) {
              _iterator17.e(err);
            } finally {
              _iterator17.f();
            }
            if (!dataset.issues) {
              dataset.issues = itemDataset.issues;
            }
            if (config2.abortEarly) {
              dataset.typed = false;
              break;
            }
          }
          if (!itemDataset.typed) {
            dataset.typed = false;
          }
          dataset.value.push(itemDataset.value);
        }
        if (!dataset.issues || !config2.abortEarly) {
          for (var _key3 = this.items.length; _key3 < input.length; _key3++) {
            dataset.value.push(input[_key3]);
          }
        }
      } else {
        _addIssue(this, "type", dataset, config2);
      }
      return dataset;
    }
  };
}

// src/schemas/looseTuple/looseTupleAsync.ts
function looseTupleAsync(items, message) {
  return {
    kind: "schema",
    type: "loose_tuple",
    reference: looseTupleAsync,
    expects: "Array",
    async: true,
    items: items,
    message: message,
    _run: function _run(dataset, config2) {
      var _this15 = this;
      return _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee16() {
        var input, itemDatasets, _iterator18, _step18, _step18$value, _key4, value2, itemDataset, pathItem, _iterator19, _step19, _dataset$issues8, issue, key;
        return _regeneratorRuntime().wrap(function _callee16$(_context16) {
          while (1) switch (_context16.prev = _context16.next) {
            case 0:
              input = dataset.value;
              if (!Array.isArray(input)) {
                _context16.next = 35;
                break;
              }
              dataset.typed = true;
              dataset.value = [];
              _context16.next = 6;
              return Promise.all(_this15.items.map(/*#__PURE__*/function () {
                var _ref14 = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee15(item, key) {
                  var value2;
                  return _regeneratorRuntime().wrap(function _callee15$(_context15) {
                    while (1) switch (_context15.prev = _context15.next) {
                      case 0:
                        value2 = input[key];
                        _context15.t0 = key;
                        _context15.t1 = value2;
                        _context15.next = 5;
                        return item._run({
                          typed: false,
                          value: value2
                        }, config2);
                      case 5:
                        _context15.t2 = _context15.sent;
                        return _context15.abrupt("return", [_context15.t0, _context15.t1, _context15.t2]);
                      case 7:
                      case "end":
                        return _context15.stop();
                    }
                  }, _callee15);
                }));
                return function (_x4, _x5) {
                  return _ref14.apply(this, arguments);
                };
              }()));
            case 6:
              itemDatasets = _context16.sent;
              _iterator18 = _createForOfIteratorHelper(itemDatasets);
              _context16.prev = 8;
              _iterator18.s();
            case 10:
              if ((_step18 = _iterator18.n()).done) {
                _context16.next = 24;
                break;
              }
              _step18$value = _slicedToArray(_step18.value, 3), _key4 = _step18$value[0], value2 = _step18$value[1], itemDataset = _step18$value[2];
              if (!itemDataset.issues) {
                _context16.next = 20;
                break;
              }
              pathItem = {
                type: "array",
                origin: "value",
                input: input,
                key: _key4,
                value: value2
              };
              _iterator19 = _createForOfIteratorHelper(itemDataset.issues);
              try {
                for (_iterator19.s(); !(_step19 = _iterator19.n()).done;) {
                  issue = _step19.value;
                  if (issue.path) {
                    issue.path.unshift(pathItem);
                  } else {
                    issue.path = [pathItem];
                  }
                  (_dataset$issues8 = dataset.issues) === null || _dataset$issues8 === void 0 || _dataset$issues8.push(issue);
                }
              } catch (err) {
                _iterator19.e(err);
              } finally {
                _iterator19.f();
              }
              if (!dataset.issues) {
                dataset.issues = itemDataset.issues;
              }
              if (!config2.abortEarly) {
                _context16.next = 20;
                break;
              }
              dataset.typed = false;
              return _context16.abrupt("break", 24);
            case 20:
              if (!itemDataset.typed) {
                dataset.typed = false;
              }
              dataset.value.push(itemDataset.value);
            case 22:
              _context16.next = 10;
              break;
            case 24:
              _context16.next = 29;
              break;
            case 26:
              _context16.prev = 26;
              _context16.t0 = _context16["catch"](8);
              _iterator18.e(_context16.t0);
            case 29:
              _context16.prev = 29;
              _iterator18.f();
              return _context16.finish(29);
            case 32:
              if (!dataset.issues || !config2.abortEarly) {
                for (key = _this15.items.length; key < input.length; key++) {
                  dataset.value.push(input[key]);
                }
              }
              _context16.next = 36;
              break;
            case 35:
              _addIssue(_this15, "type", dataset, config2);
            case 36:
              return _context16.abrupt("return", dataset);
            case 37:
            case "end":
              return _context16.stop();
          }
        }, _callee16, null, [[8, 26, 29, 32]]);
      }))();
    }
  };
}

// src/schemas/map/map.ts
function map(key, value2, message) {
  return {
    kind: "schema",
    type: "map",
    reference: map,
    expects: "Map",
    async: false,
    key: key,
    value: value2,
    message: message,
    _run: function _run(dataset, config2) {
      var input = dataset.value;
      if (input instanceof Map) {
        dataset.typed = true;
        dataset.value = /* @__PURE__ */new Map();
        var _iterator20 = _createForOfIteratorHelper(input),
          _step20;
        try {
          for (_iterator20.s(); !(_step20 = _iterator20.n()).done;) {
            var _step20$value = _slicedToArray(_step20.value, 2),
              inputKey = _step20$value[0],
              inputValue = _step20$value[1];
            var keyDataset = this.key._run({
              typed: false,
              value: inputKey
            }, config2);
            if (keyDataset.issues) {
              var pathItem = {
                type: "map",
                origin: "key",
                input: input,
                key: inputKey,
                value: inputValue
              };
              var _iterator21 = _createForOfIteratorHelper(keyDataset.issues),
                _step21;
              try {
                for (_iterator21.s(); !(_step21 = _iterator21.n()).done;) {
                  var _dataset$issues9;
                  var issue = _step21.value;
                  if (issue.path) {
                    issue.path.unshift(pathItem);
                  } else {
                    issue.path = [pathItem];
                  }
                  (_dataset$issues9 = dataset.issues) === null || _dataset$issues9 === void 0 || _dataset$issues9.push(issue);
                }
              } catch (err) {
                _iterator21.e(err);
              } finally {
                _iterator21.f();
              }
              if (!dataset.issues) {
                dataset.issues = keyDataset.issues;
              }
              if (config2.abortEarly) {
                dataset.typed = false;
                break;
              }
            }
            var valueDataset = this.value._run({
              typed: false,
              value: inputValue
            }, config2);
            if (valueDataset.issues) {
              var _pathItem = {
                type: "map",
                origin: "value",
                input: input,
                key: inputKey,
                value: inputValue
              };
              var _iterator22 = _createForOfIteratorHelper(valueDataset.issues),
                _step22;
              try {
                for (_iterator22.s(); !(_step22 = _iterator22.n()).done;) {
                  var _dataset$issues10;
                  var _issue = _step22.value;
                  if (_issue.path) {
                    _issue.path.unshift(_pathItem);
                  } else {
                    _issue.path = [_pathItem];
                  }
                  (_dataset$issues10 = dataset.issues) === null || _dataset$issues10 === void 0 || _dataset$issues10.push(_issue);
                }
              } catch (err) {
                _iterator22.e(err);
              } finally {
                _iterator22.f();
              }
              if (!dataset.issues) {
                dataset.issues = valueDataset.issues;
              }
              if (config2.abortEarly) {
                dataset.typed = false;
                break;
              }
            }
            if (!keyDataset.typed || !valueDataset.typed) {
              dataset.typed = false;
            }
            dataset.value.set(keyDataset.value, valueDataset.value);
          }
        } catch (err) {
          _iterator20.e(err);
        } finally {
          _iterator20.f();
        }
      } else {
        _addIssue(this, "type", dataset, config2);
      }
      return dataset;
    }
  };
}

// src/schemas/map/mapAsync.ts
function mapAsync(key, value2, message) {
  return {
    kind: "schema",
    type: "map",
    reference: mapAsync,
    expects: "Map",
    async: true,
    key: key,
    value: value2,
    message: message,
    _run: function _run(dataset, config2) {
      var _this16 = this;
      return _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee17() {
        var input, datasets, _iterator23, _step23, _step23$value, inputKey, inputValue, keyDataset, valueDataset, pathItem, _iterator24, _step24, _dataset$issues11, issue, _pathItem2, _iterator25, _step25, _dataset$issues12, _issue2;
        return _regeneratorRuntime().wrap(function _callee17$(_context17) {
          while (1) switch (_context17.prev = _context17.next) {
            case 0:
              input = dataset.value;
              if (!(input instanceof Map)) {
                _context17.next = 42;
                break;
              }
              dataset.typed = true;
              dataset.value = /* @__PURE__ */new Map();
              _context17.next = 6;
              return Promise.all(_toConsumableArray(input).map(function (_ref15) {
                var _ref16 = _slicedToArray(_ref15, 2),
                  inputKey = _ref16[0],
                  inputValue = _ref16[1];
                return Promise.all([inputKey, inputValue, _this16.key._run({
                  typed: false,
                  value: inputKey
                }, config2), _this16.value._run({
                  typed: false,
                  value: inputValue
                }, config2)]);
              }));
            case 6:
              datasets = _context17.sent;
              _iterator23 = _createForOfIteratorHelper(datasets);
              _context17.prev = 8;
              _iterator23.s();
            case 10:
              if ((_step23 = _iterator23.n()).done) {
                _context17.next = 32;
                break;
              }
              _step23$value = _slicedToArray(_step23.value, 4), inputKey = _step23$value[0], inputValue = _step23$value[1], keyDataset = _step23$value[2], valueDataset = _step23$value[3];
              if (!keyDataset.issues) {
                _context17.next = 20;
                break;
              }
              pathItem = {
                type: "map",
                origin: "key",
                input: input,
                key: inputKey,
                value: inputValue
              };
              _iterator24 = _createForOfIteratorHelper(keyDataset.issues);
              try {
                for (_iterator24.s(); !(_step24 = _iterator24.n()).done;) {
                  issue = _step24.value;
                  if (issue.path) {
                    issue.path.unshift(pathItem);
                  } else {
                    issue.path = [pathItem];
                  }
                  (_dataset$issues11 = dataset.issues) === null || _dataset$issues11 === void 0 || _dataset$issues11.push(issue);
                }
              } catch (err) {
                _iterator24.e(err);
              } finally {
                _iterator24.f();
              }
              if (!dataset.issues) {
                dataset.issues = keyDataset.issues;
              }
              if (!config2.abortEarly) {
                _context17.next = 20;
                break;
              }
              dataset.typed = false;
              return _context17.abrupt("break", 32);
            case 20:
              if (!valueDataset.issues) {
                _context17.next = 28;
                break;
              }
              _pathItem2 = {
                type: "map",
                origin: "value",
                input: input,
                key: inputKey,
                value: inputValue
              };
              _iterator25 = _createForOfIteratorHelper(valueDataset.issues);
              try {
                for (_iterator25.s(); !(_step25 = _iterator25.n()).done;) {
                  _issue2 = _step25.value;
                  if (_issue2.path) {
                    _issue2.path.unshift(_pathItem2);
                  } else {
                    _issue2.path = [_pathItem2];
                  }
                  (_dataset$issues12 = dataset.issues) === null || _dataset$issues12 === void 0 || _dataset$issues12.push(_issue2);
                }
              } catch (err) {
                _iterator25.e(err);
              } finally {
                _iterator25.f();
              }
              if (!dataset.issues) {
                dataset.issues = valueDataset.issues;
              }
              if (!config2.abortEarly) {
                _context17.next = 28;
                break;
              }
              dataset.typed = false;
              return _context17.abrupt("break", 32);
            case 28:
              if (!keyDataset.typed || !valueDataset.typed) {
                dataset.typed = false;
              }
              dataset.value.set(keyDataset.value, valueDataset.value);
            case 30:
              _context17.next = 10;
              break;
            case 32:
              _context17.next = 37;
              break;
            case 34:
              _context17.prev = 34;
              _context17.t0 = _context17["catch"](8);
              _iterator23.e(_context17.t0);
            case 37:
              _context17.prev = 37;
              _iterator23.f();
              return _context17.finish(37);
            case 40:
              _context17.next = 43;
              break;
            case 42:
              _addIssue(_this16, "type", dataset, config2);
            case 43:
              return _context17.abrupt("return", dataset);
            case 44:
            case "end":
              return _context17.stop();
          }
        }, _callee17, null, [[8, 34, 37, 40]]);
      }))();
    }
  };
}

// src/schemas/nan/nan.ts
function nan(message) {
  return {
    kind: "schema",
    type: "nan",
    reference: nan,
    expects: "NaN",
    async: false,
    message: message,
    _run: function _run(dataset, config2) {
      if (Number.isNaN(dataset.value)) {
        dataset.typed = true;
      } else {
        _addIssue(this, "type", dataset, config2);
      }
      return dataset;
    }
  };
}

// src/schemas/never/never.ts
function never(message) {
  return {
    kind: "schema",
    type: "never",
    reference: never,
    expects: "never",
    async: false,
    message: message,
    _run: function _run(dataset, config2) {
      _addIssue(this, "type", dataset, config2);
      return dataset;
    }
  };
}

// src/schemas/nonNullable/nonNullable.ts
function nonNullable(wrapped, message) {
  return {
    kind: "schema",
    type: "non_nullable",
    reference: nonNullable,
    expects: "!null",
    async: false,
    wrapped: wrapped,
    message: message,
    _run: function _run(dataset, config2) {
      if (dataset.value === null) {
        _addIssue(this, "type", dataset, config2);
        return dataset;
      }
      return this.wrapped._run(dataset, config2);
    }
  };
}

// src/schemas/nonNullable/nonNullableAsync.ts
function nonNullableAsync(wrapped, message) {
  return {
    kind: "schema",
    type: "non_nullable",
    reference: nonNullableAsync,
    expects: "!null",
    async: true,
    wrapped: wrapped,
    message: message,
    _run: function _run(dataset, config2) {
      var _this17 = this;
      return _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee18() {
        return _regeneratorRuntime().wrap(function _callee18$(_context18) {
          while (1) switch (_context18.prev = _context18.next) {
            case 0:
              if (!(dataset.value === null)) {
                _context18.next = 3;
                break;
              }
              _addIssue(_this17, "type", dataset, config2);
              return _context18.abrupt("return", dataset);
            case 3:
              return _context18.abrupt("return", _this17.wrapped._run(dataset, config2));
            case 4:
            case "end":
              return _context18.stop();
          }
        }, _callee18);
      }))();
    }
  };
}

// src/schemas/nonNullish/nonNullish.ts
function nonNullish(wrapped, message) {
  return {
    kind: "schema",
    type: "non_nullish",
    reference: nonNullish,
    expects: "!null & !undefined",
    async: false,
    wrapped: wrapped,
    message: message,
    _run: function _run(dataset, config2) {
      if (dataset.value === null || dataset.value === void 0) {
        _addIssue(this, "type", dataset, config2);
        return dataset;
      }
      return this.wrapped._run(dataset, config2);
    }
  };
}

// src/schemas/nonNullish/nonNullishAsync.ts
function nonNullishAsync(wrapped, message) {
  return {
    kind: "schema",
    type: "non_nullish",
    reference: nonNullishAsync,
    expects: "!null & !undefined",
    async: true,
    wrapped: wrapped,
    message: message,
    _run: function _run(dataset, config2) {
      var _this18 = this;
      return _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee19() {
        return _regeneratorRuntime().wrap(function _callee19$(_context19) {
          while (1) switch (_context19.prev = _context19.next) {
            case 0:
              if (!(dataset.value === null || dataset.value === void 0)) {
                _context19.next = 3;
                break;
              }
              _addIssue(_this18, "type", dataset, config2);
              return _context19.abrupt("return", dataset);
            case 3:
              return _context19.abrupt("return", _this18.wrapped._run(dataset, config2));
            case 4:
            case "end":
              return _context19.stop();
          }
        }, _callee19);
      }))();
    }
  };
}

// src/schemas/nonOptional/nonOptional.ts
function nonOptional(wrapped, message) {
  return {
    kind: "schema",
    type: "non_optional",
    reference: nonOptional,
    expects: "!undefined",
    async: false,
    wrapped: wrapped,
    message: message,
    _run: function _run(dataset, config2) {
      if (dataset.value === void 0) {
        _addIssue(this, "type", dataset, config2);
        return dataset;
      }
      return this.wrapped._run(dataset, config2);
    }
  };
}

// src/schemas/nonOptional/nonOptionalAsync.ts
function nonOptionalAsync(wrapped, message) {
  return {
    kind: "schema",
    type: "non_optional",
    reference: nonOptionalAsync,
    expects: "!undefined",
    async: true,
    wrapped: wrapped,
    message: message,
    _run: function _run(dataset, config2) {
      var _this19 = this;
      return _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee20() {
        return _regeneratorRuntime().wrap(function _callee20$(_context20) {
          while (1) switch (_context20.prev = _context20.next) {
            case 0:
              if (!(dataset.value === void 0)) {
                _context20.next = 3;
                break;
              }
              _addIssue(_this19, "type", dataset, config2);
              return _context20.abrupt("return", dataset);
            case 3:
              return _context20.abrupt("return", _this19.wrapped._run(dataset, config2));
            case 4:
            case "end":
              return _context20.stop();
          }
        }, _callee20);
      }))();
    }
  };
}

// src/schemas/null/null.ts
function null_(message) {
  return {
    kind: "schema",
    type: "null",
    reference: null_,
    expects: "null",
    async: false,
    message: message,
    _run: function _run(dataset, config2) {
      if (dataset.value === null) {
        dataset.typed = true;
      } else {
        _addIssue(this, "type", dataset, config2);
      }
      return dataset;
    }
  };
}

// src/schemas/nullable/nullable.ts
function nullable(wrapped) {
  var schema = {
    kind: "schema",
    type: "nullable",
    reference: nullable,
    expects: "".concat(wrapped.expects, " | null"),
    async: false,
    wrapped: wrapped,
    _run: function _run(dataset, config2) {
      if (dataset.value === null) {
        if ("default" in this) {
          dataset.value = getDefault(this, dataset, config2);
        }
        if (dataset.value === null) {
          dataset.typed = true;
          return dataset;
        }
      }
      return this.wrapped._run(dataset, config2);
    }
  };
  for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key5 = 1; _key5 < _len; _key5++) {
    args[_key5 - 1] = arguments[_key5];
  }
  if (0 in args) {
    schema["default"] = args[0];
  }
  return schema;
}

// src/schemas/nullable/nullableAsync.ts
function nullableAsync(wrapped) {
  var schema = {
    kind: "schema",
    type: "nullable",
    reference: nullableAsync,
    expects: "".concat(wrapped.expects, " | null"),
    async: true,
    wrapped: wrapped,
    _run: function _run(dataset, config2) {
      var _this20 = this;
      return _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee21() {
        return _regeneratorRuntime().wrap(function _callee21$(_context21) {
          while (1) switch (_context21.prev = _context21.next) {
            case 0:
              if (!(dataset.value === null)) {
                _context21.next = 8;
                break;
              }
              if (!("default" in _this20)) {
                _context21.next = 5;
                break;
              }
              _context21.next = 4;
              return getDefault(_this20, dataset, config2);
            case 4:
              dataset.value = _context21.sent;
            case 5:
              if (!(dataset.value === null)) {
                _context21.next = 8;
                break;
              }
              dataset.typed = true;
              return _context21.abrupt("return", dataset);
            case 8:
              return _context21.abrupt("return", _this20.wrapped._run(dataset, config2));
            case 9:
            case "end":
              return _context21.stop();
          }
        }, _callee21);
      }))();
    }
  };
  for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key6 = 1; _key6 < _len2; _key6++) {
    args[_key6 - 1] = arguments[_key6];
  }
  if (0 in args) {
    schema["default"] = args[0];
  }
  return schema;
}

// src/schemas/nullish/nullish.ts
function nullish(wrapped) {
  var schema = {
    kind: "schema",
    type: "nullish",
    reference: nullish,
    expects: "".concat(wrapped.expects, " | null | undefined"),
    async: false,
    wrapped: wrapped,
    _run: function _run(dataset, config2) {
      if (dataset.value === null || dataset.value === void 0) {
        if ("default" in this) {
          dataset.value = getDefault(this, dataset, config2);
        }
        if (dataset.value === null || dataset.value === void 0) {
          dataset.typed = true;
          return dataset;
        }
      }
      return this.wrapped._run(dataset, config2);
    }
  };
  for (var _len3 = arguments.length, args = new Array(_len3 > 1 ? _len3 - 1 : 0), _key7 = 1; _key7 < _len3; _key7++) {
    args[_key7 - 1] = arguments[_key7];
  }
  if (0 in args) {
    schema["default"] = args[0];
  }
  return schema;
}

// src/schemas/nullish/nullishAsync.ts
function nullishAsync(wrapped) {
  var schema = {
    kind: "schema",
    type: "nullish",
    reference: nullishAsync,
    expects: "".concat(wrapped.expects, " | null | undefined"),
    async: true,
    wrapped: wrapped,
    _run: function _run(dataset, config2) {
      var _this21 = this;
      return _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee22() {
        return _regeneratorRuntime().wrap(function _callee22$(_context22) {
          while (1) switch (_context22.prev = _context22.next) {
            case 0:
              if (!(dataset.value === null || dataset.value === void 0)) {
                _context22.next = 8;
                break;
              }
              if (!("default" in _this21)) {
                _context22.next = 5;
                break;
              }
              _context22.next = 4;
              return getDefault(_this21, dataset, config2);
            case 4:
              dataset.value = _context22.sent;
            case 5:
              if (!(dataset.value === null || dataset.value === void 0)) {
                _context22.next = 8;
                break;
              }
              dataset.typed = true;
              return _context22.abrupt("return", dataset);
            case 8:
              return _context22.abrupt("return", _this21.wrapped._run(dataset, config2));
            case 9:
            case "end":
              return _context22.stop();
          }
        }, _callee22);
      }))();
    }
  };
  for (var _len4 = arguments.length, args = new Array(_len4 > 1 ? _len4 - 1 : 0), _key8 = 1; _key8 < _len4; _key8++) {
    args[_key8 - 1] = arguments[_key8];
  }
  if (0 in args) {
    schema["default"] = args[0];
  }
  return schema;
}

// src/schemas/number/number.ts
function number(message) {
  return {
    kind: "schema",
    type: "number",
    reference: number,
    expects: "number",
    async: false,
    message: message,
    _run: function _run(dataset, config2) {
      if (typeof dataset.value === "number" && !isNaN(dataset.value)) {
        dataset.typed = true;
      } else {
        _addIssue(this, "type", dataset, config2);
      }
      return dataset;
    }
  };
}

// src/schemas/object/object.ts
function object(entries, message) {
  return {
    kind: "schema",
    type: "object",
    reference: object,
    expects: "Object",
    async: false,
    entries: entries,
    message: message,
    _run: function _run(dataset, config2) {
      var input = dataset.value;
      if (input && _typeof(input) === "object") {
        dataset.typed = true;
        dataset.value = {};
        for (var key in this.entries) {
          var value2 = input[key];
          var valueDataset = this.entries[key]._run({
            typed: false,
            value: value2
          }, config2);
          if (valueDataset.issues) {
            var pathItem = {
              type: "object",
              origin: "value",
              input: input,
              key: key,
              value: value2
            };
            var _iterator26 = _createForOfIteratorHelper(valueDataset.issues),
              _step26;
            try {
              for (_iterator26.s(); !(_step26 = _iterator26.n()).done;) {
                var _dataset$issues13;
                var issue = _step26.value;
                if (issue.path) {
                  issue.path.unshift(pathItem);
                } else {
                  issue.path = [pathItem];
                }
                (_dataset$issues13 = dataset.issues) === null || _dataset$issues13 === void 0 || _dataset$issues13.push(issue);
              }
            } catch (err) {
              _iterator26.e(err);
            } finally {
              _iterator26.f();
            }
            if (!dataset.issues) {
              dataset.issues = valueDataset.issues;
            }
            if (config2.abortEarly) {
              dataset.typed = false;
              break;
            }
          }
          if (!valueDataset.typed) {
            dataset.typed = false;
          }
          if (valueDataset.value !== void 0 || key in input) {
            dataset.value[key] = valueDataset.value;
          }
        }
      } else {
        _addIssue(this, "type", dataset, config2);
      }
      return dataset;
    }
  };
}

// src/schemas/object/objectAsync.ts
function objectAsync(entries, message) {
  return {
    kind: "schema",
    type: "object",
    reference: objectAsync,
    expects: "Object",
    async: true,
    entries: entries,
    message: message,
    _run: function _run(dataset, config2) {
      var _this22 = this;
      return _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee24() {
        var input, valueDatasets, _iterator27, _step27, _step27$value, key, value2, valueDataset, pathItem, _iterator28, _step28, _dataset$issues14, issue;
        return _regeneratorRuntime().wrap(function _callee24$(_context24) {
          while (1) switch (_context24.prev = _context24.next) {
            case 0:
              input = dataset.value;
              if (!(input && _typeof(input) === "object")) {
                _context24.next = 34;
                break;
              }
              dataset.typed = true;
              dataset.value = {};
              _context24.next = 6;
              return Promise.all(Object.entries(_this22.entries).map(/*#__PURE__*/function () {
                var _ref18 = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee23(_ref17) {
                  var _ref19, key, schema, value2;
                  return _regeneratorRuntime().wrap(function _callee23$(_context23) {
                    while (1) switch (_context23.prev = _context23.next) {
                      case 0:
                        _ref19 = _slicedToArray(_ref17, 2), key = _ref19[0], schema = _ref19[1];
                        value2 = input[key];
                        _context23.t0 = key;
                        _context23.t1 = value2;
                        _context23.next = 6;
                        return schema._run({
                          typed: false,
                          value: value2
                        }, config2);
                      case 6:
                        _context23.t2 = _context23.sent;
                        return _context23.abrupt("return", [_context23.t0, _context23.t1, _context23.t2]);
                      case 8:
                      case "end":
                        return _context23.stop();
                    }
                  }, _callee23);
                }));
                return function (_x6) {
                  return _ref18.apply(this, arguments);
                };
              }()));
            case 6:
              valueDatasets = _context24.sent;
              _iterator27 = _createForOfIteratorHelper(valueDatasets);
              _context24.prev = 8;
              _iterator27.s();
            case 10:
              if ((_step27 = _iterator27.n()).done) {
                _context24.next = 24;
                break;
              }
              _step27$value = _slicedToArray(_step27.value, 3), key = _step27$value[0], value2 = _step27$value[1], valueDataset = _step27$value[2];
              if (!valueDataset.issues) {
                _context24.next = 20;
                break;
              }
              pathItem = {
                type: "object",
                origin: "value",
                input: input,
                key: key,
                value: value2
              };
              _iterator28 = _createForOfIteratorHelper(valueDataset.issues);
              try {
                for (_iterator28.s(); !(_step28 = _iterator28.n()).done;) {
                  issue = _step28.value;
                  if (issue.path) {
                    issue.path.unshift(pathItem);
                  } else {
                    issue.path = [pathItem];
                  }
                  (_dataset$issues14 = dataset.issues) === null || _dataset$issues14 === void 0 || _dataset$issues14.push(issue);
                }
              } catch (err) {
                _iterator28.e(err);
              } finally {
                _iterator28.f();
              }
              if (!dataset.issues) {
                dataset.issues = valueDataset.issues;
              }
              if (!config2.abortEarly) {
                _context24.next = 20;
                break;
              }
              dataset.typed = false;
              return _context24.abrupt("break", 24);
            case 20:
              if (!valueDataset.typed) {
                dataset.typed = false;
              }
              if (valueDataset.value !== void 0 || key in input) {
                dataset.value[key] = valueDataset.value;
              }
            case 22:
              _context24.next = 10;
              break;
            case 24:
              _context24.next = 29;
              break;
            case 26:
              _context24.prev = 26;
              _context24.t0 = _context24["catch"](8);
              _iterator27.e(_context24.t0);
            case 29:
              _context24.prev = 29;
              _iterator27.f();
              return _context24.finish(29);
            case 32:
              _context24.next = 35;
              break;
            case 34:
              _addIssue(_this22, "type", dataset, config2);
            case 35:
              return _context24.abrupt("return", dataset);
            case 36:
            case "end":
              return _context24.stop();
          }
        }, _callee24, null, [[8, 26, 29, 32]]);
      }))();
    }
  };
}

// src/schemas/objectWithRest/objectWithRest.ts
function objectWithRest(entries, rest, message) {
  return {
    kind: "schema",
    type: "object_with_rest",
    reference: objectWithRest,
    expects: "Object",
    async: false,
    entries: entries,
    rest: rest,
    message: message,
    _run: function _run(dataset, config2) {
      var input = dataset.value;
      if (input && _typeof(input) === "object") {
        dataset.typed = true;
        dataset.value = {};
        for (var key in this.entries) {
          var value2 = input[key];
          var valueDataset = this.entries[key]._run({
            typed: false,
            value: value2
          }, config2);
          if (valueDataset.issues) {
            var pathItem = {
              type: "object",
              origin: "value",
              input: input,
              key: key,
              value: value2
            };
            var _iterator29 = _createForOfIteratorHelper(valueDataset.issues),
              _step29;
            try {
              for (_iterator29.s(); !(_step29 = _iterator29.n()).done;) {
                var _dataset$issues15;
                var issue = _step29.value;
                if (issue.path) {
                  issue.path.unshift(pathItem);
                } else {
                  issue.path = [pathItem];
                }
                (_dataset$issues15 = dataset.issues) === null || _dataset$issues15 === void 0 || _dataset$issues15.push(issue);
              }
            } catch (err) {
              _iterator29.e(err);
            } finally {
              _iterator29.f();
            }
            if (!dataset.issues) {
              dataset.issues = valueDataset.issues;
            }
            if (config2.abortEarly) {
              dataset.typed = false;
              break;
            }
          }
          if (!valueDataset.typed) {
            dataset.typed = false;
          }
          if (valueDataset.value !== void 0 || key in input) {
            dataset.value[key] = valueDataset.value;
          }
        }
        if (!dataset.issues || !config2.abortEarly) {
          for (var _key9 in input) {
            if (_isValidObjectKey(input, _key9) && !(_key9 in this.entries)) {
              var _value = input[_key9];
              var _valueDataset = this.rest._run({
                typed: false,
                value: _value
              }, config2);
              if (_valueDataset.issues) {
                var _pathItem3 = {
                  type: "object",
                  origin: "value",
                  input: input,
                  key: _key9,
                  value: _value
                };
                var _iterator30 = _createForOfIteratorHelper(_valueDataset.issues),
                  _step30;
                try {
                  for (_iterator30.s(); !(_step30 = _iterator30.n()).done;) {
                    var _dataset$issues16;
                    var _issue3 = _step30.value;
                    if (_issue3.path) {
                      _issue3.path.unshift(_pathItem3);
                    } else {
                      _issue3.path = [_pathItem3];
                    }
                    (_dataset$issues16 = dataset.issues) === null || _dataset$issues16 === void 0 || _dataset$issues16.push(_issue3);
                  }
                } catch (err) {
                  _iterator30.e(err);
                } finally {
                  _iterator30.f();
                }
                if (!dataset.issues) {
                  dataset.issues = _valueDataset.issues;
                }
                if (config2.abortEarly) {
                  dataset.typed = false;
                  break;
                }
              }
              if (!_valueDataset.typed) {
                dataset.typed = false;
              }
              dataset.value[_key9] = _valueDataset.value;
            }
          }
        }
      } else {
        _addIssue(this, "type", dataset, config2);
      }
      return dataset;
    }
  };
}

// src/schemas/objectWithRest/objectWithRestAsync.ts
function objectWithRestAsync(entries, rest, message) {
  return {
    kind: "schema",
    type: "object_with_rest",
    reference: objectWithRestAsync,
    expects: "Object",
    async: true,
    entries: entries,
    rest: rest,
    message: message,
    _run: function _run(dataset, config2) {
      var _this23 = this;
      return _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee27() {
        var input, _yield$Promise$all, _yield$Promise$all2, normalDatasets, restDatasets, _iterator31, _step31, _step31$value, _key10, _value2, _valueDataset2, _pathItem4, _iterator34, _step34, _dataset$issues18, _issue4, _iterator32, _step32, _step32$value, key, value2, valueDataset, pathItem, _iterator33, _step33, _dataset$issues17, issue;
        return _regeneratorRuntime().wrap(function _callee27$(_context27) {
          while (1) switch (_context27.prev = _context27.next) {
            case 0:
              input = dataset.value;
              if (!(input && _typeof(input) === "object")) {
                _context27.next = 63;
                break;
              }
              dataset.typed = true;
              dataset.value = {};
              _context27.next = 6;
              return Promise.all([
              // Parse schema of each normal entry
              // Hint: We do not distinguish between missing and `undefined` entries.
              // The reason for this decision is that it reduces the bundle size, and
              // we also expect that most users will expect this behavior.
              Promise.all(Object.entries(_this23.entries).map(/*#__PURE__*/function () {
                var _ref21 = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee25(_ref20) {
                  var _ref22, key, schema, value2;
                  return _regeneratorRuntime().wrap(function _callee25$(_context25) {
                    while (1) switch (_context25.prev = _context25.next) {
                      case 0:
                        _ref22 = _slicedToArray(_ref20, 2), key = _ref22[0], schema = _ref22[1];
                        value2 = input[key];
                        _context25.t0 = key;
                        _context25.t1 = value2;
                        _context25.next = 6;
                        return schema._run({
                          typed: false,
                          value: value2
                        }, config2);
                      case 6:
                        _context25.t2 = _context25.sent;
                        return _context25.abrupt("return", [_context25.t0, _context25.t1, _context25.t2]);
                      case 8:
                      case "end":
                        return _context25.stop();
                    }
                  }, _callee25);
                }));
                return function (_x7) {
                  return _ref21.apply(this, arguments);
                };
              }())),
              // Parse other entries with rest schema
              // Hint: We exclude specific keys for security reasons
              Promise.all(Object.entries(input).filter(function (_ref23) {
                var _ref24 = _slicedToArray(_ref23, 1),
                  key = _ref24[0];
                return _isValidObjectKey(input, key) && !(key in _this23.entries);
              }).map(/*#__PURE__*/function () {
                var _ref26 = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee26(_ref25) {
                  var _ref27, key, value2;
                  return _regeneratorRuntime().wrap(function _callee26$(_context26) {
                    while (1) switch (_context26.prev = _context26.next) {
                      case 0:
                        _ref27 = _slicedToArray(_ref25, 2), key = _ref27[0], value2 = _ref27[1];
                        _context26.t0 = key;
                        _context26.t1 = value2;
                        _context26.next = 5;
                        return _this23.rest._run({
                          typed: false,
                          value: value2
                        }, config2);
                      case 5:
                        _context26.t2 = _context26.sent;
                        return _context26.abrupt("return", [_context26.t0, _context26.t1, _context26.t2]);
                      case 7:
                      case "end":
                        return _context26.stop();
                    }
                  }, _callee26);
                }));
                return function (_x8) {
                  return _ref26.apply(this, arguments);
                };
              }()))]);
            case 6:
              _yield$Promise$all = _context27.sent;
              _yield$Promise$all2 = _slicedToArray(_yield$Promise$all, 2);
              normalDatasets = _yield$Promise$all2[0];
              restDatasets = _yield$Promise$all2[1];
              _iterator31 = _createForOfIteratorHelper(normalDatasets);
              _context27.prev = 11;
              _iterator31.s();
            case 13:
              if ((_step31 = _iterator31.n()).done) {
                _context27.next = 27;
                break;
              }
              _step31$value = _slicedToArray(_step31.value, 3), _key10 = _step31$value[0], _value2 = _step31$value[1], _valueDataset2 = _step31$value[2];
              if (!_valueDataset2.issues) {
                _context27.next = 23;
                break;
              }
              _pathItem4 = {
                type: "object",
                origin: "value",
                input: input,
                key: _key10,
                value: _value2
              };
              _iterator34 = _createForOfIteratorHelper(_valueDataset2.issues);
              try {
                for (_iterator34.s(); !(_step34 = _iterator34.n()).done;) {
                  _issue4 = _step34.value;
                  if (_issue4.path) {
                    _issue4.path.unshift(_pathItem4);
                  } else {
                    _issue4.path = [_pathItem4];
                  }
                  (_dataset$issues18 = dataset.issues) === null || _dataset$issues18 === void 0 || _dataset$issues18.push(_issue4);
                }
              } catch (err) {
                _iterator34.e(err);
              } finally {
                _iterator34.f();
              }
              if (!dataset.issues) {
                dataset.issues = _valueDataset2.issues;
              }
              if (!config2.abortEarly) {
                _context27.next = 23;
                break;
              }
              dataset.typed = false;
              return _context27.abrupt("break", 27);
            case 23:
              if (!_valueDataset2.typed) {
                dataset.typed = false;
              }
              if (_valueDataset2.value !== void 0 || _key10 in input) {
                dataset.value[_key10] = _valueDataset2.value;
              }
            case 25:
              _context27.next = 13;
              break;
            case 27:
              _context27.next = 32;
              break;
            case 29:
              _context27.prev = 29;
              _context27.t0 = _context27["catch"](11);
              _iterator31.e(_context27.t0);
            case 32:
              _context27.prev = 32;
              _iterator31.f();
              return _context27.finish(32);
            case 35:
              if (!(!dataset.issues || !config2.abortEarly)) {
                _context27.next = 61;
                break;
              }
              _iterator32 = _createForOfIteratorHelper(restDatasets);
              _context27.prev = 37;
              _iterator32.s();
            case 39:
              if ((_step32 = _iterator32.n()).done) {
                _context27.next = 53;
                break;
              }
              _step32$value = _slicedToArray(_step32.value, 3), key = _step32$value[0], value2 = _step32$value[1], valueDataset = _step32$value[2];
              if (!valueDataset.issues) {
                _context27.next = 49;
                break;
              }
              pathItem = {
                type: "object",
                origin: "value",
                input: input,
                key: key,
                value: value2
              };
              _iterator33 = _createForOfIteratorHelper(valueDataset.issues);
              try {
                for (_iterator33.s(); !(_step33 = _iterator33.n()).done;) {
                  issue = _step33.value;
                  if (issue.path) {
                    issue.path.unshift(pathItem);
                  } else {
                    issue.path = [pathItem];
                  }
                  (_dataset$issues17 = dataset.issues) === null || _dataset$issues17 === void 0 || _dataset$issues17.push(issue);
                }
              } catch (err) {
                _iterator33.e(err);
              } finally {
                _iterator33.f();
              }
              if (!dataset.issues) {
                dataset.issues = valueDataset.issues;
              }
              if (!config2.abortEarly) {
                _context27.next = 49;
                break;
              }
              dataset.typed = false;
              return _context27.abrupt("break", 53);
            case 49:
              if (!valueDataset.typed) {
                dataset.typed = false;
              }
              dataset.value[key] = valueDataset.value;
            case 51:
              _context27.next = 39;
              break;
            case 53:
              _context27.next = 58;
              break;
            case 55:
              _context27.prev = 55;
              _context27.t1 = _context27["catch"](37);
              _iterator32.e(_context27.t1);
            case 58:
              _context27.prev = 58;
              _iterator32.f();
              return _context27.finish(58);
            case 61:
              _context27.next = 64;
              break;
            case 63:
              _addIssue(_this23, "type", dataset, config2);
            case 64:
              return _context27.abrupt("return", dataset);
            case 65:
            case "end":
              return _context27.stop();
          }
        }, _callee27, null, [[11, 29, 32, 35], [37, 55, 58, 61]]);
      }))();
    }
  };
}

// src/schemas/optional/optional.ts
function optional(wrapped) {
  var schema = {
    kind: "schema",
    type: "optional",
    reference: optional,
    expects: "".concat(wrapped.expects, " | undefined"),
    async: false,
    wrapped: wrapped,
    _run: function _run(dataset, config2) {
      if (dataset.value === void 0) {
        if ("default" in this) {
          dataset.value = getDefault(this, dataset, config2);
        }
        if (dataset.value === void 0) {
          dataset.typed = true;
          return dataset;
        }
      }
      return this.wrapped._run(dataset, config2);
    }
  };
  for (var _len5 = arguments.length, args = new Array(_len5 > 1 ? _len5 - 1 : 0), _key11 = 1; _key11 < _len5; _key11++) {
    args[_key11 - 1] = arguments[_key11];
  }
  if (0 in args) {
    schema["default"] = args[0];
  }
  return schema;
}

// src/schemas/optional/optionalAsync.ts
function optionalAsync(wrapped) {
  var schema = {
    kind: "schema",
    type: "optional",
    reference: optionalAsync,
    expects: "".concat(wrapped.expects, " | undefined"),
    async: true,
    wrapped: wrapped,
    _run: function _run(dataset, config2) {
      var _this24 = this;
      return _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee28() {
        return _regeneratorRuntime().wrap(function _callee28$(_context28) {
          while (1) switch (_context28.prev = _context28.next) {
            case 0:
              if (!(dataset.value === void 0)) {
                _context28.next = 8;
                break;
              }
              if (!("default" in _this24)) {
                _context28.next = 5;
                break;
              }
              _context28.next = 4;
              return getDefault(_this24, dataset, config2);
            case 4:
              dataset.value = _context28.sent;
            case 5:
              if (!(dataset.value === void 0)) {
                _context28.next = 8;
                break;
              }
              dataset.typed = true;
              return _context28.abrupt("return", dataset);
            case 8:
              return _context28.abrupt("return", _this24.wrapped._run(dataset, config2));
            case 9:
            case "end":
              return _context28.stop();
          }
        }, _callee28);
      }))();
    }
  };
  for (var _len6 = arguments.length, args = new Array(_len6 > 1 ? _len6 - 1 : 0), _key12 = 1; _key12 < _len6; _key12++) {
    args[_key12 - 1] = arguments[_key12];
  }
  if (0 in args) {
    schema["default"] = args[0];
  }
  return schema;
}

// src/schemas/picklist/picklist.ts
function picklist(options, message) {
  return {
    kind: "schema",
    type: "picklist",
    reference: picklist,
    expects: options.map(_stringify).join(" | ") || "never",
    async: false,
    options: options,
    message: message,
    _run: function _run(dataset, config2) {
      if (this.options.includes(dataset.value)) {
        dataset.typed = true;
      } else {
        _addIssue(this, "type", dataset, config2);
      }
      return dataset;
    }
  };
}

// src/schemas/promise/promise.ts
function promise(message) {
  return {
    kind: "schema",
    type: "promise",
    reference: promise,
    expects: "Promise",
    async: false,
    message: message,
    _run: function _run(dataset, config2) {
      if (dataset.value instanceof Promise) {
        dataset.typed = true;
      } else {
        _addIssue(this, "type", dataset, config2);
      }
      return dataset;
    }
  };
}

// src/schemas/record/record.ts
function record(key, value2, message) {
  return {
    kind: "schema",
    type: "record",
    reference: record,
    expects: "Object",
    async: false,
    key: key,
    value: value2,
    message: message,
    _run: function _run(dataset, config2) {
      var input = dataset.value;
      if (input && _typeof(input) === "object") {
        dataset.typed = true;
        dataset.value = {};
        for (var entryKey in input) {
          if (_isValidObjectKey(input, entryKey)) {
            var entryValue = input[entryKey];
            var keyDataset = this.key._run({
              typed: false,
              value: entryKey
            }, config2);
            if (keyDataset.issues) {
              var pathItem = {
                type: "object",
                origin: "key",
                input: input,
                key: entryKey,
                value: entryValue
              };
              var _iterator35 = _createForOfIteratorHelper(keyDataset.issues),
                _step35;
              try {
                for (_iterator35.s(); !(_step35 = _iterator35.n()).done;) {
                  var _dataset$issues19;
                  var issue = _step35.value;
                  issue.path = [pathItem];
                  (_dataset$issues19 = dataset.issues) === null || _dataset$issues19 === void 0 || _dataset$issues19.push(issue);
                }
              } catch (err) {
                _iterator35.e(err);
              } finally {
                _iterator35.f();
              }
              if (!dataset.issues) {
                dataset.issues = keyDataset.issues;
              }
              if (config2.abortEarly) {
                dataset.typed = false;
                break;
              }
            }
            var valueDataset = this.value._run({
              typed: false,
              value: entryValue
            }, config2);
            if (valueDataset.issues) {
              var _pathItem5 = {
                type: "object",
                origin: "value",
                input: input,
                key: entryKey,
                value: entryValue
              };
              var _iterator36 = _createForOfIteratorHelper(valueDataset.issues),
                _step36;
              try {
                for (_iterator36.s(); !(_step36 = _iterator36.n()).done;) {
                  var _dataset$issues20;
                  var _issue5 = _step36.value;
                  if (_issue5.path) {
                    _issue5.path.unshift(_pathItem5);
                  } else {
                    _issue5.path = [_pathItem5];
                  }
                  (_dataset$issues20 = dataset.issues) === null || _dataset$issues20 === void 0 || _dataset$issues20.push(_issue5);
                }
              } catch (err) {
                _iterator36.e(err);
              } finally {
                _iterator36.f();
              }
              if (!dataset.issues) {
                dataset.issues = valueDataset.issues;
              }
              if (config2.abortEarly) {
                dataset.typed = false;
                break;
              }
            }
            if (!keyDataset.typed || !valueDataset.typed) {
              dataset.typed = false;
            }
            if (keyDataset.typed) {
              dataset.value[keyDataset.value] = valueDataset.value;
            }
          }
        }
      } else {
        _addIssue(this, "type", dataset, config2);
      }
      return dataset;
    }
  };
}

// src/schemas/record/recordAsync.ts
function recordAsync(key, value2, message) {
  return {
    kind: "schema",
    type: "record",
    reference: recordAsync,
    expects: "Object",
    async: true,
    key: key,
    value: value2,
    message: message,
    _run: function _run(dataset, config2) {
      var _this25 = this;
      return _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee29() {
        var input, datasets, _iterator37, _step37, _step37$value, entryKey, entryValue, keyDataset, valueDataset, pathItem, _iterator38, _step38, _dataset$issues21, issue, _pathItem6, _iterator39, _step39, _dataset$issues22, _issue6;
        return _regeneratorRuntime().wrap(function _callee29$(_context29) {
          while (1) switch (_context29.prev = _context29.next) {
            case 0:
              input = dataset.value;
              if (!(input && _typeof(input) === "object")) {
                _context29.next = 42;
                break;
              }
              dataset.typed = true;
              dataset.value = {};
              _context29.next = 6;
              return Promise.all(Object.entries(input).filter(function (_ref28) {
                var _ref29 = _slicedToArray(_ref28, 1),
                  key2 = _ref29[0];
                return _isValidObjectKey(input, key2);
              }).map(function (_ref30) {
                var _ref31 = _slicedToArray(_ref30, 2),
                  entryKey = _ref31[0],
                  entryValue = _ref31[1];
                return Promise.all([entryKey, entryValue, _this25.key._run({
                  typed: false,
                  value: entryKey
                }, config2), _this25.value._run({
                  typed: false,
                  value: entryValue
                }, config2)]);
              }));
            case 6:
              datasets = _context29.sent;
              _iterator37 = _createForOfIteratorHelper(datasets);
              _context29.prev = 8;
              _iterator37.s();
            case 10:
              if ((_step37 = _iterator37.n()).done) {
                _context29.next = 32;
                break;
              }
              _step37$value = _slicedToArray(_step37.value, 4), entryKey = _step37$value[0], entryValue = _step37$value[1], keyDataset = _step37$value[2], valueDataset = _step37$value[3];
              if (!keyDataset.issues) {
                _context29.next = 20;
                break;
              }
              pathItem = {
                type: "object",
                origin: "key",
                input: input,
                key: entryKey,
                value: entryValue
              };
              _iterator38 = _createForOfIteratorHelper(keyDataset.issues);
              try {
                for (_iterator38.s(); !(_step38 = _iterator38.n()).done;) {
                  issue = _step38.value;
                  issue.path = [pathItem];
                  (_dataset$issues21 = dataset.issues) === null || _dataset$issues21 === void 0 || _dataset$issues21.push(issue);
                }
              } catch (err) {
                _iterator38.e(err);
              } finally {
                _iterator38.f();
              }
              if (!dataset.issues) {
                dataset.issues = keyDataset.issues;
              }
              if (!config2.abortEarly) {
                _context29.next = 20;
                break;
              }
              dataset.typed = false;
              return _context29.abrupt("break", 32);
            case 20:
              if (!valueDataset.issues) {
                _context29.next = 28;
                break;
              }
              _pathItem6 = {
                type: "object",
                origin: "value",
                input: input,
                key: entryKey,
                value: entryValue
              };
              _iterator39 = _createForOfIteratorHelper(valueDataset.issues);
              try {
                for (_iterator39.s(); !(_step39 = _iterator39.n()).done;) {
                  _issue6 = _step39.value;
                  if (_issue6.path) {
                    _issue6.path.unshift(_pathItem6);
                  } else {
                    _issue6.path = [_pathItem6];
                  }
                  (_dataset$issues22 = dataset.issues) === null || _dataset$issues22 === void 0 || _dataset$issues22.push(_issue6);
                }
              } catch (err) {
                _iterator39.e(err);
              } finally {
                _iterator39.f();
              }
              if (!dataset.issues) {
                dataset.issues = valueDataset.issues;
              }
              if (!config2.abortEarly) {
                _context29.next = 28;
                break;
              }
              dataset.typed = false;
              return _context29.abrupt("break", 32);
            case 28:
              if (!keyDataset.typed || !valueDataset.typed) {
                dataset.typed = false;
              }
              if (keyDataset.typed) {
                dataset.value[keyDataset.value] = valueDataset.value;
              }
            case 30:
              _context29.next = 10;
              break;
            case 32:
              _context29.next = 37;
              break;
            case 34:
              _context29.prev = 34;
              _context29.t0 = _context29["catch"](8);
              _iterator37.e(_context29.t0);
            case 37:
              _context29.prev = 37;
              _iterator37.f();
              return _context29.finish(37);
            case 40:
              _context29.next = 43;
              break;
            case 42:
              _addIssue(_this25, "type", dataset, config2);
            case 43:
              return _context29.abrupt("return", dataset);
            case 44:
            case "end":
              return _context29.stop();
          }
        }, _callee29, null, [[8, 34, 37, 40]]);
      }))();
    }
  };
}

// src/schemas/set/set.ts
function set(value2, message) {
  return {
    kind: "schema",
    type: "set",
    reference: set,
    expects: "Set",
    async: false,
    value: value2,
    message: message,
    _run: function _run(dataset, config2) {
      var input = dataset.value;
      if (input instanceof Set) {
        dataset.typed = true;
        dataset.value = /* @__PURE__ */new Set();
        var _iterator40 = _createForOfIteratorHelper(input),
          _step40;
        try {
          for (_iterator40.s(); !(_step40 = _iterator40.n()).done;) {
            var inputValue = _step40.value;
            var valueDataset = this.value._run({
              typed: false,
              value: inputValue
            }, config2);
            if (valueDataset.issues) {
              var pathItem = {
                type: "set",
                origin: "value",
                input: input,
                key: null,
                value: inputValue
              };
              var _iterator41 = _createForOfIteratorHelper(valueDataset.issues),
                _step41;
              try {
                for (_iterator41.s(); !(_step41 = _iterator41.n()).done;) {
                  var _dataset$issues23;
                  var issue = _step41.value;
                  if (issue.path) {
                    issue.path.unshift(pathItem);
                  } else {
                    issue.path = [pathItem];
                  }
                  (_dataset$issues23 = dataset.issues) === null || _dataset$issues23 === void 0 || _dataset$issues23.push(issue);
                }
              } catch (err) {
                _iterator41.e(err);
              } finally {
                _iterator41.f();
              }
              if (!dataset.issues) {
                dataset.issues = valueDataset.issues;
              }
              if (config2.abortEarly) {
                dataset.typed = false;
                break;
              }
            }
            if (!valueDataset.typed) {
              dataset.typed = false;
            }
            dataset.value.add(valueDataset.value);
          }
        } catch (err) {
          _iterator40.e(err);
        } finally {
          _iterator40.f();
        }
      } else {
        _addIssue(this, "type", dataset, config2);
      }
      return dataset;
    }
  };
}

// src/schemas/set/setAsync.ts
function setAsync(value2, message) {
  return {
    kind: "schema",
    type: "set",
    reference: setAsync,
    expects: "Set",
    async: true,
    value: value2,
    message: message,
    _run: function _run(dataset, config2) {
      var _this26 = this;
      return _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee31() {
        var input, valueDatasets, _iterator42, _step42, _step42$value, inputValue, valueDataset, pathItem, _iterator43, _step43, _dataset$issues24, issue;
        return _regeneratorRuntime().wrap(function _callee31$(_context31) {
          while (1) switch (_context31.prev = _context31.next) {
            case 0:
              input = dataset.value;
              if (!(input instanceof Set)) {
                _context31.next = 34;
                break;
              }
              dataset.typed = true;
              dataset.value = /* @__PURE__ */new Set();
              _context31.next = 6;
              return Promise.all(_toConsumableArray(input).map(/*#__PURE__*/function () {
                var _ref32 = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee30(inputValue) {
                  return _regeneratorRuntime().wrap(function _callee30$(_context30) {
                    while (1) switch (_context30.prev = _context30.next) {
                      case 0:
                        _context30.t0 = inputValue;
                        _context30.next = 3;
                        return _this26.value._run({
                          typed: false,
                          value: inputValue
                        }, config2);
                      case 3:
                        _context30.t1 = _context30.sent;
                        return _context30.abrupt("return", [_context30.t0, _context30.t1]);
                      case 5:
                      case "end":
                        return _context30.stop();
                    }
                  }, _callee30);
                }));
                return function (_x9) {
                  return _ref32.apply(this, arguments);
                };
              }()));
            case 6:
              valueDatasets = _context31.sent;
              _iterator42 = _createForOfIteratorHelper(valueDatasets);
              _context31.prev = 8;
              _iterator42.s();
            case 10:
              if ((_step42 = _iterator42.n()).done) {
                _context31.next = 24;
                break;
              }
              _step42$value = _slicedToArray(_step42.value, 2), inputValue = _step42$value[0], valueDataset = _step42$value[1];
              if (!valueDataset.issues) {
                _context31.next = 20;
                break;
              }
              pathItem = {
                type: "set",
                origin: "value",
                input: input,
                key: null,
                value: inputValue
              };
              _iterator43 = _createForOfIteratorHelper(valueDataset.issues);
              try {
                for (_iterator43.s(); !(_step43 = _iterator43.n()).done;) {
                  issue = _step43.value;
                  if (issue.path) {
                    issue.path.unshift(pathItem);
                  } else {
                    issue.path = [pathItem];
                  }
                  (_dataset$issues24 = dataset.issues) === null || _dataset$issues24 === void 0 || _dataset$issues24.push(issue);
                }
              } catch (err) {
                _iterator43.e(err);
              } finally {
                _iterator43.f();
              }
              if (!dataset.issues) {
                dataset.issues = valueDataset.issues;
              }
              if (!config2.abortEarly) {
                _context31.next = 20;
                break;
              }
              dataset.typed = false;
              return _context31.abrupt("break", 24);
            case 20:
              if (!valueDataset.typed) {
                dataset.typed = false;
              }
              dataset.value.add(valueDataset.value);
            case 22:
              _context31.next = 10;
              break;
            case 24:
              _context31.next = 29;
              break;
            case 26:
              _context31.prev = 26;
              _context31.t0 = _context31["catch"](8);
              _iterator42.e(_context31.t0);
            case 29:
              _context31.prev = 29;
              _iterator42.f();
              return _context31.finish(29);
            case 32:
              _context31.next = 35;
              break;
            case 34:
              _addIssue(_this26, "type", dataset, config2);
            case 35:
              return _context31.abrupt("return", dataset);
            case 36:
            case "end":
              return _context31.stop();
          }
        }, _callee31, null, [[8, 26, 29, 32]]);
      }))();
    }
  };
}

// src/schemas/strictObject/strictObject.ts
function strictObject(entries, message) {
  return {
    kind: "schema",
    type: "strict_object",
    reference: strictObject,
    expects: "Object",
    async: false,
    entries: entries,
    message: message,
    _run: function _run(dataset, config2) {
      var input = dataset.value;
      if (input && _typeof(input) === "object") {
        dataset.typed = true;
        dataset.value = {};
        for (var key in this.entries) {
          var value2 = input[key];
          var valueDataset = this.entries[key]._run({
            typed: false,
            value: value2
          }, config2);
          if (valueDataset.issues) {
            var pathItem = {
              type: "object",
              origin: "value",
              input: input,
              key: key,
              value: value2
            };
            var _iterator44 = _createForOfIteratorHelper(valueDataset.issues),
              _step44;
            try {
              for (_iterator44.s(); !(_step44 = _iterator44.n()).done;) {
                var _dataset$issues25;
                var issue = _step44.value;
                if (issue.path) {
                  issue.path.unshift(pathItem);
                } else {
                  issue.path = [pathItem];
                }
                (_dataset$issues25 = dataset.issues) === null || _dataset$issues25 === void 0 || _dataset$issues25.push(issue);
              }
            } catch (err) {
              _iterator44.e(err);
            } finally {
              _iterator44.f();
            }
            if (!dataset.issues) {
              dataset.issues = valueDataset.issues;
            }
            if (config2.abortEarly) {
              dataset.typed = false;
              break;
            }
          }
          if (!valueDataset.typed) {
            dataset.typed = false;
          }
          if (valueDataset.value !== void 0 || key in input) {
            dataset.value[key] = valueDataset.value;
          }
        }
        if (!dataset.issues || !config2.abortEarly) {
          for (var _key13 in input) {
            if (!(_key13 in this.entries)) {
              var _value3 = input[_key13];
              _addIssue(this, "type", dataset, config2, {
                input: _value3,
                expected: "never",
                path: [{
                  type: "object",
                  origin: "value",
                  input: input,
                  key: _key13,
                  value: _value3
                }]
              });
              break;
            }
          }
        }
      } else {
        _addIssue(this, "type", dataset, config2);
      }
      return dataset;
    }
  };
}

// src/schemas/strictObject/strictObjectAsync.ts
function strictObjectAsync(entries, message) {
  return {
    kind: "schema",
    type: "strict_object",
    reference: strictObjectAsync,
    expects: "Object",
    async: true,
    entries: entries,
    message: message,
    _run: function _run(dataset, config2) {
      var _this27 = this;
      return _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee33() {
        var input, valueDatasets, _iterator45, _step45, _step45$value, _key14, _value4, valueDataset, pathItem, _iterator46, _step46, _dataset$issues26, issue, key, value2;
        return _regeneratorRuntime().wrap(function _callee33$(_context33) {
          while (1) switch (_context33.prev = _context33.next) {
            case 0:
              input = dataset.value;
              if (!(input && _typeof(input) === "object")) {
                _context33.next = 44;
                break;
              }
              dataset.typed = true;
              dataset.value = {};
              _context33.next = 6;
              return Promise.all(Object.entries(_this27.entries).map(/*#__PURE__*/function () {
                var _ref34 = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee32(_ref33) {
                  var _ref35, key, schema, value2;
                  return _regeneratorRuntime().wrap(function _callee32$(_context32) {
                    while (1) switch (_context32.prev = _context32.next) {
                      case 0:
                        _ref35 = _slicedToArray(_ref33, 2), key = _ref35[0], schema = _ref35[1];
                        value2 = input[key];
                        _context32.t0 = key;
                        _context32.t1 = value2;
                        _context32.next = 6;
                        return schema._run({
                          typed: false,
                          value: value2
                        }, config2);
                      case 6:
                        _context32.t2 = _context32.sent;
                        return _context32.abrupt("return", [_context32.t0, _context32.t1, _context32.t2]);
                      case 8:
                      case "end":
                        return _context32.stop();
                    }
                  }, _callee32);
                }));
                return function (_x10) {
                  return _ref34.apply(this, arguments);
                };
              }()));
            case 6:
              valueDatasets = _context33.sent;
              _iterator45 = _createForOfIteratorHelper(valueDatasets);
              _context33.prev = 8;
              _iterator45.s();
            case 10:
              if ((_step45 = _iterator45.n()).done) {
                _context33.next = 24;
                break;
              }
              _step45$value = _slicedToArray(_step45.value, 3), _key14 = _step45$value[0], _value4 = _step45$value[1], valueDataset = _step45$value[2];
              if (!valueDataset.issues) {
                _context33.next = 20;
                break;
              }
              pathItem = {
                type: "object",
                origin: "value",
                input: input,
                key: _key14,
                value: _value4
              };
              _iterator46 = _createForOfIteratorHelper(valueDataset.issues);
              try {
                for (_iterator46.s(); !(_step46 = _iterator46.n()).done;) {
                  issue = _step46.value;
                  if (issue.path) {
                    issue.path.unshift(pathItem);
                  } else {
                    issue.path = [pathItem];
                  }
                  (_dataset$issues26 = dataset.issues) === null || _dataset$issues26 === void 0 || _dataset$issues26.push(issue);
                }
              } catch (err) {
                _iterator46.e(err);
              } finally {
                _iterator46.f();
              }
              if (!dataset.issues) {
                dataset.issues = valueDataset.issues;
              }
              if (!config2.abortEarly) {
                _context33.next = 20;
                break;
              }
              dataset.typed = false;
              return _context33.abrupt("break", 24);
            case 20:
              if (!valueDataset.typed) {
                dataset.typed = false;
              }
              if (valueDataset.value !== void 0 || _key14 in input) {
                dataset.value[_key14] = valueDataset.value;
              }
            case 22:
              _context33.next = 10;
              break;
            case 24:
              _context33.next = 29;
              break;
            case 26:
              _context33.prev = 26;
              _context33.t0 = _context33["catch"](8);
              _iterator45.e(_context33.t0);
            case 29:
              _context33.prev = 29;
              _iterator45.f();
              return _context33.finish(29);
            case 32:
              if (!(!dataset.issues || !config2.abortEarly)) {
                _context33.next = 42;
                break;
              }
              _context33.t1 = _regeneratorRuntime().keys(input);
            case 34:
              if ((_context33.t2 = _context33.t1()).done) {
                _context33.next = 42;
                break;
              }
              key = _context33.t2.value;
              if (key in _this27.entries) {
                _context33.next = 40;
                break;
              }
              value2 = input[key];
              _addIssue(_this27, "type", dataset, config2, {
                input: value2,
                expected: "never",
                path: [{
                  type: "object",
                  origin: "value",
                  input: input,
                  key: key,
                  value: value2
                }]
              });
              return _context33.abrupt("break", 42);
            case 40:
              _context33.next = 34;
              break;
            case 42:
              _context33.next = 45;
              break;
            case 44:
              _addIssue(_this27, "type", dataset, config2);
            case 45:
              return _context33.abrupt("return", dataset);
            case 46:
            case "end":
              return _context33.stop();
          }
        }, _callee33, null, [[8, 26, 29, 32]]);
      }))();
    }
  };
}

// src/schemas/strictTuple/strictTuple.ts
function strictTuple(items, message) {
  return {
    kind: "schema",
    type: "strict_tuple",
    reference: strictTuple,
    expects: "Array",
    async: false,
    items: items,
    message: message,
    _run: function _run(dataset, config2) {
      var input = dataset.value;
      if (Array.isArray(input)) {
        dataset.typed = true;
        dataset.value = [];
        for (var key = 0; key < this.items.length; key++) {
          var value2 = input[key];
          var itemDataset = this.items[key]._run({
            typed: false,
            value: value2
          }, config2);
          if (itemDataset.issues) {
            var pathItem = {
              type: "array",
              origin: "value",
              input: input,
              key: key,
              value: value2
            };
            var _iterator47 = _createForOfIteratorHelper(itemDataset.issues),
              _step47;
            try {
              for (_iterator47.s(); !(_step47 = _iterator47.n()).done;) {
                var _dataset$issues27;
                var issue = _step47.value;
                if (issue.path) {
                  issue.path.unshift(pathItem);
                } else {
                  issue.path = [pathItem];
                }
                (_dataset$issues27 = dataset.issues) === null || _dataset$issues27 === void 0 || _dataset$issues27.push(issue);
              }
            } catch (err) {
              _iterator47.e(err);
            } finally {
              _iterator47.f();
            }
            if (!dataset.issues) {
              dataset.issues = itemDataset.issues;
            }
            if (config2.abortEarly) {
              dataset.typed = false;
              break;
            }
          }
          if (!itemDataset.typed) {
            dataset.typed = false;
          }
          dataset.value.push(itemDataset.value);
        }
        if (!(dataset.issues && config2.abortEarly) && this.items.length < input.length) {
          var _value5 = input[items.length];
          _addIssue(this, "type", dataset, config2, {
            input: _value5,
            expected: "never",
            path: [{
              type: "array",
              origin: "value",
              input: input,
              key: this.items.length,
              value: _value5
            }]
          });
        }
      } else {
        _addIssue(this, "type", dataset, config2);
      }
      return dataset;
    }
  };
}

// src/schemas/strictTuple/strictTupleAsync.ts
function strictTupleAsync(items, message) {
  return {
    kind: "schema",
    type: "strict_tuple",
    reference: strictTupleAsync,
    expects: "Array",
    async: true,
    items: items,
    message: message,
    _run: function _run(dataset, config2) {
      var _this28 = this;
      return _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee35() {
        var input, itemDatasets, _iterator48, _step48, _step48$value, key, _value6, itemDataset, pathItem, _iterator49, _step49, _dataset$issues28, issue, value2;
        return _regeneratorRuntime().wrap(function _callee35$(_context35) {
          while (1) switch (_context35.prev = _context35.next) {
            case 0:
              input = dataset.value;
              if (!Array.isArray(input)) {
                _context35.next = 35;
                break;
              }
              dataset.typed = true;
              dataset.value = [];
              _context35.next = 6;
              return Promise.all(_this28.items.map(/*#__PURE__*/function () {
                var _ref36 = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee34(item, key) {
                  var value2;
                  return _regeneratorRuntime().wrap(function _callee34$(_context34) {
                    while (1) switch (_context34.prev = _context34.next) {
                      case 0:
                        value2 = input[key];
                        _context34.t0 = key;
                        _context34.t1 = value2;
                        _context34.next = 5;
                        return item._run({
                          typed: false,
                          value: value2
                        }, config2);
                      case 5:
                        _context34.t2 = _context34.sent;
                        return _context34.abrupt("return", [_context34.t0, _context34.t1, _context34.t2]);
                      case 7:
                      case "end":
                        return _context34.stop();
                    }
                  }, _callee34);
                }));
                return function (_x11, _x12) {
                  return _ref36.apply(this, arguments);
                };
              }()));
            case 6:
              itemDatasets = _context35.sent;
              _iterator48 = _createForOfIteratorHelper(itemDatasets);
              _context35.prev = 8;
              _iterator48.s();
            case 10:
              if ((_step48 = _iterator48.n()).done) {
                _context35.next = 24;
                break;
              }
              _step48$value = _slicedToArray(_step48.value, 3), key = _step48$value[0], _value6 = _step48$value[1], itemDataset = _step48$value[2];
              if (!itemDataset.issues) {
                _context35.next = 20;
                break;
              }
              pathItem = {
                type: "array",
                origin: "value",
                input: input,
                key: key,
                value: _value6
              };
              _iterator49 = _createForOfIteratorHelper(itemDataset.issues);
              try {
                for (_iterator49.s(); !(_step49 = _iterator49.n()).done;) {
                  issue = _step49.value;
                  if (issue.path) {
                    issue.path.unshift(pathItem);
                  } else {
                    issue.path = [pathItem];
                  }
                  (_dataset$issues28 = dataset.issues) === null || _dataset$issues28 === void 0 || _dataset$issues28.push(issue);
                }
              } catch (err) {
                _iterator49.e(err);
              } finally {
                _iterator49.f();
              }
              if (!dataset.issues) {
                dataset.issues = itemDataset.issues;
              }
              if (!config2.abortEarly) {
                _context35.next = 20;
                break;
              }
              dataset.typed = false;
              return _context35.abrupt("break", 24);
            case 20:
              if (!itemDataset.typed) {
                dataset.typed = false;
              }
              dataset.value.push(itemDataset.value);
            case 22:
              _context35.next = 10;
              break;
            case 24:
              _context35.next = 29;
              break;
            case 26:
              _context35.prev = 26;
              _context35.t0 = _context35["catch"](8);
              _iterator48.e(_context35.t0);
            case 29:
              _context35.prev = 29;
              _iterator48.f();
              return _context35.finish(29);
            case 32:
              if (!(dataset.issues && config2.abortEarly) && _this28.items.length < input.length) {
                value2 = input[items.length];
                _addIssue(_this28, "type", dataset, config2, {
                  input: value2,
                  expected: "never",
                  path: [{
                    type: "array",
                    origin: "value",
                    input: input,
                    key: _this28.items.length,
                    value: value2
                  }]
                });
              }
              _context35.next = 36;
              break;
            case 35:
              _addIssue(_this28, "type", dataset, config2);
            case 36:
              return _context35.abrupt("return", dataset);
            case 37:
            case "end":
              return _context35.stop();
          }
        }, _callee35, null, [[8, 26, 29, 32]]);
      }))();
    }
  };
}

// src/schemas/string/string.ts
function string(message) {
  return {
    kind: "schema",
    type: "string",
    reference: string,
    expects: "string",
    async: false,
    message: message,
    _run: function _run(dataset, config2) {
      if (typeof dataset.value === "string") {
        dataset.typed = true;
      } else {
        _addIssue(this, "type", dataset, config2);
      }
      return dataset;
    }
  };
}

// src/schemas/symbol/symbol.ts
function symbol(message) {
  return {
    kind: "schema",
    type: "symbol",
    reference: symbol,
    expects: "symbol",
    async: false,
    message: message,
    _run: function _run(dataset, config2) {
      if (_typeof(dataset.value) === "symbol") {
        dataset.typed = true;
      } else {
        _addIssue(this, "type", dataset, config2);
      }
      return dataset;
    }
  };
}

// src/schemas/tuple/tuple.ts
function tuple(items, message) {
  return {
    kind: "schema",
    type: "tuple",
    reference: tuple,
    expects: "Array",
    async: false,
    items: items,
    message: message,
    _run: function _run(dataset, config2) {
      var input = dataset.value;
      if (Array.isArray(input)) {
        dataset.typed = true;
        dataset.value = [];
        for (var key = 0; key < this.items.length; key++) {
          var value2 = input[key];
          var itemDataset = this.items[key]._run({
            typed: false,
            value: value2
          }, config2);
          if (itemDataset.issues) {
            var pathItem = {
              type: "array",
              origin: "value",
              input: input,
              key: key,
              value: value2
            };
            var _iterator50 = _createForOfIteratorHelper(itemDataset.issues),
              _step50;
            try {
              for (_iterator50.s(); !(_step50 = _iterator50.n()).done;) {
                var _dataset$issues29;
                var issue = _step50.value;
                if (issue.path) {
                  issue.path.unshift(pathItem);
                } else {
                  issue.path = [pathItem];
                }
                (_dataset$issues29 = dataset.issues) === null || _dataset$issues29 === void 0 || _dataset$issues29.push(issue);
              }
            } catch (err) {
              _iterator50.e(err);
            } finally {
              _iterator50.f();
            }
            if (!dataset.issues) {
              dataset.issues = itemDataset.issues;
            }
            if (config2.abortEarly) {
              dataset.typed = false;
              break;
            }
          }
          if (!itemDataset.typed) {
            dataset.typed = false;
          }
          dataset.value.push(itemDataset.value);
        }
      } else {
        _addIssue(this, "type", dataset, config2);
      }
      return dataset;
    }
  };
}

// src/schemas/tuple/tupleAsync.ts
function tupleAsync(items, message) {
  return {
    kind: "schema",
    type: "tuple",
    reference: tupleAsync,
    expects: "Array",
    async: true,
    items: items,
    message: message,
    _run: function _run(dataset, config2) {
      var _this29 = this;
      return _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee37() {
        var input, itemDatasets, _iterator51, _step51, _step51$value, key, value2, itemDataset, pathItem, _iterator52, _step52, _dataset$issues30, issue;
        return _regeneratorRuntime().wrap(function _callee37$(_context37) {
          while (1) switch (_context37.prev = _context37.next) {
            case 0:
              input = dataset.value;
              if (!Array.isArray(input)) {
                _context37.next = 34;
                break;
              }
              dataset.typed = true;
              dataset.value = [];
              _context37.next = 6;
              return Promise.all(_this29.items.map(/*#__PURE__*/function () {
                var _ref37 = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee36(item, key) {
                  var value2;
                  return _regeneratorRuntime().wrap(function _callee36$(_context36) {
                    while (1) switch (_context36.prev = _context36.next) {
                      case 0:
                        value2 = input[key];
                        _context36.t0 = key;
                        _context36.t1 = value2;
                        _context36.next = 5;
                        return item._run({
                          typed: false,
                          value: value2
                        }, config2);
                      case 5:
                        _context36.t2 = _context36.sent;
                        return _context36.abrupt("return", [_context36.t0, _context36.t1, _context36.t2]);
                      case 7:
                      case "end":
                        return _context36.stop();
                    }
                  }, _callee36);
                }));
                return function (_x13, _x14) {
                  return _ref37.apply(this, arguments);
                };
              }()));
            case 6:
              itemDatasets = _context37.sent;
              _iterator51 = _createForOfIteratorHelper(itemDatasets);
              _context37.prev = 8;
              _iterator51.s();
            case 10:
              if ((_step51 = _iterator51.n()).done) {
                _context37.next = 24;
                break;
              }
              _step51$value = _slicedToArray(_step51.value, 3), key = _step51$value[0], value2 = _step51$value[1], itemDataset = _step51$value[2];
              if (!itemDataset.issues) {
                _context37.next = 20;
                break;
              }
              pathItem = {
                type: "array",
                origin: "value",
                input: input,
                key: key,
                value: value2
              };
              _iterator52 = _createForOfIteratorHelper(itemDataset.issues);
              try {
                for (_iterator52.s(); !(_step52 = _iterator52.n()).done;) {
                  issue = _step52.value;
                  if (issue.path) {
                    issue.path.unshift(pathItem);
                  } else {
                    issue.path = [pathItem];
                  }
                  (_dataset$issues30 = dataset.issues) === null || _dataset$issues30 === void 0 || _dataset$issues30.push(issue);
                }
              } catch (err) {
                _iterator52.e(err);
              } finally {
                _iterator52.f();
              }
              if (!dataset.issues) {
                dataset.issues = itemDataset.issues;
              }
              if (!config2.abortEarly) {
                _context37.next = 20;
                break;
              }
              dataset.typed = false;
              return _context37.abrupt("break", 24);
            case 20:
              if (!itemDataset.typed) {
                dataset.typed = false;
              }
              dataset.value.push(itemDataset.value);
            case 22:
              _context37.next = 10;
              break;
            case 24:
              _context37.next = 29;
              break;
            case 26:
              _context37.prev = 26;
              _context37.t0 = _context37["catch"](8);
              _iterator51.e(_context37.t0);
            case 29:
              _context37.prev = 29;
              _iterator51.f();
              return _context37.finish(29);
            case 32:
              _context37.next = 35;
              break;
            case 34:
              _addIssue(_this29, "type", dataset, config2);
            case 35:
              return _context37.abrupt("return", dataset);
            case 36:
            case "end":
              return _context37.stop();
          }
        }, _callee37, null, [[8, 26, 29, 32]]);
      }))();
    }
  };
}

// src/schemas/tupleWithRest/tupleWithRest.ts
function tupleWithRest(items, rest, message) {
  return {
    kind: "schema",
    type: "tuple_with_rest",
    reference: tupleWithRest,
    expects: "Array",
    async: false,
    items: items,
    rest: rest,
    message: message,
    _run: function _run(dataset, config2) {
      var input = dataset.value;
      if (Array.isArray(input)) {
        dataset.typed = true;
        dataset.value = [];
        for (var key = 0; key < this.items.length; key++) {
          var value2 = input[key];
          var itemDataset = this.items[key]._run({
            typed: false,
            value: value2
          }, config2);
          if (itemDataset.issues) {
            var pathItem = {
              type: "array",
              origin: "value",
              input: input,
              key: key,
              value: value2
            };
            var _iterator53 = _createForOfIteratorHelper(itemDataset.issues),
              _step53;
            try {
              for (_iterator53.s(); !(_step53 = _iterator53.n()).done;) {
                var _dataset$issues31;
                var issue = _step53.value;
                if (issue.path) {
                  issue.path.unshift(pathItem);
                } else {
                  issue.path = [pathItem];
                }
                (_dataset$issues31 = dataset.issues) === null || _dataset$issues31 === void 0 || _dataset$issues31.push(issue);
              }
            } catch (err) {
              _iterator53.e(err);
            } finally {
              _iterator53.f();
            }
            if (!dataset.issues) {
              dataset.issues = itemDataset.issues;
            }
            if (config2.abortEarly) {
              dataset.typed = false;
              break;
            }
          }
          if (!itemDataset.typed) {
            dataset.typed = false;
          }
          dataset.value.push(itemDataset.value);
        }
        if (!dataset.issues || !config2.abortEarly) {
          for (var _key15 = this.items.length; _key15 < input.length; _key15++) {
            var _value7 = input[_key15];
            var _itemDataset = this.rest._run({
              typed: false,
              value: _value7
            }, config2);
            if (_itemDataset.issues) {
              var _pathItem7 = {
                type: "array",
                origin: "value",
                input: input,
                key: _key15,
                value: _value7
              };
              var _iterator54 = _createForOfIteratorHelper(_itemDataset.issues),
                _step54;
              try {
                for (_iterator54.s(); !(_step54 = _iterator54.n()).done;) {
                  var _dataset$issues32;
                  var _issue7 = _step54.value;
                  if (_issue7.path) {
                    _issue7.path.unshift(_pathItem7);
                  } else {
                    _issue7.path = [_pathItem7];
                  }
                  (_dataset$issues32 = dataset.issues) === null || _dataset$issues32 === void 0 || _dataset$issues32.push(_issue7);
                }
              } catch (err) {
                _iterator54.e(err);
              } finally {
                _iterator54.f();
              }
              if (!dataset.issues) {
                dataset.issues = _itemDataset.issues;
              }
              if (config2.abortEarly) {
                dataset.typed = false;
                break;
              }
            }
            if (!_itemDataset.typed) {
              dataset.typed = false;
            }
            dataset.value.push(_itemDataset.value);
          }
        }
      } else {
        _addIssue(this, "type", dataset, config2);
      }
      return dataset;
    }
  };
}

// src/schemas/tupleWithRest/tupleWithRestAsync.ts
function tupleWithRestAsync(items, rest, message) {
  return {
    kind: "schema",
    type: "tuple_with_rest",
    reference: tupleWithRestAsync,
    expects: "Array",
    async: true,
    items: items,
    rest: rest,
    message: message,
    _run: function _run(dataset, config2) {
      var _this30 = this;
      return _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee40() {
        var input, _yield$Promise$all3, _yield$Promise$all4, normalDatasets, restDatasets, _iterator55, _step55, _step55$value, _key16, _value8, _itemDataset2, _pathItem8, _iterator58, _step58, _dataset$issues34, _issue8, _iterator56, _step56, _step56$value, key, value2, itemDataset, pathItem, _iterator57, _step57, _dataset$issues33, issue;
        return _regeneratorRuntime().wrap(function _callee40$(_context40) {
          while (1) switch (_context40.prev = _context40.next) {
            case 0:
              input = dataset.value;
              if (!Array.isArray(input)) {
                _context40.next = 63;
                break;
              }
              dataset.typed = true;
              dataset.value = [];
              _context40.next = 6;
              return Promise.all([
              // Parse schema of each normal item
              Promise.all(_this30.items.map(/*#__PURE__*/function () {
                var _ref38 = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee38(item, key) {
                  var value2;
                  return _regeneratorRuntime().wrap(function _callee38$(_context38) {
                    while (1) switch (_context38.prev = _context38.next) {
                      case 0:
                        value2 = input[key];
                        _context38.t0 = key;
                        _context38.t1 = value2;
                        _context38.next = 5;
                        return item._run({
                          typed: false,
                          value: value2
                        }, config2);
                      case 5:
                        _context38.t2 = _context38.sent;
                        return _context38.abrupt("return", [_context38.t0, _context38.t1, _context38.t2]);
                      case 7:
                      case "end":
                        return _context38.stop();
                    }
                  }, _callee38);
                }));
                return function (_x15, _x16) {
                  return _ref38.apply(this, arguments);
                };
              }())),
              // Parse other items with rest schema
              Promise.all(input.slice(_this30.items.length).map(/*#__PURE__*/function () {
                var _ref39 = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee39(value2, key) {
                  return _regeneratorRuntime().wrap(function _callee39$(_context39) {
                    while (1) switch (_context39.prev = _context39.next) {
                      case 0:
                        _context39.t0 = key + _this30.items.length;
                        _context39.t1 = value2;
                        _context39.next = 4;
                        return _this30.rest._run({
                          typed: false,
                          value: value2
                        }, config2);
                      case 4:
                        _context39.t2 = _context39.sent;
                        return _context39.abrupt("return", [_context39.t0, _context39.t1, _context39.t2]);
                      case 6:
                      case "end":
                        return _context39.stop();
                    }
                  }, _callee39);
                }));
                return function (_x17, _x18) {
                  return _ref39.apply(this, arguments);
                };
              }()))]);
            case 6:
              _yield$Promise$all3 = _context40.sent;
              _yield$Promise$all4 = _slicedToArray(_yield$Promise$all3, 2);
              normalDatasets = _yield$Promise$all4[0];
              restDatasets = _yield$Promise$all4[1];
              _iterator55 = _createForOfIteratorHelper(normalDatasets);
              _context40.prev = 11;
              _iterator55.s();
            case 13:
              if ((_step55 = _iterator55.n()).done) {
                _context40.next = 27;
                break;
              }
              _step55$value = _slicedToArray(_step55.value, 3), _key16 = _step55$value[0], _value8 = _step55$value[1], _itemDataset2 = _step55$value[2];
              if (!_itemDataset2.issues) {
                _context40.next = 23;
                break;
              }
              _pathItem8 = {
                type: "array",
                origin: "value",
                input: input,
                key: _key16,
                value: _value8
              };
              _iterator58 = _createForOfIteratorHelper(_itemDataset2.issues);
              try {
                for (_iterator58.s(); !(_step58 = _iterator58.n()).done;) {
                  _issue8 = _step58.value;
                  if (_issue8.path) {
                    _issue8.path.unshift(_pathItem8);
                  } else {
                    _issue8.path = [_pathItem8];
                  }
                  (_dataset$issues34 = dataset.issues) === null || _dataset$issues34 === void 0 || _dataset$issues34.push(_issue8);
                }
              } catch (err) {
                _iterator58.e(err);
              } finally {
                _iterator58.f();
              }
              if (!dataset.issues) {
                dataset.issues = _itemDataset2.issues;
              }
              if (!config2.abortEarly) {
                _context40.next = 23;
                break;
              }
              dataset.typed = false;
              return _context40.abrupt("break", 27);
            case 23:
              if (!_itemDataset2.typed) {
                dataset.typed = false;
              }
              dataset.value.push(_itemDataset2.value);
            case 25:
              _context40.next = 13;
              break;
            case 27:
              _context40.next = 32;
              break;
            case 29:
              _context40.prev = 29;
              _context40.t0 = _context40["catch"](11);
              _iterator55.e(_context40.t0);
            case 32:
              _context40.prev = 32;
              _iterator55.f();
              return _context40.finish(32);
            case 35:
              if (!(!dataset.issues || !config2.abortEarly)) {
                _context40.next = 61;
                break;
              }
              _iterator56 = _createForOfIteratorHelper(restDatasets);
              _context40.prev = 37;
              _iterator56.s();
            case 39:
              if ((_step56 = _iterator56.n()).done) {
                _context40.next = 53;
                break;
              }
              _step56$value = _slicedToArray(_step56.value, 3), key = _step56$value[0], value2 = _step56$value[1], itemDataset = _step56$value[2];
              if (!itemDataset.issues) {
                _context40.next = 49;
                break;
              }
              pathItem = {
                type: "array",
                origin: "value",
                input: input,
                key: key,
                value: value2
              };
              _iterator57 = _createForOfIteratorHelper(itemDataset.issues);
              try {
                for (_iterator57.s(); !(_step57 = _iterator57.n()).done;) {
                  issue = _step57.value;
                  if (issue.path) {
                    issue.path.unshift(pathItem);
                  } else {
                    issue.path = [pathItem];
                  }
                  (_dataset$issues33 = dataset.issues) === null || _dataset$issues33 === void 0 || _dataset$issues33.push(issue);
                }
              } catch (err) {
                _iterator57.e(err);
              } finally {
                _iterator57.f();
              }
              if (!dataset.issues) {
                dataset.issues = itemDataset.issues;
              }
              if (!config2.abortEarly) {
                _context40.next = 49;
                break;
              }
              dataset.typed = false;
              return _context40.abrupt("break", 53);
            case 49:
              if (!itemDataset.typed) {
                dataset.typed = false;
              }
              dataset.value.push(itemDataset.value);
            case 51:
              _context40.next = 39;
              break;
            case 53:
              _context40.next = 58;
              break;
            case 55:
              _context40.prev = 55;
              _context40.t1 = _context40["catch"](37);
              _iterator56.e(_context40.t1);
            case 58:
              _context40.prev = 58;
              _iterator56.f();
              return _context40.finish(58);
            case 61:
              _context40.next = 64;
              break;
            case 63:
              _addIssue(_this30, "type", dataset, config2);
            case 64:
              return _context40.abrupt("return", dataset);
            case 65:
            case "end":
              return _context40.stop();
          }
        }, _callee40, null, [[11, 29, 32, 35], [37, 55, 58, 61]]);
      }))();
    }
  };
}

// src/schemas/undefined/undefined.ts
function undefined_(message) {
  return {
    kind: "schema",
    type: "undefined",
    reference: undefined_,
    expects: "undefined",
    async: false,
    message: message,
    _run: function _run(dataset, config2) {
      if (dataset.value === void 0) {
        dataset.typed = true;
      } else {
        _addIssue(this, "type", dataset, config2);
      }
      return dataset;
    }
  };
}

// src/schemas/union/utils/_subIssues/_subIssues.ts
function _subIssues(datasets) {
  var issues;
  if (datasets) {
    var _iterator59 = _createForOfIteratorHelper(datasets),
      _step59;
    try {
      for (_iterator59.s(); !(_step59 = _iterator59.n()).done;) {
        var dataset = _step59.value;
        if (issues) {
          var _issues;
          (_issues = issues).push.apply(_issues, _toConsumableArray(dataset.issues));
        } else {
          issues = dataset.issues;
        }
      }
    } catch (err) {
      _iterator59.e(err);
    } finally {
      _iterator59.f();
    }
  }
  return issues;
}

// src/schemas/union/union.ts
function union(options, message) {
  return {
    kind: "schema",
    type: "union",
    reference: union,
    expects: _toConsumableArray(new Set(options.map(function (option) {
      return option.expects;
    }))).join(" | ") || "never",
    async: false,
    options: options,
    message: message,
    _run: function _run(dataset, config2) {
      var _untypedDatasets;
      var validDataset;
      var typedDatasets;
      var untypedDatasets;
      var _iterator60 = _createForOfIteratorHelper(this.options),
        _step60;
      try {
        for (_iterator60.s(); !(_step60 = _iterator60.n()).done;) {
          var schema = _step60.value;
          var optionDataset = schema._run({
            typed: false,
            value: dataset.value
          }, config2);
          if (optionDataset.typed) {
            if (optionDataset.issues) {
              if (typedDatasets) {
                typedDatasets.push(optionDataset);
              } else {
                typedDatasets = [optionDataset];
              }
            } else {
              validDataset = optionDataset;
              break;
            }
          } else {
            if (untypedDatasets) {
              untypedDatasets.push(optionDataset);
            } else {
              untypedDatasets = [optionDataset];
            }
          }
        }
      } catch (err) {
        _iterator60.e(err);
      } finally {
        _iterator60.f();
      }
      if (validDataset) {
        return validDataset;
      }
      if (typedDatasets) {
        if (typedDatasets.length === 1) {
          return typedDatasets[0];
        }
        _addIssue(this, "type", dataset, config2, {
          issues: _subIssues(typedDatasets)
        });
        dataset.typed = true;
      } else if (((_untypedDatasets = untypedDatasets) === null || _untypedDatasets === void 0 ? void 0 : _untypedDatasets.length) === 1) {
        return untypedDatasets[0];
      } else {
        _addIssue(this, "type", dataset, config2, {
          issues: _subIssues(untypedDatasets)
        });
      }
      return dataset;
    }
  };
}

// src/schemas/union/unionAsync.ts
function unionAsync(options, message) {
  return {
    kind: "schema",
    type: "union",
    reference: unionAsync,
    expects: _toConsumableArray(new Set(options.map(function (option) {
      return option.expects;
    }))).join(" | ") || "never",
    async: true,
    options: options,
    message: message,
    _run: function _run(dataset, config2) {
      var _this31 = this;
      return _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee41() {
        var _untypedDatasets2;
        var validDataset, typedDatasets, untypedDatasets, _iterator61, _step61, schema, optionDataset;
        return _regeneratorRuntime().wrap(function _callee41$(_context41) {
          while (1) switch (_context41.prev = _context41.next) {
            case 0:
              _iterator61 = _createForOfIteratorHelper(_this31.options);
              _context41.prev = 1;
              _iterator61.s();
            case 3:
              if ((_step61 = _iterator61.n()).done) {
                _context41.next = 20;
                break;
              }
              schema = _step61.value;
              _context41.next = 7;
              return schema._run({
                typed: false,
                value: dataset.value
              }, config2);
            case 7:
              optionDataset = _context41.sent;
              if (!optionDataset.typed) {
                _context41.next = 17;
                break;
              }
              if (!optionDataset.issues) {
                _context41.next = 13;
                break;
              }
              if (typedDatasets) {
                typedDatasets.push(optionDataset);
              } else {
                typedDatasets = [optionDataset];
              }
              _context41.next = 15;
              break;
            case 13:
              validDataset = optionDataset;
              return _context41.abrupt("break", 20);
            case 15:
              _context41.next = 18;
              break;
            case 17:
              if (untypedDatasets) {
                untypedDatasets.push(optionDataset);
              } else {
                untypedDatasets = [optionDataset];
              }
            case 18:
              _context41.next = 3;
              break;
            case 20:
              _context41.next = 25;
              break;
            case 22:
              _context41.prev = 22;
              _context41.t0 = _context41["catch"](1);
              _iterator61.e(_context41.t0);
            case 25:
              _context41.prev = 25;
              _iterator61.f();
              return _context41.finish(25);
            case 28:
              if (!validDataset) {
                _context41.next = 30;
                break;
              }
              return _context41.abrupt("return", validDataset);
            case 30:
              if (!typedDatasets) {
                _context41.next = 37;
                break;
              }
              if (!(typedDatasets.length === 1)) {
                _context41.next = 33;
                break;
              }
              return _context41.abrupt("return", typedDatasets[0]);
            case 33:
              _addIssue(_this31, "type", dataset, config2, {
                issues: _subIssues(typedDatasets)
              });
              dataset.typed = true;
              _context41.next = 42;
              break;
            case 37:
              if (!(((_untypedDatasets2 = untypedDatasets) === null || _untypedDatasets2 === void 0 ? void 0 : _untypedDatasets2.length) === 1)) {
                _context41.next = 41;
                break;
              }
              return _context41.abrupt("return", untypedDatasets[0]);
            case 41:
              _addIssue(_this31, "type", dataset, config2, {
                issues: _subIssues(untypedDatasets)
              });
            case 42:
              return _context41.abrupt("return", dataset);
            case 43:
            case "end":
              return _context41.stop();
          }
        }, _callee41, null, [[1, 22, 25, 28]]);
      }))();
    }
  };
}

// src/schemas/unknown/unknown.ts
function unknown() {
  return {
    kind: "schema",
    type: "unknown",
    reference: unknown,
    expects: "unknown",
    async: false,
    _run: function _run(dataset) {
      dataset.typed = true;
      return dataset;
    }
  };
}

// src/schemas/variant/utils/_discriminators/_discriminators.ts
function _discriminators(key, options) {
  var set2 = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : /* @__PURE__ */new Set();
  var _iterator62 = _createForOfIteratorHelper(options),
    _step62;
  try {
    for (_iterator62.s(); !(_step62 = _iterator62.n()).done;) {
      var schema = _step62.value;
      if (schema.type === "variant") {
        _discriminators(key, schema.options, set2);
      } else {
        set2.add(schema.entries[key].expects);
      }
    }
  } catch (err) {
    _iterator62.e(err);
  } finally {
    _iterator62.f();
  }
  return set2;
}

// src/schemas/variant/variant.ts
function variant(key, options, message) {
  var expectedDiscriminators;
  return {
    kind: "schema",
    type: "variant",
    reference: variant,
    expects: "Object",
    async: false,
    key: key,
    options: options,
    message: message,
    _run: function _run(dataset, config2) {
      var input = dataset.value;
      if (input && _typeof(input) === "object") {
        var discriminator = input[this.key];
        if (this.key in input) {
          var outputDataset;
          var _iterator63 = _createForOfIteratorHelper(this.options),
            _step63;
          try {
            for (_iterator63.s(); !(_step63 = _iterator63.n()).done;) {
              var schema = _step63.value;
              if (schema.type === "variant" || !schema.entries[this.key]._run({
                typed: false,
                value: discriminator
              }, config2).issues) {
                var optionDataset = schema._run({
                  typed: false,
                  value: input
                }, config2);
                if (!optionDataset.issues) {
                  return optionDataset;
                }
                if (!outputDataset || !outputDataset.typed && optionDataset.typed) {
                  outputDataset = optionDataset;
                }
              }
            }
          } catch (err) {
            _iterator63.e(err);
          } finally {
            _iterator63.f();
          }
          if (outputDataset) {
            return outputDataset;
          }
        }
        if (!expectedDiscriminators) {
          expectedDiscriminators = _toConsumableArray(_discriminators(this.key, this.options)).join(" | ") || "never";
        }
        _addIssue(this, "type", dataset, config2, {
          input: discriminator,
          expected: expectedDiscriminators,
          path: [{
            type: "object",
            origin: "value",
            input: input,
            key: this.key,
            value: discriminator
          }]
        });
      } else {
        _addIssue(this, "type", dataset, config2);
      }
      return dataset;
    }
  };
}

// src/schemas/variant/variantAsync.ts
function variantAsync(key, options, message) {
  var expectedDiscriminators;
  return {
    kind: "schema",
    type: "variant",
    reference: variantAsync,
    expects: "Object",
    async: true,
    key: key,
    options: options,
    message: message,
    _run: function _run(dataset, config2) {
      var _this32 = this;
      return _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee42() {
        var input, discriminator, outputDataset, _iterator64, _step64, schema, optionDataset;
        return _regeneratorRuntime().wrap(function _callee42$(_context42) {
          while (1) switch (_context42.prev = _context42.next) {
            case 0:
              input = dataset.value;
              if (!(input && _typeof(input) === "object")) {
                _context42.next = 37;
                break;
              }
              discriminator = input[_this32.key];
              if (!(_this32.key in input)) {
                _context42.next = 33;
                break;
              }
              _iterator64 = _createForOfIteratorHelper(_this32.options);
              _context42.prev = 5;
              _iterator64.s();
            case 7:
              if ((_step64 = _iterator64.n()).done) {
                _context42.next = 23;
                break;
              }
              schema = _step64.value;
              _context42.t0 = schema.type === "variant";
              if (_context42.t0) {
                _context42.next = 14;
                break;
              }
              _context42.next = 13;
              return schema.entries[_this32.key]._run({
                typed: false,
                value: discriminator
              }, config2);
            case 13:
              _context42.t0 = !_context42.sent.issues;
            case 14:
              if (!_context42.t0) {
                _context42.next = 21;
                break;
              }
              _context42.next = 17;
              return schema._run({
                typed: false,
                value: input
              }, config2);
            case 17:
              optionDataset = _context42.sent;
              if (optionDataset.issues) {
                _context42.next = 20;
                break;
              }
              return _context42.abrupt("return", optionDataset);
            case 20:
              if (!outputDataset || !outputDataset.typed && optionDataset.typed) {
                outputDataset = optionDataset;
              }
            case 21:
              _context42.next = 7;
              break;
            case 23:
              _context42.next = 28;
              break;
            case 25:
              _context42.prev = 25;
              _context42.t1 = _context42["catch"](5);
              _iterator64.e(_context42.t1);
            case 28:
              _context42.prev = 28;
              _iterator64.f();
              return _context42.finish(28);
            case 31:
              if (!outputDataset) {
                _context42.next = 33;
                break;
              }
              return _context42.abrupt("return", outputDataset);
            case 33:
              if (!expectedDiscriminators) {
                expectedDiscriminators = _toConsumableArray(_discriminators(_this32.key, _this32.options)).join(" | ") || "never";
              }
              _addIssue(_this32, "type", dataset, config2, {
                input: discriminator,
                expected: expectedDiscriminators,
                path: [{
                  type: "object",
                  origin: "value",
                  input: input,
                  key: _this32.key,
                  value: discriminator
                }]
              });
              _context42.next = 38;
              break;
            case 37:
              _addIssue(_this32, "type", dataset, config2);
            case 38:
              return _context42.abrupt("return", dataset);
            case 39:
            case "end":
              return _context42.stop();
          }
        }, _callee42, null, [[5, 25, 28, 31]]);
      }))();
    }
  };
}

// src/schemas/void/void.ts
function void_(message) {
  return {
    kind: "schema",
    type: "void",
    reference: void_,
    expects: "void",
    async: false,
    message: message,
    _run: function _run(dataset, config2) {
      if (dataset.value === void 0) {
        dataset.typed = true;
      } else {
        _addIssue(this, "type", dataset, config2);
      }
      return dataset;
    }
  };
}

// src/methods/keyof/keyof.ts
function keyof(schema, message) {
  return picklist(Object.keys(schema.entries), message);
}

// src/methods/omit/omit.ts
function omit(schema, keys) {
  var entries = _objectSpread({}, schema.entries);
  var _iterator65 = _createForOfIteratorHelper(keys),
    _step65;
  try {
    for (_iterator65.s(); !(_step65 = _iterator65.n()).done;) {
      var key = _step65.value;
      delete entries[key];
    }
  } catch (err) {
    _iterator65.e(err);
  } finally {
    _iterator65.f();
  }
  return _objectSpread(_objectSpread({}, schema), {}, {
    entries: entries
  });
}

// src/methods/parse/parse.ts
function parse(schema, input, config2) {
  var dataset = schema._run({
    typed: false,
    value: input
  }, getGlobalConfig(config2));
  if (dataset.issues) {
    throw new ValiError(dataset.issues);
  }
  return dataset.value;
}

// src/methods/parse/parseAsync.ts
function parseAsync(_x19, _x20, _x21) {
  return _parseAsync.apply(this, arguments);
} // src/methods/parser/parser.ts
function _parseAsync() {
  _parseAsync = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee48(schema, input, config2) {
    var dataset;
    return _regeneratorRuntime().wrap(function _callee48$(_context48) {
      while (1) switch (_context48.prev = _context48.next) {
        case 0:
          _context48.next = 2;
          return schema._run({
            typed: false,
            value: input
          }, getGlobalConfig(config2));
        case 2:
          dataset = _context48.sent;
          if (!dataset.issues) {
            _context48.next = 5;
            break;
          }
          throw new ValiError(dataset.issues);
        case 5:
          return _context48.abrupt("return", dataset.value);
        case 6:
        case "end":
          return _context48.stop();
      }
    }, _callee48);
  }));
  return _parseAsync.apply(this, arguments);
}
function parser(schema, config2) {
  var func = function func(input) {
    return parse(schema, input, config2);
  };
  func.schema = schema;
  func.config = config2;
  return func;
}

// src/methods/parser/parserAsync.ts
function parserAsync(schema, config2) {
  var func = function func(input) {
    return parseAsync(schema, input, config2);
  };
  func.schema = schema;
  func.config = config2;
  return func;
}

// src/methods/partial/partial.ts
function partial(schema, keys) {
  var entries = {};
  for (var key in schema.entries) {
    entries[key] = !keys || keys.includes(key) ? optional(schema.entries[key]) : schema.entries[key];
  }
  return _objectSpread(_objectSpread({}, schema), {}, {
    entries: entries
  });
}

// src/methods/partial/partialAsync.ts
function partialAsync(schema, keys) {
  var entries = {};
  for (var key in schema.entries) {
    entries[key] = !keys || keys.includes(key) ? optionalAsync(schema.entries[key]) : schema.entries[key];
  }
  return _objectSpread(_objectSpread({}, schema), {}, {
    entries: entries
  });
}

// src/methods/pick/pick.ts
function pick(schema, keys) {
  var entries = {};
  var _iterator66 = _createForOfIteratorHelper(keys),
    _step66;
  try {
    for (_iterator66.s(); !(_step66 = _iterator66.n()).done;) {
      var key = _step66.value;
      entries[key] = schema.entries[key];
    }
  } catch (err) {
    _iterator66.e(err);
  } finally {
    _iterator66.f();
  }
  return _objectSpread(_objectSpread({}, schema), {}, {
    entries: entries
  });
}

// src/methods/pipe/pipe.ts
function pipe() {
  for (var _len7 = arguments.length, pipe2 = new Array(_len7), _key17 = 0; _key17 < _len7; _key17++) {
    pipe2[_key17] = arguments[_key17];
  }
  return _objectSpread(_objectSpread({}, pipe2[0]), {}, {
    pipe: pipe2,
    _run: function _run(dataset, config2) {
      for (var _i = 0, _pipe = pipe2; _i < _pipe.length; _i++) {
        var item = _pipe[_i];
        if (item.kind !== "metadata") {
          if (dataset.issues && (item.kind === "schema" || item.kind === "transformation")) {
            dataset.typed = false;
            break;
          }
          if (!dataset.issues || !config2.abortEarly && !config2.abortPipeEarly) {
            dataset = item._run(dataset, config2);
          }
        }
      }
      return dataset;
    }
  });
}

// src/methods/pipe/pipeAsync.ts
function pipeAsync() {
  for (var _len8 = arguments.length, pipe2 = new Array(_len8), _key18 = 0; _key18 < _len8; _key18++) {
    pipe2[_key18] = arguments[_key18];
  }
  return _objectSpread(_objectSpread({}, pipe2[0]), {}, {
    pipe: pipe2,
    async: true,
    _run: function _run(dataset, config2) {
      return _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee43() {
        var _i2, _pipe2, item;
        return _regeneratorRuntime().wrap(function _callee43$(_context43) {
          while (1) switch (_context43.prev = _context43.next) {
            case 0:
              _i2 = 0, _pipe2 = pipe2;
            case 1:
              if (!(_i2 < _pipe2.length)) {
                _context43.next = 14;
                break;
              }
              item = _pipe2[_i2];
              if (!(item.kind !== "metadata")) {
                _context43.next = 11;
                break;
              }
              if (!(dataset.issues && (item.kind === "schema" || item.kind === "transformation"))) {
                _context43.next = 7;
                break;
              }
              dataset.typed = false;
              return _context43.abrupt("break", 14);
            case 7:
              if (!(!dataset.issues || !config2.abortEarly && !config2.abortPipeEarly)) {
                _context43.next = 11;
                break;
              }
              _context43.next = 10;
              return item._run(dataset, config2);
            case 10:
              dataset = _context43.sent;
            case 11:
              _i2++;
              _context43.next = 1;
              break;
            case 14:
              return _context43.abrupt("return", dataset);
            case 15:
            case "end":
              return _context43.stop();
          }
        }, _callee43);
      }))();
    }
  });
}

// src/methods/required/required.ts
function required(schema, arg2, arg3) {
  var keys = Array.isArray(arg2) ? arg2 : void 0;
  var message = Array.isArray(arg2) ? arg3 : arg2;
  var entries = {};
  for (var key in schema.entries) {
    entries[key] = !keys || keys.includes(key) ? nonOptional(schema.entries[key], message) : schema.entries[key];
  }
  return _objectSpread(_objectSpread({}, schema), {}, {
    entries: entries
  });
}

// src/methods/required/requiredAsync.ts
function requiredAsync(schema, arg2, arg3) {
  var keys = Array.isArray(arg2) ? arg2 : void 0;
  var message = Array.isArray(arg2) ? arg3 : arg2;
  var entries = {};
  for (var key in schema.entries) {
    entries[key] = !keys || keys.includes(key) ? nonOptionalAsync(schema.entries[key], message) : schema.entries[key];
  }
  return _objectSpread(_objectSpread({}, schema), {}, {
    entries: entries
  });
}

// src/methods/safeParse/safeParse.ts
function safeParse(schema, input, config2) {
  var dataset = schema._run({
    typed: false,
    value: input
  }, getGlobalConfig(config2));
  return {
    typed: dataset.typed,
    success: !dataset.issues,
    output: dataset.value,
    issues: dataset.issues
  };
}

// src/methods/safeParse/safeParseAsync.ts
function safeParseAsync(_x22, _x23, _x24) {
  return _safeParseAsync.apply(this, arguments);
} // src/methods/safeParser/safeParser.ts
function _safeParseAsync() {
  _safeParseAsync = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee49(schema, input, config2) {
    var dataset;
    return _regeneratorRuntime().wrap(function _callee49$(_context49) {
      while (1) switch (_context49.prev = _context49.next) {
        case 0:
          _context49.next = 2;
          return schema._run({
            typed: false,
            value: input
          }, getGlobalConfig(config2));
        case 2:
          dataset = _context49.sent;
          return _context49.abrupt("return", {
            typed: dataset.typed,
            success: !dataset.issues,
            output: dataset.value,
            issues: dataset.issues
          });
        case 4:
        case "end":
          return _context49.stop();
      }
    }, _callee49);
  }));
  return _safeParseAsync.apply(this, arguments);
}
function safeParser(schema, config2) {
  var func = function func(input) {
    return safeParse(schema, input, config2);
  };
  func.schema = schema;
  func.config = config2;
  return func;
}

// src/methods/safeParser/safeParserAsync.ts
function safeParserAsync(schema, config2) {
  var func = function func(input) {
    return safeParseAsync(schema, input, config2);
  };
  func.schema = schema;
  func.config = config2;
  return func;
}

// src/methods/unwrap/unwrap.ts
function unwrap(schema) {
  return schema.wrapped;
}

},{}],109:[function(require,module,exports){
'use strict';

var __createBinding = void 0 && (void 0).__createBinding || (Object.create ? function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  var desc = Object.getOwnPropertyDescriptor(m, k);
  if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
    desc = {
      enumerable: true,
      get: function get() {
        return m[k];
      }
    };
  }
  Object.defineProperty(o, k2, desc);
} : function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  o[k2] = m[k];
});
var __setModuleDefault = void 0 && (void 0).__setModuleDefault || (Object.create ? function (o, v) {
  Object.defineProperty(o, "default", {
    enumerable: true,
    value: v
  });
} : function (o, v) {
  o["default"] = v;
});
var __importStar = void 0 && (void 0).__importStar || function (mod) {
  if (mod && mod.__esModule) return mod;
  var result = {};
  if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
  __setModuleDefault(result, mod);
  return result;
};
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.encode = encode;
exports.decode = decode;
exports.encodingLength = encodingLength;
var tools = __importStar(require("uint8array-tools"));
var checkUInt64 = function checkUInt64(n) {
  if (n < 0 || n > 0xffffffffffffffffn) {
    throw new RangeError('value out of range');
  }
};
function checkUInt53(n) {
  if (n < 0 || n > Number.MAX_SAFE_INTEGER || n % 1 !== 0) throw new RangeError('value out of range');
}
function checkUint53OrUint64(n) {
  if (typeof n === 'number') checkUInt53(n);else checkUInt64(n);
}
function encode(n, buffer, offset) {
  checkUint53OrUint64(n);
  if (offset === undefined) offset = 0;
  if (buffer === undefined) {
    buffer = new Uint8Array(encodingLength(n));
  }
  var bytes = 0;
  // 8 bit
  if (n < 0xfd) {
    buffer.set([Number(n)], offset);
    bytes = 1;
    // 16 bit
  } else if (n <= 0xffff) {
    buffer.set([0xfd], offset);
    tools.writeUInt16(buffer, offset + 1, Number(n), 'LE');
    bytes = 3;
    // 32 bit
  } else if (n <= 0xffffffff) {
    buffer.set([0xfe], offset);
    tools.writeUInt32(buffer, offset + 1, Number(n), 'LE');
    bytes = 5;
    // 64 bit
  } else {
    buffer.set([0xff], offset);
    tools.writeUInt64(buffer, offset + 1, BigInt(n), 'LE');
    bytes = 9;
  }
  return {
    buffer: buffer,
    bytes: bytes
  };
}
function decode(buffer, offset) {
  if (offset === undefined) offset = 0;
  var first = buffer.at(offset);
  if (first === undefined) throw new Error('buffer too small');
  // 8 bit
  if (first < 0xfd) {
    return {
      numberValue: first,
      bigintValue: BigInt(first),
      bytes: 1
    };
    // 16 bit
  } else if (first === 0xfd) {
    var val = tools.readUInt16(buffer, offset + 1, 'LE');
    return {
      numberValue: val,
      bigintValue: BigInt(val),
      bytes: 3
    };
    // 32 bit
  } else if (first === 0xfe) {
    var _val = tools.readUInt32(buffer, offset + 1, 'LE');
    return {
      numberValue: _val,
      bigintValue: BigInt(_val),
      bytes: 5
    };
    // 64 bit
  } else {
    var number = tools.readUInt64(buffer, offset + 1, 'LE');
    return {
      numberValue: number <= Number.MAX_SAFE_INTEGER ? Number(number) : null,
      bigintValue: number,
      bytes: 9
    };
  }
}
function encodingLength(n) {
  checkUint53OrUint64(n);
  return n < 0xfd ? 1 : n <= 0xffff ? 3 : n <= 0xffffffff ? 5 : 9;
}

},{"uint8array-tools":107}],110:[function(require,module,exports){
"use strict";

var __importDefault = void 0 && (void 0).__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.encode = exports.decode = exports.encodeRaw = exports.decodeRaw = void 0;
var bs58check_1 = __importDefault(require("bs58check"));
function decodeRaw(buffer, version) {
  // check version only if defined
  if (version !== undefined && buffer[0] !== version) throw new Error('Invalid network version');
  // uncompressed
  if (buffer.length === 33) {
    return {
      version: buffer[0],
      privateKey: buffer.slice(1, 33),
      compressed: false
    };
  }
  // invalid length
  if (buffer.length !== 34) throw new Error('Invalid WIF length');
  // invalid compression flag
  if (buffer[33] !== 0x01) throw new Error('Invalid compression flag');
  return {
    version: buffer[0],
    privateKey: buffer.slice(1, 33),
    compressed: true
  };
}
exports.decodeRaw = decodeRaw;
function encodeRaw(version, privateKey, compressed) {
  if (privateKey.length !== 32) throw new TypeError('Invalid privateKey length');
  var result = new Uint8Array(compressed ? 34 : 33);
  var view = new DataView(result.buffer);
  view.setUint8(0, version);
  result.set(privateKey, 1);
  if (compressed) {
    result[33] = 0x01;
  }
  return result;
}
exports.encodeRaw = encodeRaw;
function decode(str, version) {
  return decodeRaw(bs58check_1["default"].decode(str), version);
}
exports.decode = decode;
function encode(wif) {
  return bs58check_1["default"].encode(encodeRaw(wif.version, wif.privateKey, wif.compressed));
}
exports.encode = encode;

},{"bs58check":100}],"buffer":[function(require,module,exports){
(function (Buffer){(function (){
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */
/* eslint-disable no-proto */

'use strict';

function _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function"); }
function _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }
function _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: !1 }), e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
function _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }
function _possibleConstructorReturn(t, e) { if (e && ("object" == _typeof(e) || "function" == typeof e)) return e; if (void 0 !== e) throw new TypeError("Derived constructors may only return object or undefined"); return _assertThisInitialized(t); }
function _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); return e; }
function _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }
function _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }
function _inherits(t, e) { if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, "prototype", { writable: !1 }), e && _setPrototypeOf(t, e); }
function _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
var base64 = require('base64-js');
var ieee754 = require('ieee754');
var customInspectSymbol = typeof Symbol === 'function' && typeof Symbol['for'] === 'function' // eslint-disable-line dot-notation
? Symbol['for']('nodejs.util.inspect.custom') // eslint-disable-line dot-notation
: null;
exports.Buffer = Buffer;
exports.SlowBuffer = SlowBuffer;
exports.INSPECT_MAX_BYTES = 50;
var K_MAX_LENGTH = 0x7fffffff;
exports.kMaxLength = K_MAX_LENGTH;

/**
 * If `Buffer.TYPED_ARRAY_SUPPORT`:
 *   === true    Use Uint8Array implementation (fastest)
 *   === false   Print warning and recommend using `buffer` v4.x which has an Object
 *               implementation (most compatible, even IE6)
 *
 * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
 * Opera 11.6+, iOS 4.2+.
 *
 * We report that the browser does not support typed arrays if the are not subclassable
 * using __proto__. Firefox 4-29 lacks support for adding new properties to `Uint8Array`
 * (See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438). IE 10 lacks support
 * for __proto__ and has a buggy typed array implementation.
 */
Buffer.TYPED_ARRAY_SUPPORT = typedArraySupport();
if (!Buffer.TYPED_ARRAY_SUPPORT && typeof console !== 'undefined' && typeof console.error === 'function') {
  console.error('This browser lacks typed array (Uint8Array) support which is required by ' + '`buffer` v5.x. Use `buffer` v4.x if you require old browser support.');
}
function typedArraySupport() {
  // Can typed array instances can be augmented?
  try {
    var arr = new Uint8Array(1);
    var proto = {
      foo: function foo() {
        return 42;
      }
    };
    Object.setPrototypeOf(proto, Uint8Array.prototype);
    Object.setPrototypeOf(arr, proto);
    return arr.foo() === 42;
  } catch (e) {
    return false;
  }
}
Object.defineProperty(Buffer.prototype, 'parent', {
  enumerable: true,
  get: function get() {
    if (!Buffer.isBuffer(this)) return undefined;
    return this.buffer;
  }
});
Object.defineProperty(Buffer.prototype, 'offset', {
  enumerable: true,
  get: function get() {
    if (!Buffer.isBuffer(this)) return undefined;
    return this.byteOffset;
  }
});
function createBuffer(length) {
  if (length > K_MAX_LENGTH) {
    throw new RangeError('The value "' + length + '" is invalid for option "size"');
  }
  // Return an augmented `Uint8Array` instance
  var buf = new Uint8Array(length);
  Object.setPrototypeOf(buf, Buffer.prototype);
  return buf;
}

/**
 * The Buffer constructor returns instances of `Uint8Array` that have their
 * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of
 * `Uint8Array`, so the returned instances will have all the node `Buffer` methods
 * and the `Uint8Array` methods. Square bracket notation works as expected -- it
 * returns a single octet.
 *
 * The `Uint8Array` prototype remains unmodified.
 */

function Buffer(arg, encodingOrOffset, length) {
  // Common case.
  if (typeof arg === 'number') {
    if (typeof encodingOrOffset === 'string') {
      throw new TypeError('The "string" argument must be of type string. Received type number');
    }
    return allocUnsafe(arg);
  }
  return from(arg, encodingOrOffset, length);
}
Buffer.poolSize = 8192; // not used by this implementation

function from(value, encodingOrOffset, length) {
  if (typeof value === 'string') {
    return fromString(value, encodingOrOffset);
  }
  if (ArrayBuffer.isView(value)) {
    return fromArrayView(value);
  }
  if (value == null) {
    throw new TypeError('The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' + 'or Array-like Object. Received type ' + _typeof(value));
  }
  if (isInstance(value, ArrayBuffer) || value && isInstance(value.buffer, ArrayBuffer)) {
    return fromArrayBuffer(value, encodingOrOffset, length);
  }
  if (typeof SharedArrayBuffer !== 'undefined' && (isInstance(value, SharedArrayBuffer) || value && isInstance(value.buffer, SharedArrayBuffer))) {
    return fromArrayBuffer(value, encodingOrOffset, length);
  }
  if (typeof value === 'number') {
    throw new TypeError('The "value" argument must not be of type number. Received type number');
  }
  var valueOf = value.valueOf && value.valueOf();
  if (valueOf != null && valueOf !== value) {
    return Buffer.from(valueOf, encodingOrOffset, length);
  }
  var b = fromObject(value);
  if (b) return b;
  if (typeof Symbol !== 'undefined' && Symbol.toPrimitive != null && typeof value[Symbol.toPrimitive] === 'function') {
    return Buffer.from(value[Symbol.toPrimitive]('string'), encodingOrOffset, length);
  }
  throw new TypeError('The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' + 'or Array-like Object. Received type ' + _typeof(value));
}

/**
 * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError
 * if value is a number.
 * Buffer.from(str[, encoding])
 * Buffer.from(array)
 * Buffer.from(buffer)
 * Buffer.from(arrayBuffer[, byteOffset[, length]])
 **/
Buffer.from = function (value, encodingOrOffset, length) {
  return from(value, encodingOrOffset, length);
};

// Note: Change prototype *after* Buffer.from is defined to workaround Chrome bug:
// https://github.com/feross/buffer/pull/148
Object.setPrototypeOf(Buffer.prototype, Uint8Array.prototype);
Object.setPrototypeOf(Buffer, Uint8Array);
function assertSize(size) {
  if (typeof size !== 'number') {
    throw new TypeError('"size" argument must be of type number');
  } else if (size < 0) {
    throw new RangeError('The value "' + size + '" is invalid for option "size"');
  }
}
function alloc(size, fill, encoding) {
  assertSize(size);
  if (size <= 0) {
    return createBuffer(size);
  }
  if (fill !== undefined) {
    // Only pay attention to encoding if it's a string. This
    // prevents accidentally sending in a number that would
    // be interpreted as a start offset.
    return typeof encoding === 'string' ? createBuffer(size).fill(fill, encoding) : createBuffer(size).fill(fill);
  }
  return createBuffer(size);
}

/**
 * Creates a new filled Buffer instance.
 * alloc(size[, fill[, encoding]])
 **/
Buffer.alloc = function (size, fill, encoding) {
  return alloc(size, fill, encoding);
};
function allocUnsafe(size) {
  assertSize(size);
  return createBuffer(size < 0 ? 0 : checked(size) | 0);
}

/**
 * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.
 * */
Buffer.allocUnsafe = function (size) {
  return allocUnsafe(size);
};
/**
 * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.
 */
Buffer.allocUnsafeSlow = function (size) {
  return allocUnsafe(size);
};
function fromString(string, encoding) {
  if (typeof encoding !== 'string' || encoding === '') {
    encoding = 'utf8';
  }
  if (!Buffer.isEncoding(encoding)) {
    throw new TypeError('Unknown encoding: ' + encoding);
  }
  var length = byteLength(string, encoding) | 0;
  var buf = createBuffer(length);
  var actual = buf.write(string, encoding);
  if (actual !== length) {
    // Writing a hex string, for example, that contains invalid characters will
    // cause everything after the first invalid character to be ignored. (e.g.
    // 'abxxcd' will be treated as 'ab')
    buf = buf.slice(0, actual);
  }
  return buf;
}
function fromArrayLike(array) {
  var length = array.length < 0 ? 0 : checked(array.length) | 0;
  var buf = createBuffer(length);
  for (var i = 0; i < length; i += 1) {
    buf[i] = array[i] & 255;
  }
  return buf;
}
function fromArrayView(arrayView) {
  if (isInstance(arrayView, Uint8Array)) {
    var copy = new Uint8Array(arrayView);
    return fromArrayBuffer(copy.buffer, copy.byteOffset, copy.byteLength);
  }
  return fromArrayLike(arrayView);
}
function fromArrayBuffer(array, byteOffset, length) {
  if (byteOffset < 0 || array.byteLength < byteOffset) {
    throw new RangeError('"offset" is outside of buffer bounds');
  }
  if (array.byteLength < byteOffset + (length || 0)) {
    throw new RangeError('"length" is outside of buffer bounds');
  }
  var buf;
  if (byteOffset === undefined && length === undefined) {
    buf = new Uint8Array(array);
  } else if (length === undefined) {
    buf = new Uint8Array(array, byteOffset);
  } else {
    buf = new Uint8Array(array, byteOffset, length);
  }

  // Return an augmented `Uint8Array` instance
  Object.setPrototypeOf(buf, Buffer.prototype);
  return buf;
}
function fromObject(obj) {
  if (Buffer.isBuffer(obj)) {
    var len = checked(obj.length) | 0;
    var buf = createBuffer(len);
    if (buf.length === 0) {
      return buf;
    }
    obj.copy(buf, 0, 0, len);
    return buf;
  }
  if (obj.length !== undefined) {
    if (typeof obj.length !== 'number' || numberIsNaN(obj.length)) {
      return createBuffer(0);
    }
    return fromArrayLike(obj);
  }
  if (obj.type === 'Buffer' && Array.isArray(obj.data)) {
    return fromArrayLike(obj.data);
  }
}
function checked(length) {
  // Note: cannot use `length < K_MAX_LENGTH` here because that fails when
  // length is NaN (which is otherwise coerced to zero.)
  if (length >= K_MAX_LENGTH) {
    throw new RangeError('Attempt to allocate Buffer larger than maximum ' + 'size: 0x' + K_MAX_LENGTH.toString(16) + ' bytes');
  }
  return length | 0;
}
function SlowBuffer(length) {
  if (+length != length) {
    // eslint-disable-line eqeqeq
    length = 0;
  }
  return Buffer.alloc(+length);
}
Buffer.isBuffer = function isBuffer(b) {
  return b != null && b._isBuffer === true && b !== Buffer.prototype; // so Buffer.isBuffer(Buffer.prototype) will be false
};
Buffer.compare = function compare(a, b) {
  if (isInstance(a, Uint8Array)) a = Buffer.from(a, a.offset, a.byteLength);
  if (isInstance(b, Uint8Array)) b = Buffer.from(b, b.offset, b.byteLength);
  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {
    throw new TypeError('The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array');
  }
  if (a === b) return 0;
  var x = a.length;
  var y = b.length;
  for (var i = 0, len = Math.min(x, y); i < len; ++i) {
    if (a[i] !== b[i]) {
      x = a[i];
      y = b[i];
      break;
    }
  }
  if (x < y) return -1;
  if (y < x) return 1;
  return 0;
};
Buffer.isEncoding = function isEncoding(encoding) {
  switch (String(encoding).toLowerCase()) {
    case 'hex':
    case 'utf8':
    case 'utf-8':
    case 'ascii':
    case 'latin1':
    case 'binary':
    case 'base64':
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      return true;
    default:
      return false;
  }
};
Buffer.concat = function concat(list, length) {
  if (!Array.isArray(list)) {
    throw new TypeError('"list" argument must be an Array of Buffers');
  }
  if (list.length === 0) {
    return Buffer.alloc(0);
  }
  var i;
  if (length === undefined) {
    length = 0;
    for (i = 0; i < list.length; ++i) {
      length += list[i].length;
    }
  }
  var buffer = Buffer.allocUnsafe(length);
  var pos = 0;
  for (i = 0; i < list.length; ++i) {
    var buf = list[i];
    if (isInstance(buf, Uint8Array)) {
      if (pos + buf.length > buffer.length) {
        if (!Buffer.isBuffer(buf)) buf = Buffer.from(buf);
        buf.copy(buffer, pos);
      } else {
        Uint8Array.prototype.set.call(buffer, buf, pos);
      }
    } else if (!Buffer.isBuffer(buf)) {
      throw new TypeError('"list" argument must be an Array of Buffers');
    } else {
      buf.copy(buffer, pos);
    }
    pos += buf.length;
  }
  return buffer;
};
function byteLength(string, encoding) {
  if (Buffer.isBuffer(string)) {
    return string.length;
  }
  if (ArrayBuffer.isView(string) || isInstance(string, ArrayBuffer)) {
    return string.byteLength;
  }
  if (typeof string !== 'string') {
    throw new TypeError('The "string" argument must be one of type string, Buffer, or ArrayBuffer. ' + 'Received type ' + _typeof(string));
  }
  var len = string.length;
  var mustMatch = arguments.length > 2 && arguments[2] === true;
  if (!mustMatch && len === 0) return 0;

  // Use a for loop to avoid recursion
  var loweredCase = false;
  for (;;) {
    switch (encoding) {
      case 'ascii':
      case 'latin1':
      case 'binary':
        return len;
      case 'utf8':
      case 'utf-8':
        return utf8ToBytes(string).length;
      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return len * 2;
      case 'hex':
        return len >>> 1;
      case 'base64':
        return base64ToBytes(string).length;
      default:
        if (loweredCase) {
          return mustMatch ? -1 : utf8ToBytes(string).length; // assume utf8
        }
        encoding = ('' + encoding).toLowerCase();
        loweredCase = true;
    }
  }
}
Buffer.byteLength = byteLength;
function slowToString(encoding, start, end) {
  var loweredCase = false;

  // No need to verify that "this.length <= MAX_UINT32" since it's a read-only
  // property of a typed array.

  // This behaves neither like String nor Uint8Array in that we set start/end
  // to their upper/lower bounds if the value passed is out of range.
  // undefined is handled specially as per ECMA-262 6th Edition,
  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.
  if (start === undefined || start < 0) {
    start = 0;
  }
  // Return early if start > this.length. Done here to prevent potential uint32
  // coercion fail below.
  if (start > this.length) {
    return '';
  }
  if (end === undefined || end > this.length) {
    end = this.length;
  }
  if (end <= 0) {
    return '';
  }

  // Force coercion to uint32. This will also coerce falsey/NaN values to 0.
  end >>>= 0;
  start >>>= 0;
  if (end <= start) {
    return '';
  }
  if (!encoding) encoding = 'utf8';
  while (true) {
    switch (encoding) {
      case 'hex':
        return hexSlice(this, start, end);
      case 'utf8':
      case 'utf-8':
        return utf8Slice(this, start, end);
      case 'ascii':
        return asciiSlice(this, start, end);
      case 'latin1':
      case 'binary':
        return latin1Slice(this, start, end);
      case 'base64':
        return base64Slice(this, start, end);
      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return utf16leSlice(this, start, end);
      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding);
        encoding = (encoding + '').toLowerCase();
        loweredCase = true;
    }
  }
}

// This property is used by `Buffer.isBuffer` (and the `is-buffer` npm package)
// to detect a Buffer instance. It's not possible to use `instanceof Buffer`
// reliably in a browserify context because there could be multiple different
// copies of the 'buffer' package in use. This method works even for Buffer
// instances that were created from another copy of the `buffer` package.
// See: https://github.com/feross/buffer/issues/154
Buffer.prototype._isBuffer = true;
function swap(b, n, m) {
  var i = b[n];
  b[n] = b[m];
  b[m] = i;
}
Buffer.prototype.swap16 = function swap16() {
  var len = this.length;
  if (len % 2 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 16-bits');
  }
  for (var i = 0; i < len; i += 2) {
    swap(this, i, i + 1);
  }
  return this;
};
Buffer.prototype.swap32 = function swap32() {
  var len = this.length;
  if (len % 4 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 32-bits');
  }
  for (var i = 0; i < len; i += 4) {
    swap(this, i, i + 3);
    swap(this, i + 1, i + 2);
  }
  return this;
};
Buffer.prototype.swap64 = function swap64() {
  var len = this.length;
  if (len % 8 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 64-bits');
  }
  for (var i = 0; i < len; i += 8) {
    swap(this, i, i + 7);
    swap(this, i + 1, i + 6);
    swap(this, i + 2, i + 5);
    swap(this, i + 3, i + 4);
  }
  return this;
};
Buffer.prototype.toString = function toString() {
  var length = this.length;
  if (length === 0) return '';
  if (arguments.length === 0) return utf8Slice(this, 0, length);
  return slowToString.apply(this, arguments);
};
Buffer.prototype.toLocaleString = Buffer.prototype.toString;
Buffer.prototype.equals = function equals(b) {
  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer');
  if (this === b) return true;
  return Buffer.compare(this, b) === 0;
};
Buffer.prototype.inspect = function inspect() {
  var str = '';
  var max = exports.INSPECT_MAX_BYTES;
  str = this.toString('hex', 0, max).replace(/(.{2})/g, '$1 ').trim();
  if (this.length > max) str += ' ... ';
  return '<Buffer ' + str + '>';
};
if (customInspectSymbol) {
  Buffer.prototype[customInspectSymbol] = Buffer.prototype.inspect;
}
Buffer.prototype.compare = function compare(target, start, end, thisStart, thisEnd) {
  if (isInstance(target, Uint8Array)) {
    target = Buffer.from(target, target.offset, target.byteLength);
  }
  if (!Buffer.isBuffer(target)) {
    throw new TypeError('The "target" argument must be one of type Buffer or Uint8Array. ' + 'Received type ' + _typeof(target));
  }
  if (start === undefined) {
    start = 0;
  }
  if (end === undefined) {
    end = target ? target.length : 0;
  }
  if (thisStart === undefined) {
    thisStart = 0;
  }
  if (thisEnd === undefined) {
    thisEnd = this.length;
  }
  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
    throw new RangeError('out of range index');
  }
  if (thisStart >= thisEnd && start >= end) {
    return 0;
  }
  if (thisStart >= thisEnd) {
    return -1;
  }
  if (start >= end) {
    return 1;
  }
  start >>>= 0;
  end >>>= 0;
  thisStart >>>= 0;
  thisEnd >>>= 0;
  if (this === target) return 0;
  var x = thisEnd - thisStart;
  var y = end - start;
  var len = Math.min(x, y);
  var thisCopy = this.slice(thisStart, thisEnd);
  var targetCopy = target.slice(start, end);
  for (var i = 0; i < len; ++i) {
    if (thisCopy[i] !== targetCopy[i]) {
      x = thisCopy[i];
      y = targetCopy[i];
      break;
    }
  }
  if (x < y) return -1;
  if (y < x) return 1;
  return 0;
};

// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,
// OR the last index of `val` in `buffer` at offset <= `byteOffset`.
//
// Arguments:
// - buffer - a Buffer to search
// - val - a string, Buffer, or number
// - byteOffset - an index into `buffer`; will be clamped to an int32
// - encoding - an optional encoding, relevant is val is a string
// - dir - true for indexOf, false for lastIndexOf
function bidirectionalIndexOf(buffer, val, byteOffset, encoding, dir) {
  // Empty buffer means no match
  if (buffer.length === 0) return -1;

  // Normalize byteOffset
  if (typeof byteOffset === 'string') {
    encoding = byteOffset;
    byteOffset = 0;
  } else if (byteOffset > 0x7fffffff) {
    byteOffset = 0x7fffffff;
  } else if (byteOffset < -0x80000000) {
    byteOffset = -0x80000000;
  }
  byteOffset = +byteOffset; // Coerce to Number.
  if (numberIsNaN(byteOffset)) {
    // byteOffset: it it's undefined, null, NaN, "foo", etc, search whole buffer
    byteOffset = dir ? 0 : buffer.length - 1;
  }

  // Normalize byteOffset: negative offsets start from the end of the buffer
  if (byteOffset < 0) byteOffset = buffer.length + byteOffset;
  if (byteOffset >= buffer.length) {
    if (dir) return -1;else byteOffset = buffer.length - 1;
  } else if (byteOffset < 0) {
    if (dir) byteOffset = 0;else return -1;
  }

  // Normalize val
  if (typeof val === 'string') {
    val = Buffer.from(val, encoding);
  }

  // Finally, search either indexOf (if dir is true) or lastIndexOf
  if (Buffer.isBuffer(val)) {
    // Special case: looking for empty string/buffer always fails
    if (val.length === 0) {
      return -1;
    }
    return arrayIndexOf(buffer, val, byteOffset, encoding, dir);
  } else if (typeof val === 'number') {
    val = val & 0xFF; // Search for a byte value [0-255]
    if (typeof Uint8Array.prototype.indexOf === 'function') {
      if (dir) {
        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset);
      } else {
        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset);
      }
    }
    return arrayIndexOf(buffer, [val], byteOffset, encoding, dir);
  }
  throw new TypeError('val must be string, number or Buffer');
}
function arrayIndexOf(arr, val, byteOffset, encoding, dir) {
  var indexSize = 1;
  var arrLength = arr.length;
  var valLength = val.length;
  if (encoding !== undefined) {
    encoding = String(encoding).toLowerCase();
    if (encoding === 'ucs2' || encoding === 'ucs-2' || encoding === 'utf16le' || encoding === 'utf-16le') {
      if (arr.length < 2 || val.length < 2) {
        return -1;
      }
      indexSize = 2;
      arrLength /= 2;
      valLength /= 2;
      byteOffset /= 2;
    }
  }
  function read(buf, i) {
    if (indexSize === 1) {
      return buf[i];
    } else {
      return buf.readUInt16BE(i * indexSize);
    }
  }
  var i;
  if (dir) {
    var foundIndex = -1;
    for (i = byteOffset; i < arrLength; i++) {
      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
        if (foundIndex === -1) foundIndex = i;
        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize;
      } else {
        if (foundIndex !== -1) i -= i - foundIndex;
        foundIndex = -1;
      }
    }
  } else {
    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength;
    for (i = byteOffset; i >= 0; i--) {
      var found = true;
      for (var j = 0; j < valLength; j++) {
        if (read(arr, i + j) !== read(val, j)) {
          found = false;
          break;
        }
      }
      if (found) return i;
    }
  }
  return -1;
}
Buffer.prototype.includes = function includes(val, byteOffset, encoding) {
  return this.indexOf(val, byteOffset, encoding) !== -1;
};
Buffer.prototype.indexOf = function indexOf(val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, true);
};
Buffer.prototype.lastIndexOf = function lastIndexOf(val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, false);
};
function hexWrite(buf, string, offset, length) {
  offset = Number(offset) || 0;
  var remaining = buf.length - offset;
  if (!length) {
    length = remaining;
  } else {
    length = Number(length);
    if (length > remaining) {
      length = remaining;
    }
  }
  var strLen = string.length;
  if (length > strLen / 2) {
    length = strLen / 2;
  }
  var i;
  for (i = 0; i < length; ++i) {
    var parsed = parseInt(string.substr(i * 2, 2), 16);
    if (numberIsNaN(parsed)) return i;
    buf[offset + i] = parsed;
  }
  return i;
}
function utf8Write(buf, string, offset, length) {
  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length);
}
function asciiWrite(buf, string, offset, length) {
  return blitBuffer(asciiToBytes(string), buf, offset, length);
}
function base64Write(buf, string, offset, length) {
  return blitBuffer(base64ToBytes(string), buf, offset, length);
}
function ucs2Write(buf, string, offset, length) {
  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length);
}
Buffer.prototype.write = function write(string, offset, length, encoding) {
  // Buffer#write(string)
  if (offset === undefined) {
    encoding = 'utf8';
    length = this.length;
    offset = 0;
    // Buffer#write(string, encoding)
  } else if (length === undefined && typeof offset === 'string') {
    encoding = offset;
    length = this.length;
    offset = 0;
    // Buffer#write(string, offset[, length][, encoding])
  } else if (isFinite(offset)) {
    offset = offset >>> 0;
    if (isFinite(length)) {
      length = length >>> 0;
      if (encoding === undefined) encoding = 'utf8';
    } else {
      encoding = length;
      length = undefined;
    }
  } else {
    throw new Error('Buffer.write(string, encoding, offset[, length]) is no longer supported');
  }
  var remaining = this.length - offset;
  if (length === undefined || length > remaining) length = remaining;
  if (string.length > 0 && (length < 0 || offset < 0) || offset > this.length) {
    throw new RangeError('Attempt to write outside buffer bounds');
  }
  if (!encoding) encoding = 'utf8';
  var loweredCase = false;
  for (;;) {
    switch (encoding) {
      case 'hex':
        return hexWrite(this, string, offset, length);
      case 'utf8':
      case 'utf-8':
        return utf8Write(this, string, offset, length);
      case 'ascii':
      case 'latin1':
      case 'binary':
        return asciiWrite(this, string, offset, length);
      case 'base64':
        // Warning: maxLength not taken into account in base64Write
        return base64Write(this, string, offset, length);
      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return ucs2Write(this, string, offset, length);
      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding);
        encoding = ('' + encoding).toLowerCase();
        loweredCase = true;
    }
  }
};
Buffer.prototype.toJSON = function toJSON() {
  return {
    type: 'Buffer',
    data: Array.prototype.slice.call(this._arr || this, 0)
  };
};
function base64Slice(buf, start, end) {
  if (start === 0 && end === buf.length) {
    return base64.fromByteArray(buf);
  } else {
    return base64.fromByteArray(buf.slice(start, end));
  }
}
function utf8Slice(buf, start, end) {
  end = Math.min(buf.length, end);
  var res = [];
  var i = start;
  while (i < end) {
    var firstByte = buf[i];
    var codePoint = null;
    var bytesPerSequence = firstByte > 0xEF ? 4 : firstByte > 0xDF ? 3 : firstByte > 0xBF ? 2 : 1;
    if (i + bytesPerSequence <= end) {
      var secondByte = void 0,
        thirdByte = void 0,
        fourthByte = void 0,
        tempCodePoint = void 0;
      switch (bytesPerSequence) {
        case 1:
          if (firstByte < 0x80) {
            codePoint = firstByte;
          }
          break;
        case 2:
          secondByte = buf[i + 1];
          if ((secondByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0x1F) << 0x6 | secondByte & 0x3F;
            if (tempCodePoint > 0x7F) {
              codePoint = tempCodePoint;
            }
          }
          break;
        case 3:
          secondByte = buf[i + 1];
          thirdByte = buf[i + 2];
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | thirdByte & 0x3F;
            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {
              codePoint = tempCodePoint;
            }
          }
          break;
        case 4:
          secondByte = buf[i + 1];
          thirdByte = buf[i + 2];
          fourthByte = buf[i + 3];
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | fourthByte & 0x3F;
            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {
              codePoint = tempCodePoint;
            }
          }
      }
    }
    if (codePoint === null) {
      // we did not generate a valid codePoint so insert a
      // replacement char (U+FFFD) and advance only 1 byte
      codePoint = 0xFFFD;
      bytesPerSequence = 1;
    } else if (codePoint > 0xFFFF) {
      // encode to utf16 (surrogate pair dance)
      codePoint -= 0x10000;
      res.push(codePoint >>> 10 & 0x3FF | 0xD800);
      codePoint = 0xDC00 | codePoint & 0x3FF;
    }
    res.push(codePoint);
    i += bytesPerSequence;
  }
  return decodeCodePointsArray(res);
}

// Based on http://stackoverflow.com/a/22747272/680742, the browser with
// the lowest limit is Chrome, with 0x10000 args.
// We go 1 magnitude less, for safety
var MAX_ARGUMENTS_LENGTH = 0x1000;
function decodeCodePointsArray(codePoints) {
  var len = codePoints.length;
  if (len <= MAX_ARGUMENTS_LENGTH) {
    return String.fromCharCode.apply(String, codePoints); // avoid extra slice()
  }

  // Decode in chunks to avoid "call stack size exceeded".
  var res = '';
  var i = 0;
  while (i < len) {
    res += String.fromCharCode.apply(String, codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH));
  }
  return res;
}
function asciiSlice(buf, start, end) {
  var ret = '';
  end = Math.min(buf.length, end);
  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i] & 0x7F);
  }
  return ret;
}
function latin1Slice(buf, start, end) {
  var ret = '';
  end = Math.min(buf.length, end);
  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i]);
  }
  return ret;
}
function hexSlice(buf, start, end) {
  var len = buf.length;
  if (!start || start < 0) start = 0;
  if (!end || end < 0 || end > len) end = len;
  var out = '';
  for (var i = start; i < end; ++i) {
    out += hexSliceLookupTable[buf[i]];
  }
  return out;
}
function utf16leSlice(buf, start, end) {
  var bytes = buf.slice(start, end);
  var res = '';
  // If bytes.length is odd, the last 8 bits must be ignored (same as node.js)
  for (var i = 0; i < bytes.length - 1; i += 2) {
    res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256);
  }
  return res;
}
Buffer.prototype.slice = function slice(start, end) {
  var len = this.length;
  start = ~~start;
  end = end === undefined ? len : ~~end;
  if (start < 0) {
    start += len;
    if (start < 0) start = 0;
  } else if (start > len) {
    start = len;
  }
  if (end < 0) {
    end += len;
    if (end < 0) end = 0;
  } else if (end > len) {
    end = len;
  }
  if (end < start) end = start;
  var newBuf = this.subarray(start, end);
  // Return an augmented `Uint8Array` instance
  Object.setPrototypeOf(newBuf, Buffer.prototype);
  return newBuf;
};

/*
 * Need to make sure that buffer isn't trying to write out of bounds.
 */
function checkOffset(offset, ext, length) {
  if (offset % 1 !== 0 || offset < 0) throw new RangeError('offset is not uint');
  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length');
}
Buffer.prototype.readUintLE = Buffer.prototype.readUIntLE = function readUIntLE(offset, byteLength, noAssert) {
  offset = offset >>> 0;
  byteLength = byteLength >>> 0;
  if (!noAssert) checkOffset(offset, byteLength, this.length);
  var val = this[offset];
  var mul = 1;
  var i = 0;
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul;
  }
  return val;
};
Buffer.prototype.readUintBE = Buffer.prototype.readUIntBE = function readUIntBE(offset, byteLength, noAssert) {
  offset = offset >>> 0;
  byteLength = byteLength >>> 0;
  if (!noAssert) {
    checkOffset(offset, byteLength, this.length);
  }
  var val = this[offset + --byteLength];
  var mul = 1;
  while (byteLength > 0 && (mul *= 0x100)) {
    val += this[offset + --byteLength] * mul;
  }
  return val;
};
Buffer.prototype.readUint8 = Buffer.prototype.readUInt8 = function readUInt8(offset, noAssert) {
  offset = offset >>> 0;
  if (!noAssert) checkOffset(offset, 1, this.length);
  return this[offset];
};
Buffer.prototype.readUint16LE = Buffer.prototype.readUInt16LE = function readUInt16LE(offset, noAssert) {
  offset = offset >>> 0;
  if (!noAssert) checkOffset(offset, 2, this.length);
  return this[offset] | this[offset + 1] << 8;
};
Buffer.prototype.readUint16BE = Buffer.prototype.readUInt16BE = function readUInt16BE(offset, noAssert) {
  offset = offset >>> 0;
  if (!noAssert) checkOffset(offset, 2, this.length);
  return this[offset] << 8 | this[offset + 1];
};
Buffer.prototype.readUint32LE = Buffer.prototype.readUInt32LE = function readUInt32LE(offset, noAssert) {
  offset = offset >>> 0;
  if (!noAssert) checkOffset(offset, 4, this.length);
  return (this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16) + this[offset + 3] * 0x1000000;
};
Buffer.prototype.readUint32BE = Buffer.prototype.readUInt32BE = function readUInt32BE(offset, noAssert) {
  offset = offset >>> 0;
  if (!noAssert) checkOffset(offset, 4, this.length);
  return this[offset] * 0x1000000 + (this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3]);
};
Buffer.prototype.readBigUInt64LE = defineBigIntMethod(function readBigUInt64LE(offset) {
  offset = offset >>> 0;
  validateNumber(offset, 'offset');
  var first = this[offset];
  var last = this[offset + 7];
  if (first === undefined || last === undefined) {
    boundsError(offset, this.length - 8);
  }
  var lo = first + this[++offset] * Math.pow(2, 8) + this[++offset] * Math.pow(2, 16) + this[++offset] * Math.pow(2, 24);
  var hi = this[++offset] + this[++offset] * Math.pow(2, 8) + this[++offset] * Math.pow(2, 16) + last * Math.pow(2, 24);
  return BigInt(lo) + (BigInt(hi) << BigInt(32));
});
Buffer.prototype.readBigUInt64BE = defineBigIntMethod(function readBigUInt64BE(offset) {
  offset = offset >>> 0;
  validateNumber(offset, 'offset');
  var first = this[offset];
  var last = this[offset + 7];
  if (first === undefined || last === undefined) {
    boundsError(offset, this.length - 8);
  }
  var hi = first * Math.pow(2, 24) + this[++offset] * Math.pow(2, 16) + this[++offset] * Math.pow(2, 8) + this[++offset];
  var lo = this[++offset] * Math.pow(2, 24) + this[++offset] * Math.pow(2, 16) + this[++offset] * Math.pow(2, 8) + last;
  return (BigInt(hi) << BigInt(32)) + BigInt(lo);
});
Buffer.prototype.readIntLE = function readIntLE(offset, byteLength, noAssert) {
  offset = offset >>> 0;
  byteLength = byteLength >>> 0;
  if (!noAssert) checkOffset(offset, byteLength, this.length);
  var val = this[offset];
  var mul = 1;
  var i = 0;
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul;
  }
  mul *= 0x80;
  if (val >= mul) val -= Math.pow(2, 8 * byteLength);
  return val;
};
Buffer.prototype.readIntBE = function readIntBE(offset, byteLength, noAssert) {
  offset = offset >>> 0;
  byteLength = byteLength >>> 0;
  if (!noAssert) checkOffset(offset, byteLength, this.length);
  var i = byteLength;
  var mul = 1;
  var val = this[offset + --i];
  while (i > 0 && (mul *= 0x100)) {
    val += this[offset + --i] * mul;
  }
  mul *= 0x80;
  if (val >= mul) val -= Math.pow(2, 8 * byteLength);
  return val;
};
Buffer.prototype.readInt8 = function readInt8(offset, noAssert) {
  offset = offset >>> 0;
  if (!noAssert) checkOffset(offset, 1, this.length);
  if (!(this[offset] & 0x80)) return this[offset];
  return (0xff - this[offset] + 1) * -1;
};
Buffer.prototype.readInt16LE = function readInt16LE(offset, noAssert) {
  offset = offset >>> 0;
  if (!noAssert) checkOffset(offset, 2, this.length);
  var val = this[offset] | this[offset + 1] << 8;
  return val & 0x8000 ? val | 0xFFFF0000 : val;
};
Buffer.prototype.readInt16BE = function readInt16BE(offset, noAssert) {
  offset = offset >>> 0;
  if (!noAssert) checkOffset(offset, 2, this.length);
  var val = this[offset + 1] | this[offset] << 8;
  return val & 0x8000 ? val | 0xFFFF0000 : val;
};
Buffer.prototype.readInt32LE = function readInt32LE(offset, noAssert) {
  offset = offset >>> 0;
  if (!noAssert) checkOffset(offset, 4, this.length);
  return this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16 | this[offset + 3] << 24;
};
Buffer.prototype.readInt32BE = function readInt32BE(offset, noAssert) {
  offset = offset >>> 0;
  if (!noAssert) checkOffset(offset, 4, this.length);
  return this[offset] << 24 | this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3];
};
Buffer.prototype.readBigInt64LE = defineBigIntMethod(function readBigInt64LE(offset) {
  offset = offset >>> 0;
  validateNumber(offset, 'offset');
  var first = this[offset];
  var last = this[offset + 7];
  if (first === undefined || last === undefined) {
    boundsError(offset, this.length - 8);
  }
  var val = this[offset + 4] + this[offset + 5] * Math.pow(2, 8) + this[offset + 6] * Math.pow(2, 16) + (last << 24); // Overflow

  return (BigInt(val) << BigInt(32)) + BigInt(first + this[++offset] * Math.pow(2, 8) + this[++offset] * Math.pow(2, 16) + this[++offset] * Math.pow(2, 24));
});
Buffer.prototype.readBigInt64BE = defineBigIntMethod(function readBigInt64BE(offset) {
  offset = offset >>> 0;
  validateNumber(offset, 'offset');
  var first = this[offset];
  var last = this[offset + 7];
  if (first === undefined || last === undefined) {
    boundsError(offset, this.length - 8);
  }
  var val = (first << 24) +
  // Overflow
  this[++offset] * Math.pow(2, 16) + this[++offset] * Math.pow(2, 8) + this[++offset];
  return (BigInt(val) << BigInt(32)) + BigInt(this[++offset] * Math.pow(2, 24) + this[++offset] * Math.pow(2, 16) + this[++offset] * Math.pow(2, 8) + last);
});
Buffer.prototype.readFloatLE = function readFloatLE(offset, noAssert) {
  offset = offset >>> 0;
  if (!noAssert) checkOffset(offset, 4, this.length);
  return ieee754.read(this, offset, true, 23, 4);
};
Buffer.prototype.readFloatBE = function readFloatBE(offset, noAssert) {
  offset = offset >>> 0;
  if (!noAssert) checkOffset(offset, 4, this.length);
  return ieee754.read(this, offset, false, 23, 4);
};
Buffer.prototype.readDoubleLE = function readDoubleLE(offset, noAssert) {
  offset = offset >>> 0;
  if (!noAssert) checkOffset(offset, 8, this.length);
  return ieee754.read(this, offset, true, 52, 8);
};
Buffer.prototype.readDoubleBE = function readDoubleBE(offset, noAssert) {
  offset = offset >>> 0;
  if (!noAssert) checkOffset(offset, 8, this.length);
  return ieee754.read(this, offset, false, 52, 8);
};
function checkInt(buf, value, offset, ext, max, min) {
  if (!Buffer.isBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance');
  if (value > max || value < min) throw new RangeError('"value" argument is out of bounds');
  if (offset + ext > buf.length) throw new RangeError('Index out of range');
}
Buffer.prototype.writeUintLE = Buffer.prototype.writeUIntLE = function writeUIntLE(value, offset, byteLength, noAssert) {
  value = +value;
  offset = offset >>> 0;
  byteLength = byteLength >>> 0;
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1;
    checkInt(this, value, offset, byteLength, maxBytes, 0);
  }
  var mul = 1;
  var i = 0;
  this[offset] = value & 0xFF;
  while (++i < byteLength && (mul *= 0x100)) {
    this[offset + i] = value / mul & 0xFF;
  }
  return offset + byteLength;
};
Buffer.prototype.writeUintBE = Buffer.prototype.writeUIntBE = function writeUIntBE(value, offset, byteLength, noAssert) {
  value = +value;
  offset = offset >>> 0;
  byteLength = byteLength >>> 0;
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1;
    checkInt(this, value, offset, byteLength, maxBytes, 0);
  }
  var i = byteLength - 1;
  var mul = 1;
  this[offset + i] = value & 0xFF;
  while (--i >= 0 && (mul *= 0x100)) {
    this[offset + i] = value / mul & 0xFF;
  }
  return offset + byteLength;
};
Buffer.prototype.writeUint8 = Buffer.prototype.writeUInt8 = function writeUInt8(value, offset, noAssert) {
  value = +value;
  offset = offset >>> 0;
  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0);
  this[offset] = value & 0xff;
  return offset + 1;
};
Buffer.prototype.writeUint16LE = Buffer.prototype.writeUInt16LE = function writeUInt16LE(value, offset, noAssert) {
  value = +value;
  offset = offset >>> 0;
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0);
  this[offset] = value & 0xff;
  this[offset + 1] = value >>> 8;
  return offset + 2;
};
Buffer.prototype.writeUint16BE = Buffer.prototype.writeUInt16BE = function writeUInt16BE(value, offset, noAssert) {
  value = +value;
  offset = offset >>> 0;
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0);
  this[offset] = value >>> 8;
  this[offset + 1] = value & 0xff;
  return offset + 2;
};
Buffer.prototype.writeUint32LE = Buffer.prototype.writeUInt32LE = function writeUInt32LE(value, offset, noAssert) {
  value = +value;
  offset = offset >>> 0;
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0);
  this[offset + 3] = value >>> 24;
  this[offset + 2] = value >>> 16;
  this[offset + 1] = value >>> 8;
  this[offset] = value & 0xff;
  return offset + 4;
};
Buffer.prototype.writeUint32BE = Buffer.prototype.writeUInt32BE = function writeUInt32BE(value, offset, noAssert) {
  value = +value;
  offset = offset >>> 0;
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0);
  this[offset] = value >>> 24;
  this[offset + 1] = value >>> 16;
  this[offset + 2] = value >>> 8;
  this[offset + 3] = value & 0xff;
  return offset + 4;
};
function wrtBigUInt64LE(buf, value, offset, min, max) {
  checkIntBI(value, min, max, buf, offset, 7);
  var lo = Number(value & BigInt(0xffffffff));
  buf[offset++] = lo;
  lo = lo >> 8;
  buf[offset++] = lo;
  lo = lo >> 8;
  buf[offset++] = lo;
  lo = lo >> 8;
  buf[offset++] = lo;
  var hi = Number(value >> BigInt(32) & BigInt(0xffffffff));
  buf[offset++] = hi;
  hi = hi >> 8;
  buf[offset++] = hi;
  hi = hi >> 8;
  buf[offset++] = hi;
  hi = hi >> 8;
  buf[offset++] = hi;
  return offset;
}
function wrtBigUInt64BE(buf, value, offset, min, max) {
  checkIntBI(value, min, max, buf, offset, 7);
  var lo = Number(value & BigInt(0xffffffff));
  buf[offset + 7] = lo;
  lo = lo >> 8;
  buf[offset + 6] = lo;
  lo = lo >> 8;
  buf[offset + 5] = lo;
  lo = lo >> 8;
  buf[offset + 4] = lo;
  var hi = Number(value >> BigInt(32) & BigInt(0xffffffff));
  buf[offset + 3] = hi;
  hi = hi >> 8;
  buf[offset + 2] = hi;
  hi = hi >> 8;
  buf[offset + 1] = hi;
  hi = hi >> 8;
  buf[offset] = hi;
  return offset + 8;
}
Buffer.prototype.writeBigUInt64LE = defineBigIntMethod(function writeBigUInt64LE(value) {
  var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
  return wrtBigUInt64LE(this, value, offset, BigInt(0), BigInt('0xffffffffffffffff'));
});
Buffer.prototype.writeBigUInt64BE = defineBigIntMethod(function writeBigUInt64BE(value) {
  var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
  return wrtBigUInt64BE(this, value, offset, BigInt(0), BigInt('0xffffffffffffffff'));
});
Buffer.prototype.writeIntLE = function writeIntLE(value, offset, byteLength, noAssert) {
  value = +value;
  offset = offset >>> 0;
  if (!noAssert) {
    var limit = Math.pow(2, 8 * byteLength - 1);
    checkInt(this, value, offset, byteLength, limit - 1, -limit);
  }
  var i = 0;
  var mul = 1;
  var sub = 0;
  this[offset] = value & 0xFF;
  while (++i < byteLength && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
      sub = 1;
    }
    this[offset + i] = (value / mul >> 0) - sub & 0xFF;
  }
  return offset + byteLength;
};
Buffer.prototype.writeIntBE = function writeIntBE(value, offset, byteLength, noAssert) {
  value = +value;
  offset = offset >>> 0;
  if (!noAssert) {
    var limit = Math.pow(2, 8 * byteLength - 1);
    checkInt(this, value, offset, byteLength, limit - 1, -limit);
  }
  var i = byteLength - 1;
  var mul = 1;
  var sub = 0;
  this[offset + i] = value & 0xFF;
  while (--i >= 0 && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
      sub = 1;
    }
    this[offset + i] = (value / mul >> 0) - sub & 0xFF;
  }
  return offset + byteLength;
};
Buffer.prototype.writeInt8 = function writeInt8(value, offset, noAssert) {
  value = +value;
  offset = offset >>> 0;
  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80);
  if (value < 0) value = 0xff + value + 1;
  this[offset] = value & 0xff;
  return offset + 1;
};
Buffer.prototype.writeInt16LE = function writeInt16LE(value, offset, noAssert) {
  value = +value;
  offset = offset >>> 0;
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000);
  this[offset] = value & 0xff;
  this[offset + 1] = value >>> 8;
  return offset + 2;
};
Buffer.prototype.writeInt16BE = function writeInt16BE(value, offset, noAssert) {
  value = +value;
  offset = offset >>> 0;
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000);
  this[offset] = value >>> 8;
  this[offset + 1] = value & 0xff;
  return offset + 2;
};
Buffer.prototype.writeInt32LE = function writeInt32LE(value, offset, noAssert) {
  value = +value;
  offset = offset >>> 0;
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000);
  this[offset] = value & 0xff;
  this[offset + 1] = value >>> 8;
  this[offset + 2] = value >>> 16;
  this[offset + 3] = value >>> 24;
  return offset + 4;
};
Buffer.prototype.writeInt32BE = function writeInt32BE(value, offset, noAssert) {
  value = +value;
  offset = offset >>> 0;
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000);
  if (value < 0) value = 0xffffffff + value + 1;
  this[offset] = value >>> 24;
  this[offset + 1] = value >>> 16;
  this[offset + 2] = value >>> 8;
  this[offset + 3] = value & 0xff;
  return offset + 4;
};
Buffer.prototype.writeBigInt64LE = defineBigIntMethod(function writeBigInt64LE(value) {
  var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
  return wrtBigUInt64LE(this, value, offset, -BigInt('0x8000000000000000'), BigInt('0x7fffffffffffffff'));
});
Buffer.prototype.writeBigInt64BE = defineBigIntMethod(function writeBigInt64BE(value) {
  var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
  return wrtBigUInt64BE(this, value, offset, -BigInt('0x8000000000000000'), BigInt('0x7fffffffffffffff'));
});
function checkIEEE754(buf, value, offset, ext, max, min) {
  if (offset + ext > buf.length) throw new RangeError('Index out of range');
  if (offset < 0) throw new RangeError('Index out of range');
}
function writeFloat(buf, value, offset, littleEndian, noAssert) {
  value = +value;
  offset = offset >>> 0;
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38);
  }
  ieee754.write(buf, value, offset, littleEndian, 23, 4);
  return offset + 4;
}
Buffer.prototype.writeFloatLE = function writeFloatLE(value, offset, noAssert) {
  return writeFloat(this, value, offset, true, noAssert);
};
Buffer.prototype.writeFloatBE = function writeFloatBE(value, offset, noAssert) {
  return writeFloat(this, value, offset, false, noAssert);
};
function writeDouble(buf, value, offset, littleEndian, noAssert) {
  value = +value;
  offset = offset >>> 0;
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308);
  }
  ieee754.write(buf, value, offset, littleEndian, 52, 8);
  return offset + 8;
}
Buffer.prototype.writeDoubleLE = function writeDoubleLE(value, offset, noAssert) {
  return writeDouble(this, value, offset, true, noAssert);
};
Buffer.prototype.writeDoubleBE = function writeDoubleBE(value, offset, noAssert) {
  return writeDouble(this, value, offset, false, noAssert);
};

// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
Buffer.prototype.copy = function copy(target, targetStart, start, end) {
  if (!Buffer.isBuffer(target)) throw new TypeError('argument should be a Buffer');
  if (!start) start = 0;
  if (!end && end !== 0) end = this.length;
  if (targetStart >= target.length) targetStart = target.length;
  if (!targetStart) targetStart = 0;
  if (end > 0 && end < start) end = start;

  // Copy 0 bytes; we're done
  if (end === start) return 0;
  if (target.length === 0 || this.length === 0) return 0;

  // Fatal error conditions
  if (targetStart < 0) {
    throw new RangeError('targetStart out of bounds');
  }
  if (start < 0 || start >= this.length) throw new RangeError('Index out of range');
  if (end < 0) throw new RangeError('sourceEnd out of bounds');

  // Are we oob?
  if (end > this.length) end = this.length;
  if (target.length - targetStart < end - start) {
    end = target.length - targetStart + start;
  }
  var len = end - start;
  if (this === target && typeof Uint8Array.prototype.copyWithin === 'function') {
    // Use built-in when available, missing from IE11
    this.copyWithin(targetStart, start, end);
  } else {
    Uint8Array.prototype.set.call(target, this.subarray(start, end), targetStart);
  }
  return len;
};

// Usage:
//    buffer.fill(number[, offset[, end]])
//    buffer.fill(buffer[, offset[, end]])
//    buffer.fill(string[, offset[, end]][, encoding])
Buffer.prototype.fill = function fill(val, start, end, encoding) {
  // Handle string cases:
  if (typeof val === 'string') {
    if (typeof start === 'string') {
      encoding = start;
      start = 0;
      end = this.length;
    } else if (typeof end === 'string') {
      encoding = end;
      end = this.length;
    }
    if (encoding !== undefined && typeof encoding !== 'string') {
      throw new TypeError('encoding must be a string');
    }
    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {
      throw new TypeError('Unknown encoding: ' + encoding);
    }
    if (val.length === 1) {
      var code = val.charCodeAt(0);
      if (encoding === 'utf8' && code < 128 || encoding === 'latin1') {
        // Fast path: If `val` fits into a single byte, use that numeric value.
        val = code;
      }
    }
  } else if (typeof val === 'number') {
    val = val & 255;
  } else if (typeof val === 'boolean') {
    val = Number(val);
  }

  // Invalid ranges are not set to a default, so can range check early.
  if (start < 0 || this.length < start || this.length < end) {
    throw new RangeError('Out of range index');
  }
  if (end <= start) {
    return this;
  }
  start = start >>> 0;
  end = end === undefined ? this.length : end >>> 0;
  if (!val) val = 0;
  var i;
  if (typeof val === 'number') {
    for (i = start; i < end; ++i) {
      this[i] = val;
    }
  } else {
    var bytes = Buffer.isBuffer(val) ? val : Buffer.from(val, encoding);
    var len = bytes.length;
    if (len === 0) {
      throw new TypeError('The value "' + val + '" is invalid for argument "value"');
    }
    for (i = 0; i < end - start; ++i) {
      this[i + start] = bytes[i % len];
    }
  }
  return this;
};

// CUSTOM ERRORS
// =============

// Simplified versions from Node, changed for Buffer-only usage
var errors = {};
function E(sym, getMessage, Base) {
  errors[sym] = /*#__PURE__*/function (_Base) {
    function NodeError() {
      var _this;
      _classCallCheck(this, NodeError);
      _this = _callSuper(this, NodeError);
      Object.defineProperty(_this, 'message', {
        value: getMessage.apply(_this, arguments),
        writable: true,
        configurable: true
      });

      // Add the error code to the name to include it in the stack trace.
      _this.name = "".concat(_this.name, " [").concat(sym, "]");
      // Access the stack to generate the error message including the error code
      // from the name.
      _this.stack; // eslint-disable-line no-unused-expressions
      // Reset the name to the actual name.
      delete _this.name;
      return _this;
    }
    _inherits(NodeError, _Base);
    return _createClass(NodeError, [{
      key: "code",
      get: function get() {
        return sym;
      },
      set: function set(value) {
        Object.defineProperty(this, 'code', {
          configurable: true,
          enumerable: true,
          value: value,
          writable: true
        });
      }
    }, {
      key: "toString",
      value: function toString() {
        return "".concat(this.name, " [").concat(sym, "]: ").concat(this.message);
      }
    }]);
  }(Base);
}
E('ERR_BUFFER_OUT_OF_BOUNDS', function (name) {
  if (name) {
    return "".concat(name, " is outside of buffer bounds");
  }
  return 'Attempt to access memory outside buffer bounds';
}, RangeError);
E('ERR_INVALID_ARG_TYPE', function (name, actual) {
  return "The \"".concat(name, "\" argument must be of type number. Received type ").concat(_typeof(actual));
}, TypeError);
E('ERR_OUT_OF_RANGE', function (str, range, input) {
  var msg = "The value of \"".concat(str, "\" is out of range.");
  var received = input;
  if (Number.isInteger(input) && Math.abs(input) > Math.pow(2, 32)) {
    received = addNumericalSeparator(String(input));
  } else if (typeof input === 'bigint') {
    received = String(input);
    if (input > Math.pow(BigInt(2), BigInt(32)) || input < -Math.pow(BigInt(2), BigInt(32))) {
      received = addNumericalSeparator(received);
    }
    received += 'n';
  }
  msg += " It must be ".concat(range, ". Received ").concat(received);
  return msg;
}, RangeError);
function addNumericalSeparator(val) {
  var res = '';
  var i = val.length;
  var start = val[0] === '-' ? 1 : 0;
  for (; i >= start + 4; i -= 3) {
    res = "_".concat(val.slice(i - 3, i)).concat(res);
  }
  return "".concat(val.slice(0, i)).concat(res);
}

// CHECK FUNCTIONS
// ===============

function checkBounds(buf, offset, byteLength) {
  validateNumber(offset, 'offset');
  if (buf[offset] === undefined || buf[offset + byteLength] === undefined) {
    boundsError(offset, buf.length - (byteLength + 1));
  }
}
function checkIntBI(value, min, max, buf, offset, byteLength) {
  if (value > max || value < min) {
    var n = typeof min === 'bigint' ? 'n' : '';
    var range;
    if (byteLength > 3) {
      if (min === 0 || min === BigInt(0)) {
        range = ">= 0".concat(n, " and < 2").concat(n, " ** ").concat((byteLength + 1) * 8).concat(n);
      } else {
        range = ">= -(2".concat(n, " ** ").concat((byteLength + 1) * 8 - 1).concat(n, ") and < 2 ** ") + "".concat((byteLength + 1) * 8 - 1).concat(n);
      }
    } else {
      range = ">= ".concat(min).concat(n, " and <= ").concat(max).concat(n);
    }
    throw new errors.ERR_OUT_OF_RANGE('value', range, value);
  }
  checkBounds(buf, offset, byteLength);
}
function validateNumber(value, name) {
  if (typeof value !== 'number') {
    throw new errors.ERR_INVALID_ARG_TYPE(name, 'number', value);
  }
}
function boundsError(value, length, type) {
  if (Math.floor(value) !== value) {
    validateNumber(value, type);
    throw new errors.ERR_OUT_OF_RANGE(type || 'offset', 'an integer', value);
  }
  if (length < 0) {
    throw new errors.ERR_BUFFER_OUT_OF_BOUNDS();
  }
  throw new errors.ERR_OUT_OF_RANGE(type || 'offset', ">= ".concat(type ? 1 : 0, " and <= ").concat(length), value);
}

// HELPER FUNCTIONS
// ================

var INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g;
function base64clean(str) {
  // Node takes equal signs as end of the Base64 encoding
  str = str.split('=')[0];
  // Node strips out invalid characters like \n and \t from the string, base64-js does not
  str = str.trim().replace(INVALID_BASE64_RE, '');
  // Node converts strings with length < 2 to ''
  if (str.length < 2) return '';
  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
  while (str.length % 4 !== 0) {
    str = str + '=';
  }
  return str;
}
function utf8ToBytes(string, units) {
  units = units || Infinity;
  var codePoint;
  var length = string.length;
  var leadSurrogate = null;
  var bytes = [];
  for (var i = 0; i < length; ++i) {
    codePoint = string.charCodeAt(i);

    // is surrogate component
    if (codePoint > 0xD7FF && codePoint < 0xE000) {
      // last char was a lead
      if (!leadSurrogate) {
        // no lead yet
        if (codePoint > 0xDBFF) {
          // unexpected trail
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
          continue;
        } else if (i + 1 === length) {
          // unpaired lead
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
          continue;
        }

        // valid lead
        leadSurrogate = codePoint;
        continue;
      }

      // 2 leads in a row
      if (codePoint < 0xDC00) {
        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
        leadSurrogate = codePoint;
        continue;
      }

      // valid surrogate pair
      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000;
    } else if (leadSurrogate) {
      // valid bmp char, but last char was a lead
      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
    }
    leadSurrogate = null;

    // encode utf8
    if (codePoint < 0x80) {
      if ((units -= 1) < 0) break;
      bytes.push(codePoint);
    } else if (codePoint < 0x800) {
      if ((units -= 2) < 0) break;
      bytes.push(codePoint >> 0x6 | 0xC0, codePoint & 0x3F | 0x80);
    } else if (codePoint < 0x10000) {
      if ((units -= 3) < 0) break;
      bytes.push(codePoint >> 0xC | 0xE0, codePoint >> 0x6 & 0x3F | 0x80, codePoint & 0x3F | 0x80);
    } else if (codePoint < 0x110000) {
      if ((units -= 4) < 0) break;
      bytes.push(codePoint >> 0x12 | 0xF0, codePoint >> 0xC & 0x3F | 0x80, codePoint >> 0x6 & 0x3F | 0x80, codePoint & 0x3F | 0x80);
    } else {
      throw new Error('Invalid code point');
    }
  }
  return bytes;
}
function asciiToBytes(str) {
  var byteArray = [];
  for (var i = 0; i < str.length; ++i) {
    // Node's code seems to be doing this and not & 0x7F..
    byteArray.push(str.charCodeAt(i) & 0xFF);
  }
  return byteArray;
}
function utf16leToBytes(str, units) {
  var c, hi, lo;
  var byteArray = [];
  for (var i = 0; i < str.length; ++i) {
    if ((units -= 2) < 0) break;
    c = str.charCodeAt(i);
    hi = c >> 8;
    lo = c % 256;
    byteArray.push(lo);
    byteArray.push(hi);
  }
  return byteArray;
}
function base64ToBytes(str) {
  return base64.toByteArray(base64clean(str));
}
function blitBuffer(src, dst, offset, length) {
  var i;
  for (i = 0; i < length; ++i) {
    if (i + offset >= dst.length || i >= src.length) break;
    dst[i + offset] = src[i];
  }
  return i;
}

// ArrayBuffer or Uint8Array objects from other contexts (i.e. iframes) do not pass
// the `instanceof` check but they should be treated as of that type.
// See: https://github.com/feross/buffer/issues/166
function isInstance(obj, type) {
  return obj instanceof type || obj != null && obj.constructor != null && obj.constructor.name != null && obj.constructor.name === type.name;
}
function numberIsNaN(obj) {
  // For IE11 support
  return obj !== obj; // eslint-disable-line no-self-compare
}

// Create lookup table for `toString('hex')`
// See: https://github.com/feross/buffer/issues/219
var hexSliceLookupTable = function () {
  var alphabet = '0123456789abcdef';
  var table = new Array(256);
  for (var i = 0; i < 16; ++i) {
    var i16 = i * 16;
    for (var j = 0; j < 16; ++j) {
      table[i16 + j] = alphabet[i] + alphabet[j];
    }
  }
  return table;
}();

// Return not function with Error if BigInt not supported
function defineBigIntMethod(fn) {
  return typeof BigInt === 'undefined' ? BufferBigIntNotDefined : fn;
}
function BufferBigIntNotDefined() {
  throw new Error('BigInt not supported');
}

}).call(this)}).call(this,require("buffer").Buffer)
},{"base64-js":16,"buffer":"buffer","ieee754":106}]},{},[1]);
